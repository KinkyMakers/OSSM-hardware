var LR = Object.defineProperty;
var IR = (i, e, t) => e in i ? LR(i, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : i[e] = t;
var tt = (i, e, t) => (IR(i, typeof e != "symbol" ? e + "" : e, t),
t);
(function() {
    const e = document.createElement("link").relList;
    if (e && e.supports && e.supports("modulepreload"))
        return;
    for (const s of document.querySelectorAll('link[rel="modulepreload"]'))
        n(s);
    new MutationObserver(s => {
        for (const r of s)
            if (r.type === "childList")
                for (const o of r.addedNodes)
                    o.tagName === "LINK" && o.rel === "modulepreload" && n(o)
    }
    ).observe(document, {
        childList: !0,
        subtree: !0
    });
    function t(s) {
        const r = {};
        return s.integrity && (r.integrity = s.integrity),
        s.referrerpolicy && (r.referrerPolicy = s.referrerpolicy),
        s.crossorigin === "use-credentials" ? r.credentials = "include" : s.crossorigin === "anonymous" ? r.credentials = "omit" : r.credentials = "same-origin",
        r
    }
    function n(s) {
        if (s.ep)
            return;
        s.ep = !0;
        const r = t(s);
        fetch(s.href, r)
    }
}
)();
/**
* @vue/shared v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/*! #__NO_SIDE_EFFECTS__ */
function Kv(i) {
    const e = Object.create(null);
    for (const t of i.split(","))
        e[t] = 1;
    return t => t in e
}
const yn = {}
  , Lc = []
  , hr = () => {}
  , kR = () => !1
  , Xp = i => i.charCodeAt(0) === 111 && i.charCodeAt(1) === 110 && (i.charCodeAt(2) > 122 || i.charCodeAt(2) < 97)
  , Xv = i => i.startsWith("onUpdate:")
  , Jn = Object.assign
  , Yv = (i, e) => {
    const t = i.indexOf(e);
    t > -1 && i.splice(t, 1)
}
  , PR = Object.prototype.hasOwnProperty
  , hn = (i, e) => PR.call(i, e)
  , wt = Array.isArray
  , Ic = i => Eu(i) === "[object Map]"
  , Su = i => Eu(i) === "[object Set]"
  , jx = i => Eu(i) === "[object Date]"
  , DR = i => Eu(i) === "[object RegExp]"
  , Nt = i => typeof i == "function"
  , Fn = i => typeof i == "string"
  , _r = i => typeof i == "symbol"
  , _n = i => i !== null && typeof i == "object"
  , Zv = i => (_n(i) || Nt(i)) && Nt(i.then) && Nt(i.catch)
  , nw = Object.prototype.toString
  , Eu = i => nw.call(i)
  , FR = i => Eu(i).slice(8, -1)
  , iw = i => Eu(i) === "[object Object]"
  , Jv = i => Fn(i) && i !== "NaN" && i[0] !== "-" && "" + parseInt(i, 10) === i
  , ed = Kv(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted")
  , Yp = i => {
    const e = Object.create(null);
    return t => e[t] || (e[t] = i(t))
}
  , OR = /-(\w)/g
  , Ws = Yp(i => i.replace(OR, (e, t) => t ? t.toUpperCase() : ""))
  , UR = /\B([A-Z])/g
  , Ul = Yp(i => i.replace(UR, "-$1").toLowerCase())
  , Zp = Yp(i => i.charAt(0).toUpperCase() + i.slice(1))
  , Nm = Yp(i => i ? `on${Zp(i)}` : "")
  , ha = (i, e) => !Object.is(i, e)
  , kc = (i, ...e) => {
    for (let t = 0; t < i.length; t++)
        i[t](...e)
}
  , sw = (i, e, t, n=!1) => {
    Object.defineProperty(i, e, {
        configurable: !0,
        enumerable: !1,
        writable: n,
        value: t
    })
}
  , Gh = i => {
    const e = parseFloat(i);
    return isNaN(e) ? i : e
}
  , rw = i => {
    const e = Fn(i) ? Number(i) : NaN;
    return isNaN(e) ? i : e
}
;
let Kx;
const qd = () => Kx || (Kx = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
function xs(i) {
    if (wt(i)) {
        const e = {};
        for (let t = 0; t < i.length; t++) {
            const n = i[t]
              , s = Fn(n) ? $R(n) : xs(n);
            if (s)
                for (const r in s)
                    e[r] = s[r]
        }
        return e
    } else if (Fn(i) || _n(i))
        return i
}
const NR = /;(?![^(]*\))/g
  , BR = /:([^]+)/
  , VR = /\/\*[^]*?\*\//g;
function $R(i) {
    const e = {};
    return i.replace(VR, "").split(NR).forEach(t => {
        if (t) {
            const n = t.split(BR);
            n.length > 1 && (e[n[0].trim()] = n[1].trim())
        }
    }
    ),
    e
}
function Pt(i) {
    let e = "";
    if (Fn(i))
        e = i;
    else if (wt(i))
        for (let t = 0; t < i.length; t++) {
            const n = Pt(i[t]);
            n && (e += n + " ")
        }
    else if (_n(i))
        for (const t in i)
            i[t] && (e += t + " ");
    return e.trim()
}
const HR = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly"
  , zR = Kv(HR);
function ow(i) {
    return !!i || i === ""
}
function GR(i, e) {
    if (i.length !== e.length)
        return !1;
    let t = !0;
    for (let n = 0; t && n < i.length; n++)
        t = jd(i[n], e[n]);
    return t
}
function jd(i, e) {
    if (i === e)
        return !0;
    let t = jx(i)
      , n = jx(e);
    if (t || n)
        return t && n ? i.getTime() === e.getTime() : !1;
    if (t = _r(i),
    n = _r(e),
    t || n)
        return i === e;
    if (t = wt(i),
    n = wt(e),
    t || n)
        return t && n ? GR(i, e) : !1;
    if (t = _n(i),
    n = _n(e),
    t || n) {
        if (!t || !n)
            return !1;
        const s = Object.keys(i).length
          , r = Object.keys(e).length;
        if (s !== r)
            return !1;
        for (const o in i) {
            const a = i.hasOwnProperty(o)
              , l = e.hasOwnProperty(o);
            if (a && !l || !a && l || !jd(i[o], e[o]))
                return !1
        }
    }
    return String(i) === String(e)
}
function Qv(i, e) {
    return i.findIndex(t => jd(t, e))
}
const aw = i => !!(i && i.__v_isRef === !0)
  , ee = i => Fn(i) ? i : i == null ? "" : wt(i) || _n(i) && (i.toString === nw || !Nt(i.toString)) ? aw(i) ? ee(i.value) : JSON.stringify(i, lw, 2) : String(i)
  , lw = (i, e) => aw(e) ? lw(i, e.value) : Ic(e) ? {
    [`Map(${e.size})`]: [...e.entries()].reduce( (t, [n,s], r) => (t[Bm(n, r) + " =>"] = s,
    t), {})
} : Su(e) ? {
    [`Set(${e.size})`]: [...e.values()].map(t => Bm(t))
} : _r(e) ? Bm(e) : _n(e) && !wt(e) && !iw(e) ? String(e) : e
  , Bm = (i, e="") => {
    var t;
    return _r(i) ? `Symbol(${(t = i.description) != null ? t : e})` : i
}
;
/**
* @vue/reactivity v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let Hi;
class cw {
    constructor(e=!1) {
        this.detached = e,
        this._active = !0,
        this.effects = [],
        this.cleanups = [],
        this._isPaused = !1,
        this.parent = Hi,
        !e && Hi && (this.index = (Hi.scopes || (Hi.scopes = [])).push(this) - 1)
    }
    get active() {
        return this._active
    }
    pause() {
        if (this._active) {
            this._isPaused = !0;
            let e, t;
            if (this.scopes)
                for (e = 0,
                t = this.scopes.length; e < t; e++)
                    this.scopes[e].pause();
            for (e = 0,
            t = this.effects.length; e < t; e++)
                this.effects[e].pause()
        }
    }
    resume() {
        if (this._active && this._isPaused) {
            this._isPaused = !1;
            let e, t;
            if (this.scopes)
                for (e = 0,
                t = this.scopes.length; e < t; e++)
                    this.scopes[e].resume();
            for (e = 0,
            t = this.effects.length; e < t; e++)
                this.effects[e].resume()
        }
    }
    run(e) {
        if (this._active) {
            const t = Hi;
            try {
                return Hi = this,
                e()
            } finally {
                Hi = t
            }
        }
    }
    on() {
        Hi = this
    }
    off() {
        Hi = this.parent
    }
    stop(e) {
        if (this._active) {
            this._active = !1;
            let t, n;
            for (t = 0,
            n = this.effects.length; t < n; t++)
                this.effects[t].stop();
            for (this.effects.length = 0,
            t = 0,
            n = this.cleanups.length; t < n; t++)
                this.cleanups[t]();
            if (this.cleanups.length = 0,
            this.scopes) {
                for (t = 0,
                n = this.scopes.length; t < n; t++)
                    this.scopes[t].stop(!0);
                this.scopes.length = 0
            }
            if (!this.detached && this.parent && !e) {
                const s = this.parent.scopes.pop();
                s && s !== this && (this.parent.scopes[this.index] = s,
                s.index = this.index)
            }
            this.parent = void 0
        }
    }
}
function uw(i) {
    return new cw(i)
}
function e_() {
    return Hi
}
function dw(i, e=!1) {
    Hi && Hi.cleanups.push(i)
}
let Tn;
const Vm = new WeakSet;
class fw {
    constructor(e) {
        this.fn = e,
        this.deps = void 0,
        this.depsTail = void 0,
        this.flags = 5,
        this.next = void 0,
        this.cleanup = void 0,
        this.scheduler = void 0,
        Hi && Hi.active && Hi.effects.push(this)
    }
    pause() {
        this.flags |= 64
    }
    resume() {
        this.flags & 64 && (this.flags &= -65,
        Vm.has(this) && (Vm.delete(this),
        this.trigger()))
    }
    notify() {
        this.flags & 2 && !(this.flags & 32) || this.flags & 8 || pw(this)
    }
    run() {
        if (!(this.flags & 1))
            return this.fn();
        this.flags |= 2,
        Xx(this),
        mw(this);
        const e = Tn
          , t = pr;
        Tn = this,
        pr = !0;
        try {
            return this.fn()
        } finally {
            gw(this),
            Tn = e,
            pr = t,
            this.flags &= -3
        }
    }
    stop() {
        if (this.flags & 1) {
            for (let e = this.deps; e; e = e.nextDep)
                i_(e);
            this.deps = this.depsTail = void 0,
            Xx(this),
            this.onStop && this.onStop(),
            this.flags &= -2
        }
    }
    trigger() {
        this.flags & 64 ? Vm.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty()
    }
    runIfDirty() {
        Ag(this) && this.run()
    }
    get dirty() {
        return Ag(this)
    }
}
let hw = 0, td, nd;
function pw(i, e=!1) {
    if (i.flags |= 8,
    e) {
        i.next = nd,
        nd = i;
        return
    }
    i.next = td,
    td = i
}
function t_() {
    hw++
}
function n_() {
    if (--hw > 0)
        return;
    if (nd) {
        let e = nd;
        for (nd = void 0; e; ) {
            const t = e.next;
            e.next = void 0,
            e.flags &= -9,
            e = t
        }
    }
    let i;
    for (; td; ) {
        let e = td;
        for (td = void 0; e; ) {
            const t = e.next;
            if (e.next = void 0,
            e.flags &= -9,
            e.flags & 1)
                try {
                    e.trigger()
                } catch (n) {
                    i || (i = n)
                }
            e = t
        }
    }
    if (i)
        throw i
}
function mw(i) {
    for (let e = i.deps; e; e = e.nextDep)
        e.version = -1,
        e.prevActiveLink = e.dep.activeLink,
        e.dep.activeLink = e
}
function gw(i) {
    let e, t = i.depsTail, n = t;
    for (; n; ) {
        const s = n.prevDep;
        n.version === -1 ? (n === t && (t = s),
        i_(n),
        WR(n)) : e = n,
        n.dep.activeLink = n.prevActiveLink,
        n.prevActiveLink = void 0,
        n = s
    }
    i.deps = e,
    i.depsTail = t
}
function Ag(i) {
    for (let e = i.deps; e; e = e.nextDep)
        if (e.dep.version !== e.version || e.dep.computed && (vw(e.dep.computed) || e.dep.version !== e.version))
            return !0;
    return !!i._dirty
}
function vw(i) {
    if (i.flags & 4 && !(i.flags & 16) || (i.flags &= -17,
    i.globalVersion === _d))
        return;
    i.globalVersion = _d;
    const e = i.dep;
    if (i.flags |= 2,
    e.version > 0 && !i.isSSR && i.deps && !Ag(i)) {
        i.flags &= -3;
        return
    }
    const t = Tn
      , n = pr;
    Tn = i,
    pr = !0;
    try {
        mw(i);
        const s = i.fn(i._value);
        (e.version === 0 || ha(s, i._value)) && (i._value = s,
        e.version++)
    } catch (s) {
        throw e.version++,
        s
    } finally {
        Tn = t,
        pr = n,
        gw(i),
        i.flags &= -3
    }
}
function i_(i, e=!1) {
    const {dep: t, prevSub: n, nextSub: s} = i;
    if (n && (n.nextSub = s,
    i.prevSub = void 0),
    s && (s.prevSub = n,
    i.nextSub = void 0),
    t.subs === i && (t.subs = n,
    !n && t.computed)) {
        t.computed.flags &= -5;
        for (let r = t.computed.deps; r; r = r.nextDep)
            i_(r, !0)
    }
    !e && !--t.sc && t.map && t.map.delete(t.key)
}
function WR(i) {
    const {prevDep: e, nextDep: t} = i;
    e && (e.nextDep = t,
    i.prevDep = void 0),
    t && (t.prevDep = e,
    i.nextDep = void 0)
}
let pr = !0;
const _w = [];
function Ra() {
    _w.push(pr),
    pr = !1
}
function La() {
    const i = _w.pop();
    pr = i === void 0 ? !0 : i
}
function Xx(i) {
    const {cleanup: e} = i;
    if (i.cleanup = void 0,
    e) {
        const t = Tn;
        Tn = void 0;
        try {
            e()
        } finally {
            Tn = t
        }
    }
}
let _d = 0;
class qR {
    constructor(e, t) {
        this.sub = e,
        this.dep = t,
        this.version = t.version,
        this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0
    }
}
class s_ {
    constructor(e) {
        this.computed = e,
        this.version = 0,
        this.activeLink = void 0,
        this.subs = void 0,
        this.map = void 0,
        this.key = void 0,
        this.sc = 0
    }
    track(e) {
        if (!Tn || !pr || Tn === this.computed)
            return;
        let t = this.activeLink;
        if (t === void 0 || t.sub !== Tn)
            t = this.activeLink = new qR(Tn,this),
            Tn.deps ? (t.prevDep = Tn.depsTail,
            Tn.depsTail.nextDep = t,
            Tn.depsTail = t) : Tn.deps = Tn.depsTail = t,
            xw(t);
        else if (t.version === -1 && (t.version = this.version,
        t.nextDep)) {
            const n = t.nextDep;
            n.prevDep = t.prevDep,
            t.prevDep && (t.prevDep.nextDep = n),
            t.prevDep = Tn.depsTail,
            t.nextDep = void 0,
            Tn.depsTail.nextDep = t,
            Tn.depsTail = t,
            Tn.deps === t && (Tn.deps = n)
        }
        return t
    }
    trigger(e) {
        this.version++,
        _d++,
        this.notify(e)
    }
    notify(e) {
        t_();
        try {
            for (let t = this.subs; t; t = t.prevSub)
                t.sub.notify() && t.sub.dep.notify()
        } finally {
            n_()
        }
    }
}
function xw(i) {
    if (i.dep.sc++,
    i.sub.flags & 4) {
        const e = i.dep.computed;
        if (e && !i.dep.subs) {
            e.flags |= 20;
            for (let n = e.deps; n; n = n.nextDep)
                xw(n)
        }
        const t = i.dep.subs;
        t !== i && (i.prevSub = t,
        t && (t.nextSub = i)),
        i.dep.subs = i
    }
}
const Wh = new WeakMap
  , vl = Symbol("")
  , Cg = Symbol("")
  , xd = Symbol("");
function Ii(i, e, t) {
    if (pr && Tn) {
        let n = Wh.get(i);
        n || Wh.set(i, n = new Map);
        let s = n.get(t);
        s || (n.set(t, s = new s_),
        s.map = n,
        s.key = t),
        s.track()
    }
}
function Eo(i, e, t, n, s, r) {
    const o = Wh.get(i);
    if (!o) {
        _d++;
        return
    }
    const a = l => {
        l && l.trigger()
    }
    ;
    if (t_(),
    e === "clear")
        o.forEach(a);
    else {
        const l = wt(i)
          , c = l && Jv(t);
        if (l && t === "length") {
            const u = Number(n);
            o.forEach( (d, f) => {
                (f === "length" || f === xd || !_r(f) && f >= u) && a(d)
            }
            )
        } else
            switch ((t !== void 0 || o.has(void 0)) && a(o.get(t)),
            c && a(o.get(xd)),
            e) {
            case "add":
                l ? c && a(o.get("length")) : (a(o.get(vl)),
                Ic(i) && a(o.get(Cg)));
                break;
            case "delete":
                l || (a(o.get(vl)),
                Ic(i) && a(o.get(Cg)));
                break;
            case "set":
                Ic(i) && a(o.get(vl));
                break
            }
    }
    n_()
}
function jR(i, e) {
    const t = Wh.get(i);
    return t && t.get(e)
}
function Wl(i) {
    const e = tn(i);
    return e === i ? e : (Ii(e, "iterate", xd),
    $s(i) ? e : e.map(ki))
}
function Jp(i) {
    return Ii(i = tn(i), "iterate", xd),
    i
}
const KR = {
    __proto__: null,
    [Symbol.iterator]() {
        return $m(this, Symbol.iterator, ki)
    },
    concat(...i) {
        return Wl(this).concat(...i.map(e => wt(e) ? Wl(e) : e))
    },
    entries() {
        return $m(this, "entries", i => (i[1] = ki(i[1]),
        i))
    },
    every(i, e) {
        return Qr(this, "every", i, e, void 0, arguments)
    },
    filter(i, e) {
        return Qr(this, "filter", i, e, t => t.map(ki), arguments)
    },
    find(i, e) {
        return Qr(this, "find", i, e, ki, arguments)
    },
    findIndex(i, e) {
        return Qr(this, "findIndex", i, e, void 0, arguments)
    },
    findLast(i, e) {
        return Qr(this, "findLast", i, e, ki, arguments)
    },
    findLastIndex(i, e) {
        return Qr(this, "findLastIndex", i, e, void 0, arguments)
    },
    forEach(i, e) {
        return Qr(this, "forEach", i, e, void 0, arguments)
    },
    includes(...i) {
        return Hm(this, "includes", i)
    },
    indexOf(...i) {
        return Hm(this, "indexOf", i)
    },
    join(i) {
        return Wl(this).join(i)
    },
    lastIndexOf(...i) {
        return Hm(this, "lastIndexOf", i)
    },
    map(i, e) {
        return Qr(this, "map", i, e, void 0, arguments)
    },
    pop() {
        return Cu(this, "pop")
    },
    push(...i) {
        return Cu(this, "push", i)
    },
    reduce(i, ...e) {
        return Yx(this, "reduce", i, e)
    },
    reduceRight(i, ...e) {
        return Yx(this, "reduceRight", i, e)
    },
    shift() {
        return Cu(this, "shift")
    },
    some(i, e) {
        return Qr(this, "some", i, e, void 0, arguments)
    },
    splice(...i) {
        return Cu(this, "splice", i)
    },
    toReversed() {
        return Wl(this).toReversed()
    },
    toSorted(i) {
        return Wl(this).toSorted(i)
    },
    toSpliced(...i) {
        return Wl(this).toSpliced(...i)
    },
    unshift(...i) {
        return Cu(this, "unshift", i)
    },
    values() {
        return $m(this, "values", ki)
    }
};
function $m(i, e, t) {
    const n = Jp(i)
      , s = n[e]();
    return n !== i && !$s(i) && (s._next = s.next,
    s.next = () => {
        const r = s._next();
        return r.value && (r.value = t(r.value)),
        r
    }
    ),
    s
}
const XR = Array.prototype;
function Qr(i, e, t, n, s, r) {
    const o = Jp(i)
      , a = o !== i && !$s(i)
      , l = o[e];
    if (l !== XR[e]) {
        const d = l.apply(i, r);
        return a ? ki(d) : d
    }
    let c = t;
    o !== i && (a ? c = function(d, f) {
        return t.call(this, ki(d), f, i)
    }
    : t.length > 2 && (c = function(d, f) {
        return t.call(this, d, f, i)
    }
    ));
    const u = l.call(o, c, n);
    return a && s ? s(u) : u
}
function Yx(i, e, t, n) {
    const s = Jp(i);
    let r = t;
    return s !== i && ($s(i) ? t.length > 3 && (r = function(o, a, l) {
        return t.call(this, o, a, l, i)
    }
    ) : r = function(o, a, l) {
        return t.call(this, o, ki(a), l, i)
    }
    ),
    s[e](r, ...n)
}
function Hm(i, e, t) {
    const n = tn(i);
    Ii(n, "iterate", xd);
    const s = n[e](...t);
    return (s === -1 || s === !1) && a_(t[0]) ? (t[0] = tn(t[0]),
    n[e](...t)) : s
}
function Cu(i, e, t=[]) {
    Ra(),
    t_();
    const n = tn(i)[e].apply(i, t);
    return n_(),
    La(),
    n
}
const YR = Kv("__proto__,__v_isRef,__isVue")
  , yw = new Set(Object.getOwnPropertyNames(Symbol).filter(i => i !== "arguments" && i !== "caller").map(i => Symbol[i]).filter(_r));
function ZR(i) {
    _r(i) || (i = String(i));
    const e = tn(this);
    return Ii(e, "has", i),
    e.hasOwnProperty(i)
}
class bw {
    constructor(e=!1, t=!1) {
        this._isReadonly = e,
        this._isShallow = t
    }
    get(e, t, n) {
        if (t === "__v_skip")
            return e.__v_skip;
        const s = this._isReadonly
          , r = this._isShallow;
        if (t === "__v_isReactive")
            return !s;
        if (t === "__v_isReadonly")
            return s;
        if (t === "__v_isShallow")
            return r;
        if (t === "__v_raw")
            return n === (s ? r ? aL : Tw : r ? ww : Ew).get(e) || Object.getPrototypeOf(e) === Object.getPrototypeOf(n) ? e : void 0;
        const o = wt(e);
        if (!s) {
            let l;
            if (o && (l = KR[t]))
                return l;
            if (t === "hasOwnProperty")
                return ZR
        }
        const a = Reflect.get(e, t, Sn(e) ? e : n);
        return (_r(t) ? yw.has(t) : YR(t)) || (s || Ii(e, "get", t),
        r) ? a : Sn(a) ? o && Jv(t) ? a : a.value : _n(a) ? s ? Cw(a) : ei(a) : a
    }
}
class Sw extends bw {
    constructor(e=!1) {
        super(!1, e)
    }
    set(e, t, n, s) {
        let r = e[t];
        if (!this._isShallow) {
            const l = Cl(r);
            if (!$s(n) && !Cl(n) && (r = tn(r),
            n = tn(n)),
            !wt(e) && Sn(r) && !Sn(n))
                return l ? !1 : (r.value = n,
                !0)
        }
        const o = wt(e) && Jv(t) ? Number(t) < e.length : hn(e, t)
          , a = Reflect.set(e, t, n, Sn(e) ? e : s);
        return e === tn(s) && (o ? ha(n, r) && Eo(e, "set", t, n) : Eo(e, "add", t, n)),
        a
    }
    deleteProperty(e, t) {
        const n = hn(e, t);
        e[t];
        const s = Reflect.deleteProperty(e, t);
        return s && n && Eo(e, "delete", t, void 0),
        s
    }
    has(e, t) {
        const n = Reflect.has(e, t);
        return (!_r(t) || !yw.has(t)) && Ii(e, "has", t),
        n
    }
    ownKeys(e) {
        return Ii(e, "iterate", wt(e) ? "length" : vl),
        Reflect.ownKeys(e)
    }
}
class JR extends bw {
    constructor(e=!1) {
        super(!0, e)
    }
    set(e, t) {
        return !0
    }
    deleteProperty(e, t) {
        return !0
    }
}
const QR = new Sw
  , eL = new JR
  , tL = new Sw(!0);
const Mg = i => i
  , hf = i => Reflect.getPrototypeOf(i);
function nL(i, e, t) {
    return function(...n) {
        const s = this.__v_raw
          , r = tn(s)
          , o = Ic(r)
          , a = i === "entries" || i === Symbol.iterator && o
          , l = i === "keys" && o
          , c = s[i](...n)
          , u = t ? Mg : e ? Rg : ki;
        return !e && Ii(r, "iterate", l ? Cg : vl),
        {
            next() {
                const {value: d, done: f} = c.next();
                return f ? {
                    value: d,
                    done: f
                } : {
                    value: a ? [u(d[0]), u(d[1])] : u(d),
                    done: f
                }
            },
            [Symbol.iterator]() {
                return this
            }
        }
    }
}
function pf(i) {
    return function(...e) {
        return i === "delete" ? !1 : i === "clear" ? void 0 : this
    }
}
function iL(i, e) {
    const t = {
        get(s) {
            const r = this.__v_raw
              , o = tn(r)
              , a = tn(s);
            i || (ha(s, a) && Ii(o, "get", s),
            Ii(o, "get", a));
            const {has: l} = hf(o)
              , c = e ? Mg : i ? Rg : ki;
            if (l.call(o, s))
                return c(r.get(s));
            if (l.call(o, a))
                return c(r.get(a));
            r !== o && r.get(s)
        },
        get size() {
            const s = this.__v_raw;
            return !i && Ii(tn(s), "iterate", vl),
            Reflect.get(s, "size", s)
        },
        has(s) {
            const r = this.__v_raw
              , o = tn(r)
              , a = tn(s);
            return i || (ha(s, a) && Ii(o, "has", s),
            Ii(o, "has", a)),
            s === a ? r.has(s) : r.has(s) || r.has(a)
        },
        forEach(s, r) {
            const o = this
              , a = o.__v_raw
              , l = tn(a)
              , c = e ? Mg : i ? Rg : ki;
            return !i && Ii(l, "iterate", vl),
            a.forEach( (u, d) => s.call(r, c(u), c(d), o))
        }
    };
    return Jn(t, i ? {
        add: pf("add"),
        set: pf("set"),
        delete: pf("delete"),
        clear: pf("clear")
    } : {
        add(s) {
            !e && !$s(s) && !Cl(s) && (s = tn(s));
            const r = tn(this);
            return hf(r).has.call(r, s) || (r.add(s),
            Eo(r, "add", s, s)),
            this
        },
        set(s, r) {
            !e && !$s(r) && !Cl(r) && (r = tn(r));
            const o = tn(this)
              , {has: a, get: l} = hf(o);
            let c = a.call(o, s);
            c || (s = tn(s),
            c = a.call(o, s));
            const u = l.call(o, s);
            return o.set(s, r),
            c ? ha(r, u) && Eo(o, "set", s, r) : Eo(o, "add", s, r),
            this
        },
        delete(s) {
            const r = tn(this)
              , {has: o, get: a} = hf(r);
            let l = o.call(r, s);
            l || (s = tn(s),
            l = o.call(r, s)),
            a && a.call(r, s);
            const c = r.delete(s);
            return l && Eo(r, "delete", s, void 0),
            c
        },
        clear() {
            const s = tn(this)
              , r = s.size !== 0
              , o = s.clear();
            return r && Eo(s, "clear", void 0, void 0),
            o
        }
    }),
    ["keys", "values", "entries", Symbol.iterator].forEach(s => {
        t[s] = nL(s, i, e)
    }
    ),
    t
}
function r_(i, e) {
    const t = iL(i, e);
    return (n, s, r) => s === "__v_isReactive" ? !i : s === "__v_isReadonly" ? i : s === "__v_raw" ? n : Reflect.get(hn(t, s) && s in n ? t : n, s, r)
}
const sL = {
    get: r_(!1, !1)
}
  , rL = {
    get: r_(!1, !0)
}
  , oL = {
    get: r_(!0, !1)
};
const Ew = new WeakMap
  , ww = new WeakMap
  , Tw = new WeakMap
  , aL = new WeakMap;
function lL(i) {
    switch (i) {
    case "Object":
    case "Array":
        return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
        return 2;
    default:
        return 0
    }
}
function cL(i) {
    return i.__v_skip || !Object.isExtensible(i) ? 0 : lL(FR(i))
}
function ei(i) {
    return Cl(i) ? i : o_(i, !1, QR, sL, Ew)
}
function Aw(i) {
    return o_(i, !1, tL, rL, ww)
}
function Cw(i) {
    return o_(i, !0, eL, oL, Tw)
}
function o_(i, e, t, n, s) {
    if (!_n(i) || i.__v_raw && !(e && i.__v_isReactive))
        return i;
    const r = s.get(i);
    if (r)
        return r;
    const o = cL(i);
    if (o === 0)
        return i;
    const a = new Proxy(i,o === 2 ? n : t);
    return s.set(i, a),
    a
}
function Io(i) {
    return Cl(i) ? Io(i.__v_raw) : !!(i && i.__v_isReactive)
}
function Cl(i) {
    return !!(i && i.__v_isReadonly)
}
function $s(i) {
    return !!(i && i.__v_isShallow)
}
function a_(i) {
    return i ? !!i.__v_raw : !1
}
function tn(i) {
    const e = i && i.__v_raw;
    return e ? tn(e) : i
}
function l_(i) {
    return !hn(i, "__v_skip") && Object.isExtensible(i) && sw(i, "__v_skip", !0),
    i
}
const ki = i => _n(i) ? ei(i) : i
  , Rg = i => _n(i) ? Cw(i) : i;
function Sn(i) {
    return i ? i.__v_isRef === !0 : !1
}
function xe(i) {
    return Mw(i, !1)
}
function uL(i) {
    return Mw(i, !0)
}
function Mw(i, e) {
    return Sn(i) ? i : new dL(i,e)
}
class dL {
    constructor(e, t) {
        this.dep = new s_,
        this.__v_isRef = !0,
        this.__v_isShallow = !1,
        this._rawValue = t ? e : tn(e),
        this._value = t ? e : ki(e),
        this.__v_isShallow = t
    }
    get value() {
        return this.dep.track(),
        this._value
    }
    set value(e) {
        const t = this._rawValue
          , n = this.__v_isShallow || $s(e) || Cl(e);
        e = n ? e : tn(e),
        ha(e, t) && (this._rawValue = e,
        this._value = n ? e : ki(e),
        this.dep.trigger())
    }
}
function E(i) {
    return Sn(i) ? i.value : i
}
const fL = {
    get: (i, e, t) => e === "__v_raw" ? i : E(Reflect.get(i, e, t)),
    set: (i, e, t, n) => {
        const s = i[e];
        return Sn(s) && !Sn(t) ? (s.value = t,
        !0) : Reflect.set(i, e, t, n)
    }
};
function Rw(i) {
    return Io(i) ? i : new Proxy(i,fL)
}
function hL(i) {
    const e = wt(i) ? new Array(i.length) : {};
    for (const t in i)
        e[t] = Lw(i, t);
    return e
}
class pL {
    constructor(e, t, n) {
        this._object = e,
        this._key = t,
        this._defaultValue = n,
        this.__v_isRef = !0,
        this._value = void 0
    }
    get value() {
        const e = this._object[this._key];
        return this._value = e === void 0 ? this._defaultValue : e
    }
    set value(e) {
        this._object[this._key] = e
    }
    get dep() {
        return jR(tn(this._object), this._key)
    }
}
class mL {
    constructor(e) {
        this._getter = e,
        this.__v_isRef = !0,
        this.__v_isReadonly = !0,
        this._value = void 0
    }
    get value() {
        return this._value = this._getter()
    }
}
function gL(i, e, t) {
    return Sn(i) ? i : Nt(i) ? new mL(i) : _n(i) && arguments.length > 1 ? Lw(i, e, t) : xe(i)
}
function Lw(i, e, t) {
    const n = i[e];
    return Sn(n) ? n : new pL(i,e,t)
}
class vL {
    constructor(e, t, n) {
        this.fn = e,
        this.setter = t,
        this._value = void 0,
        this.dep = new s_(this),
        this.__v_isRef = !0,
        this.deps = void 0,
        this.depsTail = void 0,
        this.flags = 16,
        this.globalVersion = _d - 1,
        this.next = void 0,
        this.effect = this,
        this.__v_isReadonly = !t,
        this.isSSR = n
    }
    notify() {
        if (this.flags |= 16,
        !(this.flags & 8) && Tn !== this)
            return pw(this, !0),
            !0
    }
    get value() {
        const e = this.dep.track();
        return vw(this),
        e && (e.version = this.dep.version),
        this._value
    }
    set value(e) {
        this.setter && this.setter(e)
    }
}
function _L(i, e, t=!1) {
    let n, s;
    return Nt(i) ? n = i : (n = i.get,
    s = i.set),
    new vL(n,s,t)
}
const mf = {}
  , qh = new WeakMap;
let Qa;
function xL(i, e=!1, t=Qa) {
    if (t) {
        let n = qh.get(t);
        n || qh.set(t, n = []),
        n.push(i)
    }
}
function yL(i, e, t=yn) {
    const {immediate: n, deep: s, once: r, scheduler: o, augmentJob: a, call: l} = t
      , c = b => s ? b : $s(b) || s === !1 || s === 0 ? wo(b, 1) : wo(b);
    let u, d, f, h, p = !1, g = !1;
    if (Sn(i) ? (d = () => i.value,
    p = $s(i)) : Io(i) ? (d = () => c(i),
    p = !0) : wt(i) ? (g = !0,
    p = i.some(b => Io(b) || $s(b)),
    d = () => i.map(b => {
        if (Sn(b))
            return b.value;
        if (Io(b))
            return c(b);
        if (Nt(b))
            return l ? l(b, 2) : b()
    }
    )) : Nt(i) ? e ? d = l ? () => l(i, 2) : i : d = () => {
        if (f) {
            Ra();
            try {
                f()
            } finally {
                La()
            }
        }
        const b = Qa;
        Qa = u;
        try {
            return l ? l(i, 3, [h]) : i(h)
        } finally {
            Qa = b
        }
    }
    : d = hr,
    e && s) {
        const b = d
          , S = s === !0 ? 1 / 0 : s;
        d = () => wo(b(), S)
    }
    const m = e_()
      , v = () => {
        u.stop(),
        m && m.active && Yv(m.effects, u)
    }
    ;
    if (r && e) {
        const b = e;
        e = (...S) => {
            b(...S),
            v()
        }
    }
    let _ = g ? new Array(i.length).fill(mf) : mf;
    const y = b => {
        if (!(!(u.flags & 1) || !u.dirty && !b))
            if (e) {
                const S = u.run();
                if (s || p || (g ? S.some( (C, M) => ha(C, _[M])) : ha(S, _))) {
                    f && f();
                    const C = Qa;
                    Qa = u;
                    try {
                        const M = [S, _ === mf ? void 0 : g && _[0] === mf ? [] : _, h];
                        l ? l(e, 3, M) : e(...M),
                        _ = S
                    } finally {
                        Qa = C
                    }
                }
            } else
                u.run()
    }
    ;
    return a && a(y),
    u = new fw(d),
    u.scheduler = o ? () => o(y, !1) : y,
    h = b => xL(b, !1, u),
    f = u.onStop = () => {
        const b = qh.get(u);
        if (b) {
            if (l)
                l(b, 4);
            else
                for (const S of b)
                    S();
            qh.delete(u)
        }
    }
    ,
    e ? n ? y(!0) : _ = u.run() : o ? o(y.bind(null, !0), !0) : u.run(),
    v.pause = u.pause.bind(u),
    v.resume = u.resume.bind(u),
    v.stop = v,
    v
}
function wo(i, e=1 / 0, t) {
    if (e <= 0 || !_n(i) || i.__v_skip || (t = t || new Set,
    t.has(i)))
        return i;
    if (t.add(i),
    e--,
    Sn(i))
        wo(i.value, e, t);
    else if (wt(i))
        for (let n = 0; n < i.length; n++)
            wo(i[n], e, t);
    else if (Su(i) || Ic(i))
        i.forEach(n => {
            wo(n, e, t)
        }
        );
    else if (iw(i)) {
        for (const n in i)
            wo(i[n], e, t);
        for (const n of Object.getOwnPropertySymbols(i))
            Object.prototype.propertyIsEnumerable.call(i, n) && wo(i[n], e, t)
    }
    return i
}
/**
* @vue/runtime-core v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function Kd(i, e, t, n) {
    try {
        return n ? i(...n) : i()
    } catch (s) {
        Xd(s, e, t)
    }
}
function xr(i, e, t, n) {
    if (Nt(i)) {
        const s = Kd(i, e, t, n);
        return s && Zv(s) && s.catch(r => {
            Xd(r, e, t)
        }
        ),
        s
    }
    if (wt(i)) {
        const s = [];
        for (let r = 0; r < i.length; r++)
            s.push(xr(i[r], e, t, n));
        return s
    }
}
function Xd(i, e, t, n=!0) {
    const s = e ? e.vnode : null
      , {errorHandler: r, throwUnhandledErrorInProduction: o} = e && e.appContext.config || yn;
    if (e) {
        let a = e.parent;
        const l = e.proxy
          , c = `https://vuejs.org/error-reference/#runtime-${t}`;
        for (; a; ) {
            const u = a.ec;
            if (u) {
                for (let d = 0; d < u.length; d++)
                    if (u[d](i, l, c) === !1)
                        return
            }
            a = a.parent
        }
        if (r) {
            Ra(),
            Kd(r, null, 10, [i, l, c]),
            La();
            return
        }
    }
    bL(i, t, s, n, o)
}
function bL(i, e, t, n=!0, s=!1) {
    if (s)
        throw i;
    console.error(i)
}
const zi = [];
let Cr = -1;
const Pc = [];
let Jo = null
  , _c = 0;
const Iw = Promise.resolve();
let jh = null;
function Yd(i) {
    const e = jh || Iw;
    return i ? e.then(this ? i.bind(this) : i) : e
}
function SL(i) {
    let e = Cr + 1
      , t = zi.length;
    for (; e < t; ) {
        const n = e + t >>> 1
          , s = zi[n]
          , r = yd(s);
        r < i || r === i && s.flags & 2 ? e = n + 1 : t = n
    }
    return e
}
function c_(i) {
    if (!(i.flags & 1)) {
        const e = yd(i)
          , t = zi[zi.length - 1];
        !t || !(i.flags & 2) && e >= yd(t) ? zi.push(i) : zi.splice(SL(e), 0, i),
        i.flags |= 1,
        kw()
    }
}
function kw() {
    jh || (jh = Iw.then(Dw))
}
function Lg(i) {
    wt(i) ? Pc.push(...i) : Jo && i.id === -1 ? Jo.splice(_c + 1, 0, i) : i.flags & 1 || (Pc.push(i),
    i.flags |= 1),
    kw()
}
function Zx(i, e, t=Cr + 1) {
    for (; t < zi.length; t++) {
        const n = zi[t];
        if (n && n.flags & 2) {
            if (i && n.id !== i.uid)
                continue;
            zi.splice(t, 1),
            t--,
            n.flags & 4 && (n.flags &= -2),
            n(),
            n.flags & 4 || (n.flags &= -2)
        }
    }
}
function Pw(i) {
    if (Pc.length) {
        const e = [...new Set(Pc)].sort( (t, n) => yd(t) - yd(n));
        if (Pc.length = 0,
        Jo) {
            Jo.push(...e);
            return
        }
        for (Jo = e,
        _c = 0; _c < Jo.length; _c++) {
            const t = Jo[_c];
            t.flags & 4 && (t.flags &= -2),
            t.flags & 8 || t(),
            t.flags &= -2
        }
        Jo = null,
        _c = 0
    }
}
const yd = i => i.id == null ? i.flags & 2 ? -1 : 1 / 0 : i.id;
function Dw(i) {
    const e = hr;
    try {
        for (Cr = 0; Cr < zi.length; Cr++) {
            const t = zi[Cr];
            t && !(t.flags & 8) && (t.flags & 4 && (t.flags &= -2),
            Kd(t, t.i, t.i ? 15 : 14),
            t.flags & 4 || (t.flags &= -2))
        }
    } finally {
        for (; Cr < zi.length; Cr++) {
            const t = zi[Cr];
            t && (t.flags &= -2)
        }
        Cr = -1,
        zi.length = 0,
        Pw(),
        jh = null,
        (zi.length || Pc.length) && Dw()
    }
}
let ai = null
  , Fw = null;
function Kh(i) {
    const e = ai;
    return ai = i,
    Fw = i && i.type.__scopeId || null,
    e
}
function Y(i, e=ai, t) {
    if (!e || i._n)
        return i;
    const n = (...s) => {
        n._d && uy(-1);
        const r = Kh(e);
        let o;
        try {
            o = i(...s)
        } finally {
            Kh(r),
            n._d && uy(1)
        }
        return o
    }
    ;
    return n._n = !0,
    n._c = !0,
    n._d = !0,
    n
}
function zt(i, e) {
    if (ai === null)
        return i;
    const t = sm(ai)
      , n = i.dirs || (i.dirs = []);
    for (let s = 0; s < e.length; s++) {
        let[r,o,a,l=yn] = e[s];
        r && (Nt(r) && (r = {
            mounted: r,
            updated: r
        }),
        r.deep && wo(o),
        n.push({
            dir: r,
            instance: t,
            value: o,
            oldValue: void 0,
            arg: a,
            modifiers: l
        }))
    }
    return i
}
function Fa(i, e, t, n) {
    const s = i.dirs
      , r = e && e.dirs;
    for (let o = 0; o < s.length; o++) {
        const a = s[o];
        r && (a.oldValue = r[o].value);
        let l = a.dir[n];
        l && (Ra(),
        xr(l, t, 8, [i.el, a, i, e]),
        La())
    }
}
const Ow = Symbol("_vte")
  , Uw = i => i.__isTeleport
  , id = i => i && (i.disabled || i.disabled === "")
  , Jx = i => i && (i.defer || i.defer === "")
  , Qx = i => typeof SVGElement < "u" && i instanceof SVGElement
  , ey = i => typeof MathMLElement == "function" && i instanceof MathMLElement
  , Ig = (i, e) => {
    const t = i && i.to;
    return Fn(t) ? e ? e(t) : null : t
}
  , Nw = {
    name: "Teleport",
    __isTeleport: !0,
    process(i, e, t, n, s, r, o, a, l, c) {
        const {mc: u, pc: d, pbc: f, o: {insert: h, querySelector: p, createText: g, createComment: m}} = c
          , v = id(e.props);
        let {shapeFlag: _, children: y, dynamicChildren: b} = e;
        if (i == null) {
            const S = e.el = g("")
              , C = e.anchor = g("");
            h(S, t, n),
            h(C, t, n);
            const M = (T, A) => {
                _ & 16 && (s && s.isCE && (s.ce._teleportTarget = T),
                u(y, T, A, s, r, o, a, l))
            }
              , L = () => {
                const T = e.target = Ig(e.props, p)
                  , A = Bw(T, e, g, h);
                T && (o !== "svg" && Qx(T) ? o = "svg" : o !== "mathml" && ey(T) && (o = "mathml"),
                v || (M(T, A),
                ph(e, !1)))
            }
            ;
            v && (M(t, C),
            ph(e, !0)),
            Jx(e.props) ? si( () => {
                L(),
                e.el.__isMounted = !0
            }
            , r) : L()
        } else {
            if (Jx(e.props) && !i.el.__isMounted) {
                si( () => {
                    Nw.process(i, e, t, n, s, r, o, a, l, c),
                    delete i.el.__isMounted
                }
                , r);
                return
            }
            e.el = i.el,
            e.targetStart = i.targetStart;
            const S = e.anchor = i.anchor
              , C = e.target = i.target
              , M = e.targetAnchor = i.targetAnchor
              , L = id(i.props)
              , T = L ? t : C
              , A = L ? S : M;
            if (o === "svg" || Qx(C) ? o = "svg" : (o === "mathml" || ey(C)) && (o = "mathml"),
            b ? (f(i.dynamicChildren, b, T, s, r, o, a),
            g_(i, e, !0)) : l || d(i, e, T, A, s, r, o, a, !1),
            v)
                L ? e.props && i.props && e.props.to !== i.props.to && (e.props.to = i.props.to) : gf(e, t, S, c, 1);
            else if ((e.props && e.props.to) !== (i.props && i.props.to)) {
                const k = e.target = Ig(e.props, p);
                k && gf(e, k, null, c, 0)
            } else
                L && gf(e, C, M, c, 1);
            ph(e, v)
        }
    },
    remove(i, e, t, {um: n, o: {remove: s}}, r) {
        const {shapeFlag: o, children: a, anchor: l, targetStart: c, targetAnchor: u, target: d, props: f} = i;
        if (d && (s(c),
        s(u)),
        r && s(l),
        o & 16) {
            const h = r || !id(f);
            for (let p = 0; p < a.length; p++) {
                const g = a[p];
                n(g, e, t, h, !!g.dynamicChildren)
            }
        }
    },
    move: gf,
    hydrate: EL
};
function gf(i, e, t, {o: {insert: n}, m: s}, r=2) {
    r === 0 && n(i.targetAnchor, e, t);
    const {el: o, anchor: a, shapeFlag: l, children: c, props: u} = i
      , d = r === 2;
    if (d && n(o, e, t),
    (!d || id(u)) && l & 16)
        for (let f = 0; f < c.length; f++)
            s(c[f], e, t, 2);
    d && n(a, e, t)
}
function EL(i, e, t, n, s, r, {o: {nextSibling: o, parentNode: a, querySelector: l, insert: c, createText: u}}, d) {
    const f = e.target = Ig(e.props, l);
    if (f) {
        const h = id(e.props)
          , p = f._lpa || f.firstChild;
        if (e.shapeFlag & 16)
            if (h)
                e.anchor = d(o(i), e, a(i), t, n, s, r),
                e.targetStart = p,
                e.targetAnchor = p && o(p);
            else {
                e.anchor = o(i);
                let g = p;
                for (; g; ) {
                    if (g && g.nodeType === 8) {
                        if (g.data === "teleport start anchor")
                            e.targetStart = g;
                        else if (g.data === "teleport anchor") {
                            e.targetAnchor = g,
                            f._lpa = e.targetAnchor && o(e.targetAnchor);
                            break
                        }
                    }
                    g = o(g)
                }
                e.targetAnchor || Bw(f, e, u, c),
                d(p && o(p), e, f, t, n, s, r)
            }
        ph(e, h)
    }
    return e.anchor && o(e.anchor)
}
const u_ = Nw;
function ph(i, e) {
    const t = i.ctx;
    if (t && t.ut) {
        let n, s;
        for (e ? (n = i.el,
        s = i.anchor) : (n = i.targetStart,
        s = i.targetAnchor); n && n !== s; )
            n.nodeType === 1 && n.setAttribute("data-v-owner", t.uid),
            n = n.nextSibling;
        t.ut()
    }
}
function Bw(i, e, t, n) {
    const s = e.targetStart = t("")
      , r = e.targetAnchor = t("");
    return s[Ow] = r,
    i && (n(s, i),
    n(r, i)),
    r
}
const Qo = Symbol("_leaveCb")
  , vf = Symbol("_enterCb");
function wL() {
    const i = {
        isMounted: !1,
        isLeaving: !1,
        isUnmounting: !1,
        leavingVNodes: new Map
    };
    return Ln( () => {
        i.isMounted = !0
    }
    ),
    Zd( () => {
        i.isUnmounting = !0
    }
    ),
    i
}
const Ls = [Function, Array]
  , Vw = {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    onBeforeEnter: Ls,
    onEnter: Ls,
    onAfterEnter: Ls,
    onEnterCancelled: Ls,
    onBeforeLeave: Ls,
    onLeave: Ls,
    onAfterLeave: Ls,
    onLeaveCancelled: Ls,
    onBeforeAppear: Ls,
    onAppear: Ls,
    onAfterAppear: Ls,
    onAppearCancelled: Ls
}
  , $w = i => {
    const e = i.subTree;
    return e.component ? $w(e.component) : e
}
  , TL = {
    name: "BaseTransition",
    props: Vw,
    setup(i, {slots: e}) {
        const t = im()
          , n = wL();
        return () => {
            const s = e.default && Gw(e.default(), !0);
            if (!s || !s.length)
                return;
            const r = Hw(s)
              , o = tn(i)
              , {mode: a} = o;
            if (n.isLeaving)
                return zm(r);
            const l = ty(r);
            if (!l)
                return zm(r);
            let c = kg(l, o, n, t, d => c = d);
            l.type !== _i && Yc(l, c);
            let u = t.subTree && ty(t.subTree);
            if (u && u.type !== _i && !lr(l, u) && $w(t).type !== _i) {
                let d = kg(u, o, n, t);
                if (Yc(u, d),
                a === "out-in" && l.type !== _i)
                    return n.isLeaving = !0,
                    d.afterLeave = () => {
                        n.isLeaving = !1,
                        t.job.flags & 8 || t.update(),
                        delete d.afterLeave,
                        u = void 0
                    }
                    ,
                    zm(r);
                a === "in-out" && l.type !== _i ? d.delayLeave = (f, h, p) => {
                    const g = zw(n, u);
                    g[String(u.key)] = u,
                    f[Qo] = () => {
                        h(),
                        f[Qo] = void 0,
                        delete c.delayedLeave,
                        u = void 0
                    }
                    ,
                    c.delayedLeave = () => {
                        p(),
                        delete c.delayedLeave,
                        u = void 0
                    }
                }
                : u = void 0
            } else
                u && (u = void 0);
            return r
        }
    }
};
function Hw(i) {
    let e = i[0];
    if (i.length > 1) {
        for (const t of i)
            if (t.type !== _i) {
                e = t;
                break
            }
    }
    return e
}
const AL = TL;
function zw(i, e) {
    const {leavingVNodes: t} = i;
    let n = t.get(e.type);
    return n || (n = Object.create(null),
    t.set(e.type, n)),
    n
}
function kg(i, e, t, n, s) {
    const {appear: r, mode: o, persisted: a=!1, onBeforeEnter: l, onEnter: c, onAfterEnter: u, onEnterCancelled: d, onBeforeLeave: f, onLeave: h, onAfterLeave: p, onLeaveCancelled: g, onBeforeAppear: m, onAppear: v, onAfterAppear: _, onAppearCancelled: y} = e
      , b = String(i.key)
      , S = zw(t, i)
      , C = (T, A) => {
        T && xr(T, n, 9, A)
    }
      , M = (T, A) => {
        const k = A[1];
        C(T, A),
        wt(T) ? T.every(D => D.length <= 1) && k() : T.length <= 1 && k()
    }
      , L = {
        mode: o,
        persisted: a,
        beforeEnter(T) {
            let A = l;
            if (!t.isMounted)
                if (r)
                    A = m || l;
                else
                    return;
            T[Qo] && T[Qo](!0);
            const k = S[b];
            k && lr(i, k) && k.el[Qo] && k.el[Qo](),
            C(A, [T])
        },
        enter(T) {
            let A = c
              , k = u
              , D = d;
            if (!t.isMounted)
                if (r)
                    A = v || c,
                    k = _ || u,
                    D = y || d;
                else
                    return;
            let F = !1;
            const z = T[vf] = G => {
                F || (F = !0,
                G ? C(D, [T]) : C(k, [T]),
                L.delayedLeave && L.delayedLeave(),
                T[vf] = void 0)
            }
            ;
            A ? M(A, [T, z]) : z()
        },
        leave(T, A) {
            const k = String(i.key);
            if (T[vf] && T[vf](!0),
            t.isUnmounting)
                return A();
            C(f, [T]);
            let D = !1;
            const F = T[Qo] = z => {
                D || (D = !0,
                A(),
                z ? C(g, [T]) : C(p, [T]),
                T[Qo] = void 0,
                S[k] === i && delete S[k])
            }
            ;
            S[k] = i,
            h ? M(h, [T, F]) : F()
        },
        clone(T) {
            const A = kg(T, e, t, n, s);
            return s && s(A),
            A
        }
    };
    return L
}
function zm(i) {
    if (Qp(i))
        return i = Do(i),
        i.children = null,
        i
}
function ty(i) {
    if (!Qp(i))
        return Uw(i.type) && i.children ? Hw(i.children) : i;
    const {shapeFlag: e, children: t} = i;
    if (t) {
        if (e & 16)
            return t[0];
        if (e & 32 && Nt(t.default))
            return t.default()
    }
}
function Yc(i, e) {
    i.shapeFlag & 6 && i.component ? (i.transition = e,
    Yc(i.component.subTree, e)) : i.shapeFlag & 128 ? (i.ssContent.transition = e.clone(i.ssContent),
    i.ssFallback.transition = e.clone(i.ssFallback)) : i.transition = e
}
function Gw(i, e=!1, t) {
    let n = []
      , s = 0;
    for (let r = 0; r < i.length; r++) {
        let o = i[r];
        const a = t == null ? o.key : String(t) + String(o.key != null ? o.key : r);
        o.type === Ge ? (o.patchFlag & 128 && s++,
        n = n.concat(Gw(o.children, e, a))) : (e || o.type !== _i) && n.push(a != null ? Do(o, {
            key: a
        }) : o)
    }
    if (s > 1)
        for (let r = 0; r < n.length; r++)
            n[r].patchFlag = -2;
    return n
}
/*! #__NO_SIDE_EFFECTS__ */
function ut(i, e) {
    return Nt(i) ? ( () => Jn({
        name: i.name
    }, e, {
        setup: i
    }))() : i
}
function Ww(i) {
    i.ids = [i.ids[0] + i.ids[2]++ + "-", 0, 0]
}
function Xh(i, e, t, n, s=!1) {
    if (wt(i)) {
        i.forEach( (p, g) => Xh(p, e && (wt(e) ? e[g] : e), t, n, s));
        return
    }
    if (_l(n) && !s) {
        n.shapeFlag & 512 && n.type.__asyncResolved && n.component.subTree.component && Xh(i, e, t, n.component.subTree);
        return
    }
    const r = n.shapeFlag & 4 ? sm(n.component) : n.el
      , o = s ? null : r
      , {i: a, r: l} = i
      , c = e && e.r
      , u = a.refs === yn ? a.refs = {} : a.refs
      , d = a.setupState
      , f = tn(d)
      , h = d === yn ? () => !1 : p => hn(f, p);
    if (c != null && c !== l && (Fn(c) ? (u[c] = null,
    h(c) && (d[c] = null)) : Sn(c) && (c.value = null)),
    Nt(l))
        Kd(l, a, 12, [o, u]);
    else {
        const p = Fn(l)
          , g = Sn(l);
        if (p || g) {
            const m = () => {
                if (i.f) {
                    const v = p ? h(l) ? d[l] : u[l] : l.value;
                    s ? wt(v) && Yv(v, r) : wt(v) ? v.includes(r) || v.push(r) : p ? (u[l] = [r],
                    h(l) && (d[l] = u[l])) : (l.value = [r],
                    i.k && (u[i.k] = l.value))
                } else
                    p ? (u[l] = o,
                    h(l) && (d[l] = o)) : g && (l.value = o,
                    i.k && (u[i.k] = o))
            }
            ;
            o ? (m.id = -1,
            si(m, t)) : m()
        }
    }
}
qd().requestIdleCallback;
qd().cancelIdleCallback;
const _l = i => !!i.type.__asyncLoader
  , Qp = i => i.type.__isKeepAlive
  , CL = {
    name: "KeepAlive",
    __isKeepAlive: !0,
    props: {
        include: [String, RegExp, Array],
        exclude: [String, RegExp, Array],
        max: [String, Number]
    },
    setup(i, {slots: e}) {
        const t = im()
          , n = t.ctx;
        if (!n.renderer)
            return () => {
                const _ = e.default && e.default();
                return _ && _.length === 1 ? _[0] : _
            }
            ;
        const s = new Map
          , r = new Set;
        let o = null;
        const a = t.suspense
          , {renderer: {p: l, m: c, um: u, o: {createElement: d}}} = n
          , f = d("div");
        n.activate = (_, y, b, S, C) => {
            const M = _.component;
            c(_, y, b, 0, a),
            l(M.vnode, _, y, b, M, a, S, _.slotScopeIds, C),
            si( () => {
                M.isDeactivated = !1,
                M.a && kc(M.a);
                const L = _.props && _.props.onVnodeMounted;
                L && Ps(L, M.parent, _)
            }
            , a)
        }
        ,
        n.deactivate = _ => {
            const y = _.component;
            Zh(y.m),
            Zh(y.a),
            c(_, f, null, 1, a),
            si( () => {
                y.da && kc(y.da);
                const b = _.props && _.props.onVnodeUnmounted;
                b && Ps(b, y.parent, _),
                y.isDeactivated = !0
            }
            , a)
        }
        ;
        function h(_) {
            Gm(_),
            u(_, t, a, !0)
        }
        function p(_) {
            s.forEach( (y, b) => {
                const S = $g(y.type);
                S && !_(S) && g(b)
            }
            )
        }
        function g(_) {
            const y = s.get(_);
            y && (!o || !lr(y, o)) ? h(y) : o && Gm(o),
            s.delete(_),
            r.delete(_)
        }
        Bt( () => [i.include, i.exclude], ([_,y]) => {
            _ && p(b => zu(_, b)),
            y && p(b => !zu(y, b))
        }
        , {
            flush: "post",
            deep: !0
        });
        let m = null;
        const v = () => {
            m != null && (Jh(t.subTree.type) ? si( () => {
                s.set(m, _f(t.subTree))
            }
            , t.subTree.suspense) : s.set(m, _f(t.subTree)))
        }
        ;
        return Ln(v),
        Kw(v),
        Zd( () => {
            s.forEach(_ => {
                const {subTree: y, suspense: b} = t
                  , S = _f(y);
                if (_.type === S.type && _.key === S.key) {
                    Gm(S);
                    const C = S.component.da;
                    C && si(C, b);
                    return
                }
                h(_)
            }
            )
        }
        ),
        () => {
            if (m = null,
            !e.default)
                return o = null;
            const _ = e.default()
              , y = _[0];
            if (_.length > 1)
                return o = null,
                _;
            if (!Ml(y) || !(y.shapeFlag & 4) && !(y.shapeFlag & 128))
                return o = null,
                y;
            let b = _f(y);
            if (b.type === _i)
                return o = null,
                b;
            const S = b.type
              , C = $g(_l(b) ? b.type.__asyncResolved || {} : S)
              , {include: M, exclude: L, max: T} = i;
            if (M && (!C || !zu(M, C)) || L && C && zu(L, C))
                return b.shapeFlag &= -257,
                o = b,
                y;
            const A = b.key == null ? S : b.key
              , k = s.get(A);
            return b.el && (b = Do(b),
            y.shapeFlag & 128 && (y.ssContent = b)),
            m = A,
            k ? (b.el = k.el,
            b.component = k.component,
            b.transition && Yc(b, b.transition),
            b.shapeFlag |= 512,
            r.delete(A),
            r.add(A)) : (r.add(A),
            T && r.size > parseInt(T, 10) && g(r.values().next().value)),
            b.shapeFlag |= 256,
            o = b,
            Jh(y.type) ? y : b
        }
    }
}
  , ML = CL;
function zu(i, e) {
    return wt(i) ? i.some(t => zu(t, e)) : Fn(i) ? i.split(",").includes(e) : DR(i) ? (i.lastIndex = 0,
    i.test(e)) : !1
}
function Ti(i, e) {
    jw(i, "a", e)
}
function qw(i, e) {
    jw(i, "da", e)
}
function jw(i, e, t=xi) {
    const n = i.__wdc || (i.__wdc = () => {
        let s = t;
        for (; s; ) {
            if (s.isDeactivated)
                return;
            s = s.parent
        }
        return i()
    }
    );
    if (em(e, n, t),
    t) {
        let s = t.parent;
        for (; s && s.parent; )
            Qp(s.parent.vnode) && RL(n, e, t, s),
            s = s.parent
    }
}
function RL(i, e, t, n) {
    const s = em(e, i, n, !0);
    Ms( () => {
        Yv(n[e], s)
    }
    , t)
}
function Gm(i) {
    i.shapeFlag &= -257,
    i.shapeFlag &= -513
}
function _f(i) {
    return i.shapeFlag & 128 ? i.ssContent : i
}
function em(i, e, t=xi, n=!1) {
    if (t) {
        const s = t[i] || (t[i] = [])
          , r = e.__weh || (e.__weh = (...o) => {
            Ra();
            const a = Rl(t)
              , l = xr(e, t, i, o);
            return a(),
            La(),
            l
        }
        );
        return n ? s.unshift(r) : s.push(r),
        r
    }
}
const No = i => (e, t=xi) => {
    (!Sd || i === "sp") && em(i, (...n) => e(...n), t)
}
  , d_ = No("bm")
  , Ln = No("m")
  , LL = No("bu")
  , Kw = No("u")
  , Zd = No("bum")
  , Ms = No("um")
  , IL = No("sp")
  , kL = No("rtg")
  , PL = No("rtc");
function DL(i, e=xi) {
    em("ec", i, e)
}
const f_ = "components"
  , FL = "directives";
function li(i, e) {
    return h_(f_, i, !0, e) || i
}
const Xw = Symbol.for("v-ndc");
function ys(i) {
    return Fn(i) ? h_(f_, i, !1) || i : i || Xw
}
function Jd(i) {
    return h_(FL, i)
}
function h_(i, e, t=!0, n=!1) {
    const s = ai || xi;
    if (s) {
        const r = s.type;
        if (i === f_) {
            const a = $g(r, !1);
            if (a && (a === e || a === Ws(e) || a === Zp(Ws(e))))
                return r
        }
        const o = ny(s[i] || r[i], e) || ny(s.appContext[i], e);
        return !o && n ? r : o
    }
}
function ny(i, e) {
    return i && (i[e] || i[Ws(e)] || i[Zp(Ws(e))])
}
function Ht(i, e, t, n) {
    let s;
    const r = t && t[n]
      , o = wt(i);
    if (o || Fn(i)) {
        const a = o && Io(i);
        let l = !1;
        a && (l = !$s(i),
        i = Jp(i)),
        s = new Array(i.length);
        for (let c = 0, u = i.length; c < u; c++)
            s[c] = e(l ? ki(i[c]) : i[c], c, void 0, r && r[c])
    } else if (typeof i == "number") {
        s = new Array(i);
        for (let a = 0; a < i; a++)
            s[a] = e(a + 1, a, void 0, r && r[a])
    } else if (_n(i))
        if (i[Symbol.iterator])
            s = Array.from(i, (a, l) => e(a, l, void 0, r && r[l]));
        else {
            const a = Object.keys(i);
            s = new Array(a.length);
            for (let l = 0, c = a.length; l < c; l++) {
                const u = a[l];
                s[l] = e(i[u], u, l, r && r[l])
            }
        }
    else
        s = [];
    return t && (t[n] = s),
    s
}
function Nl(i, e, t={}, n, s) {
    if (ai.ce || ai.parent && _l(ai.parent) && ai.parent.ce)
        return e !== "default" && (t.name = e),
        w(),
        Re(Ge, null, [O("slot", t, n && n())], 64);
    let r = i[e];
    r && r._c && (r._d = !1),
    w();
    const o = r && Yw(r(t))
      , a = t.key || o && o.key
      , l = Re(Ge, {
        key: (a && !_r(a) ? a : `_${e}`) + (!o && n ? "_fb" : "")
    }, o || (n ? n() : []), o && i._ === 1 ? 64 : -2);
    return !s && l.scopeId && (l.slotScopeIds = [l.scopeId + "-s"]),
    r && r._c && (r._d = !0),
    l
}
function Yw(i) {
    return i.some(e => Ml(e) ? !(e.type === _i || e.type === Ge && !Yw(e.children)) : !0) ? i : null
}
const Pg = i => i ? gT(i) ? sm(i) : Pg(i.parent) : null
  , sd = Jn(Object.create(null), {
    $: i => i,
    $el: i => i.vnode.el,
    $data: i => i.data,
    $props: i => i.props,
    $attrs: i => i.attrs,
    $slots: i => i.slots,
    $refs: i => i.refs,
    $parent: i => Pg(i.parent),
    $root: i => Pg(i.root),
    $host: i => i.ce,
    $emit: i => i.emit,
    $options: i => p_(i),
    $forceUpdate: i => i.f || (i.f = () => {
        c_(i.update)
    }
    ),
    $nextTick: i => i.n || (i.n = Yd.bind(i.proxy)),
    $watch: i => s5.bind(i)
})
  , Wm = (i, e) => i !== yn && !i.__isScriptSetup && hn(i, e)
  , OL = {
    get({_: i}, e) {
        if (e === "__v_skip")
            return !0;
        const {ctx: t, setupState: n, data: s, props: r, accessCache: o, type: a, appContext: l} = i;
        let c;
        if (e[0] !== "$") {
            const h = o[e];
            if (h !== void 0)
                switch (h) {
                case 1:
                    return n[e];
                case 2:
                    return s[e];
                case 4:
                    return t[e];
                case 3:
                    return r[e]
                }
            else {
                if (Wm(n, e))
                    return o[e] = 1,
                    n[e];
                if (s !== yn && hn(s, e))
                    return o[e] = 2,
                    s[e];
                if ((c = i.propsOptions[0]) && hn(c, e))
                    return o[e] = 3,
                    r[e];
                if (t !== yn && hn(t, e))
                    return o[e] = 4,
                    t[e];
                Dg && (o[e] = 0)
            }
        }
        const u = sd[e];
        let d, f;
        if (u)
            return e === "$attrs" && Ii(i.attrs, "get", ""),
            u(i);
        if ((d = a.__cssModules) && (d = d[e]))
            return d;
        if (t !== yn && hn(t, e))
            return o[e] = 4,
            t[e];
        if (f = l.config.globalProperties,
        hn(f, e))
            return f[e]
    },
    set({_: i}, e, t) {
        const {data: n, setupState: s, ctx: r} = i;
        return Wm(s, e) ? (s[e] = t,
        !0) : n !== yn && hn(n, e) ? (n[e] = t,
        !0) : hn(i.props, e) || e[0] === "$" && e.slice(1)in i ? !1 : (r[e] = t,
        !0)
    },
    has({_: {data: i, setupState: e, accessCache: t, ctx: n, appContext: s, propsOptions: r}}, o) {
        let a;
        return !!t[o] || i !== yn && hn(i, o) || Wm(e, o) || (a = r[0]) && hn(a, o) || hn(n, o) || hn(sd, o) || hn(s.config.globalProperties, o)
    },
    defineProperty(i, e, t) {
        return t.get != null ? i._.accessCache[e] = 0 : hn(t, "value") && this.set(i, e, t.value, null),
        Reflect.defineProperty(i, e, t)
    }
};
function iy(i) {
    return wt(i) ? i.reduce( (e, t) => (e[t] = null,
    e), {}) : i
}
function As(i) {
    const e = im();
    let t = i();
    return Bg(),
    Zv(t) && (t = t.catch(n => {
        throw Rl(e),
        n
    }
    )),
    [t, () => Rl(e)]
}
let Dg = !0;
function UL(i) {
    const e = p_(i)
      , t = i.proxy
      , n = i.ctx;
    Dg = !1,
    e.beforeCreate && sy(e.beforeCreate, i, "bc");
    const {data: s, computed: r, methods: o, watch: a, provide: l, inject: c, created: u, beforeMount: d, mounted: f, beforeUpdate: h, updated: p, activated: g, deactivated: m, beforeDestroy: v, beforeUnmount: _, destroyed: y, unmounted: b, render: S, renderTracked: C, renderTriggered: M, errorCaptured: L, serverPrefetch: T, expose: A, inheritAttrs: k, components: D, directives: F, filters: z} = e;
    if (c && NL(c, n, null),
    o)
        for (const X in o) {
            const K = o[X];
            Nt(K) && (n[X] = K.bind(t))
        }
    if (s) {
        const X = s.call(t, t);
        _n(X) && (i.data = ei(X))
    }
    if (Dg = !0,
    r)
        for (const X in r) {
            const K = r[X]
              , ce = Nt(K) ? K.bind(t, t) : Nt(K.get) ? K.get.bind(t, t) : hr
              , ue = !Nt(K) && Nt(K.set) ? K.set.bind(t) : hr
              , Ie = Vt({
                get: ce,
                set: ue
            });
            Object.defineProperty(n, X, {
                enumerable: !0,
                configurable: !0,
                get: () => Ie.value,
                set: ke => Ie.value = ke
            })
        }
    if (a)
        for (const X in a)
            Zw(a[X], n, t, X);
    if (l) {
        const X = Nt(l) ? l.call(t) : l;
        Reflect.ownKeys(X).forEach(K => {
            mh(K, X[K])
        }
        )
    }
    u && sy(u, i, "c");
    function H(X, K) {
        wt(K) ? K.forEach(ce => X(ce.bind(t))) : K && X(K.bind(t))
    }
    if (H(d_, d),
    H(Ln, f),
    H(LL, h),
    H(Kw, p),
    H(Ti, g),
    H(qw, m),
    H(DL, L),
    H(PL, C),
    H(kL, M),
    H(Zd, _),
    H(Ms, b),
    H(IL, T),
    wt(A))
        if (A.length) {
            const X = i.exposed || (i.exposed = {});
            A.forEach(K => {
                Object.defineProperty(X, K, {
                    get: () => t[K],
                    set: ce => t[K] = ce
                })
            }
            )
        } else
            i.exposed || (i.exposed = {});
    S && i.render === hr && (i.render = S),
    k != null && (i.inheritAttrs = k),
    D && (i.components = D),
    F && (i.directives = F),
    T && Ww(i)
}
function NL(i, e, t=hr) {
    wt(i) && (i = Fg(i));
    for (const n in i) {
        const s = i[n];
        let r;
        _n(s) ? "default"in s ? r = Es(s.from || n, s.default, !0) : r = Es(s.from || n) : r = Es(s),
        Sn(r) ? Object.defineProperty(e, n, {
            enumerable: !0,
            configurable: !0,
            get: () => r.value,
            set: o => r.value = o
        }) : e[n] = r
    }
}
function sy(i, e, t) {
    xr(wt(i) ? i.map(n => n.bind(e.proxy)) : i.bind(e.proxy), e, t)
}
function Zw(i, e, t, n) {
    let s = n.includes(".") ? uT(t, n) : () => t[n];
    if (Fn(i)) {
        const r = e[i];
        Nt(r) && Bt(s, r)
    } else if (Nt(i))
        Bt(s, i.bind(t));
    else if (_n(i))
        if (wt(i))
            i.forEach(r => Zw(r, e, t, n));
        else {
            const r = Nt(i.handler) ? i.handler.bind(t) : e[i.handler];
            Nt(r) && Bt(s, r, i)
        }
}
function p_(i) {
    const e = i.type
      , {mixins: t, extends: n} = e
      , {mixins: s, optionsCache: r, config: {optionMergeStrategies: o}} = i.appContext
      , a = r.get(e);
    let l;
    return a ? l = a : !s.length && !t && !n ? l = e : (l = {},
    s.length && s.forEach(c => Yh(l, c, o, !0)),
    Yh(l, e, o)),
    _n(e) && r.set(e, l),
    l
}
function Yh(i, e, t, n=!1) {
    const {mixins: s, extends: r} = e;
    r && Yh(i, r, t, !0),
    s && s.forEach(o => Yh(i, o, t, !0));
    for (const o in e)
        if (!(n && o === "expose")) {
            const a = BL[o] || t && t[o];
            i[o] = a ? a(i[o], e[o]) : e[o]
        }
    return i
}
const BL = {
    data: ry,
    props: oy,
    emits: oy,
    methods: Gu,
    computed: Gu,
    beforeCreate: Ni,
    created: Ni,
    beforeMount: Ni,
    mounted: Ni,
    beforeUpdate: Ni,
    updated: Ni,
    beforeDestroy: Ni,
    beforeUnmount: Ni,
    destroyed: Ni,
    unmounted: Ni,
    activated: Ni,
    deactivated: Ni,
    errorCaptured: Ni,
    serverPrefetch: Ni,
    components: Gu,
    directives: Gu,
    watch: $L,
    provide: ry,
    inject: VL
};
function ry(i, e) {
    return e ? i ? function() {
        return Jn(Nt(i) ? i.call(this, this) : i, Nt(e) ? e.call(this, this) : e)
    }
    : e : i
}
function VL(i, e) {
    return Gu(Fg(i), Fg(e))
}
function Fg(i) {
    if (wt(i)) {
        const e = {};
        for (let t = 0; t < i.length; t++)
            e[i[t]] = i[t];
        return e
    }
    return i
}
function Ni(i, e) {
    return i ? [...new Set([].concat(i, e))] : e
}
function Gu(i, e) {
    return i ? Jn(Object.create(null), i, e) : e
}
function oy(i, e) {
    return i ? wt(i) && wt(e) ? [...new Set([...i, ...e])] : Jn(Object.create(null), iy(i), iy(e != null ? e : {})) : e
}
function $L(i, e) {
    if (!i)
        return e;
    if (!e)
        return i;
    const t = Jn(Object.create(null), i);
    for (const n in e)
        t[n] = Ni(i[n], e[n]);
    return t
}
function Jw() {
    return {
        app: null,
        config: {
            isNativeTag: kR,
            performance: !1,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: void 0,
            warnHandler: void 0,
            compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: Object.create(null),
        optionsCache: new WeakMap,
        propsCache: new WeakMap,
        emitsCache: new WeakMap
    }
}
let HL = 0;
function zL(i, e) {
    return function(n, s=null) {
        Nt(n) || (n = Jn({}, n)),
        s != null && !_n(s) && (s = null);
        const r = Jw()
          , o = new WeakSet
          , a = [];
        let l = !1;
        const c = r.app = {
            _uid: HL++,
            _component: n,
            _props: s,
            _container: null,
            _context: r,
            _instance: null,
            version: L5,
            get config() {
                return r.config
            },
            set config(u) {},
            use(u, ...d) {
                return o.has(u) || (u && Nt(u.install) ? (o.add(u),
                u.install(c, ...d)) : Nt(u) && (o.add(u),
                u(c, ...d))),
                c
            },
            mixin(u) {
                return r.mixins.includes(u) || r.mixins.push(u),
                c
            },
            component(u, d) {
                return d ? (r.components[u] = d,
                c) : r.components[u]
            },
            directive(u, d) {
                return d ? (r.directives[u] = d,
                c) : r.directives[u]
            },
            mount(u, d, f) {
                if (!l) {
                    const h = c._ceVNode || O(n, s);
                    return h.appContext = r,
                    f === !0 ? f = "svg" : f === !1 && (f = void 0),
                    d && e ? e(h, u) : i(h, u, f),
                    l = !0,
                    c._container = u,
                    u.__vue_app__ = c,
                    sm(h.component)
                }
            },
            onUnmount(u) {
                a.push(u)
            },
            unmount() {
                l && (xr(a, c._instance, 16),
                i(null, c._container),
                delete c._container.__vue_app__)
            },
            provide(u, d) {
                return r.provides[u] = d,
                c
            },
            runWithContext(u) {
                const d = xl;
                xl = c;
                try {
                    return u()
                } finally {
                    xl = d
                }
            }
        };
        return c
    }
}
let xl = null;
function mh(i, e) {
    if (xi) {
        let t = xi.provides;
        const n = xi.parent && xi.parent.provides;
        n === t && (t = xi.provides = Object.create(n)),
        t[i] = e
    }
}
function Es(i, e, t=!1) {
    const n = xi || ai;
    if (n || xl) {
        const s = xl ? xl._context.provides : n ? n.parent == null ? n.vnode.appContext && n.vnode.appContext.provides : n.parent.provides : void 0;
        if (s && i in s)
            return s[i];
        if (arguments.length > 1)
            return t && Nt(e) ? e.call(n && n.proxy) : e
    }
}
function GL() {
    return !!(xi || ai || xl)
}
const Qw = {}
  , eT = () => Object.create(Qw)
  , tT = i => Object.getPrototypeOf(i) === Qw;
function WL(i, e, t, n=!1) {
    const s = {}
      , r = eT();
    i.propsDefaults = Object.create(null),
    nT(i, e, s, r);
    for (const o in i.propsOptions[0])
        o in s || (s[o] = void 0);
    t ? i.props = n ? s : Aw(s) : i.type.props ? i.props = s : i.props = r,
    i.attrs = r
}
function qL(i, e, t, n) {
    const {props: s, attrs: r, vnode: {patchFlag: o}} = i
      , a = tn(s)
      , [l] = i.propsOptions;
    let c = !1;
    if ((n || o > 0) && !(o & 16)) {
        if (o & 8) {
            const u = i.vnode.dynamicProps;
            for (let d = 0; d < u.length; d++) {
                let f = u[d];
                if (tm(i.emitsOptions, f))
                    continue;
                const h = e[f];
                if (l)
                    if (hn(r, f))
                        h !== r[f] && (r[f] = h,
                        c = !0);
                    else {
                        const p = Ws(f);
                        s[p] = Og(l, a, p, h, i, !1)
                    }
                else
                    h !== r[f] && (r[f] = h,
                    c = !0)
            }
        }
    } else {
        nT(i, e, s, r) && (c = !0);
        let u;
        for (const d in a)
            (!e || !hn(e, d) && ((u = Ul(d)) === d || !hn(e, u))) && (l ? t && (t[d] !== void 0 || t[u] !== void 0) && (s[d] = Og(l, a, d, void 0, i, !0)) : delete s[d]);
        if (r !== a)
            for (const d in r)
                (!e || !hn(e, d) && !0) && (delete r[d],
                c = !0)
    }
    c && Eo(i.attrs, "set", "")
}
function nT(i, e, t, n) {
    const [s,r] = i.propsOptions;
    let o = !1, a;
    if (e)
        for (let l in e) {
            if (ed(l))
                continue;
            const c = e[l];
            let u;
            s && hn(s, u = Ws(l)) ? !r || !r.includes(u) ? t[u] = c : (a || (a = {}))[u] = c : tm(i.emitsOptions, l) || (!(l in n) || c !== n[l]) && (n[l] = c,
            o = !0)
        }
    if (r) {
        const l = tn(t)
          , c = a || yn;
        for (let u = 0; u < r.length; u++) {
            const d = r[u];
            t[d] = Og(s, l, d, c[d], i, !hn(c, d))
        }
    }
    return o
}
function Og(i, e, t, n, s, r) {
    const o = i[t];
    if (o != null) {
        const a = hn(o, "default");
        if (a && n === void 0) {
            const l = o.default;
            if (o.type !== Function && !o.skipFactory && Nt(l)) {
                const {propsDefaults: c} = s;
                if (t in c)
                    n = c[t];
                else {
                    const u = Rl(s);
                    n = c[t] = l.call(null, e),
                    u()
                }
            } else
                n = l;
            s.ce && s.ce._setProp(t, n)
        }
        o[0] && (r && !a ? n = !1 : o[1] && (n === "" || n === Ul(t)) && (n = !0))
    }
    return n
}
const jL = new WeakMap;
function iT(i, e, t=!1) {
    const n = t ? jL : e.propsCache
      , s = n.get(i);
    if (s)
        return s;
    const r = i.props
      , o = {}
      , a = [];
    let l = !1;
    if (!Nt(i)) {
        const u = d => {
            l = !0;
            const [f,h] = iT(d, e, !0);
            Jn(o, f),
            h && a.push(...h)
        }
        ;
        !t && e.mixins.length && e.mixins.forEach(u),
        i.extends && u(i.extends),
        i.mixins && i.mixins.forEach(u)
    }
    if (!r && !l)
        return _n(i) && n.set(i, Lc),
        Lc;
    if (wt(r))
        for (let u = 0; u < r.length; u++) {
            const d = Ws(r[u]);
            ay(d) && (o[d] = yn)
        }
    else if (r)
        for (const u in r) {
            const d = Ws(u);
            if (ay(d)) {
                const f = r[u]
                  , h = o[d] = wt(f) || Nt(f) ? {
                    type: f
                } : Jn({}, f)
                  , p = h.type;
                let g = !1
                  , m = !0;
                if (wt(p))
                    for (let v = 0; v < p.length; ++v) {
                        const _ = p[v]
                          , y = Nt(_) && _.name;
                        if (y === "Boolean") {
                            g = !0;
                            break
                        } else
                            y === "String" && (m = !1)
                    }
                else
                    g = Nt(p) && p.name === "Boolean";
                h[0] = g,
                h[1] = m,
                (g || hn(h, "default")) && a.push(d)
            }
        }
    const c = [o, a];
    return _n(i) && n.set(i, c),
    c
}
function ay(i) {
    return i[0] !== "$" && !ed(i)
}
const sT = i => i[0] === "_" || i === "$stable"
  , m_ = i => wt(i) ? i.map(rr) : [rr(i)]
  , KL = (i, e, t) => {
    if (e._n)
        return e;
    const n = Y( (...s) => m_(e(...s)), t);
    return n._c = !1,
    n
}
  , rT = (i, e, t) => {
    const n = i._ctx;
    for (const s in i) {
        if (sT(s))
            continue;
        const r = i[s];
        if (Nt(r))
            e[s] = KL(s, r, n);
        else if (r != null) {
            const o = m_(r);
            e[s] = () => o
        }
    }
}
  , oT = (i, e) => {
    const t = m_(e);
    i.slots.default = () => t
}
  , aT = (i, e, t) => {
    for (const n in e)
        (t || n !== "_") && (i[n] = e[n])
}
  , XL = (i, e, t) => {
    const n = i.slots = eT();
    if (i.vnode.shapeFlag & 32) {
        const s = e._;
        s ? (aT(n, e, t),
        t && sw(n, "_", s, !0)) : rT(e, n)
    } else
        e && oT(i, e)
}
  , YL = (i, e, t) => {
    const {vnode: n, slots: s} = i;
    let r = !0
      , o = yn;
    if (n.shapeFlag & 32) {
        const a = e._;
        a ? t && a === 1 ? r = !1 : aT(s, e, t) : (r = !e.$stable,
        rT(e, s)),
        o = e
    } else
        e && (oT(i, e),
        o = {
            default: 1
        });
    if (r)
        for (const a in s)
            !sT(a) && o[a] == null && delete s[a]
}
;
function ZL() {
    typeof __VUE_PROD_HYDRATION_MISMATCH_DETAILS__ != "boolean" && (qd().__VUE_PROD_HYDRATION_MISMATCH_DETAILS__ = !1)
}
const si = v5;
function JL(i) {
    return QL(i)
}
function QL(i, e) {
    ZL();
    const t = qd();
    t.__VUE__ = !0;
    const {insert: n, remove: s, patchProp: r, createElement: o, createText: a, createComment: l, setText: c, setElementText: u, parentNode: d, nextSibling: f, setScopeId: h=hr, insertStaticContent: p} = i
      , g = (B, V, Q, he=null, Ee=null, we=null, Le=void 0, N=null, I=!!V.dynamicChildren) => {
        if (B === V)
            return;
        B && !lr(B, V) && (he = q(B),
        ke(B, Ee, we, !0),
        B = null),
        V.patchFlag === -2 && (I = !1,
        V.dynamicChildren = null);
        const {type: W, ref: re, shapeFlag: oe} = V;
        switch (W) {
        case nm:
            m(B, V, Q, he);
            break;
        case _i:
            v(B, V, Q, he);
            break;
        case gh:
            B == null && _(V, Q, he, Le);
            break;
        case Ge:
            D(B, V, Q, he, Ee, we, Le, N, I);
            break;
        default:
            oe & 1 ? S(B, V, Q, he, Ee, we, Le, N, I) : oe & 6 ? F(B, V, Q, he, Ee, we, Le, N, I) : (oe & 64 || oe & 128) && W.process(B, V, Q, he, Ee, we, Le, N, I, Pe)
        }
        re != null && Ee && Xh(re, B && B.ref, we, V || B, !V)
    }
      , m = (B, V, Q, he) => {
        if (B == null)
            n(V.el = a(V.children), Q, he);
        else {
            const Ee = V.el = B.el;
            V.children !== B.children && c(Ee, V.children)
        }
    }
      , v = (B, V, Q, he) => {
        B == null ? n(V.el = l(V.children || ""), Q, he) : V.el = B.el
    }
      , _ = (B, V, Q, he) => {
        [B.el,B.anchor] = p(B.children, V, Q, he, B.el, B.anchor)
    }
      , y = ({el: B, anchor: V}, Q, he) => {
        let Ee;
        for (; B && B !== V; )
            Ee = f(B),
            n(B, Q, he),
            B = Ee;
        n(V, Q, he)
    }
      , b = ({el: B, anchor: V}) => {
        let Q;
        for (; B && B !== V; )
            Q = f(B),
            s(B),
            B = Q;
        s(V)
    }
      , S = (B, V, Q, he, Ee, we, Le, N, I) => {
        V.type === "svg" ? Le = "svg" : V.type === "math" && (Le = "mathml"),
        B == null ? C(V, Q, he, Ee, we, Le, N, I) : T(B, V, Ee, we, Le, N, I)
    }
      , C = (B, V, Q, he, Ee, we, Le, N) => {
        let I, W;
        const {props: re, shapeFlag: oe, transition: fe, dirs: $e} = B;
        if (I = B.el = o(B.type, we, re && re.is, re),
        oe & 8 ? u(I, B.children) : oe & 16 && L(B.children, I, null, he, Ee, qm(B, we), Le, N),
        $e && Fa(B, null, he, "created"),
        M(I, B, B.scopeId, Le, he),
        re) {
            for (const qe in re)
                qe !== "value" && !ed(qe) && r(I, qe, null, re[qe], we, he);
            "value"in re && r(I, "value", null, re.value, we),
            (W = re.onVnodeBeforeMount) && Ps(W, he, B)
        }
        $e && Fa(B, null, he, "beforeMount");
        const Oe = e5(Ee, fe);
        Oe && fe.beforeEnter(I),
        n(I, V, Q),
        ((W = re && re.onVnodeMounted) || Oe || $e) && si( () => {
            W && Ps(W, he, B),
            Oe && fe.enter(I),
            $e && Fa(B, null, he, "mounted")
        }
        , Ee)
    }
      , M = (B, V, Q, he, Ee) => {
        if (Q && h(B, Q),
        he)
            for (let we = 0; we < he.length; we++)
                h(B, he[we]);
        if (Ee) {
            let we = Ee.subTree;
            if (V === we || Jh(we.type) && (we.ssContent === V || we.ssFallback === V)) {
                const Le = Ee.vnode;
                M(B, Le, Le.scopeId, Le.slotScopeIds, Ee.parent)
            }
        }
    }
      , L = (B, V, Q, he, Ee, we, Le, N, I=0) => {
        for (let W = I; W < B.length; W++) {
            const re = B[W] = N ? ea(B[W]) : rr(B[W]);
            g(null, re, V, Q, he, Ee, we, Le, N)
        }
    }
      , T = (B, V, Q, he, Ee, we, Le) => {
        const N = V.el = B.el;
        let {patchFlag: I, dynamicChildren: W, dirs: re} = V;
        I |= B.patchFlag & 16;
        const oe = B.props || yn
          , fe = V.props || yn;
        let $e;
        if (Q && Oa(Q, !1),
        ($e = fe.onVnodeBeforeUpdate) && Ps($e, Q, V, B),
        re && Fa(V, B, Q, "beforeUpdate"),
        Q && Oa(Q, !0),
        (oe.innerHTML && fe.innerHTML == null || oe.textContent && fe.textContent == null) && u(N, ""),
        W ? A(B.dynamicChildren, W, N, Q, he, qm(V, Ee), we) : Le || K(B, V, N, null, Q, he, qm(V, Ee), we, !1),
        I > 0) {
            if (I & 16)
                k(N, oe, fe, Q, Ee);
            else if (I & 2 && oe.class !== fe.class && r(N, "class", null, fe.class, Ee),
            I & 4 && r(N, "style", oe.style, fe.style, Ee),
            I & 8) {
                const Oe = V.dynamicProps;
                for (let qe = 0; qe < Oe.length; qe++) {
                    const nt = Oe[qe]
                      , Be = oe[nt]
                      , Xe = fe[nt];
                    (Xe !== Be || nt === "value") && r(N, nt, Be, Xe, Ee, Q)
                }
            }
            I & 1 && B.children !== V.children && u(N, V.children)
        } else
            !Le && W == null && k(N, oe, fe, Q, Ee);
        (($e = fe.onVnodeUpdated) || re) && si( () => {
            $e && Ps($e, Q, V, B),
            re && Fa(V, B, Q, "updated")
        }
        , he)
    }
      , A = (B, V, Q, he, Ee, we, Le) => {
        for (let N = 0; N < V.length; N++) {
            const I = B[N]
              , W = V[N]
              , re = I.el && (I.type === Ge || !lr(I, W) || I.shapeFlag & 70) ? d(I.el) : Q;
            g(I, W, re, null, he, Ee, we, Le, !0)
        }
    }
      , k = (B, V, Q, he, Ee) => {
        if (V !== Q) {
            if (V !== yn)
                for (const we in V)
                    !ed(we) && !(we in Q) && r(B, we, V[we], null, Ee, he);
            for (const we in Q) {
                if (ed(we))
                    continue;
                const Le = Q[we]
                  , N = V[we];
                Le !== N && we !== "value" && r(B, we, N, Le, Ee, he)
            }
            "value"in Q && r(B, "value", V.value, Q.value, Ee)
        }
    }
      , D = (B, V, Q, he, Ee, we, Le, N, I) => {
        const W = V.el = B ? B.el : a("")
          , re = V.anchor = B ? B.anchor : a("");
        let {patchFlag: oe, dynamicChildren: fe, slotScopeIds: $e} = V;
        $e && (N = N ? N.concat($e) : $e),
        B == null ? (n(W, Q, he),
        n(re, Q, he),
        L(V.children || [], Q, re, Ee, we, Le, N, I)) : oe > 0 && oe & 64 && fe && B.dynamicChildren ? (A(B.dynamicChildren, fe, Q, Ee, we, Le, N),
        (V.key != null || Ee && V === Ee.subTree) && g_(B, V, !0)) : K(B, V, Q, re, Ee, we, Le, N, I)
    }
      , F = (B, V, Q, he, Ee, we, Le, N, I) => {
        V.slotScopeIds = N,
        B == null ? V.shapeFlag & 512 ? Ee.ctx.activate(V, Q, he, Le, I) : z(V, Q, he, Ee, we, Le, I) : G(B, V, I)
    }
      , z = (B, V, Q, he, Ee, we, Le) => {
        const N = B.component = w5(B, he, Ee);
        if (Qp(B) && (N.ctx.renderer = Pe),
        T5(N, !1, Le),
        N.asyncDep) {
            if (Ee && Ee.registerDep(N, H, Le),
            !B.el) {
                const I = N.subTree = O(_i);
                v(null, I, V, Q)
            }
        } else
            H(N, B, V, Q, Ee, we, Le)
    }
      , G = (B, V, Q) => {
        const he = V.component = B.component;
        if (u5(B, V, Q))
            if (he.asyncDep && !he.asyncResolved) {
                X(he, V, Q);
                return
            } else
                he.next = V,
                he.update();
        else
            V.el = B.el,
            he.vnode = V
    }
      , H = (B, V, Q, he, Ee, we, Le) => {
        const N = () => {
            if (B.isMounted) {
                let {next: oe, bu: fe, u: $e, parent: Oe, vnode: qe} = B;
                {
                    const ht = lT(B);
                    if (ht) {
                        oe && (oe.el = qe.el,
                        X(B, oe, Le)),
                        ht.asyncDep.then( () => {
                            B.isUnmounted || N()
                        }
                        );
                        return
                    }
                }
                let nt = oe, Be;
                Oa(B, !1),
                oe ? (oe.el = qe.el,
                X(B, oe, Le)) : oe = qe,
                fe && kc(fe),
                (Be = oe.props && oe.props.onVnodeBeforeUpdate) && Ps(Be, Oe, oe, qe),
                Oa(B, !0);
                const Xe = jm(B)
                  , Rt = B.subTree;
                B.subTree = Xe,
                g(Rt, Xe, d(Rt.el), q(Rt), B, Ee, we),
                oe.el = Xe.el,
                nt === null && v_(B, Xe.el),
                $e && si($e, Ee),
                (Be = oe.props && oe.props.onVnodeUpdated) && si( () => Ps(Be, Oe, oe, qe), Ee)
            } else {
                let oe;
                const {el: fe, props: $e} = V
                  , {bm: Oe, m: qe, parent: nt, root: Be, type: Xe} = B
                  , Rt = _l(V);
                if (Oa(B, !1),
                Oe && kc(Oe),
                !Rt && (oe = $e && $e.onVnodeBeforeMount) && Ps(oe, nt, V),
                Oa(B, !0),
                fe && j) {
                    const ht = () => {
                        B.subTree = jm(B),
                        j(fe, B.subTree, B, Ee, null)
                    }
                    ;
                    Rt && Xe.__asyncHydrate ? Xe.__asyncHydrate(fe, B, ht) : ht()
                } else {
                    Be.ce && Be.ce._injectChildStyle(Xe);
                    const ht = B.subTree = jm(B);
                    g(null, ht, Q, he, B, Ee, we),
                    V.el = ht.el
                }
                if (qe && si(qe, Ee),
                !Rt && (oe = $e && $e.onVnodeMounted)) {
                    const ht = V;
                    si( () => Ps(oe, nt, ht), Ee)
                }
                (V.shapeFlag & 256 || nt && _l(nt.vnode) && nt.vnode.shapeFlag & 256) && B.a && si(B.a, Ee),
                B.isMounted = !0,
                V = Q = he = null
            }
        }
        ;
        B.scope.on();
        const I = B.effect = new fw(N);
        B.scope.off();
        const W = B.update = I.run.bind(I)
          , re = B.job = I.runIfDirty.bind(I);
        re.i = B,
        re.id = B.uid,
        I.scheduler = () => c_(re),
        Oa(B, !0),
        W()
    }
      , X = (B, V, Q) => {
        V.component = B;
        const he = B.vnode.props;
        B.vnode = V,
        B.next = null,
        qL(B, V.props, he, Q),
        YL(B, V.children, Q),
        Ra(),
        Zx(B),
        La()
    }
      , K = (B, V, Q, he, Ee, we, Le, N, I=!1) => {
        const W = B && B.children
          , re = B ? B.shapeFlag : 0
          , oe = V.children
          , {patchFlag: fe, shapeFlag: $e} = V;
        if (fe > 0) {
            if (fe & 128) {
                ue(W, oe, Q, he, Ee, we, Le, N, I);
                return
            } else if (fe & 256) {
                ce(W, oe, Q, he, Ee, we, Le, N, I);
                return
            }
        }
        $e & 8 ? (re & 16 && be(W, Ee, we),
        oe !== W && u(Q, oe)) : re & 16 ? $e & 16 ? ue(W, oe, Q, he, Ee, we, Le, N, I) : be(W, Ee, we, !0) : (re & 8 && u(Q, ""),
        $e & 16 && L(oe, Q, he, Ee, we, Le, N, I))
    }
      , ce = (B, V, Q, he, Ee, we, Le, N, I) => {
        B = B || Lc,
        V = V || Lc;
        const W = B.length
          , re = V.length
          , oe = Math.min(W, re);
        let fe;
        for (fe = 0; fe < oe; fe++) {
            const $e = V[fe] = I ? ea(V[fe]) : rr(V[fe]);
            g(B[fe], $e, Q, null, Ee, we, Le, N, I)
        }
        W > re ? be(B, Ee, we, !0, !1, oe) : L(V, Q, he, Ee, we, Le, N, I, oe)
    }
      , ue = (B, V, Q, he, Ee, we, Le, N, I) => {
        let W = 0;
        const re = V.length;
        let oe = B.length - 1
          , fe = re - 1;
        for (; W <= oe && W <= fe; ) {
            const $e = B[W]
              , Oe = V[W] = I ? ea(V[W]) : rr(V[W]);
            if (lr($e, Oe))
                g($e, Oe, Q, null, Ee, we, Le, N, I);
            else
                break;
            W++
        }
        for (; W <= oe && W <= fe; ) {
            const $e = B[oe]
              , Oe = V[fe] = I ? ea(V[fe]) : rr(V[fe]);
            if (lr($e, Oe))
                g($e, Oe, Q, null, Ee, we, Le, N, I);
            else
                break;
            oe--,
            fe--
        }
        if (W > oe) {
            if (W <= fe) {
                const $e = fe + 1
                  , Oe = $e < re ? V[$e].el : he;
                for (; W <= fe; )
                    g(null, V[W] = I ? ea(V[W]) : rr(V[W]), Q, Oe, Ee, we, Le, N, I),
                    W++
            }
        } else if (W > fe)
            for (; W <= oe; )
                ke(B[W], Ee, we, !0),
                W++;
        else {
            const $e = W
              , Oe = W
              , qe = new Map;
            for (W = Oe; W <= fe; W++) {
                const _t = V[W] = I ? ea(V[W]) : rr(V[W]);
                _t.key != null && qe.set(_t.key, W)
            }
            let nt, Be = 0;
            const Xe = fe - Oe + 1;
            let Rt = !1
              , ht = 0;
            const lt = new Array(Xe);
            for (W = 0; W < Xe; W++)
                lt[W] = 0;
            for (W = $e; W <= oe; W++) {
                const _t = B[W];
                if (Be >= Xe) {
                    ke(_t, Ee, we, !0);
                    continue
                }
                let Xt;
                if (_t.key != null)
                    Xt = qe.get(_t.key);
                else
                    for (nt = Oe; nt <= fe; nt++)
                        if (lt[nt - Oe] === 0 && lr(_t, V[nt])) {
                            Xt = nt;
                            break
                        }
                Xt === void 0 ? ke(_t, Ee, we, !0) : (lt[Xt - Oe] = W + 1,
                Xt >= ht ? ht = Xt : Rt = !0,
                g(_t, V[Xt], Q, null, Ee, we, Le, N, I),
                Be++)
            }
            const kt = Rt ? t5(lt) : Lc;
            for (nt = kt.length - 1,
            W = Xe - 1; W >= 0; W--) {
                const _t = Oe + W
                  , Xt = V[_t]
                  , te = _t + 1 < re ? V[_t + 1].el : he;
                lt[W] === 0 ? g(null, Xt, Q, te, Ee, we, Le, N, I) : Rt && (nt < 0 || W !== kt[nt] ? Ie(Xt, Q, te, 2) : nt--)
            }
        }
    }
      , Ie = (B, V, Q, he, Ee=null) => {
        const {el: we, type: Le, transition: N, children: I, shapeFlag: W} = B;
        if (W & 6) {
            Ie(B.component.subTree, V, Q, he);
            return
        }
        if (W & 128) {
            B.suspense.move(V, Q, he);
            return
        }
        if (W & 64) {
            Le.move(B, V, Q, Pe);
            return
        }
        if (Le === Ge) {
            n(we, V, Q);
            for (let oe = 0; oe < I.length; oe++)
                Ie(I[oe], V, Q, he);
            n(B.anchor, V, Q);
            return
        }
        if (Le === gh) {
            y(B, V, Q);
            return
        }
        if (he !== 2 && W & 1 && N)
            if (he === 0)
                N.beforeEnter(we),
                n(we, V, Q),
                si( () => N.enter(we), Ee);
            else {
                const {leave: oe, delayLeave: fe, afterLeave: $e} = N
                  , Oe = () => n(we, V, Q)
                  , qe = () => {
                    oe(we, () => {
                        Oe(),
                        $e && $e()
                    }
                    )
                }
                ;
                fe ? fe(we, Oe, qe) : qe()
            }
        else
            n(we, V, Q)
    }
      , ke = (B, V, Q, he=!1, Ee=!1) => {
        const {type: we, props: Le, ref: N, children: I, dynamicChildren: W, shapeFlag: re, patchFlag: oe, dirs: fe, cacheIndex: $e} = B;
        if (oe === -2 && (Ee = !1),
        N != null && Xh(N, null, Q, B, !0),
        $e != null && (V.renderCache[$e] = void 0),
        re & 256) {
            V.ctx.deactivate(B);
            return
        }
        const Oe = re & 1 && fe
          , qe = !_l(B);
        let nt;
        if (qe && (nt = Le && Le.onVnodeBeforeUnmount) && Ps(nt, V, B),
        re & 6)
            Se(B.component, Q, he);
        else {
            if (re & 128) {
                B.suspense.unmount(Q, he);
                return
            }
            Oe && Fa(B, null, V, "beforeUnmount"),
            re & 64 ? B.type.remove(B, V, Q, Pe, he) : W && !W.hasOnce && (we !== Ge || oe > 0 && oe & 64) ? be(W, V, Q, !1, !0) : (we === Ge && oe & 384 || !Ee && re & 16) && be(I, V, Q),
            he && We(B)
        }
        (qe && (nt = Le && Le.onVnodeUnmounted) || Oe) && si( () => {
            nt && Ps(nt, V, B),
            Oe && Fa(B, null, V, "unmounted")
        }
        , Q)
    }
      , We = B => {
        const {type: V, el: Q, anchor: he, transition: Ee} = B;
        if (V === Ge) {
            se(Q, he);
            return
        }
        if (V === gh) {
            b(B);
            return
        }
        const we = () => {
            s(Q),
            Ee && !Ee.persisted && Ee.afterLeave && Ee.afterLeave()
        }
        ;
        if (B.shapeFlag & 1 && Ee && !Ee.persisted) {
            const {leave: Le, delayLeave: N} = Ee
              , I = () => Le(Q, we);
            N ? N(B.el, we, I) : I()
        } else
            we()
    }
      , se = (B, V) => {
        let Q;
        for (; B !== V; )
            Q = f(B),
            s(B),
            B = Q;
        s(V)
    }
      , Se = (B, V, Q) => {
        const {bum: he, scope: Ee, job: we, subTree: Le, um: N, m: I, a: W} = B;
        Zh(I),
        Zh(W),
        he && kc(he),
        Ee.stop(),
        we && (we.flags |= 8,
        ke(Le, B, V, Q)),
        N && si(N, V),
        si( () => {
            B.isUnmounted = !0
        }
        , V),
        V && V.pendingBranch && !V.isUnmounted && B.asyncDep && !B.asyncResolved && B.suspenseId === V.pendingId && (V.deps--,
        V.deps === 0 && V.resolve())
    }
      , be = (B, V, Q, he=!1, Ee=!1, we=0) => {
        for (let Le = we; Le < B.length; Le++)
            ke(B[Le], V, Q, he, Ee)
    }
      , q = B => {
        if (B.shapeFlag & 6)
            return q(B.component.subTree);
        if (B.shapeFlag & 128)
            return B.suspense.next();
        const V = f(B.anchor || B.el)
          , Q = V && V[Ow];
        return Q ? f(Q) : V
    }
    ;
    let me = !1;
    const Ce = (B, V, Q) => {
        B == null ? V._vnode && ke(V._vnode, null, null, !0) : g(V._vnode || null, B, V, null, null, null, Q),
        V._vnode = B,
        me || (me = !0,
        Zx(),
        Pw(),
        me = !1)
    }
      , Pe = {
        p: g,
        um: ke,
        m: Ie,
        r: We,
        mt: z,
        mc: L,
        pc: K,
        pbc: A,
        n: q,
        o: i
    };
    let vt, j;
    return e && ([vt,j] = e(Pe)),
    {
        render: Ce,
        hydrate: vt,
        createApp: zL(Ce, vt)
    }
}
function qm({type: i, props: e}, t) {
    return t === "svg" && i === "foreignObject" || t === "mathml" && i === "annotation-xml" && e && e.encoding && e.encoding.includes("html") ? void 0 : t
}
function Oa({effect: i, job: e}, t) {
    t ? (i.flags |= 32,
    e.flags |= 4) : (i.flags &= -33,
    e.flags &= -5)
}
function e5(i, e) {
    return (!i || i && !i.pendingBranch) && e && !e.persisted
}
function g_(i, e, t=!1) {
    const n = i.children
      , s = e.children;
    if (wt(n) && wt(s))
        for (let r = 0; r < n.length; r++) {
            const o = n[r];
            let a = s[r];
            a.shapeFlag & 1 && !a.dynamicChildren && ((a.patchFlag <= 0 || a.patchFlag === 32) && (a = s[r] = ea(s[r]),
            a.el = o.el),
            !t && a.patchFlag !== -2 && g_(o, a)),
            a.type === nm && (a.el = o.el)
        }
}
function t5(i) {
    const e = i.slice()
      , t = [0];
    let n, s, r, o, a;
    const l = i.length;
    for (n = 0; n < l; n++) {
        const c = i[n];
        if (c !== 0) {
            if (s = t[t.length - 1],
            i[s] < c) {
                e[n] = s,
                t.push(n);
                continue
            }
            for (r = 0,
            o = t.length - 1; r < o; )
                a = r + o >> 1,
                i[t[a]] < c ? r = a + 1 : o = a;
            c < i[t[r]] && (r > 0 && (e[n] = t[r - 1]),
            t[r] = n)
        }
    }
    for (r = t.length,
    o = t[r - 1]; r-- > 0; )
        t[r] = o,
        o = e[o];
    return t
}
function lT(i) {
    const e = i.subTree.component;
    if (e)
        return e.asyncDep && !e.asyncResolved ? e : lT(e)
}
function Zh(i) {
    if (i)
        for (let e = 0; e < i.length; e++)
            i[e].flags |= 8
}
const n5 = Symbol.for("v-scx")
  , i5 = () => Es(n5);
function Bt(i, e, t) {
    return cT(i, e, t)
}
function cT(i, e, t=yn) {
    const {immediate: n, deep: s, flush: r, once: o} = t
      , a = Jn({}, t)
      , l = e && n || !e && r !== "post";
    let c;
    if (Sd) {
        if (r === "sync") {
            const h = i5();
            c = h.__watcherHandles || (h.__watcherHandles = [])
        } else if (!l) {
            const h = () => {}
            ;
            return h.stop = hr,
            h.resume = hr,
            h.pause = hr,
            h
        }
    }
    const u = xi;
    a.call = (h, p, g) => xr(h, u, p, g);
    let d = !1;
    r === "post" ? a.scheduler = h => {
        si(h, u && u.suspense)
    }
    : r !== "sync" && (d = !0,
    a.scheduler = (h, p) => {
        p ? h() : c_(h)
    }
    ),
    a.augmentJob = h => {
        e && (h.flags |= 4),
        d && (h.flags |= 2,
        u && (h.id = u.uid,
        h.i = u))
    }
    ;
    const f = yL(i, e, a);
    return Sd && (c ? c.push(f) : l && f()),
    f
}
function s5(i, e, t) {
    const n = this.proxy
      , s = Fn(i) ? i.includes(".") ? uT(n, i) : () => n[i] : i.bind(n, n);
    let r;
    Nt(e) ? r = e : (r = e.handler,
    t = e);
    const o = Rl(this)
      , a = cT(s, r.bind(n), t);
    return o(),
    a
}
function uT(i, e) {
    const t = e.split(".");
    return () => {
        let n = i;
        for (let s = 0; s < t.length && n; s++)
            n = n[t[s]];
        return n
    }
}
const r5 = (i, e) => e === "modelValue" || e === "model-value" ? i.modelModifiers : i[`${e}Modifiers`] || i[`${Ws(e)}Modifiers`] || i[`${Ul(e)}Modifiers`];
function o5(i, e, ...t) {
    if (i.isUnmounted)
        return;
    const n = i.vnode.props || yn;
    let s = t;
    const r = e.startsWith("update:")
      , o = r && r5(n, e.slice(7));
    o && (o.trim && (s = t.map(u => Fn(u) ? u.trim() : u)),
    o.number && (s = t.map(Gh)));
    let a, l = n[a = Nm(e)] || n[a = Nm(Ws(e))];
    !l && r && (l = n[a = Nm(Ul(e))]),
    l && xr(l, i, 6, s);
    const c = n[a + "Once"];
    if (c) {
        if (!i.emitted)
            i.emitted = {};
        else if (i.emitted[a])
            return;
        i.emitted[a] = !0,
        xr(c, i, 6, s)
    }
}
function dT(i, e, t=!1) {
    const n = e.emitsCache
      , s = n.get(i);
    if (s !== void 0)
        return s;
    const r = i.emits;
    let o = {}
      , a = !1;
    if (!Nt(i)) {
        const l = c => {
            const u = dT(c, e, !0);
            u && (a = !0,
            Jn(o, u))
        }
        ;
        !t && e.mixins.length && e.mixins.forEach(l),
        i.extends && l(i.extends),
        i.mixins && i.mixins.forEach(l)
    }
    return !r && !a ? (_n(i) && n.set(i, null),
    null) : (wt(r) ? r.forEach(l => o[l] = null) : Jn(o, r),
    _n(i) && n.set(i, o),
    o)
}
function tm(i, e) {
    return !i || !Xp(e) ? !1 : (e = e.slice(2).replace(/Once$/, ""),
    hn(i, e[0].toLowerCase() + e.slice(1)) || hn(i, Ul(e)) || hn(i, e))
}
function jm(i) {
    const {type: e, vnode: t, proxy: n, withProxy: s, propsOptions: [r], slots: o, attrs: a, emit: l, render: c, renderCache: u, props: d, data: f, setupState: h, ctx: p, inheritAttrs: g} = i
      , m = Kh(i);
    let v, _;
    try {
        if (t.shapeFlag & 4) {
            const b = s || n
              , S = b;
            v = rr(c.call(S, b, u, d, h, f, p)),
            _ = a
        } else {
            const b = e;
            v = rr(b.length > 1 ? b(d, {
                attrs: a,
                slots: o,
                emit: l
            }) : b(d, null)),
            _ = e.props ? a : l5(a)
        }
    } catch (b) {
        rd.length = 0,
        Xd(b, i, 1),
        v = O(_i)
    }
    let y = v;
    if (_ && g !== !1) {
        const b = Object.keys(_)
          , {shapeFlag: S} = y;
        b.length && S & 7 && (r && b.some(Xv) && (_ = c5(_, r)),
        y = Do(y, _, !1, !0))
    }
    return t.dirs && (y = Do(y, null, !1, !0),
    y.dirs = y.dirs ? y.dirs.concat(t.dirs) : t.dirs),
    t.transition && Yc(y, t.transition),
    v = y,
    Kh(m),
    v
}
function a5(i, e=!0) {
    let t;
    for (let n = 0; n < i.length; n++) {
        const s = i[n];
        if (Ml(s)) {
            if (s.type !== _i || s.children === "v-if") {
                if (t)
                    return;
                t = s
            }
        } else
            return
    }
    return t
}
const l5 = i => {
    let e;
    for (const t in i)
        (t === "class" || t === "style" || Xp(t)) && ((e || (e = {}))[t] = i[t]);
    return e
}
  , c5 = (i, e) => {
    const t = {};
    for (const n in i)
        (!Xv(n) || !(n.slice(9)in e)) && (t[n] = i[n]);
    return t
}
;
function u5(i, e, t) {
    const {props: n, children: s, component: r} = i
      , {props: o, children: a, patchFlag: l} = e
      , c = r.emitsOptions;
    if (e.dirs || e.transition)
        return !0;
    if (t && l >= 0) {
        if (l & 1024)
            return !0;
        if (l & 16)
            return n ? ly(n, o, c) : !!o;
        if (l & 8) {
            const u = e.dynamicProps;
            for (let d = 0; d < u.length; d++) {
                const f = u[d];
                if (o[f] !== n[f] && !tm(c, f))
                    return !0
            }
        }
    } else
        return (s || a) && (!a || !a.$stable) ? !0 : n === o ? !1 : n ? o ? ly(n, o, c) : !0 : !!o;
    return !1
}
function ly(i, e, t) {
    const n = Object.keys(e);
    if (n.length !== Object.keys(i).length)
        return !0;
    for (let s = 0; s < n.length; s++) {
        const r = n[s];
        if (e[r] !== i[r] && !tm(t, r))
            return !0
    }
    return !1
}
function v_({vnode: i, parent: e}, t) {
    for (; e; ) {
        const n = e.subTree;
        if (n.suspense && n.suspense.activeBranch === i && (n.el = i.el),
        n === i)
            (i = e.vnode).el = t,
            e = e.parent;
        else
            break
    }
}
const Jh = i => i.__isSuspense;
let Ug = 0;
const d5 = {
    name: "Suspense",
    __isSuspense: !0,
    process(i, e, t, n, s, r, o, a, l, c) {
        if (i == null)
            h5(e, t, n, s, r, o, a, l, c);
        else {
            if (r && r.deps > 0 && !i.suspense.isInFallback) {
                e.suspense = i.suspense,
                e.suspense.vnode = e,
                e.el = i.el;
                return
            }
            p5(i, e, t, n, s, o, a, l, c)
        }
    },
    hydrate: m5,
    normalize: g5
}
  , f5 = d5;
function bd(i, e) {
    const t = i.props && i.props[e];
    Nt(t) && t()
}
function h5(i, e, t, n, s, r, o, a, l) {
    const {p: c, o: {createElement: u}} = l
      , d = u("div")
      , f = i.suspense = fT(i, s, n, e, d, t, r, o, a, l);
    c(null, f.pendingBranch = i.ssContent, d, null, n, f, r, o),
    f.deps > 0 ? (bd(i, "onPending"),
    bd(i, "onFallback"),
    c(null, i.ssFallback, e, t, n, null, r, o),
    Dc(f, i.ssFallback)) : f.resolve(!1, !0)
}
function p5(i, e, t, n, s, r, o, a, {p: l, um: c, o: {createElement: u}}) {
    const d = e.suspense = i.suspense;
    d.vnode = e,
    e.el = i.el;
    const f = e.ssContent
      , h = e.ssFallback
      , {activeBranch: p, pendingBranch: g, isInFallback: m, isHydrating: v} = d;
    if (g)
        d.pendingBranch = f,
        lr(f, g) ? (l(g, f, d.hiddenContainer, null, s, d, r, o, a),
        d.deps <= 0 ? d.resolve() : m && (v || (l(p, h, t, n, s, null, r, o, a),
        Dc(d, h)))) : (d.pendingId = Ug++,
        v ? (d.isHydrating = !1,
        d.activeBranch = g) : c(g, s, d),
        d.deps = 0,
        d.effects.length = 0,
        d.hiddenContainer = u("div"),
        m ? (l(null, f, d.hiddenContainer, null, s, d, r, o, a),
        d.deps <= 0 ? d.resolve() : (l(p, h, t, n, s, null, r, o, a),
        Dc(d, h))) : p && lr(f, p) ? (l(p, f, t, n, s, d, r, o, a),
        d.resolve(!0)) : (l(null, f, d.hiddenContainer, null, s, d, r, o, a),
        d.deps <= 0 && d.resolve()));
    else if (p && lr(f, p))
        l(p, f, t, n, s, d, r, o, a),
        Dc(d, f);
    else if (bd(e, "onPending"),
    d.pendingBranch = f,
    f.shapeFlag & 512 ? d.pendingId = f.component.suspenseId : d.pendingId = Ug++,
    l(null, f, d.hiddenContainer, null, s, d, r, o, a),
    d.deps <= 0)
        d.resolve();
    else {
        const {timeout: _, pendingId: y} = d;
        _ > 0 ? setTimeout( () => {
            d.pendingId === y && d.fallback(h)
        }
        , _) : _ === 0 && d.fallback(h)
    }
}
function fT(i, e, t, n, s, r, o, a, l, c, u=!1) {
    const {p: d, m: f, um: h, n: p, o: {parentNode: g, remove: m}} = c;
    let v;
    const _ = _5(i);
    _ && e && e.pendingBranch && (v = e.pendingId,
    e.deps++);
    const y = i.props ? rw(i.props.timeout) : void 0
      , b = r
      , S = {
        vnode: i,
        parent: e,
        parentComponent: t,
        namespace: o,
        container: n,
        hiddenContainer: s,
        deps: 0,
        pendingId: Ug++,
        timeout: typeof y == "number" ? y : -1,
        activeBranch: null,
        pendingBranch: null,
        isInFallback: !u,
        isHydrating: u,
        isUnmounted: !1,
        effects: [],
        resolve(C=!1, M=!1) {
            const {vnode: L, activeBranch: T, pendingBranch: A, pendingId: k, effects: D, parentComponent: F, container: z} = S;
            let G = !1;
            S.isHydrating ? S.isHydrating = !1 : C || (G = T && A.transition && A.transition.mode === "out-in",
            G && (T.transition.afterLeave = () => {
                k === S.pendingId && (f(A, z, r === b ? p(T) : r, 0),
                Lg(D))
            }
            ),
            T && (g(T.el) === z && (r = p(T)),
            h(T, F, S, !0)),
            G || f(A, z, r, 0)),
            Dc(S, A),
            S.pendingBranch = null,
            S.isInFallback = !1;
            let H = S.parent
              , X = !1;
            for (; H; ) {
                if (H.pendingBranch) {
                    H.effects.push(...D),
                    X = !0;
                    break
                }
                H = H.parent
            }
            !X && !G && Lg(D),
            S.effects = [],
            _ && e && e.pendingBranch && v === e.pendingId && (e.deps--,
            e.deps === 0 && !M && e.resolve()),
            bd(L, "onResolve")
        },
        fallback(C) {
            if (!S.pendingBranch)
                return;
            const {vnode: M, activeBranch: L, parentComponent: T, container: A, namespace: k} = S;
            bd(M, "onFallback");
            const D = p(L)
              , F = () => {
                !S.isInFallback || (d(null, C, A, D, T, null, k, a, l),
                Dc(S, C))
            }
              , z = C.transition && C.transition.mode === "out-in";
            z && (L.transition.afterLeave = F),
            S.isInFallback = !0,
            h(L, T, null, !0),
            z || F()
        },
        move(C, M, L) {
            S.activeBranch && f(S.activeBranch, C, M, L),
            S.container = C
        },
        next() {
            return S.activeBranch && p(S.activeBranch)
        },
        registerDep(C, M, L) {
            const T = !!S.pendingBranch;
            T && S.deps++;
            const A = C.vnode.el;
            C.asyncDep.catch(k => {
                Xd(k, C, 0)
            }
            ).then(k => {
                if (C.isUnmounted || S.isUnmounted || S.pendingId !== C.suspenseId)
                    return;
                C.asyncResolved = !0;
                const {vnode: D} = C;
                Vg(C, k, !1),
                A && (D.el = A);
                const F = !A && C.subTree.el;
                M(C, D, g(A || C.subTree.el), A ? null : p(C.subTree), S, o, L),
                F && m(F),
                v_(C, D.el),
                T && --S.deps === 0 && S.resolve()
            }
            )
        },
        unmount(C, M) {
            S.isUnmounted = !0,
            S.activeBranch && h(S.activeBranch, t, C, M),
            S.pendingBranch && h(S.pendingBranch, t, C, M)
        }
    };
    return S
}
function m5(i, e, t, n, s, r, o, a, l) {
    const c = e.suspense = fT(e, n, t, i.parentNode, document.createElement("div"), null, s, r, o, a, !0)
      , u = l(i, c.pendingBranch = e.ssContent, t, c, r, o);
    return c.deps === 0 && c.resolve(!1, !0),
    u
}
function g5(i) {
    const {shapeFlag: e, children: t} = i
      , n = e & 32;
    i.ssContent = cy(n ? t.default : t),
    i.ssFallback = n ? cy(t.fallback) : O(_i)
}
function cy(i) {
    let e;
    if (Nt(i)) {
        const t = Zc && i._c;
        t && (i._d = !1,
        w()),
        i = i(),
        t && (i._d = !0,
        e = ss,
        hT())
    }
    return wt(i) && (i = a5(i)),
    i = rr(i),
    e && !i.dynamicChildren && (i.dynamicChildren = e.filter(t => t !== i)),
    i
}
function v5(i, e) {
    e && e.pendingBranch ? wt(i) ? e.effects.push(...i) : e.effects.push(i) : Lg(i)
}
function Dc(i, e) {
    i.activeBranch = e;
    const {vnode: t, parentComponent: n} = i;
    let s = e.el;
    for (; !s && e.component; )
        e = e.component.subTree,
        s = e.el;
    t.el = s,
    n && n.subTree === t && (n.vnode.el = s,
    v_(n, s))
}
function _5(i) {
    const e = i.props && i.props.suspensible;
    return e != null && e !== !1
}
const Ge = Symbol.for("v-fgt")
  , nm = Symbol.for("v-txt")
  , _i = Symbol.for("v-cmt")
  , gh = Symbol.for("v-stc")
  , rd = [];
let ss = null;
function w(i=!1) {
    rd.push(ss = i ? null : [])
}
function hT() {
    rd.pop(),
    ss = rd[rd.length - 1] || null
}
let Zc = 1;
function uy(i, e=!1) {
    Zc += i,
    i < 0 && ss && e && (ss.hasOnce = !0)
}
function pT(i) {
    return i.dynamicChildren = Zc > 0 ? ss || Lc : null,
    hT(),
    Zc > 0 && ss && ss.push(i),
    i
}
function R(i, e, t, n, s, r) {
    return pT(x(i, e, t, n, s, r, !0))
}
function Re(i, e, t, n, s) {
    return pT(O(i, e, t, n, s, !0))
}
function Ml(i) {
    return i ? i.__v_isVNode === !0 : !1
}
function lr(i, e) {
    return i.type === e.type && i.key === e.key
}
const mT = ({key: i}) => i != null ? i : null
  , vh = ({ref: i, ref_key: e, ref_for: t}) => (typeof i == "number" && (i = "" + i),
i != null ? Fn(i) || Sn(i) || Nt(i) ? {
    i: ai,
    r: i,
    k: e,
    f: !!t
} : i : null);
function x(i, e=null, t=null, n=0, s=null, r=i === Ge ? 0 : 1, o=!1, a=!1) {
    const l = {
        __v_isVNode: !0,
        __v_skip: !0,
        type: i,
        props: e,
        key: e && mT(e),
        ref: e && vh(e),
        scopeId: Fw,
        slotScopeIds: null,
        children: t,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetStart: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag: r,
        patchFlag: n,
        dynamicProps: s,
        dynamicChildren: null,
        appContext: null,
        ctx: ai
    };
    return a ? (__(l, t),
    r & 128 && i.normalize(l)) : t && (l.shapeFlag |= Fn(t) ? 8 : 16),
    Zc > 0 && !o && ss && (l.patchFlag > 0 || r & 6) && l.patchFlag !== 32 && ss.push(l),
    l
}
const O = x5;
function x5(i, e=null, t=null, n=0, s=null, r=!1) {
    if ((!i || i === Xw) && (i = _i),
    Ml(i)) {
        const a = Do(i, e, !0);
        return t && __(a, t),
        Zc > 0 && !r && ss && (a.shapeFlag & 6 ? ss[ss.indexOf(i)] = a : ss.push(a)),
        a.patchFlag = -2,
        a
    }
    if (R5(i) && (i = i.__vccOpts),
    e) {
        e = y5(e);
        let {class: a, style: l} = e;
        a && !Fn(a) && (e.class = Pt(a)),
        _n(l) && (a_(l) && !wt(l) && (l = Jn({}, l)),
        e.style = xs(l))
    }
    const o = Fn(i) ? 1 : Jh(i) ? 128 : Uw(i) ? 64 : _n(i) ? 4 : Nt(i) ? 2 : 0;
    return x(i, e, t, n, s, o, r, !0)
}
function y5(i) {
    return i ? a_(i) || tT(i) ? Jn({}, i) : i : null
}
function Do(i, e, t=!1, n=!1) {
    const {props: s, ref: r, patchFlag: o, children: a, transition: l} = i
      , c = e ? b5(s || {}, e) : s
      , u = {
        __v_isVNode: !0,
        __v_skip: !0,
        type: i.type,
        props: c,
        key: c && mT(c),
        ref: e && e.ref ? t && r ? wt(r) ? r.concat(vh(e)) : [r, vh(e)] : vh(e) : r,
        scopeId: i.scopeId,
        slotScopeIds: i.slotScopeIds,
        children: a,
        target: i.target,
        targetStart: i.targetStart,
        targetAnchor: i.targetAnchor,
        staticCount: i.staticCount,
        shapeFlag: i.shapeFlag,
        patchFlag: e && i.type !== Ge ? o === -1 ? 16 : o | 16 : o,
        dynamicProps: i.dynamicProps,
        dynamicChildren: i.dynamicChildren,
        appContext: i.appContext,
        dirs: i.dirs,
        transition: l,
        component: i.component,
        suspense: i.suspense,
        ssContent: i.ssContent && Do(i.ssContent),
        ssFallback: i.ssFallback && Do(i.ssFallback),
        el: i.el,
        anchor: i.anchor,
        ctx: i.ctx,
        ce: i.ce
    };
    return l && n && Yc(u, l.clone(u)),
    u
}
function J(i=" ", e=0) {
    return O(nm, null, i, e)
}
function pa(i, e) {
    const t = O(gh, null, i);
    return t.staticCount = e,
    t
}
function le(i="", e=!1) {
    return e ? (w(),
    Re(_i, null, i)) : O(_i, null, i)
}
function rr(i) {
    return i == null || typeof i == "boolean" ? O(_i) : wt(i) ? O(Ge, null, i.slice()) : Ml(i) ? ea(i) : O(nm, null, String(i))
}
function ea(i) {
    return i.el === null && i.patchFlag !== -1 || i.memo ? i : Do(i)
}
function __(i, e) {
    let t = 0;
    const {shapeFlag: n} = i;
    if (e == null)
        e = null;
    else if (wt(e))
        t = 16;
    else if (typeof e == "object")
        if (n & 65) {
            const s = e.default;
            s && (s._c && (s._d = !1),
            __(i, s()),
            s._c && (s._d = !0));
            return
        } else {
            t = 32;
            const s = e._;
            !s && !tT(e) ? e._ctx = ai : s === 3 && ai && (ai.slots._ === 1 ? e._ = 1 : (e._ = 2,
            i.patchFlag |= 1024))
        }
    else
        Nt(e) ? (e = {
            default: e,
            _ctx: ai
        },
        t = 32) : (e = String(e),
        n & 64 ? (t = 16,
        e = [J(e)]) : t = 8);
    i.children = e,
    i.shapeFlag |= t
}
function b5(...i) {
    const e = {};
    for (let t = 0; t < i.length; t++) {
        const n = i[t];
        for (const s in n)
            if (s === "class")
                e.class !== n.class && (e.class = Pt([e.class, n.class]));
            else if (s === "style")
                e.style = xs([e.style, n.style]);
            else if (Xp(s)) {
                const r = e[s]
                  , o = n[s];
                o && r !== o && !(wt(r) && r.includes(o)) && (e[s] = r ? [].concat(r, o) : o)
            } else
                s !== "" && (e[s] = n[s])
    }
    return e
}
function Ps(i, e, t, n=null) {
    xr(i, e, 7, [t, n])
}
const S5 = Jw();
let E5 = 0;
function w5(i, e, t) {
    const n = i.type
      , s = (e ? e.appContext : i.appContext) || S5
      , r = {
        uid: E5++,
        vnode: i,
        type: n,
        parent: e,
        appContext: s,
        root: null,
        next: null,
        subTree: null,
        effect: null,
        update: null,
        job: null,
        scope: new cw(!0),
        render: null,
        proxy: null,
        exposed: null,
        exposeProxy: null,
        withProxy: null,
        provides: e ? e.provides : Object.create(s.provides),
        ids: e ? e.ids : ["", 0, 0],
        accessCache: null,
        renderCache: [],
        components: null,
        directives: null,
        propsOptions: iT(n, s),
        emitsOptions: dT(n, s),
        emit: null,
        emitted: null,
        propsDefaults: yn,
        inheritAttrs: n.inheritAttrs,
        ctx: yn,
        data: yn,
        props: yn,
        attrs: yn,
        slots: yn,
        refs: yn,
        setupState: yn,
        setupContext: null,
        suspense: t,
        suspenseId: t ? t.pendingId : 0,
        asyncDep: null,
        asyncResolved: !1,
        isMounted: !1,
        isUnmounted: !1,
        isDeactivated: !1,
        bc: null,
        c: null,
        bm: null,
        m: null,
        bu: null,
        u: null,
        um: null,
        bum: null,
        da: null,
        a: null,
        rtg: null,
        rtc: null,
        ec: null,
        sp: null
    };
    return r.ctx = {
        _: r
    },
    r.root = e ? e.root : r,
    r.emit = o5.bind(null, r),
    i.ce && i.ce(r),
    r
}
let xi = null;
const im = () => xi || ai;
let Qh, Ng;
{
    const i = qd()
      , e = (t, n) => {
        let s;
        return (s = i[t]) || (s = i[t] = []),
        s.push(n),
        r => {
            s.length > 1 ? s.forEach(o => o(r)) : s[0](r)
        }
    }
    ;
    Qh = e("__VUE_INSTANCE_SETTERS__", t => xi = t),
    Ng = e("__VUE_SSR_SETTERS__", t => Sd = t)
}
const Rl = i => {
    const e = xi;
    return Qh(i),
    i.scope.on(),
    () => {
        i.scope.off(),
        Qh(e)
    }
}
  , Bg = () => {
    xi && xi.scope.off(),
    Qh(null)
}
;
function gT(i) {
    return i.vnode.shapeFlag & 4
}
let Sd = !1;
function T5(i, e=!1, t=!1) {
    e && Ng(e);
    const {props: n, children: s} = i.vnode
      , r = gT(i);
    WL(i, n, r, e),
    XL(i, s, t);
    const o = r ? A5(i, e) : void 0;
    return e && Ng(!1),
    o
}
function A5(i, e) {
    const t = i.type;
    i.accessCache = Object.create(null),
    i.proxy = new Proxy(i.ctx,OL);
    const {setup: n} = t;
    if (n) {
        Ra();
        const s = i.setupContext = n.length > 1 ? M5(i) : null
          , r = Rl(i)
          , o = Kd(n, i, 0, [i.props, s])
          , a = Zv(o);
        if (La(),
        r(),
        (a || i.sp) && !_l(i) && Ww(i),
        a) {
            if (o.then(Bg, Bg),
            e)
                return o.then(l => {
                    Vg(i, l, e)
                }
                ).catch(l => {
                    Xd(l, i, 0)
                }
                );
            i.asyncDep = o
        } else
            Vg(i, o, e)
    } else
        vT(i, e)
}
function Vg(i, e, t) {
    Nt(e) ? i.type.__ssrInlineRender ? i.ssrRender = e : i.render = e : _n(e) && (i.setupState = Rw(e)),
    vT(i, t)
}
let dy;
function vT(i, e, t) {
    const n = i.type;
    if (!i.render) {
        if (!e && dy && !n.render) {
            const s = n.template || p_(i).template;
            if (s) {
                const {isCustomElement: r, compilerOptions: o} = i.appContext.config
                  , {delimiters: a, compilerOptions: l} = n
                  , c = Jn(Jn({
                    isCustomElement: r,
                    delimiters: a
                }, o), l);
                n.render = dy(s, c)
            }
        }
        i.render = n.render || hr
    }
    {
        const s = Rl(i);
        Ra();
        try {
            UL(i)
        } finally {
            La(),
            s()
        }
    }
}
const C5 = {
    get(i, e) {
        return Ii(i, "get", ""),
        i[e]
    }
};
function M5(i) {
    const e = t => {
        i.exposed = t || {}
    }
    ;
    return {
        attrs: new Proxy(i.attrs,C5),
        slots: i.slots,
        emit: i.emit,
        expose: e
    }
}
function sm(i) {
    return i.exposed ? i.exposeProxy || (i.exposeProxy = new Proxy(Rw(l_(i.exposed)),{
        get(e, t) {
            if (t in e)
                return e[t];
            if (t in sd)
                return sd[t](i)
        },
        has(e, t) {
            return t in e || t in sd
        }
    })) : i.proxy
}
function $g(i, e=!0) {
    return Nt(i) ? i.displayName || i.name : i.name || e && i.__name
}
function R5(i) {
    return Nt(i) && "__vccOpts"in i
}
const Vt = (i, e) => _L(i, e, Sd);
function x_(i, e, t) {
    const n = arguments.length;
    return n === 2 ? _n(e) && !wt(e) ? Ml(e) ? O(i, null, [e]) : O(i, e) : O(i, null, e) : (n > 3 ? t = Array.prototype.slice.call(arguments, 2) : n === 3 && Ml(t) && (t = [t]),
    O(i, e, t))
}
const L5 = "3.5.13";
/**
* @vue/runtime-dom v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let Hg;
const fy = typeof window < "u" && window.trustedTypes;
if (fy)
    try {
        Hg = fy.createPolicy("vue", {
            createHTML: i => i
        })
    } catch {}
const _T = Hg ? i => Hg.createHTML(i) : i => i
  , I5 = "http://www.w3.org/2000/svg"
  , k5 = "http://www.w3.org/1998/Math/MathML"
  , po = typeof document < "u" ? document : null
  , hy = po && po.createElement("template")
  , P5 = {
    insert: (i, e, t) => {
        e.insertBefore(i, t || null)
    }
    ,
    remove: i => {
        const e = i.parentNode;
        e && e.removeChild(i)
    }
    ,
    createElement: (i, e, t, n) => {
        const s = e === "svg" ? po.createElementNS(I5, i) : e === "mathml" ? po.createElementNS(k5, i) : t ? po.createElement(i, {
            is: t
        }) : po.createElement(i);
        return i === "select" && n && n.multiple != null && s.setAttribute("multiple", n.multiple),
        s
    }
    ,
    createText: i => po.createTextNode(i),
    createComment: i => po.createComment(i),
    setText: (i, e) => {
        i.nodeValue = e
    }
    ,
    setElementText: (i, e) => {
        i.textContent = e
    }
    ,
    parentNode: i => i.parentNode,
    nextSibling: i => i.nextSibling,
    querySelector: i => po.querySelector(i),
    setScopeId(i, e) {
        i.setAttribute(e, "")
    },
    insertStaticContent(i, e, t, n, s, r) {
        const o = t ? t.previousSibling : e.lastChild;
        if (s && (s === r || s.nextSibling))
            for (; e.insertBefore(s.cloneNode(!0), t),
            !(s === r || !(s = s.nextSibling)); )
                ;
        else {
            hy.innerHTML = _T(n === "svg" ? `<svg>${i}</svg>` : n === "mathml" ? `<math>${i}</math>` : i);
            const a = hy.content;
            if (n === "svg" || n === "mathml") {
                const l = a.firstChild;
                for (; l.firstChild; )
                    a.appendChild(l.firstChild);
                a.removeChild(l)
            }
            e.insertBefore(a, t)
        }
        return [o ? o.nextSibling : e.firstChild, t ? t.previousSibling : e.lastChild]
    }
}
  , $o = "transition"
  , Mu = "animation"
  , Ed = Symbol("_vtc")
  , xT = {
    name: String,
    type: String,
    css: {
        type: Boolean,
        default: !0
    },
    duration: [String, Number, Object],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
}
  , D5 = Jn({}, Vw, xT)
  , F5 = i => (i.displayName = "Transition",
i.props = D5,
i)
  , y_ = F5( (i, {slots: e}) => x_(AL, O5(i), e))
  , Ua = (i, e=[]) => {
    wt(i) ? i.forEach(t => t(...e)) : i && i(...e)
}
  , py = i => i ? wt(i) ? i.some(e => e.length > 1) : i.length > 1 : !1;
function O5(i) {
    const e = {};
    for (const D in i)
        D in xT || (e[D] = i[D]);
    if (i.css === !1)
        return e;
    const {name: t="v", type: n, duration: s, enterFromClass: r=`${t}-enter-from`, enterActiveClass: o=`${t}-enter-active`, enterToClass: a=`${t}-enter-to`, appearFromClass: l=r, appearActiveClass: c=o, appearToClass: u=a, leaveFromClass: d=`${t}-leave-from`, leaveActiveClass: f=`${t}-leave-active`, leaveToClass: h=`${t}-leave-to`} = i
      , p = U5(s)
      , g = p && p[0]
      , m = p && p[1]
      , {onBeforeEnter: v, onEnter: _, onEnterCancelled: y, onLeave: b, onLeaveCancelled: S, onBeforeAppear: C=v, onAppear: M=_, onAppearCancelled: L=y} = e
      , T = (D, F, z, G) => {
        D._enterCancelled = G,
        Na(D, F ? u : a),
        Na(D, F ? c : o),
        z && z()
    }
      , A = (D, F) => {
        D._isLeaving = !1,
        Na(D, d),
        Na(D, h),
        Na(D, f),
        F && F()
    }
      , k = D => (F, z) => {
        const G = D ? M : _
          , H = () => T(F, D, z);
        Ua(G, [F, H]),
        my( () => {
            Na(F, D ? l : r),
            eo(F, D ? u : a),
            py(G) || gy(F, n, g, H)
        }
        )
    }
    ;
    return Jn(e, {
        onBeforeEnter(D) {
            Ua(v, [D]),
            eo(D, r),
            eo(D, o)
        },
        onBeforeAppear(D) {
            Ua(C, [D]),
            eo(D, l),
            eo(D, c)
        },
        onEnter: k(!1),
        onAppear: k(!0),
        onLeave(D, F) {
            D._isLeaving = !0;
            const z = () => A(D, F);
            eo(D, d),
            D._enterCancelled ? (eo(D, f),
            xy()) : (xy(),
            eo(D, f)),
            my( () => {
                !D._isLeaving || (Na(D, d),
                eo(D, h),
                py(b) || gy(D, n, m, z))
            }
            ),
            Ua(b, [D, z])
        },
        onEnterCancelled(D) {
            T(D, !1, void 0, !0),
            Ua(y, [D])
        },
        onAppearCancelled(D) {
            T(D, !0, void 0, !0),
            Ua(L, [D])
        },
        onLeaveCancelled(D) {
            A(D),
            Ua(S, [D])
        }
    })
}
function U5(i) {
    if (i == null)
        return null;
    if (_n(i))
        return [Km(i.enter), Km(i.leave)];
    {
        const e = Km(i);
        return [e, e]
    }
}
function Km(i) {
    return rw(i)
}
function eo(i, e) {
    e.split(/\s+/).forEach(t => t && i.classList.add(t)),
    (i[Ed] || (i[Ed] = new Set)).add(e)
}
function Na(i, e) {
    e.split(/\s+/).forEach(n => n && i.classList.remove(n));
    const t = i[Ed];
    t && (t.delete(e),
    t.size || (i[Ed] = void 0))
}
function my(i) {
    requestAnimationFrame( () => {
        requestAnimationFrame(i)
    }
    )
}
let N5 = 0;
function gy(i, e, t, n) {
    const s = i._endId = ++N5
      , r = () => {
        s === i._endId && n()
    }
    ;
    if (t != null)
        return setTimeout(r, t);
    const {type: o, timeout: a, propCount: l} = B5(i, e);
    if (!o)
        return n();
    const c = o + "end";
    let u = 0;
    const d = () => {
        i.removeEventListener(c, f),
        r()
    }
      , f = h => {
        h.target === i && ++u >= l && d()
    }
    ;
    setTimeout( () => {
        u < l && d()
    }
    , a + 1),
    i.addEventListener(c, f)
}
function B5(i, e) {
    const t = window.getComputedStyle(i)
      , n = p => (t[p] || "").split(", ")
      , s = n(`${$o}Delay`)
      , r = n(`${$o}Duration`)
      , o = vy(s, r)
      , a = n(`${Mu}Delay`)
      , l = n(`${Mu}Duration`)
      , c = vy(a, l);
    let u = null
      , d = 0
      , f = 0;
    e === $o ? o > 0 && (u = $o,
    d = o,
    f = r.length) : e === Mu ? c > 0 && (u = Mu,
    d = c,
    f = l.length) : (d = Math.max(o, c),
    u = d > 0 ? o > c ? $o : Mu : null,
    f = u ? u === $o ? r.length : l.length : 0);
    const h = u === $o && /\b(transform|all)(,|$)/.test(n(`${$o}Property`).toString());
    return {
        type: u,
        timeout: d,
        propCount: f,
        hasTransform: h
    }
}
function vy(i, e) {
    for (; i.length < e.length; )
        i = i.concat(i);
    return Math.max(...e.map( (t, n) => _y(t) + _y(i[n])))
}
function _y(i) {
    return i === "auto" ? 0 : Number(i.slice(0, -1).replace(",", ".")) * 1e3
}
function xy() {
    return document.body.offsetHeight
}
function V5(i, e, t) {
    const n = i[Ed];
    n && (e = (e ? [e, ...n] : [...n]).join(" ")),
    e == null ? i.removeAttribute("class") : t ? i.setAttribute("class", e) : i.className = e
}
const ep = Symbol("_vod")
  , yT = Symbol("_vsh")
  , $n = {
    beforeMount(i, {value: e}, {transition: t}) {
        i[ep] = i.style.display === "none" ? "" : i.style.display,
        t && e ? t.beforeEnter(i) : Ru(i, e)
    },
    mounted(i, {value: e}, {transition: t}) {
        t && e && t.enter(i)
    },
    updated(i, {value: e, oldValue: t}, {transition: n}) {
        !e != !t && (n ? e ? (n.beforeEnter(i),
        Ru(i, !0),
        n.enter(i)) : n.leave(i, () => {
            Ru(i, !1)
        }
        ) : Ru(i, e))
    },
    beforeUnmount(i, {value: e}) {
        Ru(i, e)
    }
};
function Ru(i, e) {
    i.style.display = e ? i[ep] : "none",
    i[yT] = !e
}
const $5 = Symbol("")
  , H5 = /(^|;)\s*display\s*:/;
function z5(i, e, t) {
    const n = i.style
      , s = Fn(t);
    let r = !1;
    if (t && !s) {
        if (e)
            if (Fn(e))
                for (const o of e.split(";")) {
                    const a = o.slice(0, o.indexOf(":")).trim();
                    t[a] == null && _h(n, a, "")
                }
            else
                for (const o in e)
                    t[o] == null && _h(n, o, "");
        for (const o in t)
            o === "display" && (r = !0),
            _h(n, o, t[o])
    } else if (s) {
        if (e !== t) {
            const o = n[$5];
            o && (t += ";" + o),
            n.cssText = t,
            r = H5.test(t)
        }
    } else
        e && i.removeAttribute("style");
    ep in i && (i[ep] = r ? n.display : "",
    i[yT] && (n.display = "none"))
}
const yy = /\s*!important$/;
function _h(i, e, t) {
    if (wt(t))
        t.forEach(n => _h(i, e, n));
    else if (t == null && (t = ""),
    e.startsWith("--"))
        i.setProperty(e, t);
    else {
        const n = G5(i, e);
        yy.test(t) ? i.setProperty(Ul(n), t.replace(yy, ""), "important") : i[n] = t
    }
}
const by = ["Webkit", "Moz", "ms"]
  , Xm = {};
function G5(i, e) {
    const t = Xm[e];
    if (t)
        return t;
    let n = Ws(e);
    if (n !== "filter" && n in i)
        return Xm[e] = n;
    n = Zp(n);
    for (let s = 0; s < by.length; s++) {
        const r = by[s] + n;
        if (r in i)
            return Xm[e] = r
    }
    return e
}
const Sy = "http://www.w3.org/1999/xlink";
function Ey(i, e, t, n, s, r=zR(e)) {
    n && e.startsWith("xlink:") ? t == null ? i.removeAttributeNS(Sy, e.slice(6, e.length)) : i.setAttributeNS(Sy, e, t) : t == null || r && !ow(t) ? i.removeAttribute(e) : i.setAttribute(e, r ? "" : _r(t) ? String(t) : t)
}
function wy(i, e, t, n, s) {
    if (e === "innerHTML" || e === "textContent") {
        t != null && (i[e] = e === "innerHTML" ? _T(t) : t);
        return
    }
    const r = i.tagName;
    if (e === "value" && r !== "PROGRESS" && !r.includes("-")) {
        const a = r === "OPTION" ? i.getAttribute("value") || "" : i.value
          , l = t == null ? i.type === "checkbox" ? "on" : "" : String(t);
        (a !== l || !("_value"in i)) && (i.value = l),
        t == null && i.removeAttribute(e),
        i._value = t;
        return
    }
    let o = !1;
    if (t === "" || t == null) {
        const a = typeof i[e];
        a === "boolean" ? t = ow(t) : t == null && a === "string" ? (t = "",
        o = !0) : a === "number" && (t = 0,
        o = !0)
    }
    try {
        i[e] = t
    } catch {}
    o && i.removeAttribute(s || e)
}
function oa(i, e, t, n) {
    i.addEventListener(e, t, n)
}
function W5(i, e, t, n) {
    i.removeEventListener(e, t, n)
}
const Ty = Symbol("_vei");
function q5(i, e, t, n, s=null) {
    const r = i[Ty] || (i[Ty] = {})
      , o = r[e];
    if (n && o)
        o.value = n;
    else {
        const [a,l] = j5(e);
        if (n) {
            const c = r[e] = Y5(n, s);
            oa(i, a, c, l)
        } else
            o && (W5(i, a, o, l),
            r[e] = void 0)
    }
}
const Ay = /(?:Once|Passive|Capture)$/;
function j5(i) {
    let e;
    if (Ay.test(i)) {
        e = {};
        let n;
        for (; n = i.match(Ay); )
            i = i.slice(0, i.length - n[0].length),
            e[n[0].toLowerCase()] = !0
    }
    return [i[2] === ":" ? i.slice(3) : Ul(i.slice(2)), e]
}
let Ym = 0;
const K5 = Promise.resolve()
  , X5 = () => Ym || (K5.then( () => Ym = 0),
Ym = Date.now());
function Y5(i, e) {
    const t = n => {
        if (!n._vts)
            n._vts = Date.now();
        else if (n._vts <= t.attached)
            return;
        xr(Z5(n, t.value), e, 5, [n])
    }
    ;
    return t.value = i,
    t.attached = X5(),
    t
}
function Z5(i, e) {
    if (wt(e)) {
        const t = i.stopImmediatePropagation;
        return i.stopImmediatePropagation = () => {
            t.call(i),
            i._stopped = !0
        }
        ,
        e.map(n => s => !s._stopped && n && n(s))
    } else
        return e
}
const Cy = i => i.charCodeAt(0) === 111 && i.charCodeAt(1) === 110 && i.charCodeAt(2) > 96 && i.charCodeAt(2) < 123
  , J5 = (i, e, t, n, s, r) => {
    const o = s === "svg";
    e === "class" ? V5(i, n, o) : e === "style" ? z5(i, t, n) : Xp(e) ? Xv(e) || q5(i, e, t, n, r) : (e[0] === "." ? (e = e.slice(1),
    !0) : e[0] === "^" ? (e = e.slice(1),
    !1) : Q5(i, e, n, o)) ? (wy(i, e, n),
    !i.tagName.includes("-") && (e === "value" || e === "checked" || e === "selected") && Ey(i, e, n, o, r, e !== "value")) : i._isVueCE && (/[A-Z]/.test(e) || !Fn(n)) ? wy(i, Ws(e), n, r, e) : (e === "true-value" ? i._trueValue = n : e === "false-value" && (i._falseValue = n),
    Ey(i, e, n, o))
}
;
function Q5(i, e, t, n) {
    if (n)
        return !!(e === "innerHTML" || e === "textContent" || e in i && Cy(e) && Nt(t));
    if (e === "spellcheck" || e === "draggable" || e === "translate" || e === "form" || e === "list" && i.tagName === "INPUT" || e === "type" && i.tagName === "TEXTAREA")
        return !1;
    if (e === "width" || e === "height") {
        const s = i.tagName;
        if (s === "IMG" || s === "VIDEO" || s === "CANVAS" || s === "SOURCE")
            return !1
    }
    return Cy(e) && Fn(t) ? !1 : e in i
}
const Jc = i => {
    const e = i.props["onUpdate:modelValue"] || !1;
    return wt(e) ? t => kc(e, t) : e
}
;
function e4(i) {
    i.target.composing = !0
}
function My(i) {
    const e = i.target;
    e.composing && (e.composing = !1,
    e.dispatchEvent(new Event("input")))
}
const ko = Symbol("_assign")
  , b_ = {
    created(i, {modifiers: {lazy: e, trim: t, number: n}}, s) {
        i[ko] = Jc(s);
        const r = n || s.props && s.props.type === "number";
        oa(i, e ? "change" : "input", o => {
            if (o.target.composing)
                return;
            let a = i.value;
            t && (a = a.trim()),
            r && (a = Gh(a)),
            i[ko](a)
        }
        ),
        t && oa(i, "change", () => {
            i.value = i.value.trim()
        }
        ),
        e || (oa(i, "compositionstart", e4),
        oa(i, "compositionend", My),
        oa(i, "change", My))
    },
    mounted(i, {value: e}) {
        i.value = e == null ? "" : e
    },
    beforeUpdate(i, {value: e, oldValue: t, modifiers: {lazy: n, trim: s, number: r}}, o) {
        if (i[ko] = Jc(o),
        i.composing)
            return;
        const a = (r || i.type === "number") && !/^0\d/.test(i.value) ? Gh(i.value) : i.value
          , l = e == null ? "" : e;
        a !== l && (document.activeElement === i && i.type !== "range" && (n && e === t || s && i.value.trim() === l) || (i.value = l))
    }
}
  , Fc = {
    deep: !0,
    created(i, e, t) {
        i[ko] = Jc(t),
        oa(i, "change", () => {
            const n = i._modelValue
              , s = Td(i)
              , r = i.checked
              , o = i[ko];
            if (wt(n)) {
                const a = Qv(n, s)
                  , l = a !== -1;
                if (r && !l)
                    o(n.concat(s));
                else if (!r && l) {
                    const c = [...n];
                    c.splice(a, 1),
                    o(c)
                }
            } else if (Su(n)) {
                const a = new Set(n);
                r ? a.add(s) : a.delete(s),
                o(a)
            } else
                o(bT(i, r))
        }
        )
    },
    mounted: Ry,
    beforeUpdate(i, e, t) {
        i[ko] = Jc(t),
        Ry(i, e, t)
    }
};
function Ry(i, {value: e, oldValue: t}, n) {
    i._modelValue = e;
    let s;
    if (wt(e))
        s = Qv(e, n.props.value) > -1;
    else if (Su(e))
        s = e.has(n.props.value);
    else {
        if (e === t)
            return;
        s = jd(e, bT(i, !0))
    }
    i.checked !== s && (i.checked = s)
}
const wd = {
    deep: !0,
    created(i, {value: e, modifiers: {number: t}}, n) {
        const s = Su(e);
        oa(i, "change", () => {
            const r = Array.prototype.filter.call(i.options, o => o.selected).map(o => t ? Gh(Td(o)) : Td(o));
            i[ko](i.multiple ? s ? new Set(r) : r : r[0]),
            i._assigning = !0,
            Yd( () => {
                i._assigning = !1
            }
            )
        }
        ),
        i[ko] = Jc(n)
    },
    mounted(i, {value: e}) {
        Ly(i, e)
    },
    beforeUpdate(i, e, t) {
        i[ko] = Jc(t)
    },
    updated(i, {value: e}) {
        i._assigning || Ly(i, e)
    }
};
function Ly(i, e) {
    const t = i.multiple
      , n = wt(e);
    if (!(t && !n && !Su(e))) {
        for (let s = 0, r = i.options.length; s < r; s++) {
            const o = i.options[s]
              , a = Td(o);
            if (t)
                if (n) {
                    const l = typeof a;
                    l === "string" || l === "number" ? o.selected = e.some(c => String(c) === String(a)) : o.selected = Qv(e, a) > -1
                } else
                    o.selected = e.has(a);
            else if (jd(Td(o), e)) {
                i.selectedIndex !== s && (i.selectedIndex = s);
                return
            }
        }
        !t && i.selectedIndex !== -1 && (i.selectedIndex = -1)
    }
}
function Td(i) {
    return "_value"in i ? i._value : i.value
}
function bT(i, e) {
    const t = e ? "_trueValue" : "_falseValue";
    return t in i ? i[t] : e
}
const t4 = ["ctrl", "shift", "alt", "meta"]
  , n4 = {
    stop: i => i.stopPropagation(),
    prevent: i => i.preventDefault(),
    self: i => i.target !== i.currentTarget,
    ctrl: i => !i.ctrlKey,
    shift: i => !i.shiftKey,
    alt: i => !i.altKey,
    meta: i => !i.metaKey,
    left: i => "button"in i && i.button !== 0,
    middle: i => "button"in i && i.button !== 1,
    right: i => "button"in i && i.button !== 2,
    exact: (i, e) => t4.some(t => i[`${t}Key`] && !e.includes(t))
}
  , Vn = (i, e) => {
    const t = i._withMods || (i._withMods = {})
      , n = e.join(".");
    return t[n] || (t[n] = (s, ...r) => {
        for (let o = 0; o < e.length; o++) {
            const a = n4[e[o]];
            if (a && a(s, e))
                return
        }
        return i(s, ...r)
    }
    )
}
  , i4 = Jn({
    patchProp: J5
}, P5);
let Iy;
function s4() {
    return Iy || (Iy = JL(i4))
}
const r4 = (...i) => {
    const e = s4().createApp(...i)
      , {mount: t} = e;
    return e.mount = n => {
        const s = a4(n);
        if (!s)
            return;
        const r = e._component;
        !Nt(r) && !r.render && !r.template && (r.template = s.innerHTML),
        s.nodeType === 1 && (s.textContent = "");
        const o = t(s, !1, o4(s));
        return s instanceof Element && (s.removeAttribute("v-cloak"),
        s.setAttribute("data-v-app", "")),
        o
    }
    ,
    e
}
;
function o4(i) {
    if (i instanceof SVGElement)
        return "svg";
    if (typeof MathMLElement == "function" && i instanceof MathMLElement)
        return "mathml"
}
function a4(i) {
    return Fn(i) ? document.querySelector(i) : i
}
const l4 = "/assets/FleshyThrust-4.db61c49f.webm";
/*!
  * vue-router v4.5.0
  * (c) 2024 Eduardo San Martin Morote
  * @license MIT
  */
const xc = typeof document < "u";
function ST(i) {
    return typeof i == "object" || "displayName"in i || "props"in i || "__vccOpts"in i
}
function c4(i) {
    return i.__esModule || i[Symbol.toStringTag] === "Module" || i.default && ST(i.default)
}
const fn = Object.assign;
function Zm(i, e) {
    const t = {};
    for (const n in e) {
        const s = e[n];
        t[n] = yr(s) ? s.map(i) : i(s)
    }
    return t
}
const od = () => {}
  , yr = Array.isArray
  , ET = /#/g
  , u4 = /&/g
  , d4 = /\//g
  , f4 = /=/g
  , h4 = /\?/g
  , wT = /\+/g
  , p4 = /%5B/g
  , m4 = /%5D/g
  , TT = /%5E/g
  , g4 = /%60/g
  , AT = /%7B/g
  , v4 = /%7C/g
  , CT = /%7D/g
  , _4 = /%20/g;
function S_(i) {
    return encodeURI("" + i).replace(v4, "|").replace(p4, "[").replace(m4, "]")
}
function x4(i) {
    return S_(i).replace(AT, "{").replace(CT, "}").replace(TT, "^")
}
function zg(i) {
    return S_(i).replace(wT, "%2B").replace(_4, "+").replace(ET, "%23").replace(u4, "%26").replace(g4, "`").replace(AT, "{").replace(CT, "}").replace(TT, "^")
}
function y4(i) {
    return zg(i).replace(f4, "%3D")
}
function b4(i) {
    return S_(i).replace(ET, "%23").replace(h4, "%3F")
}
function S4(i) {
    return i == null ? "" : b4(i).replace(d4, "%2F")
}
function Ad(i) {
    try {
        return decodeURIComponent("" + i)
    } catch {}
    return "" + i
}
const E4 = /\/$/
  , w4 = i => i.replace(E4, "");
function Jm(i, e, t="/") {
    let n, s = {}, r = "", o = "";
    const a = e.indexOf("#");
    let l = e.indexOf("?");
    return a < l && a >= 0 && (l = -1),
    l > -1 && (n = e.slice(0, l),
    r = e.slice(l + 1, a > -1 ? a : e.length),
    s = i(r)),
    a > -1 && (n = n || e.slice(0, a),
    o = e.slice(a, e.length)),
    n = M4(n != null ? n : e, t),
    {
        fullPath: n + (r && "?") + r + o,
        path: n,
        query: s,
        hash: Ad(o)
    }
}
function T4(i, e) {
    const t = e.query ? i(e.query) : "";
    return e.path + (t && "?") + t + (e.hash || "")
}
function ky(i, e) {
    return !e || !i.toLowerCase().startsWith(e.toLowerCase()) ? i : i.slice(e.length) || "/"
}
function A4(i, e, t) {
    const n = e.matched.length - 1
      , s = t.matched.length - 1;
    return n > -1 && n === s && Qc(e.matched[n], t.matched[s]) && MT(e.params, t.params) && i(e.query) === i(t.query) && e.hash === t.hash
}
function Qc(i, e) {
    return (i.aliasOf || i) === (e.aliasOf || e)
}
function MT(i, e) {
    if (Object.keys(i).length !== Object.keys(e).length)
        return !1;
    for (const t in i)
        if (!C4(i[t], e[t]))
            return !1;
    return !0
}
function C4(i, e) {
    return yr(i) ? Py(i, e) : yr(e) ? Py(e, i) : i === e
}
function Py(i, e) {
    return yr(e) ? i.length === e.length && i.every( (t, n) => t === e[n]) : i.length === 1 && i[0] === e
}
function M4(i, e) {
    if (i.startsWith("/"))
        return i;
    if (!i)
        return e;
    const t = e.split("/")
      , n = i.split("/")
      , s = n[n.length - 1];
    (s === ".." || s === ".") && n.push("");
    let r = t.length - 1, o, a;
    for (o = 0; o < n.length; o++)
        if (a = n[o],
        a !== ".")
            if (a === "..")
                r > 1 && r--;
            else
                break;
    return t.slice(0, r).join("/") + "/" + n.slice(o).join("/")
}
const Ho = {
    path: "/",
    name: void 0,
    params: {},
    query: {},
    hash: "",
    fullPath: "/",
    matched: [],
    meta: {},
    redirectedFrom: void 0
};
var Cd;
(function(i) {
    i.pop = "pop",
    i.push = "push"
}
)(Cd || (Cd = {}));
var ad;
(function(i) {
    i.back = "back",
    i.forward = "forward",
    i.unknown = ""
}
)(ad || (ad = {}));
function R4(i) {
    if (!i)
        if (xc) {
            const e = document.querySelector("base");
            i = e && e.getAttribute("href") || "/",
            i = i.replace(/^\w+:\/\/[^\/]+/, "")
        } else
            i = "/";
    return i[0] !== "/" && i[0] !== "#" && (i = "/" + i),
    w4(i)
}
const L4 = /^[^#]+#/;
function I4(i, e) {
    return i.replace(L4, "#") + e
}
function k4(i, e) {
    const t = document.documentElement.getBoundingClientRect()
      , n = i.getBoundingClientRect();
    return {
        behavior: e.behavior,
        left: n.left - t.left - (e.left || 0),
        top: n.top - t.top - (e.top || 0)
    }
}
const rm = () => ({
    left: window.scrollX,
    top: window.scrollY
});
function P4(i) {
    let e;
    if ("el"in i) {
        const t = i.el
          , n = typeof t == "string" && t.startsWith("#")
          , s = typeof t == "string" ? n ? document.getElementById(t.slice(1)) : document.querySelector(t) : t;
        if (!s)
            return;
        e = k4(s, i)
    } else
        e = i;
    "scrollBehavior"in document.documentElement.style ? window.scrollTo(e) : window.scrollTo(e.left != null ? e.left : window.scrollX, e.top != null ? e.top : window.scrollY)
}
function Dy(i, e) {
    return (history.state ? history.state.position - e : -1) + i
}
const Gg = new Map;
function D4(i, e) {
    Gg.set(i, e)
}
function F4(i) {
    const e = Gg.get(i);
    return Gg.delete(i),
    e
}
let O4 = () => location.protocol + "//" + location.host;
function RT(i, e) {
    const {pathname: t, search: n, hash: s} = e
      , r = i.indexOf("#");
    if (r > -1) {
        let a = s.includes(i.slice(r)) ? i.slice(r).length : 1
          , l = s.slice(a);
        return l[0] !== "/" && (l = "/" + l),
        ky(l, "")
    }
    return ky(t, i) + n + s
}
function U4(i, e, t, n) {
    let s = []
      , r = []
      , o = null;
    const a = ({state: f}) => {
        const h = RT(i, location)
          , p = t.value
          , g = e.value;
        let m = 0;
        if (f) {
            if (t.value = h,
            e.value = f,
            o && o === p) {
                o = null;
                return
            }
            m = g ? f.position - g.position : 0
        } else
            n(h);
        s.forEach(v => {
            v(t.value, p, {
                delta: m,
                type: Cd.pop,
                direction: m ? m > 0 ? ad.forward : ad.back : ad.unknown
            })
        }
        )
    }
    ;
    function l() {
        o = t.value
    }
    function c(f) {
        s.push(f);
        const h = () => {
            const p = s.indexOf(f);
            p > -1 && s.splice(p, 1)
        }
        ;
        return r.push(h),
        h
    }
    function u() {
        const {history: f} = window;
        !f.state || f.replaceState(fn({}, f.state, {
            scroll: rm()
        }), "")
    }
    function d() {
        for (const f of r)
            f();
        r = [],
        window.removeEventListener("popstate", a),
        window.removeEventListener("beforeunload", u)
    }
    return window.addEventListener("popstate", a),
    window.addEventListener("beforeunload", u, {
        passive: !0
    }),
    {
        pauseListeners: l,
        listen: c,
        destroy: d
    }
}
function Fy(i, e, t, n=!1, s=!1) {
    return {
        back: i,
        current: e,
        forward: t,
        replaced: n,
        position: window.history.length,
        scroll: s ? rm() : null
    }
}
function N4(i) {
    const {history: e, location: t} = window
      , n = {
        value: RT(i, t)
    }
      , s = {
        value: e.state
    };
    s.value || r(n.value, {
        back: null,
        current: n.value,
        forward: null,
        position: e.length - 1,
        replaced: !0,
        scroll: null
    }, !0);
    function r(l, c, u) {
        const d = i.indexOf("#")
          , f = d > -1 ? (t.host && document.querySelector("base") ? i : i.slice(d)) + l : O4() + i + l;
        try {
            e[u ? "replaceState" : "pushState"](c, "", f),
            s.value = c
        } catch (h) {
            console.error(h),
            t[u ? "replace" : "assign"](f)
        }
    }
    function o(l, c) {
        const u = fn({}, e.state, Fy(s.value.back, l, s.value.forward, !0), c, {
            position: s.value.position
        });
        r(l, u, !0),
        n.value = l
    }
    function a(l, c) {
        const u = fn({}, s.value, e.state, {
            forward: l,
            scroll: rm()
        });
        r(u.current, u, !0);
        const d = fn({}, Fy(n.value, l, null), {
            position: u.position + 1
        }, c);
        r(l, d, !1),
        n.value = l
    }
    return {
        location: n,
        state: s,
        push: a,
        replace: o
    }
}
function B4(i) {
    i = R4(i);
    const e = N4(i)
      , t = U4(i, e.state, e.location, e.replace);
    function n(r, o=!0) {
        o || t.pauseListeners(),
        history.go(r)
    }
    const s = fn({
        location: "",
        base: i,
        go: n,
        createHref: I4.bind(null, i)
    }, e, t);
    return Object.defineProperty(s, "location", {
        enumerable: !0,
        get: () => e.location.value
    }),
    Object.defineProperty(s, "state", {
        enumerable: !0,
        get: () => e.state.value
    }),
    s
}
function V4(i) {
    return typeof i == "string" || i && typeof i == "object"
}
function LT(i) {
    return typeof i == "string" || typeof i == "symbol"
}
const IT = Symbol("");
var Oy;
(function(i) {
    i[i.aborted = 4] = "aborted",
    i[i.cancelled = 8] = "cancelled",
    i[i.duplicated = 16] = "duplicated"
}
)(Oy || (Oy = {}));
function eu(i, e) {
    return fn(new Error, {
        type: i,
        [IT]: !0
    }, e)
}
function to(i, e) {
    return i instanceof Error && IT in i && (e == null || !!(i.type & e))
}
const Uy = "[^/]+?"
  , $4 = {
    sensitive: !1,
    strict: !1,
    start: !0,
    end: !0
}
  , H4 = /[.+*?^${}()[\]/\\]/g;
function z4(i, e) {
    const t = fn({}, $4, e)
      , n = [];
    let s = t.start ? "^" : "";
    const r = [];
    for (const c of i) {
        const u = c.length ? [] : [90];
        t.strict && !c.length && (s += "/");
        for (let d = 0; d < c.length; d++) {
            const f = c[d];
            let h = 40 + (t.sensitive ? .25 : 0);
            if (f.type === 0)
                d || (s += "/"),
                s += f.value.replace(H4, "\\$&"),
                h += 40;
            else if (f.type === 1) {
                const {value: p, repeatable: g, optional: m, regexp: v} = f;
                r.push({
                    name: p,
                    repeatable: g,
                    optional: m
                });
                const _ = v || Uy;
                if (_ !== Uy) {
                    h += 10;
                    try {
                        new RegExp(`(${_})`)
                    } catch (b) {
                        throw new Error(`Invalid custom RegExp for param "${p}" (${_}): ` + b.message)
                    }
                }
                let y = g ? `((?:${_})(?:/(?:${_}))*)` : `(${_})`;
                d || (y = m && c.length < 2 ? `(?:/${y})` : "/" + y),
                m && (y += "?"),
                s += y,
                h += 20,
                m && (h += -8),
                g && (h += -20),
                _ === ".*" && (h += -50)
            }
            u.push(h)
        }
        n.push(u)
    }
    if (t.strict && t.end) {
        const c = n.length - 1;
        n[c][n[c].length - 1] += .7000000000000001
    }
    t.strict || (s += "/?"),
    t.end ? s += "$" : t.strict && !s.endsWith("/") && (s += "(?:/|$)");
    const o = new RegExp(s,t.sensitive ? "" : "i");
    function a(c) {
        const u = c.match(o)
          , d = {};
        if (!u)
            return null;
        for (let f = 1; f < u.length; f++) {
            const h = u[f] || ""
              , p = r[f - 1];
            d[p.name] = h && p.repeatable ? h.split("/") : h
        }
        return d
    }
    function l(c) {
        let u = ""
          , d = !1;
        for (const f of i) {
            (!d || !u.endsWith("/")) && (u += "/"),
            d = !1;
            for (const h of f)
                if (h.type === 0)
                    u += h.value;
                else if (h.type === 1) {
                    const {value: p, repeatable: g, optional: m} = h
                      , v = p in c ? c[p] : "";
                    if (yr(v) && !g)
                        throw new Error(`Provided param "${p}" is an array but it is not repeatable (* or + modifiers)`);
                    const _ = yr(v) ? v.join("/") : v;
                    if (!_)
                        if (m)
                            f.length < 2 && (u.endsWith("/") ? u = u.slice(0, -1) : d = !0);
                        else
                            throw new Error(`Missing required param "${p}"`);
                    u += _
                }
        }
        return u || "/"
    }
    return {
        re: o,
        score: n,
        keys: r,
        parse: a,
        stringify: l
    }
}
function G4(i, e) {
    let t = 0;
    for (; t < i.length && t < e.length; ) {
        const n = e[t] - i[t];
        if (n)
            return n;
        t++
    }
    return i.length < e.length ? i.length === 1 && i[0] === 40 + 40 ? -1 : 1 : i.length > e.length ? e.length === 1 && e[0] === 40 + 40 ? 1 : -1 : 0
}
function kT(i, e) {
    let t = 0;
    const n = i.score
      , s = e.score;
    for (; t < n.length && t < s.length; ) {
        const r = G4(n[t], s[t]);
        if (r)
            return r;
        t++
    }
    if (Math.abs(s.length - n.length) === 1) {
        if (Ny(n))
            return 1;
        if (Ny(s))
            return -1
    }
    return s.length - n.length
}
function Ny(i) {
    const e = i[i.length - 1];
    return i.length > 0 && e[e.length - 1] < 0
}
const W4 = {
    type: 0,
    value: ""
}
  , q4 = /[a-zA-Z0-9_]/;
function j4(i) {
    if (!i)
        return [[]];
    if (i === "/")
        return [[W4]];
    if (!i.startsWith("/"))
        throw new Error(`Invalid path "${i}"`);
    function e(h) {
        throw new Error(`ERR (${t})/"${c}": ${h}`)
    }
    let t = 0
      , n = t;
    const s = [];
    let r;
    function o() {
        r && s.push(r),
        r = []
    }
    let a = 0, l, c = "", u = "";
    function d() {
        !c || (t === 0 ? r.push({
            type: 0,
            value: c
        }) : t === 1 || t === 2 || t === 3 ? (r.length > 1 && (l === "*" || l === "+") && e(`A repeatable param (${c}) must be alone in its segment. eg: '/:ids+.`),
        r.push({
            type: 1,
            value: c,
            regexp: u,
            repeatable: l === "*" || l === "+",
            optional: l === "*" || l === "?"
        })) : e("Invalid state to consume buffer"),
        c = "")
    }
    function f() {
        c += l
    }
    for (; a < i.length; ) {
        if (l = i[a++],
        l === "\\" && t !== 2) {
            n = t,
            t = 4;
            continue
        }
        switch (t) {
        case 0:
            l === "/" ? (c && d(),
            o()) : l === ":" ? (d(),
            t = 1) : f();
            break;
        case 4:
            f(),
            t = n;
            break;
        case 1:
            l === "(" ? t = 2 : q4.test(l) ? f() : (d(),
            t = 0,
            l !== "*" && l !== "?" && l !== "+" && a--);
            break;
        case 2:
            l === ")" ? u[u.length - 1] == "\\" ? u = u.slice(0, -1) + l : t = 3 : u += l;
            break;
        case 3:
            d(),
            t = 0,
            l !== "*" && l !== "?" && l !== "+" && a--,
            u = "";
            break;
        default:
            e("Unknown state");
            break
        }
    }
    return t === 2 && e(`Unfinished custom RegExp for param "${c}"`),
    d(),
    o(),
    s
}
function K4(i, e, t) {
    const n = z4(j4(i.path), t)
      , s = fn(n, {
        record: i,
        parent: e,
        children: [],
        alias: []
    });
    return e && !s.record.aliasOf == !e.record.aliasOf && e.children.push(s),
    s
}
function X4(i, e) {
    const t = []
      , n = new Map;
    e = Hy({
        strict: !1,
        end: !0,
        sensitive: !1
    }, e);
    function s(d) {
        return n.get(d)
    }
    function r(d, f, h) {
        const p = !h
          , g = Vy(d);
        g.aliasOf = h && h.record;
        const m = Hy(e, d)
          , v = [g];
        if ("alias"in d) {
            const b = typeof d.alias == "string" ? [d.alias] : d.alias;
            for (const S of b)
                v.push(Vy(fn({}, g, {
                    components: h ? h.record.components : g.components,
                    path: S,
                    aliasOf: h ? h.record : g
                })))
        }
        let _, y;
        for (const b of v) {
            const {path: S} = b;
            if (f && S[0] !== "/") {
                const C = f.record.path
                  , M = C[C.length - 1] === "/" ? "" : "/";
                b.path = f.record.path + (S && M + S)
            }
            if (_ = K4(b, f, m),
            h ? h.alias.push(_) : (y = y || _,
            y !== _ && y.alias.push(_),
            p && d.name && !$y(_) && o(d.name)),
            PT(_) && l(_),
            g.children) {
                const C = g.children;
                for (let M = 0; M < C.length; M++)
                    r(C[M], _, h && h.children[M])
            }
            h = h || _
        }
        return y ? () => {
            o(y)
        }
        : od
    }
    function o(d) {
        if (LT(d)) {
            const f = n.get(d);
            f && (n.delete(d),
            t.splice(t.indexOf(f), 1),
            f.children.forEach(o),
            f.alias.forEach(o))
        } else {
            const f = t.indexOf(d);
            f > -1 && (t.splice(f, 1),
            d.record.name && n.delete(d.record.name),
            d.children.forEach(o),
            d.alias.forEach(o))
        }
    }
    function a() {
        return t
    }
    function l(d) {
        const f = J4(d, t);
        t.splice(f, 0, d),
        d.record.name && !$y(d) && n.set(d.record.name, d)
    }
    function c(d, f) {
        let h, p = {}, g, m;
        if ("name"in d && d.name) {
            if (h = n.get(d.name),
            !h)
                throw eu(1, {
                    location: d
                });
            m = h.record.name,
            p = fn(By(f.params, h.keys.filter(y => !y.optional).concat(h.parent ? h.parent.keys.filter(y => y.optional) : []).map(y => y.name)), d.params && By(d.params, h.keys.map(y => y.name))),
            g = h.stringify(p)
        } else if (d.path != null)
            g = d.path,
            h = t.find(y => y.re.test(g)),
            h && (p = h.parse(g),
            m = h.record.name);
        else {
            if (h = f.name ? n.get(f.name) : t.find(y => y.re.test(f.path)),
            !h)
                throw eu(1, {
                    location: d,
                    currentLocation: f
                });
            m = h.record.name,
            p = fn({}, f.params, d.params),
            g = h.stringify(p)
        }
        const v = [];
        let _ = h;
        for (; _; )
            v.unshift(_.record),
            _ = _.parent;
        return {
            name: m,
            path: g,
            params: p,
            matched: v,
            meta: Z4(v)
        }
    }
    i.forEach(d => r(d));
    function u() {
        t.length = 0,
        n.clear()
    }
    return {
        addRoute: r,
        resolve: c,
        removeRoute: o,
        clearRoutes: u,
        getRoutes: a,
        getRecordMatcher: s
    }
}
function By(i, e) {
    const t = {};
    for (const n of e)
        n in i && (t[n] = i[n]);
    return t
}
function Vy(i) {
    const e = {
        path: i.path,
        redirect: i.redirect,
        name: i.name,
        meta: i.meta || {},
        aliasOf: i.aliasOf,
        beforeEnter: i.beforeEnter,
        props: Y4(i),
        children: i.children || [],
        instances: {},
        leaveGuards: new Set,
        updateGuards: new Set,
        enterCallbacks: {},
        components: "components"in i ? i.components || null : i.component && {
            default: i.component
        }
    };
    return Object.defineProperty(e, "mods", {
        value: {}
    }),
    e
}
function Y4(i) {
    const e = {}
      , t = i.props || !1;
    if ("component"in i)
        e.default = t;
    else
        for (const n in i.components)
            e[n] = typeof t == "object" ? t[n] : t;
    return e
}
function $y(i) {
    for (; i; ) {
        if (i.record.aliasOf)
            return !0;
        i = i.parent
    }
    return !1
}
function Z4(i) {
    return i.reduce( (e, t) => fn(e, t.meta), {})
}
function Hy(i, e) {
    const t = {};
    for (const n in i)
        t[n] = n in e ? e[n] : i[n];
    return t
}
function J4(i, e) {
    let t = 0
      , n = e.length;
    for (; t !== n; ) {
        const r = t + n >> 1;
        kT(i, e[r]) < 0 ? n = r : t = r + 1
    }
    const s = Q4(i);
    return s && (n = e.lastIndexOf(s, n - 1)),
    n
}
function Q4(i) {
    let e = i;
    for (; e = e.parent; )
        if (PT(e) && kT(i, e) === 0)
            return e
}
function PT({record: i}) {
    return !!(i.name || i.components && Object.keys(i.components).length || i.redirect)
}
function eI(i) {
    const e = {};
    if (i === "" || i === "?")
        return e;
    const n = (i[0] === "?" ? i.slice(1) : i).split("&");
    for (let s = 0; s < n.length; ++s) {
        const r = n[s].replace(wT, " ")
          , o = r.indexOf("=")
          , a = Ad(o < 0 ? r : r.slice(0, o))
          , l = o < 0 ? null : Ad(r.slice(o + 1));
        if (a in e) {
            let c = e[a];
            yr(c) || (c = e[a] = [c]),
            c.push(l)
        } else
            e[a] = l
    }
    return e
}
function zy(i) {
    let e = "";
    for (let t in i) {
        const n = i[t];
        if (t = y4(t),
        n == null) {
            n !== void 0 && (e += (e.length ? "&" : "") + t);
            continue
        }
        (yr(n) ? n.map(r => r && zg(r)) : [n && zg(n)]).forEach(r => {
            r !== void 0 && (e += (e.length ? "&" : "") + t,
            r != null && (e += "=" + r))
        }
        )
    }
    return e
}
function tI(i) {
    const e = {};
    for (const t in i) {
        const n = i[t];
        n !== void 0 && (e[t] = yr(n) ? n.map(s => s == null ? null : "" + s) : n == null ? n : "" + n)
    }
    return e
}
const DT = Symbol("")
  , Gy = Symbol("")
  , om = Symbol("")
  , E_ = Symbol("")
  , Wg = Symbol("");
function Lu() {
    let i = [];
    function e(n) {
        return i.push(n),
        () => {
            const s = i.indexOf(n);
            s > -1 && i.splice(s, 1)
        }
    }
    function t() {
        i = []
    }
    return {
        add: e,
        list: () => i.slice(),
        reset: t
    }
}
function nI(i, e, t) {
    const n = () => {
        i[e].delete(t)
    }
    ;
    Ms(n),
    qw(n),
    Ti( () => {
        i[e].add(t)
    }
    ),
    i[e].add(t)
}
function iI(i) {
    const e = Es(DT, {}).value;
    !e || nI(e, "updateGuards", i)
}
function ta(i, e, t, n, s, r=o => o()) {
    const o = n && (n.enterCallbacks[s] = n.enterCallbacks[s] || []);
    return () => new Promise( (a, l) => {
        const c = f => {
            f === !1 ? l(eu(4, {
                from: t,
                to: e
            })) : f instanceof Error ? l(f) : V4(f) ? l(eu(2, {
                from: e,
                to: f
            })) : (o && n.enterCallbacks[s] === o && typeof f == "function" && o.push(f),
            a())
        }
          , u = r( () => i.call(n && n.instances[s], e, t, c));
        let d = Promise.resolve(u);
        i.length < 3 && (d = d.then(c)),
        d.catch(f => l(f))
    }
    )
}
function Qm(i, e, t, n, s=r => r()) {
    const r = [];
    for (const o of i)
        for (const a in o.components) {
            let l = o.components[a];
            if (!(e !== "beforeRouteEnter" && !o.instances[a]))
                if (ST(l)) {
                    const u = (l.__vccOpts || l)[e];
                    u && r.push(ta(u, t, n, o, a, s))
                } else {
                    let c = l();
                    r.push( () => c.then(u => {
                        if (!u)
                            throw new Error(`Couldn't resolve component "${a}" at "${o.path}"`);
                        const d = c4(u) ? u.default : u;
                        o.mods[a] = u,
                        o.components[a] = d;
                        const h = (d.__vccOpts || d)[e];
                        return h && ta(h, t, n, o, a, s)()
                    }
                    ))
                }
        }
    return r
}
function Wy(i) {
    const e = Es(om)
      , t = Es(E_)
      , n = Vt( () => {
        const l = E(i.to);
        return e.resolve(l)
    }
    )
      , s = Vt( () => {
        const {matched: l} = n.value
          , {length: c} = l
          , u = l[c - 1]
          , d = t.matched;
        if (!u || !d.length)
            return -1;
        const f = d.findIndex(Qc.bind(null, u));
        if (f > -1)
            return f;
        const h = qy(l[c - 2]);
        return c > 1 && qy(u) === h && d[d.length - 1].path !== h ? d.findIndex(Qc.bind(null, l[c - 2])) : f
    }
    )
      , r = Vt( () => s.value > -1 && lI(t.params, n.value.params))
      , o = Vt( () => s.value > -1 && s.value === t.matched.length - 1 && MT(t.params, n.value.params));
    function a(l={}) {
        if (aI(l)) {
            const c = e[E(i.replace) ? "replace" : "push"](E(i.to)).catch(od);
            return i.viewTransition && typeof document < "u" && "startViewTransition"in document && document.startViewTransition( () => c),
            c
        }
        return Promise.resolve()
    }
    return {
        route: n,
        href: Vt( () => n.value.href),
        isActive: r,
        isExactActive: o,
        navigate: a
    }
}
function sI(i) {
    return i.length === 1 ? i[0] : i
}
const rI = ut({
    name: "RouterLink",
    compatConfig: {
        MODE: 3
    },
    props: {
        to: {
            type: [String, Object],
            required: !0
        },
        replace: Boolean,
        activeClass: String,
        exactActiveClass: String,
        custom: Boolean,
        ariaCurrentValue: {
            type: String,
            default: "page"
        }
    },
    useLink: Wy,
    setup(i, {slots: e}) {
        const t = ei(Wy(i))
          , {options: n} = Es(om)
          , s = Vt( () => ({
            [jy(i.activeClass, n.linkActiveClass, "router-link-active")]: t.isActive,
            [jy(i.exactActiveClass, n.linkExactActiveClass, "router-link-exact-active")]: t.isExactActive
        }));
        return () => {
            const r = e.default && sI(e.default(t));
            return i.custom ? r : x_("a", {
                "aria-current": t.isExactActive ? i.ariaCurrentValue : null,
                href: t.href,
                onClick: t.navigate,
                class: s.value
            }, r)
        }
    }
})
  , oI = rI;
function aI(i) {
    if (!(i.metaKey || i.altKey || i.ctrlKey || i.shiftKey) && !i.defaultPrevented && !(i.button !== void 0 && i.button !== 0)) {
        if (i.currentTarget && i.currentTarget.getAttribute) {
            const e = i.currentTarget.getAttribute("target");
            if (/\b_blank\b/i.test(e))
                return
        }
        return i.preventDefault && i.preventDefault(),
        !0
    }
}
function lI(i, e) {
    for (const t in e) {
        const n = e[t]
          , s = i[t];
        if (typeof n == "string") {
            if (n !== s)
                return !1
        } else if (!yr(s) || s.length !== n.length || n.some( (r, o) => r !== s[o]))
            return !1
    }
    return !0
}
function qy(i) {
    return i ? i.aliasOf ? i.aliasOf.path : i.path : ""
}
const jy = (i, e, t) => i != null ? i : e != null ? e : t
  , cI = ut({
    name: "RouterView",
    inheritAttrs: !1,
    props: {
        name: {
            type: String,
            default: "default"
        },
        route: Object
    },
    compatConfig: {
        MODE: 3
    },
    setup(i, {attrs: e, slots: t}) {
        const n = Es(Wg)
          , s = Vt( () => i.route || n.value)
          , r = Es(Gy, 0)
          , o = Vt( () => {
            let c = E(r);
            const {matched: u} = s.value;
            let d;
            for (; (d = u[c]) && !d.components; )
                c++;
            return c
        }
        )
          , a = Vt( () => s.value.matched[o.value]);
        mh(Gy, Vt( () => o.value + 1)),
        mh(DT, a),
        mh(Wg, s);
        const l = xe();
        return Bt( () => [l.value, a.value, i.name], ([c,u,d], [f,h,p]) => {
            u && (u.instances[d] = c,
            h && h !== u && c && c === f && (u.leaveGuards.size || (u.leaveGuards = h.leaveGuards),
            u.updateGuards.size || (u.updateGuards = h.updateGuards))),
            c && u && (!h || !Qc(u, h) || !f) && (u.enterCallbacks[d] || []).forEach(g => g(c))
        }
        , {
            flush: "post"
        }),
        () => {
            const c = s.value
              , u = i.name
              , d = a.value
              , f = d && d.components[u];
            if (!f)
                return Ky(t.default, {
                    Component: f,
                    route: c
                });
            const h = d.props[u]
              , p = h ? h === !0 ? c.params : typeof h == "function" ? h(c) : h : null
              , m = x_(f, fn({}, p, e, {
                onVnodeUnmounted: v => {
                    v.component.isUnmounted && (d.instances[u] = null)
                }
                ,
                ref: l
            }));
            return Ky(t.default, {
                Component: m,
                route: c
            }) || m
        }
    }
});
function Ky(i, e) {
    if (!i)
        return null;
    const t = i(e);
    return t.length === 1 ? t[0] : t
}
const uI = cI;
function dI(i) {
    const e = X4(i.routes, i)
      , t = i.parseQuery || eI
      , n = i.stringifyQuery || zy
      , s = i.history
      , r = Lu()
      , o = Lu()
      , a = Lu()
      , l = uL(Ho);
    let c = Ho;
    xc && i.scrollBehavior && "scrollRestoration"in history && (history.scrollRestoration = "manual");
    const u = Zm.bind(null, q => "" + q)
      , d = Zm.bind(null, S4)
      , f = Zm.bind(null, Ad);
    function h(q, me) {
        let Ce, Pe;
        return LT(q) ? (Ce = e.getRecordMatcher(q),
        Pe = me) : Pe = q,
        e.addRoute(Pe, Ce)
    }
    function p(q) {
        const me = e.getRecordMatcher(q);
        me && e.removeRoute(me)
    }
    function g() {
        return e.getRoutes().map(q => q.record)
    }
    function m(q) {
        return !!e.getRecordMatcher(q)
    }
    function v(q, me) {
        if (me = fn({}, me || l.value),
        typeof q == "string") {
            const V = Jm(t, q, me.path)
              , Q = e.resolve({
                path: V.path
            }, me)
              , he = s.createHref(V.fullPath);
            return fn(V, Q, {
                params: f(Q.params),
                hash: Ad(V.hash),
                redirectedFrom: void 0,
                href: he
            })
        }
        let Ce;
        if (q.path != null)
            Ce = fn({}, q, {
                path: Jm(t, q.path, me.path).path
            });
        else {
            const V = fn({}, q.params);
            for (const Q in V)
                V[Q] == null && delete V[Q];
            Ce = fn({}, q, {
                params: d(V)
            }),
            me.params = d(me.params)
        }
        const Pe = e.resolve(Ce, me)
          , vt = q.hash || "";
        Pe.params = u(f(Pe.params));
        const j = T4(n, fn({}, q, {
            hash: x4(vt),
            path: Pe.path
        }))
          , B = s.createHref(j);
        return fn({
            fullPath: j,
            hash: vt,
            query: n === zy ? tI(q.query) : q.query || {}
        }, Pe, {
            redirectedFrom: void 0,
            href: B
        })
    }
    function _(q) {
        return typeof q == "string" ? Jm(t, q, l.value.path) : fn({}, q)
    }
    function y(q, me) {
        if (c !== q)
            return eu(8, {
                from: me,
                to: q
            })
    }
    function b(q) {
        return M(q)
    }
    function S(q) {
        return b(fn(_(q), {
            replace: !0
        }))
    }
    function C(q) {
        const me = q.matched[q.matched.length - 1];
        if (me && me.redirect) {
            const {redirect: Ce} = me;
            let Pe = typeof Ce == "function" ? Ce(q) : Ce;
            return typeof Pe == "string" && (Pe = Pe.includes("?") || Pe.includes("#") ? Pe = _(Pe) : {
                path: Pe
            },
            Pe.params = {}),
            fn({
                query: q.query,
                hash: q.hash,
                params: Pe.path != null ? {} : q.params
            }, Pe)
        }
    }
    function M(q, me) {
        const Ce = c = v(q)
          , Pe = l.value
          , vt = q.state
          , j = q.force
          , B = q.replace === !0
          , V = C(Ce);
        if (V)
            return M(fn(_(V), {
                state: typeof V == "object" ? fn({}, vt, V.state) : vt,
                force: j,
                replace: B
            }), me || Ce);
        const Q = Ce;
        Q.redirectedFrom = me;
        let he;
        return !j && A4(n, Pe, Ce) && (he = eu(16, {
            to: Q,
            from: Pe
        }),
        Ie(Pe, Pe, !0, !1)),
        (he ? Promise.resolve(he) : A(Q, Pe)).catch(Ee => to(Ee) ? to(Ee, 2) ? Ee : ue(Ee) : K(Ee, Q, Pe)).then(Ee => {
            if (Ee) {
                if (to(Ee, 2))
                    return M(fn({
                        replace: B
                    }, _(Ee.to), {
                        state: typeof Ee.to == "object" ? fn({}, vt, Ee.to.state) : vt,
                        force: j
                    }), me || Q)
            } else
                Ee = D(Q, Pe, !0, B, vt);
            return k(Q, Pe, Ee),
            Ee
        }
        )
    }
    function L(q, me) {
        const Ce = y(q, me);
        return Ce ? Promise.reject(Ce) : Promise.resolve()
    }
    function T(q) {
        const me = se.values().next().value;
        return me && typeof me.runWithContext == "function" ? me.runWithContext(q) : q()
    }
    function A(q, me) {
        let Ce;
        const [Pe,vt,j] = fI(q, me);
        Ce = Qm(Pe.reverse(), "beforeRouteLeave", q, me);
        for (const V of Pe)
            V.leaveGuards.forEach(Q => {
                Ce.push(ta(Q, q, me))
            }
            );
        const B = L.bind(null, q, me);
        return Ce.push(B),
        be(Ce).then( () => {
            Ce = [];
            for (const V of r.list())
                Ce.push(ta(V, q, me));
            return Ce.push(B),
            be(Ce)
        }
        ).then( () => {
            Ce = Qm(vt, "beforeRouteUpdate", q, me);
            for (const V of vt)
                V.updateGuards.forEach(Q => {
                    Ce.push(ta(Q, q, me))
                }
                );
            return Ce.push(B),
            be(Ce)
        }
        ).then( () => {
            Ce = [];
            for (const V of j)
                if (V.beforeEnter)
                    if (yr(V.beforeEnter))
                        for (const Q of V.beforeEnter)
                            Ce.push(ta(Q, q, me));
                    else
                        Ce.push(ta(V.beforeEnter, q, me));
            return Ce.push(B),
            be(Ce)
        }
        ).then( () => (q.matched.forEach(V => V.enterCallbacks = {}),
        Ce = Qm(j, "beforeRouteEnter", q, me, T),
        Ce.push(B),
        be(Ce))).then( () => {
            Ce = [];
            for (const V of o.list())
                Ce.push(ta(V, q, me));
            return Ce.push(B),
            be(Ce)
        }
        ).catch(V => to(V, 8) ? V : Promise.reject(V))
    }
    function k(q, me, Ce) {
        a.list().forEach(Pe => T( () => Pe(q, me, Ce)))
    }
    function D(q, me, Ce, Pe, vt) {
        const j = y(q, me);
        if (j)
            return j;
        const B = me === Ho
          , V = xc ? history.state : {};
        Ce && (Pe || B ? s.replace(q.fullPath, fn({
            scroll: B && V && V.scroll
        }, vt)) : s.push(q.fullPath, vt)),
        l.value = q,
        Ie(q, me, Ce, B),
        ue()
    }
    let F;
    function z() {
        F || (F = s.listen( (q, me, Ce) => {
            if (!Se.listening)
                return;
            const Pe = v(q)
              , vt = C(Pe);
            if (vt) {
                M(fn(vt, {
                    replace: !0,
                    force: !0
                }), Pe).catch(od);
                return
            }
            c = Pe;
            const j = l.value;
            xc && D4(Dy(j.fullPath, Ce.delta), rm()),
            A(Pe, j).catch(B => to(B, 12) ? B : to(B, 2) ? (M(fn(_(B.to), {
                force: !0
            }), Pe).then(V => {
                to(V, 20) && !Ce.delta && Ce.type === Cd.pop && s.go(-1, !1)
            }
            ).catch(od),
            Promise.reject()) : (Ce.delta && s.go(-Ce.delta, !1),
            K(B, Pe, j))).then(B => {
                B = B || D(Pe, j, !1),
                B && (Ce.delta && !to(B, 8) ? s.go(-Ce.delta, !1) : Ce.type === Cd.pop && to(B, 20) && s.go(-1, !1)),
                k(Pe, j, B)
            }
            ).catch(od)
        }
        ))
    }
    let G = Lu(), H = Lu(), X;
    function K(q, me, Ce) {
        ue(q);
        const Pe = H.list();
        return Pe.length ? Pe.forEach(vt => vt(q, me, Ce)) : console.error(q),
        Promise.reject(q)
    }
    function ce() {
        return X && l.value !== Ho ? Promise.resolve() : new Promise( (q, me) => {
            G.add([q, me])
        }
        )
    }
    function ue(q) {
        return X || (X = !q,
        z(),
        G.list().forEach( ([me,Ce]) => q ? Ce(q) : me()),
        G.reset()),
        q
    }
    function Ie(q, me, Ce, Pe) {
        const {scrollBehavior: vt} = i;
        if (!xc || !vt)
            return Promise.resolve();
        const j = !Ce && F4(Dy(q.fullPath, 0)) || (Pe || !Ce) && history.state && history.state.scroll || null;
        return Yd().then( () => vt(q, me, j)).then(B => B && P4(B)).catch(B => K(B, q, me))
    }
    const ke = q => s.go(q);
    let We;
    const se = new Set
      , Se = {
        currentRoute: l,
        listening: !0,
        addRoute: h,
        removeRoute: p,
        clearRoutes: e.clearRoutes,
        hasRoute: m,
        getRoutes: g,
        resolve: v,
        options: i,
        push: b,
        replace: S,
        go: ke,
        back: () => ke(-1),
        forward: () => ke(1),
        beforeEach: r.add,
        beforeResolve: o.add,
        afterEach: a.add,
        onError: H.add,
        isReady: ce,
        install(q) {
            const me = this;
            q.component("RouterLink", oI),
            q.component("RouterView", uI),
            q.config.globalProperties.$router = me,
            Object.defineProperty(q.config.globalProperties, "$route", {
                enumerable: !0,
                get: () => E(l)
            }),
            xc && !We && l.value === Ho && (We = !0,
            b(s.location).catch(vt => {}
            ));
            const Ce = {};
            for (const vt in Ho)
                Object.defineProperty(Ce, vt, {
                    get: () => l.value[vt],
                    enumerable: !0
                });
            q.provide(om, me),
            q.provide(E_, Aw(Ce)),
            q.provide(Wg, l);
            const Pe = q.unmount;
            se.add(q),
            q.unmount = function() {
                se.delete(q),
                se.size < 1 && (c = Ho,
                F && F(),
                F = null,
                l.value = Ho,
                We = !1,
                X = !1),
                Pe()
            }
        }
    };
    function be(q) {
        return q.reduce( (me, Ce) => me.then( () => T(Ce)), Promise.resolve())
    }
    return Se
}
function fI(i, e) {
    const t = []
      , n = []
      , s = []
      , r = Math.max(e.matched.length, i.matched.length);
    for (let o = 0; o < r; o++) {
        const a = e.matched[o];
        a && (i.matched.find(c => Qc(c, a)) ? n.push(a) : t.push(a));
        const l = i.matched[o];
        l && (e.matched.find(c => Qc(c, l)) || s.push(l))
    }
    return [t, n, s]
}
function ti() {
    return Es(om)
}
function Ki(i) {
    return Es(E_)
}
const vn = ut({
    __name: "Input",
    props: {
        modelValue: {},
        textarea: {
            type: Boolean
        },
        disabled: {
            type: Boolean
        },
        required: {
            type: Boolean
        },
        min: {},
        max: {},
        rows: {},
        type: {},
        placeholder: {},
        transparent: {
            type: Boolean
        }
    },
    emits: ["update:modelValue", "blur", "input"],
    setup(i, {emit: e}) {
        const t = i
          , n = e
          , s = r => {
            n("update:modelValue", r.target.value),
            n("input")
        }
        ;
        return (r, o) => (w(),
        Re(ys(t.textarea ? "textarea" : "input"), {
            value: t.modelValue,
            onInput: s,
            onBlur: o[0] || (o[0] = a => n("blur")),
            type: r.type,
            required: t.required,
            disabled: t.disabled,
            min: t.min,
            max: t.max,
            rows: t.rows,
            placeholder: t.placeholder,
            class: "w-full py-1.5 px-2 focus-visible:outline-none bg-zinc-800 focus:ring-2 ring-blue-500 disabled:opacity-70 rounded-md text-lg md:text-base"
        }, null, 40, ["value", "type", "required", "disabled", "min", "max", "rows", "placeholder"]))
    }
})
  , hI = {
    key: 0,
    viewBox: "0 0 24 24"
}
  , pI = {
    key: 1,
    viewBox: "0 0 24 24"
}
  , mI = {
    key: 2,
    viewBox: "0 0 24 24"
}
  , gI = {
    key: 3,
    viewBox: "0 0 24 24"
}
  , vI = {
    key: 4,
    viewBox: "0 0 24 24"
}
  , _I = {
    key: 5,
    viewBox: "0 0 24 24"
}
  , xI = {
    key: 6,
    viewBox: "0 0 24 24"
}
  , yI = {
    key: 7,
    viewBox: "0 0 24 24"
}
  , bI = {
    key: 8,
    viewBox: "0 0 97 142",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
}
  , SI = {
    key: 9,
    viewBox: "0 0 64 64",
    xmlns: "http://www.w3.org/2000/svg"
}
  , EI = {
    key: 10,
    viewBox: "0 0 24 24"
}
  , wI = {
    key: 11,
    viewBox: "0 0 24 24"
}
  , TI = {
    key: 12,
    viewBox: "0 0 24 24"
}
  , AI = {
    key: 13,
    viewBox: "0 0 24 24"
}
  , CI = {
    key: 14,
    viewBox: "0 0 24 24"
}
  , MI = {
    key: 15,
    viewBox: "0 0 24 24"
}
  , RI = {
    key: 16,
    viewBox: "0 0 24 24"
}
  , LI = {
    key: 17,
    viewBox: "0 0 24 24"
}
  , II = {
    key: 18,
    viewBox: "0 0 24 24"
}
  , kI = {
    key: 19,
    viewBox: "0 0 24 24"
}
  , PI = {
    key: 20,
    viewBox: "0 0 24 24"
}
  , DI = {
    key: 21,
    viewBox: "0 0 24 24"
}
  , FI = {
    key: 22,
    viewBox: "0 0 24 24"
}
  , OI = {
    key: 23,
    viewBox: "0 0 24 24"
}
  , UI = {
    key: 24,
    viewBox: "0 0 24 24"
}
  , NI = {
    key: 25,
    viewBox: "0 0 24 24"
}
  , BI = {
    key: 26,
    viewBox: "0 0 24 24"
}
  , VI = {
    key: 27,
    viewBox: "0 0 24 24"
}
  , $I = {
    key: 28,
    viewBox: "0 0 24 24"
}
  , HI = {
    key: 29,
    viewBox: "0 0 24 24"
}
  , zI = {
    key: 30,
    viewBox: "0 0 24 24"
}
  , GI = {
    key: 31,
    viewBox: "0 0 24 24"
}
  , WI = {
    key: 32,
    viewBox: "0 0 24 24"
}
  , qI = {
    key: 33,
    viewBox: "0 0 24 24"
}
  , jI = {
    key: 34,
    viewBox: "0 0 24 24"
}
  , KI = {
    key: 35,
    viewBox: "0 0 24 24"
}
  , XI = {
    key: 36,
    viewBox: "0 0 24 24"
}
  , YI = {
    key: 37,
    viewBox: "0 0 24 24"
}
  , ZI = {
    key: 38,
    viewBox: "0 0 24 24"
}
  , JI = {
    key: 39,
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    stroke: "currentColor",
    "stroke-width": "2"
}
  , QI = {
    key: 40,
    viewBox: "0 0 24 24"
}
  , ek = {
    key: 41,
    viewBox: "0 0 24 24"
}
  , tk = {
    key: 42,
    viewBox: "0 0 24 24"
}
  , nk = {
    key: 43,
    viewBox: "0 0 24 24"
}
  , ik = {
    key: 44,
    viewBox: "0 0 24 24"
}
  , sk = {
    key: 45,
    viewBox: "0 0 24 24"
}
  , rk = {
    key: 46,
    viewBox: "0 0 24 24"
}
  , ok = {
    key: 47,
    viewBox: "0 0 24 24"
}
  , ak = {
    key: 48,
    viewBox: "0 0 24 24"
}
  , lk = {
    key: 49,
    viewBox: "0 0 24 24"
}
  , ck = {
    key: 50,
    viewBox: "0 0 24 24"
}
  , uk = {
    key: 51,
    viewBox: "0 0 240 240",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
}
  , dk = {
    key: 52,
    viewBox: "0 0 24 24"
}
  , fk = {
    key: 53,
    viewBox: "0 0 24 24"
}
  , hk = {
    key: 54,
    viewBox: "0 0 24 24"
}
  , pk = {
    key: 55,
    viewBox: "0 0 24 24"
}
  , mk = {
    key: 56,
    viewBox: "0 0 24 24"
}
  , gk = {
    key: 57,
    viewBox: "0 0 24 24"
}
  , vk = {
    key: 58,
    viewBox: "0 0 24 24"
}
  , _k = {
    key: 59,
    viewBox: "0 0 24 24"
}
  , xk = {
    key: 60,
    viewBox: "0 0 24 24"
}
  , yk = {
    key: 61,
    viewBox: "0 0 24 24"
}
  , bk = {
    key: 62,
    viewBox: "0 0 24 24"
}
  , Sk = {
    key: 63,
    viewBox: "0 0 24 24"
}
  , Ek = {
    key: 64,
    viewBox: "0 0 24 24"
}
  , wk = {
    key: 65,
    viewBox: "0 0 24 24"
}
  , Tk = {
    key: 66,
    viewBox: "0 0 24 24"
}
  , Ak = {
    key: 67,
    viewBox: "0 0 24 24"
}
  , Ck = {
    key: 68
}
  , Mk = {
    key: 69,
    viewBox: "0 0 24 24"
}
  , Rk = {
    key: 70,
    viewBox: "0 0 24 24"
}
  , Lk = {
    key: 71,
    viewBox: "0 0 24 24"
}
  , Ik = {
    key: 72,
    viewBox: "0 0 24 24"
}
  , kk = {
    key: 73,
    viewBox: "0 0 24 24"
}
  , Pk = {
    key: 74,
    viewBox: "0 0 24 24"
}
  , Dk = {
    key: 75,
    viewBox: "0 0 24 24"
}
  , Fk = {
    key: 76,
    viewBox: "0 0 24 24"
}
  , Ok = {
    key: 77,
    viewBox: "0 0 24 24"
}
  , Uk = {
    key: 78,
    fill: "none",
    viewBox: "0 0 24 24"
}
  , Nk = {
    key: 79,
    fill: "none",
    viewBox: "0 0 38 36"
}
  , Bk = {
    key: 80,
    viewBox: "0 0 24 24"
}
  , Vk = {
    key: 81,
    viewBox: "0 0 256 256",
    fill: "none"
}
  , $k = {
    key: 82,
    viewBox: "0 0 24 24"
}
  , Hk = {
    key: 83,
    viewBox: "0 0 24 24"
}
  , zk = {
    key: 84,
    viewBox: "0 0 24 24"
}
  , Gk = {
    key: 85,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 256 256"
}
  , Wk = {
    key: 86,
    viewBox: "0 0 24 24"
}
  , qk = {
    key: 87,
    viewBox: "0 0 24 24"
}
  , jk = {
    key: 88,
    viewBox: "0 0 24 24"
}
  , Kk = {
    key: 89,
    viewBox: "0 0 24 24"
}
  , Xk = {
    key: 90,
    viewBox: "0 0 24 24"
}
  , Yk = {
    key: 91,
    viewBox: "0 0 24 24"
}
  , Zk = {
    key: 92,
    viewBox: "0 0 24 24"
}
  , Jk = {
    key: 93,
    viewBox: "0 0 24 24"
}
  , Qk = {
    key: 94,
    viewBox: "0 0 24 24"
}
  , eP = {
    key: 95,
    viewBox: "0 0 24 24"
}
  , tP = {
    key: 96,
    viewBox: "0 0 24 24"
}
  , nP = {
    key: 97,
    viewBox: "0 0 24 24"
}
  , iP = {
    key: 98,
    viewBox: "0 0 24 24"
}
  , sP = {
    key: 99,
    viewBox: "0 0 24 24"
}
  , rP = {
    key: 100,
    viewBox: "0 0 24 24"
}
  , oP = {
    key: 101,
    viewBox: "0 0 24 24"
}
  , aP = {
    key: 102,
    viewBox: "0 0 24 24"
}
  , lP = {
    key: 103,
    viewBox: "0 0 24 24"
}
  , cP = {
    key: 104,
    viewBox: "0 0 24 24"
}
  , uP = {
    key: 105,
    viewBox: "0 0 24 24"
}
  , dP = {
    key: 106,
    viewBox: "0 0 24 24"
}
  , fP = {
    key: 107,
    viewBox: "0 0 24 24"
}
  , hP = {
    key: 108,
    viewBox: "0 0 24 24",
    fill: "none"
}
  , pP = {
    key: 109,
    viewBox: "0 0 24 24",
    fill: "none"
}
  , mP = {
    key: 110,
    viewBox: "0 0 24 24",
    fill: "none"
}
  , gP = {
    key: 111,
    viewBox: "0 0 173 81",
    fill: "none"
}
  , vP = {
    key: 112,
    viewBox: "0 0 24 24"
}
  , _P = {
    key: 113,
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg",
    "xmlns:xlink": "http://www.w3.org/1999/xlink"
}
  , xP = {
    key: 114,
    viewBox: "0 -23.5 256 256",
    xmlns: "http://www.w3.org/2000/svg",
    "xmlns:xlink": "http://www.w3.org/1999/xlink"
}
  , yP = {
    key: 115,
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg",
    "xmlns:xlink": "http://www.w3.org/1999/xlink"
}
  , bP = {
    key: 116,
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 22 21"
}
  , SP = {
    key: 117,
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24"
}
  , EP = {
    key: 118,
    viewBox: "-2.04 -2.04 24.52 24.52",
    xmlns: "http://www.w3.org/2000/svg",
    fill: "currentColor"
}
  , wP = {
    key: 119,
    viewBox: "0 0 24 24"
}
  , TP = {
    key: 120,
    viewBox: "0 0 24 24"
}
  , AP = {
    key: 121,
    viewBox: "0 0 24 24"
}
  , CP = {
    key: 122,
    fill: "currentColor",
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg"
}
  , MP = {
    key: 123,
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg"
}
  , RP = {
    key: 124,
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 18 20",
    fill: "currentColor"
}
  , LP = {
    key: 125,
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 18 20",
    fill: "currentColor"
}
  , IP = {
    key: 126,
    version: "1.1",
    xmlns: "http://www.w3.org/2000/svg",
    "xmlns:xlink": "http://www.w3.org/1999/xlink",
    viewBox: "0 0 26.676 26.676",
    "xml:space": "preserve"
}
  , ze = ut({
    __name: "Icon",
    props: {
        name: {}
    },
    setup(i) {
        const e = i
          , t = n => e.name === n;
        return (n, s) => t("fire") ? (w(),
        R("svg", hI, s[0] || (s[0] = [x("path", {
            fill: "currentColor",
            d: "M17.66 11.2C17.43 10.9 17.15 10.64 16.89 10.38C16.22 9.78 15.46 9.35 14.82 8.72C13.33 7.26 13 4.85 13.95 3C13 3.23 12.17 3.75 11.46 4.32C8.87 6.4 7.85 10.07 9.07 13.22C9.11 13.32 9.15 13.42 9.15 13.55C9.15 13.77 9 13.97 8.8 14.05C8.57 14.15 8.33 14.09 8.14 13.93C8.08 13.88 8.04 13.83 8 13.76C6.87 12.33 6.69 10.28 7.45 8.64C5.78 10 4.87 12.3 5 14.47C5.06 14.97 5.12 15.47 5.29 15.97C5.43 16.57 5.7 17.17 6 17.7C7.08 19.43 8.95 20.67 10.96 20.92C13.1 21.19 15.39 20.8 17.03 19.32C18.86 17.66 19.5 15 18.56 12.72L18.43 12.46C18.22 12 17.66 11.2 17.66 11.2M14.5 17.5C14.22 17.74 13.76 18 13.4 18.1C12.28 18.5 11.16 17.94 10.5 17.28C11.69 17 12.4 16.12 12.61 15.23C12.78 14.43 12.46 13.77 12.33 13C12.21 12.26 12.23 11.63 12.5 10.94C12.69 11.32 12.89 11.7 13.13 12C13.9 13 15.11 13.44 15.37 14.8C15.41 14.94 15.43 15.08 15.43 15.23C15.46 16.05 15.1 16.95 14.5 17.5H14.5Z"
        }, null, -1)]))) : t("new") ? (w(),
        R("svg", pI, s[1] || (s[1] = [x("path", {
            fill: "currentColor",
            d: "M20,11H4V8H20M20,15H13V13H20M20,19H13V17H20M11,19H4V13H11M20.33,4.67L18.67,3L17,4.67L15.33,3L13.67,4.67L12,3L10.33,4.67L8.67,3L7,4.67L5.33,3L3.67,4.67L2,3V19A2,2 0 0,0 4,21H20A2,2 0 0,0 22,19V3L20.33,4.67Z"
        }, null, -1)]))) : t("top") ? (w(),
        R("svg", mI, s[2] || (s[2] = [x("path", {
            fill: "currentColor",
            d: "M3,22V8H7V22H3M10,22V2H14V22H10M17,22V14H21V22H17Z"
        }, null, -1)]))) : t("comments") ? (w(),
        R("svg", gI, s[3] || (s[3] = [x("path", {
            fill: "currentColor",
            d: "M3,15H1V3A2,2 0 0,1 3,1H19V3H3V15M12,23A1,1 0 0,1 11,22V19H7A2,2 0 0,1 5,17V7A2,2 0 0,1 7,5H21A2,2 0 0,1 23,7V17A2,2 0 0,1 21,19H16.9L13.2,22.71C13,22.89 12.76,23 12.5,23H12M9,9V11H19V9H9M9,13V15H17V13H9Z"
        }, null, -1)]))) : t("thumbs-up") ? (w(),
        R("svg", vI, s[4] || (s[4] = [x("path", {
            fill: "currentColor",
            d: "M23,10C23,8.89 22.1,8 21,8H14.68L15.64,3.43C15.66,3.33 15.67,3.22 15.67,3.11C15.67,2.7 15.5,2.32 15.23,2.05L14.17,1L7.59,7.58C7.22,7.95 7,8.45 7,9V19A2,2 0 0,0 9,21H18C18.83,21 19.54,20.5 19.84,19.78L22.86,12.73C22.95,12.5 23,12.26 23,12V10M1,21H5V9H1V21Z"
        }, null, -1)]))) : t("search") ? (w(),
        R("svg", _I, s[5] || (s[5] = [x("path", {
            fill: "currentColor",
            d: "M9.5,3A6.5,6.5 0 0,1 16,9.5C16,11.11 15.41,12.59 14.44,13.73L14.71,14H15.5L20.5,19L19,20.5L14,15.5V14.71L13.73,14.44C12.59,15.41 11.11,16 9.5,16A6.5,6.5 0 0,1 3,9.5A6.5,6.5 0 0,1 9.5,3M9.5,5C7,5 5,7 5,9.5C5,12 7,14 9.5,14C12,14 14,12 14,9.5C14,7 12,5 9.5,5Z"
        }, null, -1)]))) : t("loading") ? (w(),
        R("svg", xI, s[6] || (s[6] = [x("path", {
            fill: "currentColor",
            d: "M12,4V2A10,10 0 0,0 2,12H4A8,8 0 0,1 12,4Z"
        }, null, -1)]))) : t("close") ? (w(),
        R("svg", yI, s[7] || (s[7] = [x("path", {
            fill: "currentColor",
            d: "M19,6.41L17.59,5L12,10.59L6.41,5L5,6.41L10.59,12L5,17.59L6.41,19L12,13.41L17.59,19L19,17.59L13.41,12L19,6.41Z"
        }, null, -1)]))) : t("thehandy") ? (w(),
        R("svg", bI, s[8] || (s[8] = [x("g", {
            "clip-path": "url(#clip0_7_18)"
        }, [x("path", {
            d: "M38.5965 19.2044V90.7908C38.5965 101.797 29.4502 110.801 18.4074 110.293C13.4567 110.048 8.78916 107.921 5.36689 104.352C1.94461 100.782 0.0284422 96.0415 0.0133561 91.1072V19.4969C0.0133561 9.12635 8.14455 0.417711 18.5463 0.0161828C21.1397 -0.0783716 23.7257 0.347554 26.1502 1.2686C28.5748 2.18964 30.7885 3.58696 32.6593 5.37736C34.5301 7.16775 36.0199 9.31461 37.0399 11.6901C38.0599 14.0656 38.5892 16.6211 38.5965 19.2044ZM81.937 65.0956V108.357H43.3619V65.0956C43.3619 62.5737 43.8609 60.0765 44.8304 57.7465C45.7999 55.4165 47.2209 53.2995 49.0123 51.5162C50.8037 49.7329 52.9303 48.3184 55.2709 47.3533C57.6115 46.3882 60.12 45.8914 62.6535 45.8914C65.1869 45.8914 67.6954 46.3882 70.036 47.3533C72.3766 48.3184 74.5033 49.7329 76.2946 51.5162C78.086 53.2995 79.507 55.4165 80.4765 57.7465C81.446 60.0765 81.945 62.5737 81.945 65.0956H81.937ZM13.9224 125.862V134.653H9.93159V126.708C9.93159 124.708 8.94057 123.498 7.38592 123.498C5.37449 123.498 3.98813 124.849 3.98813 127.383V134.653H0V113.5H3.98813V122.99C4.89367 120.961 6.53647 120.031 8.60133 120.031C12.0258 120.031 13.9224 122.371 13.9224 125.862ZM15.8751 127.412C15.8751 123.075 18.4234 120.031 22.5264 120.031C24.4764 120.031 26.2661 120.905 26.9686 122.371H26.998V120.342H30.9861V134.653H26.998V132.454H26.9686C26.2047 134.004 24.4497 134.962 22.5264 134.962C18.4234 134.962 15.8751 131.896 15.8751 127.412ZM27.1102 127.553V127.375C27.1102 124.841 25.609 123.208 23.4319 123.208C21.3083 123.208 19.8098 124.87 19.8098 127.404C19.8098 130.109 21.3083 131.771 23.4319 131.771C25.609 131.779 27.1102 130.146 27.1102 127.553ZM47.9377 125.862V134.653H43.9496V126.708C43.9496 124.708 42.9585 123.498 41.4039 123.498C39.3925 123.498 38.0061 124.849 38.0061 127.383V134.653H34.018V120.342H38.0061V123.001C38.9117 120.972 40.5545 120.041 42.6193 120.041C46.0438 120.031 47.9377 122.371 47.9377 125.862ZM49.8824 127.412C49.8824 123.075 52.4307 120.031 56.5337 120.031C58.4863 120.031 60.439 120.905 61.1442 122.371H61.1736V113.5H65.1644V134.653H61.1843V132.454H61.1549C60.4203 134.004 58.4676 134.962 56.5444 134.962C52.4414 134.962 49.8824 131.896 49.8824 127.412ZM53.8171 127.412C53.8171 130.117 55.3156 131.779 57.4392 131.779C59.6163 131.779 61.1175 130.146 61.1175 127.553V127.375C61.1175 124.841 59.6163 123.208 57.4392 123.208C55.3263 123.216 53.8277 124.878 53.8277 127.412H53.8171ZM81.937 136.001C81.937 139.607 78.9586 142 74.8262 142C70.6938 142 67.9211 140.03 67.5551 136.536H71.5994C71.9119 137.972 73.1006 138.958 74.8048 138.958C76.6159 138.958 77.9462 137.804 77.9462 136.225V131.438C77.0406 133.326 75.4272 134.198 73.4478 134.198C70.1649 134.198 68.0146 132.002 68.0146 128.141V120.342H72.0054V127.497C72.0054 129.526 72.967 130.736 74.5511 130.736C76.5598 130.736 77.9462 129.356 77.9462 126.849V120.342H81.937V136.001ZM88.8821 114.398H86.7291V120.32H85.6767V114.398H83.4996V113.492H88.8821V114.398ZM97.0053 113.492V120.32H95.9903V115.162L93.6503 117.885H93.3832L91.0191 115.143V120.323H90.0041V113.492H90.9176L93.506 116.627L96.1185 113.492H97.0053Z",
            fill: "currentColor"
        })], -1), x("defs", null, [x("clipPath", {
            id: "clip0_7_18"
        }, [x("rect", {
            width: "97",
            height: "142",
            fill: "white"
        })])], -1)]))) : t("autoblow") ? (w(),
        R("svg", SI, s[9] || (s[9] = [x("path", {
            d: "M0 0 C8.04071716 5.46768767 14.35713546 11.78672485 16.953125 21.328125 C17.97008074 32.73931439 17.08780568 41.52074309 9.640625 50.578125 C3.75028057 56.89640044 -1.9995096 60.87830798 -10.81640625 61.6640625 C-22.23808647 61.92046185 -29.76998744 60.10045244 -38.2578125 52.1875 C-45.41707366 44.7468705 -47.46537447 37.63799487 -47.41040039 27.37304688 C-47.154444 17.46241552 -43.06295379 11.07888989 -36.046875 4.328125 C-26.55128048 -3.80505814 -11.27874483 -6.1129075 0 0 Z M-27.046875 16.328125 C-28.90715089 20.09944064 -29.28508972 23.10218958 -29.2421875 27.28515625 C-29.23574219 28.39697266 -29.22929687 29.50878906 -29.22265625 30.65429688 C-29.20589844 31.80478516 -29.18914063 32.95527344 -29.171875 34.140625 C-29.16285156 35.31044922 -29.15382813 36.48027344 -29.14453125 37.68554688 C-29.12101232 40.56661553 -29.08814352 43.44726489 -29.046875 46.328125 C-27.066875 46.328125 -25.086875 46.328125 -23.046875 46.328125 C-23.046875 43.028125 -23.046875 39.728125 -23.046875 36.328125 C-17.766875 36.328125 -12.486875 36.328125 -7.046875 36.328125 C-7.046875 39.628125 -7.046875 42.928125 -7.046875 46.328125 C-5.066875 46.328125 -3.086875 46.328125 -1.046875 46.328125 C-0.95940572 42.28659585 -0.90632518 38.24531195 -0.859375 34.203125 C-0.83423828 33.06101562 -0.80910156 31.91890625 -0.78320312 30.7421875 C-0.71934782 23.42011245 -1.24060683 18.76806662 -5.984375 12.953125 C-13.42277043 9.0062213 -21.62883493 9.91202491 -27.046875 16.328125 Z ",
            fill: "currentColor",
            transform: "translate(47.046875,2.671875)"
        }, null, -1), x("path", {
            d: "M0 0 C1.9375 1.5 1.9375 1.5 3 4 C3.23120142 7.04765513 3.13527848 9.93368777 3 13 C-2.28 13 -7.56 13 -13 13 C-13.36627907 4.69767442 -13.36627907 4.69767442 -11.6875 1.5 C-7.99353237 -1.78352678 -4.53412747 -1.05256531 0 0 Z ",
            fill: "currentColor",
            transform: "translate(37,20)"
        }, null, -1)]))) : t("bluetooth") ? (w(),
        R("svg", EI, s[10] || (s[10] = [x("path", {
            fill: "currentColor",
            d: "M14.88,16.29L13,18.17V14.41M13,5.83L14.88,7.71L13,9.58M17.71,7.71L12,2H11V9.58L6.41,5L5,6.41L10.59,12L5,17.58L6.41,19L11,14.41V22H12L17.71,16.29L13.41,12L17.71,7.71Z"
        }, null, -1)]))) : t("usb-port") ? (w(),
        R("svg", wI, s[11] || (s[11] = [x("path", {
            fill: "currentColor",
            d: "M8 2C6.9 2 6 2.9 6 4V12H5V16L9 20V22H15V20L19 16V12H18V4C18 2.9 17.11 2 16 2M8 4H16V12H8M9 7V9H11V7M13 7V9H15V7Z"
        }, null, -1)]))) : t("chevron-left") ? (w(),
        R("svg", TI, s[12] || (s[12] = [x("path", {
            fill: "currentColor",
            d: "M15.41,16.58L10.83,12L15.41,7.41L14,6L8,12L14,18L15.41,16.58Z"
        }, null, -1)]))) : t("chevron-right") ? (w(),
        R("svg", AI, s[13] || (s[13] = [x("path", {
            fill: "currentColor",
            d: "M8.59,16.58L13.17,12L8.59,7.41L10,6L16,12L10,18L8.59,16.58Z"
        }, null, -1)]))) : t("account") ? (w(),
        R("svg", CI, s[14] || (s[14] = [x("path", {
            fill: "currentColor",
            d: "M12,19.2C9.5,19.2 7.29,17.92 6,16C6.03,14 10,12.9 12,12.9C14,12.9 17.97,14 18,16C16.71,17.92 14.5,19.2 12,19.2M12,5A3,3 0 0,1 15,8A3,3 0 0,1 12,11A3,3 0 0,1 9,8A3,3 0 0,1 12,5M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12C22,6.47 17.5,2 12,2Z"
        }, null, -1)]))) : t("more") ? (w(),
        R("svg", MI, s[15] || (s[15] = [x("path", {
            fill: "currentColor",
            d: "M12,16A2,2 0 0,1 14,18A2,2 0 0,1 12,20A2,2 0 0,1 10,18A2,2 0 0,1 12,16M12,10A2,2 0 0,1 14,12A2,2 0 0,1 12,14A2,2 0 0,1 10,12A2,2 0 0,1 12,10M12,4A2,2 0 0,1 14,6A2,2 0 0,1 12,8A2,2 0 0,1 10,6A2,2 0 0,1 12,4Z"
        }, null, -1)]))) : t("video-box") ? (w(),
        R("svg", RI, s[16] || (s[16] = [x("path", {
            fill: "currentColor",
            d: "M18,16L14,12.8V16H6V8H14V11.2L18,8M20,4H4A2,2 0 0,0 2,6V18A2,2 0 0,0 4,20H20A2,2 0 0,0 22,18V6C22,4.89 21.1,4 20,4Z"
        }, null, -1)]))) : t("chart-timeline-sparkles") ? (w(),
        R("svg", LI, s[17] || (s[17] = [x("path", {
            fill: "currentColor",
            d: "M21 8C19.5 8 18.7 9.4 19.1 10.5L15.5 14.1C15.2 14 14.8 14 14.5 14.1L11.9 11.5C12.3 10.4 11.5 9 10 9C8.6 9 7.7 10.4 8.1 11.5L3.5 16C2.4 15.7 1 16.5 1 18C1 19.1 1.9 20 3 20C4.4 20 5.3 18.6 4.9 17.5L9.4 12.9C9.7 13 10.1 13 10.4 12.9L13 15.5C12.7 16.5 13.5 18 15 18C16.5 18 17.3 16.6 16.9 15.5L20.5 11.9C21.6 12.2 23 11.4 23 10C23 8.9 22.1 8 21 8M15 9L15.9 6.9L18 6L15.9 5.1L15 3L14.1 5.1L12 6L14.1 6.9L15 9M3.5 11L4 9L6 8.5L4 8L3.5 6L3 8L1 8.5L3 9L3.5 11Z"
        }, null, -1)]))) : t("tag-text") ? (w(),
        R("svg", II, s[18] || (s[18] = [x("path", {
            fill: "currentColor",
            d: "M21.41 11.58L12.41 2.58A2 2 0 0 0 11 2H4A2 2 0 0 0 2 4V11A2 2 0 0 0 2.59 12.41L11.59 21.41A2 2 0 0 0 13 22A2 2 0 0 0 14.41 21.41L21.41 14.41A2 2 0 0 0 22 13A2 2 0 0 0 21.41 11.58M6.5 8A1.5 1.5 0 1 1 8 6.5A1.5 1.5 0 0 1 6.5 8M11.59 15.41L7.59 11.41L9 10L13 14M15.59 14.41L10.09 8.91L11.5 7.5L17 13Z"
        }, null, -1)]))) : t("woman-face-shimmer") ? (w(),
        R("svg", kI, s[19] || (s[19] = [x("path", {
            fill: "currentColor",
            d: "M19.5 1L18.41 3.41L16 4.5L18.41 5.59L19.5 8L20.6 5.59L23 4.5L20.6 3.41L19.5 1M12 2C6.5 2 2 6.5 2 12V22H22V12C22 10.53 21.67 9.13 21.1 7.87L19.86 10.59C19.94 11.05 20 11.5 20 12C20 16.43 16.43 20 12 20C7.57 20 4 16.43 4 12C4 11.96 4 11.91 4 11.87A10 10 0 0 0 9.74 6.31A10 10 0 0 0 17.5 10A10 10 0 0 0 18.83 9.91L17.35 6.65L12.6 4.5L16.13 2.9C14.87 2.33 13.47 2 12 2M9 11.75A1.25 1.25 0 0 0 7.75 13A1.25 1.25 0 0 0 9 14.25A1.25 1.25 0 0 0 10.25 13A1.25 1.25 0 0 0 9 11.75M15 11.75A1.25 1.25 0 0 0 13.75 13A1.25 1.25 0 0 0 15 14.25A1.25 1.25 0 0 0 16.25 13A1.25 1.25 0 0 0 15 11.75Z"
        }, null, -1)]))) : t("plus") ? (w(),
        R("svg", PI, s[20] || (s[20] = [x("path", {
            fill: "currentColor",
            d: "M19,13H13V19H11V13H5V11H11V5H13V11H19V13Z"
        }, null, -1)]))) : t("speedometer") ? (w(),
        R("svg", DI, s[21] || (s[21] = [x("path", {
            fill: "currentColor",
            d: "M12,16A3,3 0 0,1 9,13C9,11.88 9.61,10.9 10.5,10.39L20.21,4.77L14.68,14.35C14.18,15.33 13.17,16 12,16M12,3C13.81,3 15.5,3.5 16.97,4.32L14.87,5.53C14,5.19 13,5 12,5A8,8 0 0,0 4,13C4,15.21 4.89,17.21 6.34,18.65H6.35C6.74,19.04 6.74,19.67 6.35,20.06C5.96,20.45 5.32,20.45 4.93,20.07V20.07C3.12,18.26 2,15.76 2,13A10,10 0 0,1 12,3M22,13C22,15.76 20.88,18.26 19.07,20.07V20.07C18.68,20.45 18.05,20.45 17.66,20.06C17.27,19.67 17.27,19.04 17.66,18.65V18.65C19.11,17.2 20,15.21 20,13C20,12 19.81,11 19.46,10.1L20.67,8C21.5,9.5 22,11.18 22,13Z"
        }, null, -1)]))) : t("heart") ? (w(),
        R("svg", FI, s[22] || (s[22] = [x("path", {
            fill: "currentColor",
            d: "M12,21.35L10.55,20.03C5.4,15.36 2,12.27 2,8.5C2,5.41 4.42,3 7.5,3C9.24,3 10.91,3.81 12,5.08C13.09,3.81 14.76,3 16.5,3C19.58,3 22,5.41 22,8.5C22,12.27 18.6,15.36 13.45,20.03L12,21.35Z"
        }, null, -1)]))) : t("eye") ? (w(),
        R("svg", OI, s[23] || (s[23] = [x("path", {
            fill: "currentColor",
            d: "M12,9A3,3 0 0,1 15,12A3,3 0 0,1 12,15A3,3 0 0,1 9,12A3,3 0 0,1 12,9M12,4.5C17,4.5 21.27,7.61 23,12C21.27,16.39 17,19.5 12,19.5C7,19.5 2.73,16.39 1,12C2.73,7.61 7,4.5 12,4.5M3.18,12C4.83,15.36 8.24,17.5 12,17.5C15.76,17.5 19.17,15.36 20.82,12C19.17,8.64 15.76,6.5 12,6.5C8.24,6.5 4.83,8.64 3.18,12Z"
        }, null, -1)]))) : t("pencil") ? (w(),
        R("svg", UI, s[24] || (s[24] = [x("path", {
            fill: "currentColor",
            d: "M20.71,7.04C21.1,6.65 21.1,6 20.71,5.63L18.37,3.29C18,2.9 17.35,2.9 16.96,3.29L15.12,5.12L18.87,8.87M3,17.25V21H6.75L17.81,9.93L14.06,6.18L3,17.25Z"
        }, null, -1)]))) : t("notification") ? (w(),
        R("svg", NI, s[25] || (s[25] = [x("path", {
            fill: "currentColor",
            d: "M21,19V20H3V19L5,17V11C5,7.9 7.03,5.17 10,4.29C10,4.19 10,4.1 10,4A2,2 0 0,1 12,2A2,2 0 0,1 14,4C14,4.1 14,4.19 14,4.29C16.97,5.17 19,7.9 19,11V17L21,19M14,21A2,2 0 0,1 12,23A2,2 0 0,1 10,21"
        }, null, -1)]))) : t("bell") ? (w(),
        R("svg", BI, s[26] || (s[26] = [x("path", {
            fill: "currentColor",
            d: "M10 21H14C14 22.1 13.1 23 12 23S10 22.1 10 21M21 19V20H3V19L5 17V11C5 7.9 7 5.2 10 4.3V4C10 2.9 10.9 2 12 2S14 2.9 14 4V4.3C17 5.2 19 7.9 19 11V17L21 19M17 11C17 8.2 14.8 6 12 6S7 8.2 7 11V18H17V11Z"
        }, null, -1)]))) : t("chevron-left") ? (w(),
        R("svg", VI, s[27] || (s[27] = [x("path", {
            fill: "currentColor",
            d: "M15.41,16.58L10.83,12L15.41,7.41L14,6L8,12L14,18L15.41,16.58Z"
        }, null, -1)]))) : t("play") ? (w(),
        R("svg", $I, s[28] || (s[28] = [x("path", {
            fill: "currentColor",
            d: "M8,5.14V19.14L19,12.14L8,5.14Z"
        }, null, -1)]))) : t("volume-high") ? (w(),
        R("svg", HI, s[29] || (s[29] = [x("path", {
            fill: "currentColor",
            d: "M14,3.23V5.29C16.89,6.15 19,8.83 19,12C19,15.17 16.89,17.84 14,18.7V20.77C18,19.86 21,16.28 21,12C21,7.72 18,4.14 14,3.23M16.5,12C16.5,10.23 15.5,8.71 14,7.97V16C15.5,15.29 16.5,13.76 16.5,12M3,9V15H7L12,20V4L7,9H3Z"
        }, null, -1)]))) : t("arrow-expand") ? (w(),
        R("svg", zI, s[30] || (s[30] = [x("path", {
            fill: "currentColor",
            d: "M10,21V19H6.41L10.91,14.5L9.5,13.09L5,17.59V14H3V21H10M14.5,10.91L19,6.41V10H21V3H14V5H17.59L13.09,9.5L14.5,10.91Z"
        }, null, -1)]))) : t("quality-high") ? (w(),
        R("svg", GI, s[31] || (s[31] = [x("path", {
            fill: "currentColor",
            d: "M14.5,13.5H16.5V10.5H14.5M18,14A1,1 0 0,1 17,15H16.25V16.5H14.75V15H14A1,1 0 0,1 13,14V10A1,1 0 0,1 14,9H17A1,1 0 0,1 18,10M11,15H9.5V13H7.5V15H6V9H7.5V11.5H9.5V9H11M19,4H5C3.89,4 3,4.89 3,6V18A2,2 0 0,0 5,20H19A2,2 0 0,0 21,18V6C21,4.89 20.1,4 19,4Z"
        }, null, -1)]))) : t("pause") ? (w(),
        R("svg", WI, s[32] || (s[32] = [x("path", {
            fill: "currentColor",
            d: "M14,19H18V5H14M6,19H10V5H6V19Z"
        }, null, -1)]))) : t("arrow-collapse") ? (w(),
        R("svg", qI, s[33] || (s[33] = [x("path", {
            fill: "currentColor",
            d: "M19.5,3.09L15,7.59V4H13V11H20V9H16.41L20.91,4.5L19.5,3.09M4,13V15H7.59L3.09,19.5L4.5,20.91L9,16.41V20H11V13H4Z"
        }, null, -1)]))) : t("logout") ? (w(),
        R("svg", jI, s[34] || (s[34] = [x("path", {
            fill: "currentColor",
            d: "M14.08,15.59L16.67,13H7V11H16.67L14.08,8.41L15.5,7L20.5,12L15.5,17L14.08,15.59M19,3A2,2 0 0,1 21,5V9.67L19,7.67V5H5V19H19V16.33L21,14.33V19A2,2 0 0,1 19,21H5C3.89,21 3,20.1 3,19V5C3,3.89 3.89,3 5,3H19Z"
        }, null, -1)]))) : t("eye-outline") ? (w(),
        R("svg", KI, s[35] || (s[35] = [x("path", {
            fill: "currentColor",
            d: "M12,9A3,3 0 0,1 15,12A3,3 0 0,1 12,15A3,3 0 0,1 9,12A3,3 0 0,1 12,9M12,4.5C17,4.5 21.27,7.61 23,12C21.27,16.39 17,19.5 12,19.5C7,19.5 2.73,16.39 1,12C2.73,7.61 7,4.5 12,4.5M3.18,12C4.83,15.36 8.24,17.5 12,17.5C15.76,17.5 19.17,15.36 20.82,12C19.17,8.64 15.76,6.5 12,6.5C8.24,6.5 4.83,8.64 3.18,12Z"
        }, null, -1)]))) : t("home") ? (w(),
        R("svg", XI, s[36] || (s[36] = [x("path", {
            fill: "currentColor",
            d: "M10,20V14H14V20H19V12H22L12,3L2,12H5V20H10Z"
        }, null, -1)]))) : t("star") ? (w(),
        R("svg", YI, s[37] || (s[37] = [x("path", {
            fill: "currentColor",
            d: "M12,17.27L18.18,21L16.54,13.97L22,9.24L14.81,8.62L12,2L9.19,8.62L2,9.24L7.45,13.97L5.82,21L12,17.27Z"
        }, null, -1)]))) : t("account-group") ? (w(),
        R("svg", ZI, s[38] || (s[38] = [x("path", {
            fill: "currentColor",
            d: "M12,5.5A3.5,3.5 0 0,1 15.5,9A3.5,3.5 0 0,1 12,12.5A3.5,3.5 0 0,1 8.5,9A3.5,3.5 0 0,1 12,5.5M5,8C5.56,8 6.08,8.15 6.53,8.42C6.38,9.85 6.8,11.27 7.66,12.38C7.16,13.34 6.16,14 5,14A3,3 0 0,1 2,11A3,3 0 0,1 5,8M19,8A3,3 0 0,1 22,11A3,3 0 0,1 19,14C17.84,14 16.84,13.34 16.34,12.38C17.2,11.27 17.62,9.85 17.47,8.42C17.92,8.15 18.44,8 19,8M5.5,18.25C5.5,16.18 8.41,14.5 12,14.5C15.59,14.5 18.5,16.18 18.5,18.25V20H5.5V18.25M0,20V18.5C0,17.11 1.89,15.94 4.45,15.6C3.86,16.28 3.5,17.22 3.5,18.25V20H0M24,20H20.5V18.25C20.5,17.22 20.14,16.28 19.55,15.6C22.11,15.94 24,17.11 24,18.5V20Z"
        }, null, -1)]))) : t("link") ? (w(),
        R("svg", JI, s[39] || (s[39] = [x("path", {
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            d: "M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1"
        }, null, -1)]))) : t("warning") ? (w(),
        R("svg", QI, s[40] || (s[40] = [x("path", {
            fill: "currentColor",
            d: "M13 14H11V9H13M13 18H11V16H13M1 21H23L12 2L1 21Z"
        }, null, -1)]))) : t("television-play") ? (w(),
        R("svg", ek, s[41] || (s[41] = [x("path", {
            fill: "currentColor",
            d: "M21,3H3C1.89,3 1,3.89 1,5V17A2,2 0 0,0 3,19H8V21H16V19H21A2,2 0 0,0 23,17V5C23,3.89 22.1,3 21,3M21,17H3V5H21M16,11L9,15V7"
        }, null, -1)]))) : t("shape") ? (w(),
        R("svg", tk, s[42] || (s[42] = [x("path", {
            fill: "currentColor",
            d: "M11,13.5V21.5H3V13.5H11M12,2L17.5,11H6.5L12,2M17.5,13C20,13 22,15 22,17.5C22,20 20,22 17.5,22C15,22 13,20 13,17.5C13,15 15,13 17.5,13Z"
        }, null, -1)]))) : t("fast-forward") ? (w(),
        R("svg", nk, s[43] || (s[43] = [x("path", {
            fill: "currentColor",
            d: "M13,6V18L21.5,12M4,18L12.5,12L4,6V18Z"
        }, null, -1)]))) : t("shimmer") ? (w(),
        R("svg", ik, s[44] || (s[44] = [x("path", {
            fill: "currentColor",
            d: "M10.6 9.6L9 15L7.4 9.6L2 8L7.4 6.4L9 1L10.6 6.4L16 8L10.6 9.6M17 14.2L21 12L18.8 16L21 20L17 17.8L13 20L15.2 16L13 12L17 14.2M10 16L8.3 19L10 22L7 20.3L4 22L5.7 19L4 16L7 17.7L10 16"
        }, null, -1)]))) : t("open-in-new") ? (w(),
        R("svg", sk, s[45] || (s[45] = [x("path", {
            fill: "currentColor",
            d: "M14,3V5H17.59L7.76,14.83L9.17,16.24L19,6.41V10H21V3M19,19H5V5H12V3H5C3.89,3 3,3.9 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V12H19V19Z"
        }, null, -1)]))) : t("comment-text-multiple") ? (w(),
        R("svg", rk, s[46] || (s[46] = [x("path", {
            fill: "currentColor",
            d: "M3,15H1V3A2,2 0 0,1 3,1H19V3H3V15M12,23A1,1 0 0,1 11,22V19H7A2,2 0 0,1 5,17V7A2,2 0 0,1 7,5H21A2,2 0 0,1 23,7V17A2,2 0 0,1 21,19H16.9L13.2,22.71C13,22.89 12.76,23 12.5,23H12M9,9V11H19V9H9M9,13V15H17V13H9Z"
        }, null, -1)]))) : t("playbox-multiple-outline") ? (w(),
        R("svg", ok, s[47] || (s[47] = [x("path", {
            fill: "currentColor",
            d: "M4 6H2V20C2 21.1 2.9 22 4 22H18V20H4V6M20 4V16H8V4H20M20 2H8C6.9 2 6 2.9 6 4V16C6 17.1 6.9 18 8 18H20C21.1 18 22 17.1 22 16V4C22 2.9 21.1 2 20 2M12 14.5V5.5L18 10L12 14.5Z"
        }, null, -1)]))) : t("explore") ? (w(),
        R("svg", ak, s[48] || (s[48] = [x("path", {
            fill: "currentColor",
            d: "M14.19,14.19L6,18L9.81,9.81L18,6M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M12,10.9A1.1,1.1 0 0,0 10.9,12A1.1,1.1 0 0,0 12,13.1A1.1,1.1 0 0,0 13.1,12A1.1,1.1 0 0,0 12,10.9Z"
        }, null, -1)]))) : t("video-plus") ? (w(),
        R("svg", lk, s[49] || (s[49] = [x("path", {
            fill: "currentColor",
            d: "M17,10.5V7A1,1 0 0,0 16,6H4A1,1 0 0,0 3,7V17A1,1 0 0,0 4,18H16A1,1 0 0,0 17,17V13.5L21,17.5V6.5L17,10.5M14,13H11V16H9V13H6V11H9V8H11V11H14V13Z"
        }, null, -1)]))) : t("sort") ? (w(),
        R("svg", ck, s[50] || (s[50] = [x("path", {
            fill: "currentColor",
            d: "M18 21L14 17H17V7H14L18 3L22 7H19V17H22M2 19V17H12V19M2 13V11H9V13M2 7V5H6V7H2Z"
        }, null, -1)]))) : t("faptap") ? (w(),
        R("svg", uk, s[51] || (s[51] = [pa('<mask id="mask0_2_58" style="mask-type:alpha;" maskUnits="userSpaceOnUse" x="0" y="0" width="240" height="240"><path fill-rule="evenodd" clip-rule="evenodd" d="M240 0H0V240H240V0ZM132.762 49.0014C123.177 48.9181 113.943 52.6027 107.049 59.2616C107.011 59.2978 106.974 59.3343 106.937 59.3712L99.3595 66.949C95.8448 70.4637 95.8448 76.1622 99.3595 79.6769C102.874 83.1916 108.573 83.1916 112.087 79.6769L119.604 72.16C123.099 68.8107 127.764 66.9586 132.606 67.0007C137.471 67.043 142.125 68.9944 145.565 72.4348C149.006 75.8752 150.957 80.5291 150.999 85.3943C151.041 90.2359 149.189 94.9012 145.84 98.3953L118.346 125.889L118.345 125.89C114.866 129.368 110.147 131.322 105.227 131.322C100.307 131.322 95.5884 129.368 92.1087 125.889C88.5935 122.375 82.895 122.376 79.3808 125.891C75.8666 129.407 75.8675 135.105 79.3827 138.619C86.2379 145.472 95.5343 149.322 105.227 149.322C114.921 149.322 124.217 145.472 131.072 138.619L131.073 138.618L158.629 111.063C158.666 111.026 158.702 110.989 158.738 110.951C165.397 104.057 169.082 94.8227 168.999 85.2379C168.915 75.6532 165.071 66.4846 158.293 59.7069C151.515 52.9292 142.347 49.0847 132.762 49.0014ZM91.4497 90.0006C81.7565 90.0006 72.4601 93.8505 65.6049 100.704L65.604 100.705L38.0999 128.209C34.6366 131.569 31.8727 135.582 29.9678 140.016C28.052 144.476 27.0436 149.273 27.0014 154.127C26.9592 158.981 27.8841 163.794 29.7222 168.287C31.5602 172.779 34.2746 176.861 37.7069 180.293C41.1392 183.725 45.2207 186.44 49.7132 188.278C54.2058 190.116 59.0194 191.041 63.8732 190.999C68.727 190.956 73.5238 189.948 77.9838 188.032C82.4175 186.128 86.4299 183.364 89.79 179.902L97.3286 172.37C100.845 168.857 100.847 163.158 97.3344 159.642C93.8212 156.126 88.1227 156.123 84.6064 159.636L77.0149 167.221C76.977 167.259 76.9395 167.297 76.9023 167.335C75.1907 169.107 73.1431 170.521 70.8793 171.494C68.6154 172.466 66.1806 172.978 63.7168 172.999C61.253 173.021 58.8096 172.551 56.5292 171.618C54.2488 170.685 52.177 169.307 50.4348 167.565C48.6926 165.823 47.3148 163.751 46.3818 161.471C45.4488 159.19 44.9793 156.747 45.0007 154.283C45.0221 151.819 45.534 149.385 46.5065 147.121C47.4789 144.857 48.8925 142.809 50.6648 141.098C50.7023 141.061 50.7395 141.025 50.7763 140.988L78.3309 113.433L78.3319 113.432C81.8115 109.954 86.5299 108.001 91.4497 108.001C96.37 108.001 101.089 109.955 104.568 113.433C108.084 116.948 113.782 116.947 117.296 113.432C120.811 109.916 120.81 104.218 117.294 100.704C110.439 93.8505 101.143 90.0006 91.4497 90.0006Z" fill="#FF0000"></path></mask><g mask="url(#mask0_2_58)"><path d="M0 65C0 29.1015 29.1015 0 65 0H175C210.899 0 240 29.1015 240 65V175C240 210.899 210.899 240 175 240H65C29.1015 240 0 210.899 0 175V65Z" fill="white" fill-opacity="0.6"></path><path d="M0 65C0 29.1015 29.1015 0 65 0H131C166.899 0 196 29.1015 196 65V175C196 210.899 166.899 240 131 240H65C29.1015 240 0 210.899 0 175V65Z" fill="white"></path></g>', 2)]))) : t("home-outline") ? (w(),
        R("svg", dk, s[52] || (s[52] = [x("path", {
            fill: "currentColor",
            d: "M12 5.69L17 10.19V18H15V12H9V18H7V10.19L12 5.69M12 3L2 12H5V20H11V14H13V20H19V12H22"
        }, null, -1)]))) : t("account-group-outline") ? (w(),
        R("svg", fk, s[53] || (s[53] = [x("path", {
            fill: "currentColor",
            d: "M12,5A3.5,3.5 0 0,0 8.5,8.5A3.5,3.5 0 0,0 12,12A3.5,3.5 0 0,0 15.5,8.5A3.5,3.5 0 0,0 12,5M12,7A1.5,1.5 0 0,1 13.5,8.5A1.5,1.5 0 0,1 12,10A1.5,1.5 0 0,1 10.5,8.5A1.5,1.5 0 0,1 12,7M5.5,8A2.5,2.5 0 0,0 3,10.5C3,11.44 3.53,12.25 4.29,12.68C4.65,12.88 5.06,13 5.5,13C5.94,13 6.35,12.88 6.71,12.68C7.08,12.47 7.39,12.17 7.62,11.81C6.89,10.86 6.5,9.7 6.5,8.5C6.5,8.41 6.5,8.31 6.5,8.22C6.2,8.08 5.86,8 5.5,8M18.5,8C18.14,8 17.8,8.08 17.5,8.22C17.5,8.31 17.5,8.41 17.5,8.5C17.5,9.7 17.11,10.86 16.38,11.81C16.5,12 16.63,12.15 16.78,12.3C16.94,12.45 17.1,12.58 17.29,12.68C17.65,12.88 18.06,13 18.5,13C18.94,13 19.35,12.88 19.71,12.68C20.47,12.25 21,11.44 21,10.5A2.5,2.5 0 0,0 18.5,8M12,14C9.66,14 5,15.17 5,17.5V19H19V17.5C19,15.17 14.34,14 12,14M4.71,14.55C2.78,14.78 0,15.76 0,17.5V19H3V17.07C3,16.06 3.69,15.22 4.71,14.55M19.29,14.55C20.31,15.22 21,16.06 21,17.07V19H24V17.5C24,15.76 21.22,14.78 19.29,14.55M12,16C13.53,16 15.24,16.5 16.23,17H7.77C8.76,16.5 10.47,16 12,16Z"
        }, null, -1)]))) : t("explore-outline") ? (w(),
        R("svg", hk, s[54] || (s[54] = [x("path", {
            fill: "currentColor",
            d: "M7,17L10.2,10.2L17,7L13.8,13.8L7,17M12,11.1A0.9,0.9 0 0,0 11.1,12A0.9,0.9 0 0,0 12,12.9A0.9,0.9 0 0,0 12.9,12A0.9,0.9 0 0,0 12,11.1M12,2A10,10 0 0,1 22,12A10,10 0 0,1 12,22A10,10 0 0,1 2,12A10,10 0 0,1 12,2M12,4A8,8 0 0,0 4,12A8,8 0 0,0 12,20A8,8 0 0,0 20,12A8,8 0 0,0 12,4Z"
        }, null, -1)]))) : t("shape-outline") ? (w(),
        R("svg", pk, s[55] || (s[55] = [x("path", {
            fill: "currentColor",
            d: "M11,13.5V21.5H3V13.5H11M9,15.5H5V19.5H9V15.5M12,2L17.5,11H6.5L12,2M12,5.86L10.08,9H13.92L12,5.86M17.5,13C20,13 22,15 22,17.5C22,20 20,22 17.5,22C15,22 13,20 13,17.5C13,15 15,13 17.5,13M17.5,15A2.5,2.5 0 0,0 15,17.5A2.5,2.5 0 0,0 17.5,20A2.5,2.5 0 0,0 20,17.5A2.5,2.5 0 0,0 17.5,15Z"
        }, null, -1)]))) : t("woman-face-shimmer-outline") ? (w(),
        R("svg", mk, s[56] || (s[56] = [x("path", {
            fill: "currentColor",
            d: "M19.5 1L18.41 3.41L16 4.5L18.41 5.59L19.5 8L20.6 5.59L23 4.5L20.6 3.41M12 2C6.5 2 2 6.5 2 12V22H22V12C22 10.53 21.67 9.13 21.1 7.87L19.86 10.57C19.95 11.04 20 11.5 20 12C20 16.43 16.43 20 12 20C7.57 20 4 16.43 4 12C4 11.95 4 11.91 4 11.86C6.61 10.89 8.69 8.88 9.74 6.31C11.61 8.61 14.44 10 17.5 10C17.94 10 18.39 9.97 18.83 9.91L17.96 8C17.81 8 17.65 8 17.5 8C14.68 8 12.1 6.5 10.66 4.12C11.1 4.05 11.54 4 12 4C12.5 4 12.96 4.05 13.42 4.13L16.13 2.91C14.87 2.33 13.47 2 12 2M8.09 5C7.46 6.91 6.15 8.5 4.41 9.5C5.04 7.57 6.37 6 8.09 5M9 11.75C8.31 11.75 7.75 12.31 7.75 13C7.75 13.69 8.31 14.25 9 14.25C9.69 14.25 10.25 13.69 10.25 13C10.25 12.31 9.69 11.75 9 11.75M15 11.75C14.31 11.75 13.75 12.31 13.75 13C13.75 13.69 14.31 14.25 15 14.25C15.69 14.25 16.25 13.69 16.25 13C16.25 12.31 15.69 11.75 15 11.75M4 17.97C4.58 18.74 5.26 19.42 6.03 20H4M20 17.97V20H17.97C18.74 19.42 19.42 18.74 20 17.97Z"
        }, null, -1)]))) : t("person") ? (w(),
        R("svg", gk, s[57] || (s[57] = [x("path", {
            fill: "currentColor",
            d: "M12,4A4,4 0 0,1 16,8A4,4 0 0,1 12,12A4,4 0 0,1 8,8A4,4 0 0,1 12,4M12,14C16.42,14 20,15.79 20,18V20H4V18C4,15.79 7.58,14 12,14Z"
        }, null, -1)]))) : t("pound") ? (w(),
        R("svg", vk, s[58] || (s[58] = [x("path", {
            fill: "currentColor",
            d: "M5.41,21L6.12,17H2.12L2.47,15H6.47L7.53,9H3.53L3.88,7H7.88L8.59,3H10.59L9.88,7H15.88L16.59,3H18.59L17.88,7H21.88L21.53,9H17.53L16.47,15H20.47L20.12,17H16.12L15.41,21H13.41L14.12,17H8.12L7.41,21H5.41M9.53,9L8.47,15H14.47L15.53,9H9.53Z"
        }, null, -1)]))) : t("motion-play-outline") ? (w(),
        R("svg", _k, s[59] || (s[59] = [x("path", {
            fill: "currentColor",
            d: "M10 16.5L16 12L10 7.5M22 12C22 6.46 17.54 2 12 2C10.83 2 9.7 2.19 8.62 2.56L9.32 4.5C10.17 4.16 11.06 3.97 12 3.97C16.41 3.97 20.03 7.59 20.03 12C20.03 16.41 16.41 20.03 12 20.03C7.59 20.03 3.97 16.41 3.97 12C3.97 11.06 4.16 10.12 4.5 9.28L2.56 8.62C2.19 9.7 2 10.83 2 12C2 17.54 6.46 22 12 22C17.54 22 22 17.54 22 12M5.47 3.97C6.32 3.97 7 4.68 7 5.47C7 6.32 6.32 7 5.47 7C4.68 7 3.97 6.32 3.97 5.47C3.97 4.68 4.68 3.97 5.47 3.97Z"
        }, null, -1)]))) : t("motion-play") ? (w(),
        R("svg", xk, s[60] || (s[60] = [x("path", {
            fill: "currentColor",
            d: "M22 12C22 6.46 17.54 2 12 2C10.83 2 9.7 2.19 8.62 2.56L9.32 4.5C10.17 4.16 11.06 3.97 12 3.97C16.41 3.97 20.03 7.59 20.03 12C20.03 16.41 16.41 20.03 12 20.03C7.59 20.03 3.97 16.41 3.97 12C3.97 11.06 4.16 10.12 4.5 9.28L2.56 8.62C2.19 9.7 2 10.83 2 12C2 17.54 6.46 22 12 22C17.54 22 22 17.54 22 12M5.47 3.97C6.32 3.97 7 4.68 7 5.47C7 6.32 6.32 7 5.47 7C4.68 7 3.97 6.32 3.97 5.47C3.97 4.68 4.68 3.97 5.47 3.97M18 12C18 8.67 15.33 6 12 6C8.67 6 6 8.67 6 12C6 15.33 8.67 18 12 18C15.33 18 18 15.33 18 12M15 12L10 15V9"
        }, null, -1)]))) : t("sort-ascending") ? (w(),
        R("svg", yk, s[61] || (s[61] = [x("path", {
            fill: "currentColor",
            d: "M19 17H22L18 21L14 17H17V3H19M2 17H12V19H2M6 5V7H2V5M2 11H9V13H2V11Z"
        }, null, -1)]))) : t("sort-descending") ? (w(),
        R("svg", bk, s[62] || (s[62] = [x("path", {
            fill: "currentColor",
            d: "M19 7H22L18 3L14 7H17V21H19M2 17H12V19H2M6 5V7H2V5M2 11H9V13H2V11Z"
        }, null, -1)]))) : t("help-outline") ? (w(),
        R("svg", Sk, s[63] || (s[63] = [x("path", {
            fill: "currentColor",
            d: "M11,18H13V16H11V18M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20,12C20,16.41 16.41,20 12,20M12,6A4,4 0 0,0 8,10H10A2,2 0 0,1 12,8A2,2 0 0,1 14,10C14,12 11,11.75 11,15H13C13,12.75 16,12.5 16,10A4,4 0 0,0 12,6Z"
        }, null, -1)]))) : t("help") ? (w(),
        R("svg", Ek, s[64] || (s[64] = [x("path", {
            fill: "currentColor",
            d: "M15.07,11.25L14.17,12.17C13.45,12.89 13,13.5 13,15H11V14.5C11,13.39 11.45,12.39 12.17,11.67L13.41,10.41C13.78,10.05 14,9.55 14,9C14,7.89 13.1,7 12,7A2,2 0 0,0 10,9H8A4,4 0 0,1 12,5A4,4 0 0,1 16,9C16,9.88 15.64,10.67 15.07,11.25M13,19H11V17H13M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12C22,6.47 17.5,2 12,2Z"
        }, null, -1)]))) : t("download") ? (w(),
        R("svg", wk, s[65] || (s[65] = [x("path", {
            fill: "currentColor",
            d: "M5,20H19V18H5M19,9H15V3H9V9H5L12,16L19,9Z"
        }, null, -1)]))) : t("burger") ? (w(),
        R("svg", Tk, s[66] || (s[66] = [x("path", {
            fill: "currentColor",
            d: "M3,6H21V8H3V6M3,11H21V13H3V11M3,16H21V18H3V16Z"
        }, null, -1)]))) : t("danger") ? (w(),
        R("svg", Ak, s[67] || (s[67] = [x("path", {
            fill: "currentColor",
            d: "M13 14H11V9H13M13 18H11V16H13M1 21H23L12 2L1 21Z"
        }, null, -1)]))) : t("chart-gantt") ? (w(),
        R("svg", Ck, s[68] || (s[68] = [x("path", {
            fill: "currentColor",
            d: "M2,5H10V2H12V22H10V18H6V15H10V13H4V10H10V8H2V5M14,5H17V8H14V5M14,10H19V13H14V10M14,15H22V18H14V15Z"
        }, null, -1)]))) : t("forum-outline") ? (w(),
        R("svg", Mk, s[69] || (s[69] = [x("path", {
            fill: "currentColor",
            d: "M15,4V11H5.17L4,12.17V4H15M16,2H3A1,1 0 0,0 2,3V17L6,13H16A1,1 0 0,0 17,12V3A1,1 0 0,0 16,2M21,6H19V15H6V17A1,1 0 0,0 7,18H18L22,22V7A1,1 0 0,0 21,6Z"
        }, null, -1)]))) : t("unfold") ? (w(),
        R("svg", Rk, s[70] || (s[70] = [x("path", {
            fill: "currentColor",
            d: "M12,18.17L8.83,15L7.42,16.41L12,21L16.59,16.41L15.17,15M12,5.83L15.17,9L16.58,7.59L12,3L7.41,7.59L8.83,9L12,5.83Z"
        }, null, -1)]))) : t("chevron-down") ? (w(),
        R("svg", Lk, s[71] || (s[71] = [x("path", {
            fill: "currentColor",
            d: "M7.41,8.58L12,13.17L16.59,8.58L18,10L12,16L6,10L7.41,8.58Z"
        }, null, -1)]))) : t("playbox-multiple-outline") ? (w(),
        R("svg", Ik, s[72] || (s[72] = [x("path", {
            fill: "currentColor",
            d: "M4 6H2V20C2 21.1 2.9 22 4 22H18V20H4V6M20 4V16H8V4H20M20 2H8C6.9 2 6 2.9 6 4V16C6 17.1 6.9 18 8 18H20C21.1 18 22 17.1 22 16V4C22 2.9 21.1 2 20 2M12 14.5V5.5L18 10L12 14.5Z"
        }, null, -1)]))) : t("heart-multiple-outline") ? (w(),
        R("svg", kk, s[73] || (s[73] = [x("path", {
            fill: "currentColor",
            d: "M12,21.1L10.5,22.4C3.9,16.5 0.5,13.4 0.5,9.6C0.5,8.4 0.9,7.3 1.5,6.4C1.5,6.6 1.5,6.8 1.5,7C1.5,11.7 5.4,15.2 12,21.1M13.6,17C18.3,12.7 21.5,9.9 21.6,7C21.6,5 20.1,3.5 18.1,3.5C16.5,3.5 15,4.5 14.5,5.9H12.6C12,4.5 10.5,3.5 9,3.5C7,3.5 5.5,5 5.5,7C5.5,9.9 8.6,12.7 13.4,17L13.5,17.1M18,1.5C21.1,1.5 23.5,3.9 23.5,7C23.5,10.7 20.1,13.8 13.5,19.8C6.9,13.9 3.5,10.8 3.5,7C3.5,3.9 5.9,1.5 9,1.5C10.7,1.5 12.4,2.3 13.5,3.6C14.6,2.3 16.3,1.5 18,1.5Z"
        }, null, -1)]))) : t("animation-play-outline") ? (w(),
        R("svg", Pk, s[74] || (s[74] = [x("path", {
            fill: "currentColor",
            d: "M20,8H4V6H20V8M18,2H6V4H18V2M22,12V20A2,2 0 0,1 20,22H4A2,2 0 0,1 2,20V12A2,2 0 0,1 4,10H20A2,2 0 0,1 22,12M16,16L10,12.73V19.26L16,16Z"
        }, null, -1)]))) : t("lock-reset") ? (w(),
        R("svg", Dk, s[75] || (s[75] = [x("path", {
            fill: "currentColor",
            d: "M12.63,2C18.16,2 22.64,6.5 22.64,12C22.64,17.5 18.16,22 12.63,22C9.12,22 6.05,20.18 4.26,17.43L5.84,16.18C7.25,18.47 9.76,20 12.64,20A8,8 0 0,0 20.64,12A8,8 0 0,0 12.64,4C8.56,4 5.2,7.06 4.71,11H7.47L3.73,14.73L0,11H2.69C3.19,5.95 7.45,2 12.63,2M15.59,10.24C16.09,10.25 16.5,10.65 16.5,11.16V15.77C16.5,16.27 16.09,16.69 15.58,16.69H10.05C9.54,16.69 9.13,16.27 9.13,15.77V11.16C9.13,10.65 9.54,10.25 10.04,10.24V9.23C10.04,7.7 11.29,6.46 12.81,6.46C14.34,6.46 15.59,7.7 15.59,9.23V10.24M12.81,7.86C12.06,7.86 11.44,8.47 11.44,9.23V10.24H14.19V9.23C14.19,8.47 13.57,7.86 12.81,7.86Z"
        }, null, -1)]))) : t("smiley") ? (w(),
        R("svg", Fk, s[76] || (s[76] = [x("path", {
            fill: "currentColor",
            d: "M20,12A8,8 0 0,0 12,4A8,8 0 0,0 4,12A8,8 0 0,0 12,20A8,8 0 0,0 20,12M22,12A10,10 0 0,1 12,22A10,10 0 0,1 2,12A10,10 0 0,1 12,2A10,10 0 0,1 22,12M10,9.5C10,10.3 9.3,11 8.5,11C7.7,11 7,10.3 7,9.5C7,8.7 7.7,8 8.5,8C9.3,8 10,8.7 10,9.5M17,9.5C17,10.3 16.3,11 15.5,11C14.7,11 14,10.3 14,9.5C14,8.7 14.7,8 15.5,8C16.3,8 17,8.7 17,9.5M12,17.23C10.25,17.23 8.71,16.5 7.81,15.42L9.23,14C9.68,14.72 10.75,15.23 12,15.23C13.25,15.23 14.32,14.72 14.77,14L16.19,15.42C15.29,16.5 13.75,17.23 12,17.23Z"
        }, null, -1)]))) : t("view-grid-outline") ? (w(),
        R("svg", Ok, s[77] || (s[77] = [x("path", {
            fill: "currentColor",
            d: "M3 11H11V3H3M5 5H9V9H5M13 21H21V13H13M15 15H19V19H15M3 21H11V13H3M5 15H9V19H5M13 3V11H21V3M19 9H15V5H19Z"
        }, null, -1)]))) : t("discord") ? (w(),
        R("svg", Uk, s[78] || (s[78] = [x("mask", {
            id: "a",
            style: {
                "mask-type": "alpha"
            },
            maskUnits: "userSpaceOnUse",
            x: "1",
            y: "4",
            width: "22",
            height: "17"
        }, [x("path", {
            d: "M23 4H1v17h22V4z",
            fill: "currentColor"
        })], -1), x("g", {
            mask: "url(#a)"
        }, [x("path", {
            d: "M19.624 5.514a18.174 18.174 0 00-4.478-1.386.068.068 0 00-.072.034c-.194.343-.408.791-.558 1.143a16.79 16.79 0 00-5.03 0c-.15-.36-.371-.8-.565-1.143a.07.07 0 00-.072-.034c-1.572.27-3.075.743-4.478 1.386a.064.064 0 00-.03.025C1.49 9.79.708 13.935 1.091 18.03c.002.02.013.04.029.051a18.26 18.26 0 005.493 2.77.071.071 0 00.077-.025c.423-.576.8-1.184 1.124-1.823a.07.07 0 00-.038-.097 12.024 12.024 0 01-1.716-.816.07.07 0 01-.007-.117c.115-.086.23-.175.34-.266a.068.068 0 01.072-.01c3.6 1.64 7.498 1.64 11.056 0a.068.068 0 01.072.009c.11.09.226.181.342.267a.07.07 0 01-.006.117c-.548.32-1.118.59-1.717.815a.07.07 0 00-.038.098c.33.638.708 1.246 1.123 1.822a.07.07 0 00.078.026 18.2 18.2 0 005.502-2.77.07.07 0 00.028-.05c.459-4.734-.768-8.846-3.253-12.491a.055.055 0 00-.028-.026zM8.352 15.537c-1.084 0-1.977-.993-1.977-2.212 0-1.22.875-2.212 1.977-2.212 1.11 0 1.994 1.002 1.977 2.212 0 1.22-.876 2.212-1.977 2.212zm7.31 0c-1.084 0-1.977-.993-1.977-2.212 0-1.22.876-2.212 1.977-2.212 1.11 0 1.994 1.002 1.977 2.212 0 1.22-.867 2.212-1.977 2.212z",
            fill: "currentColor"
        })], -1)]))) : t("profile") ? (w(),
        R("svg", Nk, s[79] || (s[79] = [x("path", {
            fill: "currentColor",
            "fill-rule": "evenodd",
            d: "M25.77 8.53s-1.8-.08-2.65-.34c.77-.78.77-2.24.77-2.24s-1.89.77-4.55.77c-1.88-.08-2.57-.34-3.94 1.04-1.63 1.64-1.63 2.07-2.66 2.07.86 1.2.43 2.4.43 2.4l-.08 1.82.08.34s0 .09.09.26c0 .09 0 .26.09.35l.25 1.37s-.08.1-.17 0c-.26-.34-.6-.51-1.03-.51-.26 0-.68.69-.34 1.63.26.7.51 1.12.77 2.07.26.95.77 1.64 1.03 1.47.09-.09.17-.35.26-.78 0-.08.08 0 .17.09.08.86.26 1.63.43 2.07.17.25.34.6.51.86-.17 1.46-.34 3.27-.68 4.65-2.14.58-5.36 1.53-8.23 2.23 3.28 3.5 7.5 5.24 12.68 5.24 4.04 0 7.15-1.05 10.15-3.29-2.47-1.48-5.56-3.66-6.9-3.66H19c-.77 0-2.4-.7-2.57-1.3a4.48 4.48 0 0 1-.09-1.9c0-.08.18-.08.26 0 .69.78 1.03 1.3 1.72 1.3h1.54c.6 0 2.66-1.8 3.51-4.05.18-.52.35-1.38.43-2.32 0-.1.09-.18.09-.1.08.44.26.96.34.96.26.17.6-.52 1.03-1.47.43-.86.43-1.38.6-2.07.26-.94-.09-1.63-.34-1.63a.78.78 0 0 0-.6.26c-.09 0-.18 0-.18-.09 0-.6.1-1.55.78-2.07-.95-.86-.35-2.32-.35-2.32.35.17.86.17.86.17l-.69-1.12c.52-.09.95-.52.95-.52s-1.37-.34-2.06-.86c.6-.17 1.54-.78 1.54-.78z",
            "clip-rule": "evenodd"
        }, null, -1)]))) : t("flag") ? (w(),
        R("svg", Bk, s[80] || (s[80] = [x("path", {
            fill: "currentColor",
            d: "M14.4,6L14,4H5V21H7V14H12.6L13,16H20V6H14.4Z"
        }, null, -1)]))) : t("intiface") ? (w(),
        R("svg", Vk, s[81] || (s[81] = [x("path", {
            d: "M71.3 106.2V83.52h73.08v132.3H191v22.68H65v-22.68h51.66V106.2H71.3z",
            fill: "currentColor"
        }, null, -1), x("circle", {
            cx: "126.74",
            cy: "39.42",
            r: "21.42",
            fill: "currentColor"
        }, null, -1)]))) : t("clock-outline") ? (w(),
        R("svg", $k, s[82] || (s[82] = [x("path", {
            fill: "currentColor",
            d: "M12,20A8,8 0 0,0 20,12A8,8 0 0,0 12,4A8,8 0 0,0 4,12A8,8 0 0,0 12,20M12,2A10,10 0 0,1 22,12A10,10 0 0,1 12,22C6.47,22 2,17.5 2,12A10,10 0 0,1 12,2M12.5,7V12.25L17,14.92L16.25,16.15L11,13V7H12.5Z"
        }, null, -1)]))) : t("upload") ? (w(),
        R("svg", Hk, s[83] || (s[83] = [x("path", {
            fill: "currentColor",
            d: "M9,16V10H5L12,3L19,10H15V16H9M5,20V18H19V20H5Z"
        }, null, -1)]))) : t("currency") ? (w(),
        R("svg", zk, s[84] || (s[84] = [x("path", {
            fill: "currentColor",
            d: "M7,15H9C9,16.08 10.37,17 12,17C13.63,17 15,16.08 15,15C15,13.9 13.96,13.5 11.76,12.97C9.64,12.44 7,11.78 7,9C7,7.21 8.47,5.69 10.5,5.18V3H13.5V5.18C15.53,5.69 17,7.21 17,9H15C15,7.92 13.63,7 12,7C10.37,7 9,7.92 9,9C9,10.1 10.04,10.5 12.24,11.03C14.36,11.56 17,12.22 17,15C17,16.79 15.53,18.31 13.5,18.82V21H10.5V18.82C8.47,18.31 7,16.79 7,15Z"
        }, null, -1)]))) : t("old-faptap") ? (w(),
        R("svg", Gk, s[85] || (s[85] = [x("path", {
            d: "M187.25 189.449L207 179.205v-25.609m-59.25-46.083L128 117.756l19.75-10.243zM128 117.756l-19.75-10.243L128 117.756zm0 0v25.609-25.609zm79-40.948l-19.75 10.23L207 76.782v.026zm0 0l-19.75-10.257L207 76.795v.013zm0 0v25.596-25.622.026zm-59.25-30.744L128 35.834l-19.75 10.243h39.5v-.013zM49 76.782l19.75-10.244L49 76.782v0zm0 0l19.75 10.243L49 76.782zm0 0v25.609-25.61zm79 143.385l-19.75-10.244L128 220.167zm0 0l19.75-10.244L128 220.167zm0 0v-25.596 25.596zm-59.25-30.718L49 179.205v-25.609l19.75 35.853v0z",
            stroke: "currentColor",
            "stroke-width": "26.333",
            "stroke-linecap": "round",
            "stroke-linejoin": "round"
        }, null, -1)]))) : t("heart-outline") ? (w(),
        R("svg", Wk, s[86] || (s[86] = [x("path", {
            fill: "currentColor",
            d: "M12.1,18.55L12,18.65L11.89,18.55C7.14,14.24 4,11.39 4,8.5C4,6.5 5.5,5 7.5,5C9.04,5 10.54,6 11.07,7.36H12.93C13.46,6 14.96,5 16.5,5C18.5,5 20,6.5 20,8.5C20,11.39 16.86,14.24 12.1,18.55M16.5,3C14.76,3 13.09,3.81 12,5.08C10.91,3.81 9.24,3 7.5,3C4.42,3 2,5.41 2,8.5C2,12.27 5.4,15.36 10.55,20.03L12,21.35L13.45,20.03C18.6,15.36 22,12.27 22,8.5C22,5.41 19.58,3 16.5,3Z"
        }, null, -1)]))) : t("heart") ? (w(),
        R("svg", qk, s[87] || (s[87] = [x("path", {
            fill: "currentColor",
            d: "M12,21.35L10.55,20.03C5.4,15.36 2,12.27 2,8.5C2,5.41 4.42,3 7.5,3C9.24,3 10.91,3.81 12,5.08C13.09,3.81 14.76,3 16.5,3C19.58,3 22,5.41 22,8.5C22,12.27 18.6,15.36 13.45,20.03L12,21.35Z"
        }, null, -1)]))) : t("currency") ? (w(),
        R("svg", jk, s[88] || (s[88] = [x("path", {
            fill: "currentColor",
            d: "M7,15H9C9,16.08 10.37,17 12,17C13.63,17 15,16.08 15,15C15,13.9 13.96,13.5 11.76,12.97C9.64,12.44 7,11.78 7,9C7,7.21 8.47,5.69 10.5,5.18V3H13.5V5.18C15.53,5.69 17,7.21 17,9H15C15,7.92 13.63,7 12,7C10.37,7 9,7.92 9,9C9,10.1 10.04,10.5 12.24,11.03C14.36,11.56 17,12.22 17,15C17,16.79 15.53,18.31 13.5,18.82V21H10.5V18.82C8.47,18.31 7,16.79 7,15Z"
        }, null, -1)]))) : t("mail-fast-outline") ? (w(),
        R("svg", Kk, s[89] || (s[89] = [x("path", {
            fill: "currentColor",
            d: "M22 5.5H9C7.9 5.5 7 6.4 7 7.5V16.5C7 17.61 7.9 18.5 9 18.5H22C23.11 18.5 24 17.61 24 16.5V7.5C24 6.4 23.11 5.5 22 5.5M22 16.5H9V9.17L15.5 12.5L22 9.17V16.5M15.5 10.81L9 7.5H22L15.5 10.81M5 16.5C5 16.67 5.03 16.83 5.05 17H1C.448 17 0 16.55 0 16S.448 15 1 15H5V16.5M3 7H5.05C5.03 7.17 5 7.33 5 7.5V9H3C2.45 9 2 8.55 2 8S2.45 7 3 7M1 12C1 11.45 1.45 11 2 11H5V13H2C1.45 13 1 12.55 1 12Z"
        }, null, -1)]))) : t("alert-circle-outline") ? (w(),
        R("svg", Xk, s[90] || (s[90] = [x("path", {
            fill: "currentColor",
            d: "M11,15H13V17H11V15M11,7H13V13H11V7M12,2C6.47,2 2,6.5 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4A8,8 0 0,1 20,12A8,8 0 0,1 12,20Z"
        }, null, -1)]))) : t("account-key-outline") ? (w(),
        R("svg", Yk, s[91] || (s[91] = [x("path", {
            fill: "currentColor",
            d: "M11 10V12H9V14H7V12H5.8C5.4 13.2 4.3 14 3 14C1.3 14 0 12.7 0 11S1.3 8 3 8C4.3 8 5.4 8.8 5.8 10H11M3 10C2.4 10 2 10.4 2 11S2.4 12 3 12 4 11.6 4 11 3.6 10 3 10M16 14C18.7 14 24 15.3 24 18V20H8V18C8 15.3 13.3 14 16 14M16 12C13.8 12 12 10.2 12 8S13.8 4 16 4 20 5.8 20 8 18.2 12 16 12Z"
        }, null, -1)]))) : t("account-plus") ? (w(),
        R("svg", Zk, s[92] || (s[92] = [x("path", {
            fill: "currentColor",
            d: "M15,14C12.33,14 7,15.33 7,18V20H23V18C23,15.33 17.67,14 15,14M6,10V7H4V10H1V12H4V15H6V12H9V10M15,12A4,4 0 0,0 19,8A4,4 0 0,0 15,4A4,4 0 0,0 11,8A4,4 0 0,0 15,12Z"
        }, null, -1)]))) : t("send") ? (w(),
        R("svg", Jk, s[93] || (s[93] = [x("path", {
            fill: "currentColor",
            d: "M2,21L23,12L2,3V10L17,12L2,14V21Z"
        }, null, -1)]))) : t("forum-outline") ? (w(),
        R("svg", Qk, s[94] || (s[94] = [x("path", {
            fill: "currentColor",
            d: "M15,4V11H5.17L4,12.17V4H15M16,2H3A1,1 0 0,0 2,3V17L6,13H16A1,1 0 0,0 17,12V3A1,1 0 0,0 16,2M21,6H19V15H6V17A1,1 0 0,0 7,18H18L22,22V7A1,1 0 0,0 21,6Z"
        }, null, -1)]))) : t("cellphone-screenshot") ? (w(),
        R("svg", eP, s[95] || (s[95] = [x("path", {
            fill: "currentColor",
            d: "M7,1A2,2 0 0,0 5,3V21A2,2 0 0,0 7,23H17A2,2 0 0,0 19,21V3A2,2 0 0,0 17,1H7M7,4H17V20H7V4M9,6V10H10.5V7.5H13V6H9M13.5,14V16.5H11V18H15V14H13.5Z"
        }, null, -1)]))) : t("cog") ? (w(),
        R("svg", tP, s[96] || (s[96] = [x("path", {
            fill: "currentColor",
            d: "M12,15.5A3.5,3.5 0 0,1 8.5,12A3.5,3.5 0 0,1 12,8.5A3.5,3.5 0 0,1 15.5,12A3.5,3.5 0 0,1 12,15.5M19.43,12.97C19.47,12.65 19.5,12.33 19.5,12C19.5,11.67 19.47,11.34 19.43,11L21.54,9.37C21.73,9.22 21.78,8.95 21.66,8.73L19.66,5.27C19.54,5.05 19.27,4.96 19.05,5.05L16.56,6.05C16.04,5.66 15.5,5.32 14.87,5.07L14.5,2.42C14.46,2.18 14.25,2 14,2H10C9.75,2 9.54,2.18 9.5,2.42L9.13,5.07C8.5,5.32 7.96,5.66 7.44,6.05L4.95,5.05C4.73,4.96 4.46,5.05 4.34,5.27L2.34,8.73C2.21,8.95 2.27,9.22 2.46,9.37L4.57,11C4.53,11.34 4.5,11.67 4.5,12C4.5,12.33 4.53,12.65 4.57,12.97L2.46,14.63C2.27,14.78 2.21,15.05 2.34,15.27L4.34,18.73C4.46,18.95 4.73,19.03 4.95,18.95L7.44,17.94C7.96,18.34 8.5,18.68 9.13,18.93L9.5,21.58C9.54,21.82 9.75,22 10,22H14C14.25,22 14.46,21.82 14.5,21.58L14.87,18.93C15.5,18.67 16.04,18.34 16.56,17.94L19.05,18.95C19.27,19.03 19.54,18.95 19.66,18.73L21.66,15.27C21.78,15.05 21.73,14.78 21.54,14.63L19.43,12.97Z"
        }, null, -1)]))) : t("swap-horizontal") ? (w(),
        R("svg", nP, s[97] || (s[97] = [x("path", {
            fill: "currentColor",
            d: "M21,9L17,5V8H10V10H17V13M7,11L3,15L7,19V16H14V14H7V11Z"
        }, null, -1)]))) : t("close-box") ? (w(),
        R("svg", iP, s[98] || (s[98] = [x("path", {
            fill: "currentColor",
            d: "M12,2C17.53,2 22,6.47 22,12C22,17.53 17.53,22 12,22C6.47,22 2,17.53 2,12C2,6.47 6.47,2 12,2M15.59,7L12,10.59L8.41,7L7,8.41L10.59,12L7,15.59L8.41,17L12,13.41L15.59,17L17,15.59L13.41,12L17,8.41L15.59,7Z"
        }, null, -1)]))) : t("pencil-ruler") ? (w(),
        R("svg", sP, s[99] || (s[99] = [x("path", {
            fill: "currentColor",
            d: "M3 17.25V21H6.75L17.81 9.93L14.06 6.18L3 17.25M22.61 18.36L18.36 22.61L13.16 17.41L14.93 15.64L15.93 16.64L18.4 14.16L19.82 15.58L18.36 17L19.42 18L20.84 16.6L22.61 18.36M6.61 10.83L1.39 5.64L5.64 1.39L7.4 3.16L4.93 5.64L6 6.7L8.46 4.22L9.88 5.64L8.46 7.05L9.46 8.05L6.61 10.83M20.71 7C21.1 6.61 21.1 6 20.71 5.59L18.37 3.29C18 2.9 17.35 2.9 16.96 3.29L15.12 5.12L18.87 8.87L20.71 7Z"
        }, null, -1)]))) : t("arrow-left-right") ? (w(),
        R("svg", rP, s[100] || (s[100] = [x("path", {
            fill: "currentColor",
            d: "M6.45,17.45L1,12L6.45,6.55L7.86,7.96L4.83,11H19.17L16.14,7.96L17.55,6.55L23,12L17.55,17.45L16.14,16.04L19.17,13H4.83L7.86,16.04L6.45,17.45Z"
        }, null, -1)]))) : t("view-column") ? (w(),
        R("svg", oP, s[101] || (s[101] = [x("path", {
            fill: "currentColor",
            d: "M4 5V18H21V5H4M14 7V16H11V7H14M6 7H9V16H6V7M19 16H16V7H19V16Z"
        }, null, -1)]))) : t("calendar") ? (w(),
        R("svg", aP, s[102] || (s[102] = [x("path", {
            fill: "currentColor",
            d: "M7 11H9V13H7V11M21 5V19C21 20.11 20.11 21 19 21H5C3.89 21 3 20.1 3 19V5C3 3.9 3.9 3 5 3H6V1H8V3H16V1H18V3H19C20.11 3 21 3.9 21 5M5 7H19V5H5V7M19 19V9H5V19H19M15 13V11H17V13H15M11 13V11H13V13H11M7 15H9V17H7V15M15 17V15H17V17H15M11 17V15H13V17H11Z"
        }, null, -1)]))) : t("clock") ? (w(),
        R("svg", lP, s[103] || (s[103] = [x("path", {
            fill: "currentColor",
            d: "M12 20C16.42 20 20 16.42 20 12S16.42 4 12 4 4 7.58 4 12 7.58 20 12 20M12 2C17.5 2 22 6.5 22 12S17.5 22 12 22C6.47 22 2 17.5 2 12C2 6.5 6.5 2 12 2M12.5 13V13H11V7H12.5V11.26L16.2 9.13L16.95 10.43L12.5 13Z"
        }, null, -1)]))) : t("video-plus") ? (w(),
        R("svg", cP, s[104] || (s[104] = [x("path", {
            fill: "currentColor",
            d: "M17,10.5V7A1,1 0 0,0 16,6H4A1,1 0 0,0 3,7V17A1,1 0 0,0 4,18H16A1,1 0 0,0 17,17V13.5L21,17.5V6.5L17,10.5M14,13H11V16H9V13H6V11H9V8H11V11H14V13Z"
        }, null, -1)]))) : t("youtube-studio") ? (w(),
        R("svg", uP, s[105] || (s[105] = [x("path", {
            fill: "currentColor",
            d: "M10,15L15,12L10,9V15M19.45,13L21.56,14.63C21.78,14.78 21.81,15 21.66,15.28L19.64,18.75C19.5,18.97 19.31,19.03 19.03,18.94L16.55,17.95C15.89,18.42 15.33,18.75 14.86,18.94L14.5,21.56C14.42,21.84 14.27,22 14,22H10C9.73,22 9.58,21.84 9.5,21.56L9.14,18.94C8.55,18.69 8,18.36 7.45,17.95L4.97,18.94C4.69,19.03 4.5,18.97 4.36,18.75L2.34,15.28C2.19,15 2.22,14.78 2.44,14.63L4.55,13C4.5,12.77 4.5,12.44 4.5,12C4.5,11.56 4.5,11.23 4.55,11L2.44,9.38C2.22,9.22 2.19,9 2.34,8.72L4.36,5.25C4.5,5.03 4.69,4.97 4.97,5.06L7.45,6.05C8.11,5.58 8.67,5.25 9.14,5.06L9.5,2.44C9.58,2.16 9.73,2 10,2H14C14.27,2 14.42,2.16 14.5,2.44L14.86,5.06C15.45,5.31 16,5.64 16.55,6.05L19.03,5.06C19.31,4.97 19.5,5.03 19.64,5.25L21.66,8.72C21.81,9 21.78,9.22 21.56,9.38L19.45,11C19.5,11.23 19.5,11.56 19.5,12C19.5,12.44 19.5,12.77 19.45,13Z"
        }, null, -1)]))) : t("notification-badge-outline") ? (w(),
        R("svg", dP, s[106] || (s[106] = [x("path", {
            fill: "currentColor",
            d: "M19 17V11.8C18.5 11.9 18 12 17.5 12H17V18H7V11C7 8.2 9.2 6 12 6C12.1 4.7 12.7 3.6 13.5 2.7C13.2 2.3 12.6 2 12 2C10.9 2 10 2.9 10 4V4.3C7 5.2 5 7.9 5 11V17L3 19V20H21V19L19 17M10 21C10 22.1 10.9 23 12 23S14 22.1 14 21H10M21 6.5C21 8.4 19.4 10 17.5 10S14 8.4 14 6.5 15.6 3 17.5 3 21 4.6 21 6.5"
        }, null, -1)]))) : t("arrow-left") ? (w(),
        R("svg", fP, s[107] || (s[107] = [x("path", {
            fill: "currentColor",
            d: "M20,11V13H8L13.5,18.5L12.08,19.92L4.16,12L12.08,4.08L13.5,5.5L8,11H20Z"
        }, null, -1)]))) : t("orientation-transgender") ? (w(),
        R("svg", hP, s[108] || (s[108] = [x("path", {
            d: "M19.58 3H15V1H23V9H21V4.41L16.17 9.24C16.69 10.03 17 11 17 12C17 14.42 15.28 16.44 13 16.9V19H15V21H13V23H11V21H9V19H11V16.9C8.72 16.44 7 14.42 7 12C7 11 7.3 10.04 7.82 9.26L6.64 8.07L5.24 9.46L3.83 8.04L5.23 6.65L3 4.42V8H1V1H8V3H4.41L6.64 5.24L8.08 3.81L9.5 5.23L8.06 6.66L9.23 7.84C10 7.31 11 7 12 7C13 7 13.96 7.3 14.75 7.83L19.58 3ZM12 9C11.2044 9 10.4413 9.31607 9.87868 9.87868C9.31607 10.4413 9 11.2044 9 12C9 12.7956 9.31607 13.5587 9.87868 14.1213C10.4413 14.6839 11.2044 15 12 15C12.7956 15 13.5587 14.6839 14.1213 14.1213C14.6839 13.5587 15 12.7956 15 12C15 11.2044 14.6839 10.4413 14.1213 9.87868C13.5587 9.31607 12.7956 9 12 9Z",
            fill: "currentColor"
        }, null, -1)]))) : t("orientation-straight") ? (w(),
        R("svg", pP, s[109] || (s[109] = [x("path", {
            d: "M17.58 4H14V2H21V9H19V5.41L15.17 9.24C15.69 10.03 16 11 16 12C16 14.42 14.28 16.44 12 16.9V19H14V21H12V23H10V21H8V19H10V16.9C7.72 16.44 6 14.42 6 12C6 10.6739 6.52678 9.40215 7.46447 8.46447C8.40215 7.52678 9.67392 7 11 7C12 7 12.96 7.3 13.75 7.83L17.58 4ZM11 9C10.2044 9 9.44129 9.31607 8.87868 9.87868C8.31607 10.4413 8 11.2044 8 12C8 12.7956 8.31607 13.5587 8.87868 14.1213C9.44129 14.6839 10.2044 15 11 15C11.7956 15 12.5587 14.6839 13.1213 14.1213C13.6839 13.5587 14 12.7956 14 12C14 11.2044 13.6839 10.4413 13.1213 9.87868C12.5587 9.31607 11.7956 9 11 9Z",
            fill: "currentColor"
        }, null, -1)]))) : t("orientation-gay") ? (w(),
        R("svg", mP, s[110] || (s[110] = [x("path", {
            d: "M13.2222 11.1482C14.2733 11.1482 15.2593 11.4822 16.0496 12.0526L20.2133 7.88889H16.4815V6.25926H23V12.7778H21.3704V9.03778L17.2067 13.1852C17.777 14 18.1111 14.9778 18.1111 16.037C18.1111 17.3337 17.596 18.5772 16.6792 19.494C15.7624 20.4109 14.5188 20.9259 13.2222 20.9259C11.9256 20.9259 10.6821 20.4109 9.76527 19.494C8.84842 18.5772 8.33334 17.3337 8.33334 16.037C8.33334 14.7404 8.84842 13.4969 9.76527 12.5801C10.6821 11.6632 11.9256 11.1482 13.2222 11.1482ZM13.2222 12.7778C12.3578 12.7778 11.5288 13.1212 10.9176 13.7324C10.3064 14.3436 9.96297 15.1726 9.96297 16.037C9.96297 16.9014 10.3064 17.7305 10.9176 18.3417C11.5288 18.9529 12.3578 19.2963 13.2222 19.2963C14.0866 19.2963 14.9156 18.9529 15.5269 18.3417C16.1381 17.7305 16.4815 16.9014 16.4815 16.037C16.4815 15.1726 16.1381 14.3436 15.5269 13.7324C14.9156 13.1212 14.0866 12.7778 13.2222 12.7778Z",
            fill: "currentColor"
        }, null, -1), x("path", {
            d: "M5.88889 7.88889C6.94 7.88889 7.92593 8.22296 8.7163 8.79333L12.88 4.62963H9.14815V3H15.6667V9.51852H14.037V5.77852L9.87333 9.92593C10.4437 10.7407 10.7778 11.7185 10.7778 12.7778C10.7778 14.0744 10.2627 15.3179 9.34585 16.2347C8.42901 17.1516 7.1855 17.6667 5.88889 17.6667C4.59227 17.6667 3.34877 17.1516 2.43192 16.2347C1.51508 15.3179 1 14.0744 1 12.7778C1 11.4812 1.51508 10.2377 2.43192 9.32081C3.34877 8.40397 4.59227 7.88889 5.88889 7.88889ZM5.88889 9.51852C5.02448 9.51852 4.19547 9.8619 3.58424 10.4731C2.97301 11.0844 2.62963 11.9134 2.62963 12.7778C2.62963 13.6422 2.97301 14.4712 3.58424 15.0824C4.19547 15.6937 5.02448 16.037 5.88889 16.037C6.7533 16.037 7.5823 15.6937 8.19353 15.0824C8.80476 14.4712 9.14815 13.6422 9.14815 12.7778C9.14815 11.9134 8.80476 11.0844 8.19353 10.4731C7.5823 9.8619 6.7533 9.51852 5.88889 9.51852Z",
            fill: "currentColor"
        }, null, -1)]))) : t("loob") ? (w(),
        R("svg", gP, s[111] || (s[111] = [pa('<rect width="5" height="63" fill="currentColor"></rect><rect x="132" width="5" height="61" fill="currentColor"></rect><circle cx="40.5" cy="60.5" r="17.5" stroke="currentColor" stroke-width="6"></circle><circle cx="96.5" cy="60.5" r="17.5" stroke="currentColor" stroke-width="6"></circle><circle cx="152.5" cy="60.5" r="17.5" stroke="currentColor" stroke-width="6"></circle>', 5)]))) : t("shield-crown") ? (w(),
        R("svg", vP, s[112] || (s[112] = [x("path", {
            fill: "currentColor",
            d: "M12 1L21 5V11C21 16.55 17.16 21.74 12 23C6.84 21.74 3 16.55 3 11V5L12 1M16 14H8V15.5C8 15.77 8.19 15.96 8.47 16L8.57 16H15.43C15.74 16 15.95 15.84 16 15.59L16 15.5V14M17 8L17 8L14.33 10.67L12 8.34L9.67 10.67L7 8L7 8L8 13H16L17 8Z"
        }, null, -1)]))) : t("discord") ? (w(),
        R("svg", _P, s[113] || (s[113] = [x("g", null, [x("path", {
            d: "M216.856339,16.5966031 C200.285002,8.84328665 182.566144,3.2084988 164.041564,0 C161.766523,4.11318106 159.108624,9.64549908 157.276099,14.0464379 C137.583995,11.0849896 118.072967,11.0849896 98.7430163,14.0464379 C96.9108417,9.64549908 94.1925838,4.11318106 91.8971895,0 C73.3526068,3.2084988 55.6133949,8.86399117 39.0420583,16.6376612 C5.61752293,67.146514 -3.4433191,116.400813 1.08711069,164.955721 C23.2560196,181.510915 44.7403634,191.567697 65.8621325,198.148576 C71.0772151,190.971126 75.7283628,183.341335 79.7352139,175.300261 C72.104019,172.400575 64.7949724,168.822202 57.8887866,164.667963 C59.7209612,163.310589 61.5131304,161.891452 63.2445898,160.431257 C105.36741,180.133187 151.134928,180.133187 192.754523,160.431257 C194.506336,161.891452 196.298154,163.310589 198.110326,164.667963 C191.183787,168.842556 183.854737,172.420929 176.223542,175.320965 C180.230393,183.341335 184.861538,190.991831 190.096624,198.16893 C211.238746,191.588051 232.743023,181.531619 254.911949,164.955721 C260.227747,108.668201 245.831087,59.8662432 216.856339,16.5966031 Z M85.4738752,135.09489 C72.8290281,135.09489 62.4592217,123.290155 62.4592217,108.914901 C62.4592217,94.5396472 72.607595,82.7145587 85.4738752,82.7145587 C98.3405064,82.7145587 108.709962,94.5189427 108.488529,108.914901 C108.508531,123.290155 98.3405064,135.09489 85.4738752,135.09489 Z M170.525237,135.09489 C157.88039,135.09489 147.510584,123.290155 147.510584,108.914901 C147.510584,94.5396472 157.658606,82.7145587 170.525237,82.7145587 C183.391518,82.7145587 193.761324,94.5189427 193.539891,108.914901 C193.539891,123.290155 183.391518,135.09489 170.525237,135.09489 Z",
            fill: "#5865F2",
            "fill-rule": "nonzero"
        })], -1)]))) : t("twitter") ? (w(),
        R("svg", xP, s[114] || (s[114] = [x("g", null, [x("path", {
            d: "M256,25.4500259 C246.580841,29.6272672 236.458451,32.4504868 225.834156,33.7202333 C236.678503,27.2198053 245.00583,16.9269929 248.927437,4.66307685 C238.779765,10.6812633 227.539325,15.0523376 215.57599,17.408298 C205.994835,7.2006971 192.34506,0.822 177.239197,0.822 C148.232605,0.822 124.716076,24.3375931 124.716076,53.3423116 C124.716076,57.4586875 125.181462,61.4673784 126.076652,65.3112644 C82.4258385,63.1210453 43.7257252,42.211429 17.821398,10.4359288 C13.3005011,18.1929938 10.710443,27.2151234 10.710443,36.8402889 C10.710443,55.061526 19.9835254,71.1374907 34.0762135,80.5557137 C25.4660961,80.2832239 17.3681846,77.9207088 10.2862577,73.9869292 C10.2825122,74.2060448 10.2825122,74.4260967 10.2825122,74.647085 C10.2825122,100.094453 28.3867003,121.322443 52.413563,126.14673 C48.0059695,127.347184 43.3661509,127.988612 38.5755734,127.988612 C35.1914554,127.988612 31.9009766,127.659938 28.694773,127.046602 C35.3777973,147.913145 54.7742053,163.097665 77.7569918,163.52185 C59.7820257,177.607983 37.1354036,186.004604 12.5289147,186.004604 C8.28987161,186.004604 4.10888474,185.75646 0,185.271409 C23.2431033,200.173139 50.8507261,208.867532 80.5109185,208.867532 C177.116529,208.867532 229.943977,128.836982 229.943977,59.4326002 C229.943977,57.1552968 229.893412,54.8901664 229.792282,52.6381454 C240.053257,45.2331635 248.958338,35.9825545 256,25.4500259",
            fill: "#ffffff"
        })], -1)]))) : t("ai") ? (w(),
        R("svg", yP, s[115] || (s[115] = [x("g", null, [x("path", {
            d: "M4.9996 7V11M9.9996 2V6M17.9996 16V20M2.9996 9H6.9996M7.9996 4H11.9996M15.9996 18H19.9996M13.9996 7L16.828 9.82843M19.5162 3.74612L20.0819 4.3118C20.4779 4.70782 20.6759 4.90583 20.7501 5.13416C20.8154 5.335 20.8154 5.55135 20.7501 5.75219C20.6759 5.98052 20.4779 6.17853 20.0819 6.57454L6.52508 20.1314C6.12906 20.5274 5.93105 20.7254 5.70272 20.7996C5.50188 20.8649 5.28553 20.8649 5.08469 20.7996C4.85636 20.7254 4.65835 20.5274 4.26234 20.1314L3.69665 19.5657C3.30063 19.1697 3.10262 18.9717 3.02844 18.7433C2.96318 18.5425 2.96318 18.3262 3.02844 18.1253C3.10262 17.897 3.30063 17.699 3.69665 17.303L17.2535 3.74612C17.6495 3.3501 17.8475 3.15209 18.0758 3.0779C18.2767 3.01265 18.493 3.01265 18.6939 3.0779C18.9222 3.15209 19.1202 3.3501 19.5162 3.74612Z",
            stroke: "currentColor",
            "stroke-width": "2",
            "stroke-linecap": "round",
            "stroke-linejoin": "round"
        })], -1)]))) : t("user-reset") ? (w(),
        R("svg", bP, s[116] || (s[116] = [x("path", {
            d: "M13.16,3.17A8.83,8.83,0,1,1,5.76,16.8l1.4-1.11a7.05,7.05,0,1,0-1-4.57H8.6L5.3,14.41,2,11.12H4.38a8.83,8.83,0,0,1,8.78-7.95m2",
            fill: "currentColor"
        }, null, -1), x("path", {
            d: "M12 21.008q0 0.576 0.224 1.152 2.592 1.856 5.76 1.856t5.76-1.856q0.256-0.576 0.256-1.152-0.256-1.344-1.088-2.464t-2.048-1.792q1.12-1.152 1.12-2.752v-1.984q0-1.664-1.184-2.848t-2.816-1.152-2.816 1.152-1.184 2.848v1.984q0 1.6 1.12 2.752-1.216 0.672-2.048 1.792t-1.056 2.464z",
            transform: "translate(-3 -3) scale(0.65) translate(7 7)",
            fill: "currentColor"
        }, null, -1)]))) : t("trash") ? (w(),
        R("svg", SP, s[117] || (s[117] = [x("g", null, [x("path", {
            fill: "currentColor",
            d: "M21 6h-5V4.33A2.42 2.42 0 0 0 13.5 2h-3A2.42 2.42 0 0 0 8 4.33V6H3a1 1 0 0 0 0 2h1v11a3 3 0 0 0 3 3h10a3 3 0 0 0 3-3V8h1a1 1 0 0 0 0-2zM10 16a1 1 0 0 1-2 0v-4a1 1 0 0 1 2 0zm0-11.67c0-.16.21-.33.5-.33h3c.29 0 .5.17.5.33V6h-4zM16 16a1 1 0 0 1-2 0v-4a1 1 0 0 1 2 0z"
        })], -1)]))) : t("user-delete") ? (w(),
        R("svg", EP, s[118] || (s[118] = [pa('<g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round" stroke="currentColor" stroke-width="1.062672"></g><g id="SVGRepo_iconCarrier"><g id="delete-user-circle-left" transform="translate(-1.586 -2)"><path id="secondary" fill="currentColor" d="M7,19.5a9,9,0,0,0,9.94,0A5,5,0,0,0,7,19.5Z"></path><path id="primary" d="M6,7.5l-3,3m0-3,3,3m1,9a9,9,0,0,0,9.94,0A5,5,0,0,0,7,19.5Z" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.0436"></path><path id="primary-2" data-name="primary" d="M9,13.64A4,4,0,1,0,12,7a4.09,4.09,0,0,0-2,.53" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.0436"></path><path id="primary-3" data-name="primary" d="M9,3.52A8.8,8.8,0,0,1,12,3,9,9,0,1,1,5.64,18.36,8.86,8.86,0,0,1,3.52,15" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.0436"></path></g></g>', 2)]))) : t("onlineBadges") ? (w(),
        R("svg", wP, s[119] || (s[119] = [x("circle", {
            cx: "12",
            cy: "12",
            r: "4",
            fill: "currentColor"
        }, null, -1)]))) : t("endcall") ? (w(),
        R("svg", TP, s[120] || (s[120] = [x("path", {
            fill: "currentColor",
            d: "M12,9C10.4,9 8.85,9.25 7.4,9.72V12.82C7.4,13.22 7.17,13.56 6.84,13.72C5.86,14.21 4.97,14.84 4.17,15.57C4,15.75 3.75,15.86 3.5,15.86C3.2,15.86 2.95,15.74 2.77,15.56L0.29,13.08C0.11,12.9 0,12.65 0,12.38C0,12.1 0.11,11.85 0.29,11.67C3.34,8.77 7.46,7 12,7C16.54,7 20.66,8.77 23.71,11.67C23.89,11.85 24,12.1 24,12.38C24,12.65 23.89,12.9 23.71,13.08L21.23,15.56C21.05,15.74 20.8,15.86 20.5,15.86C20.25,15.86 20,15.75 19.82,15.57C19.03,14.84 18.14,14.21 17.16,13.72C16.83,13.56 16.6,13.22 16.6,12.82V9.72C15.15,9.25 13.6,9 12,9Z"
        }, null, -1)]))) : t("pause") ? (w(),
        R("svg", AP, s[121] || (s[121] = [x("path", {
            fill: "currentColor",
            d: "M14,19H18V5H14M6,19H10V5H6V19Z"
        }, null, -1)]))) : t("mute") ? (w(),
        R("svg", CP, s[122] || (s[122] = [x("path", {
            d: "M8 5C8 2.79086 9.79086 1 12 1C14.2091 1 16 2.79086 16 5V12C16 14.2091 14.2091 16 12 16C9.79086 16 8 14.2091 8 12V5Z",
            fill: "currentColor"
        }, null, -1), x("path", {
            d: "M6.25 11.8438V12C6.25 13.525 6.8558 14.9875 7.93414 16.0659C9.01247 17.1442 10.475 17.75 12 17.75C13.525 17.75 14.9875 17.1442 16.0659 16.0659C17.1442 14.9875 17.75 13.525 17.75 12V11.8438C17.75 11.2915 18.1977 10.8438 18.75 10.8438H19.25C19.8023 10.8438 20.25 11.2915 20.25 11.8437V12C20.25 14.188 19.3808 16.2865 17.8336 17.8336C16.5842 19.0831 14.9753 19.8903 13.25 20.1548V22C13.25 22.5523 12.8023 23 12.25 23H11.75C11.1977 23 10.75 22.5523 10.75 22V20.1548C9.02471 19.8903 7.41579 19.0831 6.16637 17.8336C4.61919 16.2865 3.75 14.188 3.75 12V11.8438C3.75 11.2915 4.19772 10.8438 4.75 10.8438H5.25C5.80228 10.8438 6.25 11.2915 6.25 11.8438Z",
            fill: "currentColor"
        }, null, -1)]))) : t("unmute") ? (w(),
        R("svg", MP, s[123] || (s[123] = [x("path", {
            d: "M12 1C13.6452 1 15.0585 1.99333 15.6728 3.41298L7.99997 11.0858V5C7.99997 2.79086 9.79083 1 12 1Z",
            fill: "currentColor"
        }, null, -1), x("path", {
            d: "M6.24997 12C6.24997 12.2632 6.26801 12.5245 6.30342 12.7823L4.25194 14.8338C3.92295 13.9344 3.74997 12.9761 3.74997 12V11.8438C3.74997 11.2915 4.19769 10.8438 4.74997 10.8438H5.24997C5.80226 10.8438 6.24997 11.2915 6.24997 11.8438V12Z",
            fill: "currentColor"
        }, null, -1), x("path", {
            d: "M7.3242 18.7971L3.76773 22.3535C3.3772 22.7441 2.74404 22.7441 2.35352 22.3535L1.64641 21.6464C1.25588 21.2559 1.25588 20.6227 1.64641 20.2322L20.2322 1.64644C20.6227 1.25591 21.2559 1.25591 21.6464 1.64644L22.3535 2.35354C22.744 2.74407 22.744 3.37723 22.3535 3.76776L16 10.1213V12C16 14.2091 14.2091 16 12 16C11.4457 16 10.9177 15.8873 10.4378 15.6835L9.13553 16.9857C9.99969 17.4822 10.986 17.75 12 17.75C13.525 17.75 14.9875 17.1442 16.0658 16.0659C17.1442 14.9875 17.75 13.525 17.75 12V11.8438C17.75 11.2915 18.1977 10.8438 18.75 10.8438H19.25C19.8023 10.8438 20.25 11.2915 20.25 11.8437V12C20.25 14.188 19.3808 16.2865 17.8336 17.8336C16.5842 19.0831 14.9753 19.8903 13.25 20.1548V23H10.75V20.1548C9.51944 19.9662 8.34812 19.5014 7.3242 18.7971Z",
            fill: "currentColor"
        }, null, -1)]))) : t("video-enable") ? (w(),
        R("svg", RP, s[124] || (s[124] = [x("path", {
            id: "zzzz",
            d: "M16,10l2.577-1.546c.793-.476,1.19-.714,1.516-.683a1,1,0,0,1,.713.4C21,8.438,21,8.9,21,9.826v4.348c0,.925,0,1.387-.194,1.652a1,1,0,0,1-.713.4c-.326.03-.723-.208-1.516-.683L16,14M6.2,18h6.6a4.968,4.968,0,0,0,2.108-.218,2,2,0,0,0,.874-.874A4.968,4.968,0,0,0,16,14.8V9.2a4.968,4.968,0,0,0-.218-2.108,2,2,0,0,0-.874-.874A4.969,4.969,0,0,0,12.8,6H6.2a4.969,4.969,0,0,0-2.108.218,2,2,0,0,0-.874.874A4.969,4.969,0,0,0,3,9.2v5.6a4.969,4.969,0,0,0,.218,2.108,2,2,0,0,0,.874.874A4.968,4.968,0,0,0,6.2,18Z"
        }, null, -1)]))) : t("video-disable") ? (w(),
        R("svg", LP, s[125] || (s[125] = [x("path", {
            id: "zzzz",
            d: "M16,10l2.577-1.546c.793-.476,1.19-.714,1.516-.683a1,1,0,0,1,.713.4C21,8.438,21,8.9,21,9.826v4.348c0,.925,0,1.387-.194,1.652a1,1,0,0,1-.713.4c-.326.03-.723-.208-1.516-.683L16,14M6.2,18h6.6a4.968,4.968,0,0,0,2.108-.218,2,2,0,0,0,.874-.874A4.968,4.968,0,0,0,16,14.8V9.2a4.968,4.968,0,0,0-.218-2.108,2,2,0,0,0-.874-.874A4.969,4.969,0,0,0,12.8,6H6.2a4.969,4.969,0,0,0-2.108.218,2,2,0,0,0-.874.874A4.969,4.969,0,0,0,3,9.2v5.6a4.969,4.969,0,0,0,.218,2.108,2,2,0,0,0,.874.874A4.968,4.968,0,0,0,6.2,18Z"
        }, null, -1), x("line", {
            x1: "16",
            y1: "5",
            x2: "2",
            y2: "19",
            stroke: "currentColor",
            "stroke-width": "3"
        }, null, -1), x("line", {
            x1: "16",
            y1: "5",
            x2: "3",
            y2: "18",
            stroke: "white",
            "stroke-width": "2"
        }, null, -1)]))) : t("back-arrow") ? (w(),
        R("svg", IP, s[126] || (s[126] = [x("g", null, [x("path", {
            d: "M26.105,21.891c-0.229,0-0.439-0.131-0.529-0.346l0,0c-0.066-0.156-1.716-3.857-7.885-4.59         c-1.285-0.156-2.824-0.236-4.693-0.25v4.613c0,0.213-0.115,0.406-0.304,0.508c-0.188,0.098-0.413,0.084-0.588-0.033L0.254,13.815         C0.094,13.708,0,13.528,0,13.339c0-0.191,0.094-0.365,0.254-0.477l11.857-7.979c0.175-0.121,0.398-0.129,0.588-0.029         c0.19,0.102,0.303,0.295,0.303,0.502v4.293c2.578,0.336,13.674,2.33,13.674,11.674c0,0.271-0.191,0.508-0.459,0.562         C26.18,21.891,26.141,21.891,26.105,21.891z",
            fill: "currentColor"
        })], -1)]))) : le("", !0)
    }
})
  , je = ut({
    __name: "Button",
    props: {
        theme: {},
        loading: {
            type: Boolean
        },
        disabled: {
            type: Boolean
        },
        rounded: {
            type: Boolean
        },
        href: {},
        to: {},
        type: {},
        dense: {
            type: Boolean
        }
    },
    setup(i) {
        const e = i
          , t = Vt( () => {
            let s;
            switch (e.theme) {
            case "green":
                s = ["bg-green-500", "hover:bg-green-600", "active:bg-green-700"];
                break;
            case "red":
                s = ["bg-red-500", "hover:bg-red-600", "active:bg-red-700"];
                break;
            case "blue":
                s = ["bg-blue-500", "hover:bg-blue-600", "active:bg-blue-700"];
                break;
            case "transparent":
                s = ["hover:bg-zinc-800/50"];
                break;
            case "light":
                s = ["bg-zinc-700", "hover:bg-zinc-600", "hover:bg-zinc-500"];
                break;
            default:
                s = ["bg-zinc-800", "hover:bg-zinc-700", "active:bg-zinc-600"];
                break
            }
            return e.dense && s.push("!px-2", "!py-1"),
            s
        }
        )
          , n = Vt( () => {
            let s = "button";
            return e.to && (s = "router-link"),
            e.href && (s = "a"),
            s
        }
        );
        return (s, r) => (w(),
        Re(ys(n.value), {
            class: Pt([t.value, "block rounded-md px-3 py-1.5 text-center font-semibold md:text-sm overflow-hidden disabled:opacity-75 cursor-pointer disabled:cursor-not-allowed"]),
            to: s.to,
            type: s.type,
            href: s.href || s.to,
            target: s.href ? "_blank" : void 0,
            disabled: s.disabled || e.loading
        }, {
            default: Y( () => [e.loading ? (w(),
            Re(ze, {
                key: 0,
                name: "loading",
                class: "h-5 w-5 animate-spin mx-auto"
            })) : Nl(s.$slots, "default", {
                key: 1
            })]),
            _: 3
        }, 8, ["class", "to", "type", "href", "target", "disabled"]))
    }
})
  , kP = i => {
    const e = Object.entries(i).filter( ([,t]) => t !== void 0).map( ([t,n]) => `${t}=${n}`).join("&");
    return e ? `?${e}` : ""
}
  , PP = (i, e) => {
    const t = kP(e);
    return `${i}${t}`
}
;
var DP = !1;
/*!
 * pinia v2.2.6
 * (c) 2024 Eduardo San Martin Morote
 * @license MIT
 */
let FT;
const am = i => FT = i
  , OT = Symbol();
function qg(i) {
    return i && typeof i == "object" && Object.prototype.toString.call(i) === "[object Object]" && typeof i.toJSON != "function"
}
var ld;
(function(i) {
    i.direct = "direct",
    i.patchObject = "patch object",
    i.patchFunction = "patch function"
}
)(ld || (ld = {}));
function FP() {
    const i = uw(!0)
      , e = i.run( () => xe({}));
    let t = []
      , n = [];
    const s = l_({
        install(r) {
            am(s),
            s._a = r,
            r.provide(OT, s),
            r.config.globalProperties.$pinia = s,
            n.forEach(o => t.push(o)),
            n = []
        },
        use(r) {
            return !this._a && !DP ? n.push(r) : t.push(r),
            this
        },
        _p: t,
        _a: null,
        _e: i,
        _s: new Map,
        state: e
    });
    return s
}
const UT = () => {}
;
function Xy(i, e, t, n=UT) {
    i.push(e);
    const s = () => {
        const r = i.indexOf(e);
        r > -1 && (i.splice(r, 1),
        n())
    }
    ;
    return !t && e_() && dw(s),
    s
}
function ql(i, ...e) {
    i.slice().forEach(t => {
        t(...e)
    }
    )
}
const OP = i => i()
  , Yy = Symbol()
  , e0 = Symbol();
function jg(i, e) {
    i instanceof Map && e instanceof Map ? e.forEach( (t, n) => i.set(n, t)) : i instanceof Set && e instanceof Set && e.forEach(i.add, i);
    for (const t in e) {
        if (!e.hasOwnProperty(t))
            continue;
        const n = e[t]
          , s = i[t];
        qg(s) && qg(n) && i.hasOwnProperty(t) && !Sn(n) && !Io(n) ? i[t] = jg(s, n) : i[t] = n
    }
    return i
}
const UP = Symbol();
function NP(i) {
    return !qg(i) || !i.hasOwnProperty(UP)
}
const {assign: Zo} = Object;
function BP(i) {
    return !!(Sn(i) && i.effect)
}
function VP(i, e, t, n) {
    const {state: s, actions: r, getters: o} = e
      , a = t.state.value[i];
    let l;
    function c() {
        a || (t.state.value[i] = s ? s() : {});
        const u = hL(t.state.value[i]);
        return Zo(u, r, Object.keys(o || {}).reduce( (d, f) => (d[f] = l_(Vt( () => {
            am(t);
            const h = t._s.get(i);
            return o[f].call(h, h)
        }
        )),
        d), {}))
    }
    return l = NT(i, c, e, t, n, !0),
    l
}
function NT(i, e, t={}, n, s, r) {
    let o;
    const a = Zo({
        actions: {}
    }, t)
      , l = {
        deep: !0
    };
    let c, u, d = [], f = [], h;
    const p = n.state.value[i];
    !r && !p && (n.state.value[i] = {}),
    xe({});
    let g;
    function m(L) {
        let T;
        c = u = !1,
        typeof L == "function" ? (L(n.state.value[i]),
        T = {
            type: ld.patchFunction,
            storeId: i,
            events: h
        }) : (jg(n.state.value[i], L),
        T = {
            type: ld.patchObject,
            payload: L,
            storeId: i,
            events: h
        });
        const A = g = Symbol();
        Yd().then( () => {
            g === A && (c = !0)
        }
        ),
        u = !0,
        ql(d, T, n.state.value[i])
    }
    const v = r ? function() {
        const {state: T} = t
          , A = T ? T() : {};
        this.$patch(k => {
            Zo(k, A)
        }
        )
    }
    : UT;
    function _() {
        o.stop(),
        d = [],
        f = [],
        n._s.delete(i)
    }
    const y = (L, T="") => {
        if (Yy in L)
            return L[e0] = T,
            L;
        const A = function() {
            am(n);
            const k = Array.from(arguments)
              , D = []
              , F = [];
            function z(X) {
                D.push(X)
            }
            function G(X) {
                F.push(X)
            }
            ql(f, {
                args: k,
                name: A[e0],
                store: S,
                after: z,
                onError: G
            });
            let H;
            try {
                H = L.apply(this && this.$id === i ? this : S, k)
            } catch (X) {
                throw ql(F, X),
                X
            }
            return H instanceof Promise ? H.then(X => (ql(D, X),
            X)).catch(X => (ql(F, X),
            Promise.reject(X))) : (ql(D, H),
            H)
        };
        return A[Yy] = !0,
        A[e0] = T,
        A
    }
      , b = {
        _p: n,
        $id: i,
        $onAction: Xy.bind(null, f),
        $patch: m,
        $reset: v,
        $subscribe(L, T={}) {
            const A = Xy(d, L, T.detached, () => k())
              , k = o.run( () => Bt( () => n.state.value[i], D => {
                (T.flush === "sync" ? u : c) && L({
                    storeId: i,
                    type: ld.direct,
                    events: h
                }, D)
            }
            , Zo({}, l, T)));
            return A
        },
        $dispose: _
    }
      , S = ei(b);
    n._s.set(i, S);
    const M = (n._a && n._a.runWithContext || OP)( () => n._e.run( () => (o = uw()).run( () => e({
        action: y
    }))));
    for (const L in M) {
        const T = M[L];
        if (Sn(T) && !BP(T) || Io(T))
            r || (p && NP(T) && (Sn(T) ? T.value = p[L] : jg(T, p[L])),
            n.state.value[i][L] = T);
        else if (typeof T == "function") {
            const A = y(T, L);
            M[L] = A,
            a.actions[L] = T
        }
    }
    return Zo(S, M),
    Zo(tn(S), M),
    Object.defineProperty(S, "$state", {
        get: () => n.state.value[i],
        set: L => {
            m(T => {
                Zo(T, L)
            }
            )
        }
    }),
    n._p.forEach(L => {
        Zo(S, o.run( () => L({
            store: S,
            app: n._a,
            pinia: n,
            options: a
        })))
    }
    ),
    p && r && t.hydrate && t.hydrate(S.$state, p),
    c = !0,
    u = !0,
    S
}
/*! #__NO_SIDE_EFFECTS__ */
function Qd(i, e, t) {
    let n, s;
    const r = typeof e == "function";
    typeof i == "string" ? (n = i,
    s = r ? t : e) : (s = i,
    n = i.id);
    function o(a, l) {
        const c = GL();
        return a = a || (c ? Es(OT, null) : null),
        a && am(a),
        a = FT,
        a._s.has(n) || (r ? NT(n, e, s, a) : VP(n, s, a)),
        a._s.get(n)
    }
    return o.$id = n,
    o
}
function Pn(i) {
    {
        const e = tn(i)
          , t = {};
        for (const n in e) {
            const s = e[n];
            (Sn(s) || Io(s)) && (t[n] = gL(i, n))
        }
        return t
    }
}
var pe = typeof window < "u" ? window : void 0
  , rs = typeof globalThis < "u" ? globalThis : pe
  , BT = Array.prototype
  , Zy = BT.forEach
  , Jy = BT.indexOf
  , bs = rs == null ? void 0 : rs.navigator
  , dt = rs == null ? void 0 : rs.document
  , es = rs == null ? void 0 : rs.location
  , Kg = rs == null ? void 0 : rs.fetch
  , Xg = rs != null && rs.XMLHttpRequest && "withCredentials"in new rs.XMLHttpRequest ? rs.XMLHttpRequest : void 0
  , Qy = rs == null ? void 0 : rs.AbortController
  , mi = bs == null ? void 0 : bs.userAgent
  , Gt = pe != null ? pe : {}
  , na = {
    DEBUG: !1,
    LIB_VERSION: "1.190.2"
}
  , tp = {}
  , lm = function(i) {
    return i.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "")
};
function Oc(i, e, t) {
    if (Wn(i)) {
        if (Zy && i.forEach === Zy)
            i.forEach(e, t);
        else if ("length"in i && i.length === +i.length) {
            for (var n = 0, s = i.length; n < s; n++)
                if (n in i && e.call(t, i[n], n) === tp)
                    return
        }
    }
}
function bn(i, e, t) {
    if (!Mn(i)) {
        if (Wn(i))
            return Oc(i, e, t);
        if (qP(i)) {
            for (var n of i.entries())
                if (e.call(t, n[1], n[0]) === tp)
                    return
        } else
            for (var s in i)
                if (HT.call(i, s) && e.call(t, i[s], s) === tp)
                    return
    }
}
var Gi = function(i) {
    for (var e = arguments.length, t = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++)
        t[n - 1] = arguments[n];
    return Oc(t, function(s) {
        for (var r in s)
            s[r] !== void 0 && (i[r] = s[r])
    }),
    i
};
function Zt(i, e) {
    return i.indexOf(e) !== -1
}
function xh(i) {
    for (var e = Object.keys(i), t = e.length, n = new Array(t); t--; )
        n[t] = [e[t], i[e[t]]];
    return n
}
var e2 = function(i) {
    try {
        return i()
    } catch {
        return
    }
}
  , $P = function(i) {
    return function() {
        try {
            for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
                t[n] = arguments[n];
            return i.apply(this, t)
        } catch (s) {
            Fe.critical("Implementation error. Please turn on debug mode and open a ticket on https://app.posthog.com/home#panel=support%3Asupport%3A."),
            Fe.critical(s)
        }
    }
}
  , np = function(i) {
    var e = {};
    return bn(i, function(t, n) {
        Di(t) && t.length > 0 && (e[n] = t)
    }),
    e
}
  , Yg = function(i) {
    return i.replace(/^\$/, "")
};
function HP(i, e) {
    return t = i,
    n = r => Di(r) && !Ia(e) ? r.slice(0, e) : r,
    s = new Set,
    function r(o, a) {
        return o !== Object(o) ? n ? n(o, a) : o : s.has(o) ? void 0 : (s.add(o),
        Wn(o) ? (l = [],
        Oc(o, c => {
            l.push(r(c))
        }
        )) : (l = {},
        bn(o, (c, u) => {
            s.has(c) || (l[u] = r(c, u))
        }
        )),
        l);
        var l
    }(t);
    var t, n, s
}
var zP = function(i) {
    var e, t, n, s, r = "";
    for (e = t = 0,
    n = (i = (i + "").replace(/\r\n/g, `
`).replace(/\r/g, `
`)).length,
    s = 0; s < n; s++) {
        var o = i.charCodeAt(s)
          , a = null;
        o < 128 ? t++ : a = o > 127 && o < 2048 ? String.fromCharCode(o >> 6 | 192, 63 & o | 128) : String.fromCharCode(o >> 12 | 224, o >> 6 & 63 | 128, 63 & o | 128),
        Ia(a) || (t > e && (r += i.substring(e, t)),
        r += a,
        e = t = s + 1)
    }
    return t > e && (r += i.substring(e, i.length)),
    r
}
  , To = function() {
    function i(e) {
        return e && (e.preventDefault = i.preventDefault,
        e.stopPropagation = i.stopPropagation),
        e
    }
    return i.preventDefault = function() {
        this.returnValue = !1
    }
    ,
    i.stopPropagation = function() {
        this.cancelBubble = !0
    }
    ,
    function(e, t, n, s, r) {
        if (e)
            if (e.addEventListener && !s)
                e.addEventListener(t, n, !!r);
            else {
                var o = "on" + t
                  , a = e[o];
                e[o] = function(l, c, u) {
                    return function(d) {
                        if (d = d || i(pe == null ? void 0 : pe.event)) {
                            var f, h = !0;
                            Os(u) && (f = u(d));
                            var p = c.call(l, d);
                            return f !== !1 && p !== !1 || (h = !1),
                            h
                        }
                    }
                }(e, n, a)
            }
        else
            Fe.error("No valid element provided to register_event")
    }
}();
function VT(i, e) {
    for (var t = 0; t < i.length; t++)
        if (e(i[t]))
            return i[t]
}
var cr, t0 = "$copy_autocapture", GP = ["$snapshot", "$pageview", "$pageleave", "$set", "survey dismissed", "survey sent", "survey shown", "$identify", "$groupidentify", "$create_alias", "$$client_ingestion_warning", "$web_experiment_applied", "$feature_enrollment_update", "$feature_flag_called"];
(function(i) {
    i.GZipJS = "gzip-js",
    i.Base64 = "base64"
}
)(cr || (cr = {}));
var WP = Array.isArray
  , $T = Object.prototype
  , HT = $T.hasOwnProperty
  , cm = $T.toString
  , Wn = WP || function(i) {
    return cm.call(i) === "[object Array]"
}
  , Os = i => typeof i == "function"
  , Zn = i => i === Object(i) && !Wn(i)
  , bc = i => {
    if (Zn(i)) {
        for (var e in i)
            if (HT.call(i, e))
                return !1;
        return !0
    }
    return !1
}
  , Et = i => i === void 0
  , Di = i => cm.call(i) == "[object String]"
  , t2 = i => Di(i) && i.trim().length === 0
  , Ia = i => i === null
  , Mn = i => Et(i) || Ia(i)
  , vs = i => cm.call(i) == "[object Number]"
  , cl = i => cm.call(i) === "[object Boolean]"
  , qP = i => i instanceof FormData
  , jP = i => Zt(GP, i)
  , n2 = "[PostHog.js]"
  , Fe = {
    _log: function(i) {
        if (pe && (na.DEBUG || Gt.POSTHOG_DEBUG) && !Et(pe.console) && pe.console) {
            for (var e = ("__rrweb_original__"in pe.console[i]) ? pe.console[i].__rrweb_original__ : pe.console[i], t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), s = 1; s < t; s++)
                n[s - 1] = arguments[s];
            e(n2, ...n)
        }
    },
    info: function() {
        for (var i = arguments.length, e = new Array(i), t = 0; t < i; t++)
            e[t] = arguments[t];
        Fe._log("log", ...e)
    },
    warn: function() {
        for (var i = arguments.length, e = new Array(i), t = 0; t < i; t++)
            e[t] = arguments[t];
        Fe._log("warn", ...e)
    },
    error: function() {
        for (var i = arguments.length, e = new Array(i), t = 0; t < i; t++)
            e[t] = arguments[t];
        Fe._log("error", ...e)
    },
    critical: function() {
        for (var i = arguments.length, e = new Array(i), t = 0; t < i; t++)
            e[t] = arguments[t];
        console.error(n2, ...e)
    },
    uninitializedWarning: i => {
        Fe.error("You must initialize PostHog before calling ".concat(i))
    }
}
  , i2 = (i, e, t) => {
    if (i.config.disable_external_dependency_loading)
        return Fe.warn("".concat(e, " was requested but loading of external scripts is disabled.")),
        t("Loading of external scripts is disabled");
    var n = () => {
        if (!dt)
            return t("document not found");
        var s = dt.createElement("script");
        s.type = "text/javascript",
        s.crossOrigin = "anonymous",
        s.src = e,
        s.onload = a => t(void 0, a),
        s.onerror = a => t(a);
        var r, o = dt.querySelectorAll("body > script");
        o.length > 0 ? (r = o[0].parentNode) === null || r === void 0 || r.insertBefore(s, o[0]) : dt.body.appendChild(s)
    }
    ;
    dt != null && dt.body ? n() : dt == null || dt.addEventListener("DOMContentLoaded", n)
}
;
function s2(i, e) {
    var t = Object.keys(i);
    if (Object.getOwnPropertySymbols) {
        var n = Object.getOwnPropertySymbols(i);
        e && (n = n.filter(function(s) {
            return Object.getOwnPropertyDescriptor(i, s).enumerable
        })),
        t.push.apply(t, n)
    }
    return t
}
function Ze(i) {
    for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e] != null ? arguments[e] : {};
        e % 2 ? s2(Object(t), !0).forEach(function(n) {
            ot(i, n, t[n])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(i, Object.getOwnPropertyDescriptors(t)) : s2(Object(t)).forEach(function(n) {
            Object.defineProperty(i, n, Object.getOwnPropertyDescriptor(t, n))
        })
    }
    return i
}
function ot(i, e, t) {
    return e in i ? Object.defineProperty(i, e, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : i[e] = t,
    i
}
function zT(i, e) {
    if (i == null)
        return {};
    var t, n, s = function(o, a) {
        if (o == null)
            return {};
        var l, c, u = {}, d = Object.keys(o);
        for (c = 0; c < d.length; c++)
            l = d[c],
            a.indexOf(l) >= 0 || (u[l] = o[l]);
        return u
    }(i, e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(i);
        for (n = 0; n < r.length; n++)
            t = r[n],
            e.indexOf(t) >= 0 || Object.prototype.propertyIsEnumerable.call(i, t) && (s[t] = i[t])
    }
    return s
}
Gt.__PosthogExtensions__ = Gt.__PosthogExtensions__ || {},
Gt.__PosthogExtensions__.loadExternalDependency = (i, e, t) => {
    var n = "/static/".concat(e, ".js") + "?v=".concat(i.version);
    if (e === "toolbar") {
        var s = 3e5
          , r = Math.floor(Date.now() / s) * s;
        n = "".concat(n, "&t=").concat(r)
    }
    var o = i.requestRouter.endpointFor("assets", n);
    i2(i, o, t)
}
,
Gt.__PosthogExtensions__.loadSiteApp = (i, e, t) => {
    var n = i.requestRouter.endpointFor("api", e);
    i2(i, n, t)
}
;
var GT = "$people_distinct_id"
  , Wu = "__alias"
  , qu = "__timers"
  , r2 = "$autocapture_disabled_server_side"
  , Zg = "$heatmaps_enabled_server_side"
  , o2 = "$exception_capture_enabled_server_side"
  , a2 = "$web_vitals_enabled_server_side"
  , WT = "$dead_clicks_enabled_server_side"
  , l2 = "$web_vitals_allowed_metrics"
  , Jg = "$session_recording_enabled_server_side"
  , c2 = "$console_log_recording_enabled_server_side"
  , u2 = "$session_recording_network_payload_capture"
  , d2 = "$session_recording_canvas_recording"
  , f2 = "$replay_sample_rate"
  , h2 = "$replay_minimum_duration"
  , ip = "$sesid"
  , ju = "$session_is_sampled"
  , n0 = "$session_recording_url_trigger_activated_session"
  , i0 = "$session_recording_event_trigger_activated_session"
  , Sc = "$enabled_feature_flags"
  , Qg = "$early_access_features"
  , Ec = "$stored_person_properties"
  , ia = "$stored_group_properties"
  , e1 = "$surveys"
  , xf = "$surveys_activated"
  , sp = "$flag_call_reported"
  , mo = "$user_state"
  , t1 = "$client_session_props"
  , n1 = "$capture_rate_limit"
  , i1 = "$initial_campaign_params"
  , s1 = "$initial_referrer_info"
  , r1 = "$initial_person_info"
  , rp = "$epp"
  , qT = "__POSTHOG_TOOLBAR__"
  , KP = [GT, Wu, "__cmpns", qu, Jg, Zg, ip, Sc, mo, Qg, ia, Ec, e1, sp, t1, n1, i1, s1, rp]
  , s0 = "$active_feature_flags"
  , yf = "$override_feature_flags"
  , p2 = "$feature_flag_payloads"
  , m2 = i => {
    var e = {};
    for (var [t,n] of xh(i || {}))
        n && (e[t] = n);
    return e
}
;
class XP {
    constructor(e) {
        this.instance = e,
        this._override_warning = !1,
        this.featureFlagEventHandlers = [],
        this.reloadFeatureFlagsQueued = !1,
        this.reloadFeatureFlagsInAction = !1
    }
    getFlags() {
        return Object.keys(this.getFlagVariants())
    }
    getFlagVariants() {
        var e = this.instance.get_property(Sc)
          , t = this.instance.get_property(yf);
        if (!t)
            return e || {};
        for (var n = Gi({}, e), s = Object.keys(t), r = 0; r < s.length; r++)
            n[s[r]] = t[s[r]];
        return this._override_warning || (Fe.warn(" Overriding feature flags!", {
            enabledFlags: e,
            overriddenFlags: t,
            finalFlags: n
        }),
        this._override_warning = !0),
        n
    }
    getFlagPayloads() {
        return this.instance.get_property(p2) || {}
    }
    reloadFeatureFlags() {
        this.reloadFeatureFlagsQueued || (this.reloadFeatureFlagsQueued = !0,
        this._startReloadTimer())
    }
    setAnonymousDistinctId(e) {
        this.$anon_distinct_id = e
    }
    setReloadingPaused(e) {
        this.reloadFeatureFlagsInAction = e
    }
    resetRequestQueue() {
        this.reloadFeatureFlagsQueued = !1
    }
    _startReloadTimer() {
        this.reloadFeatureFlagsQueued && !this.reloadFeatureFlagsInAction && setTimeout( () => {
            !this.reloadFeatureFlagsInAction && this.reloadFeatureFlagsQueued && (this.reloadFeatureFlagsQueued = !1,
            this._reloadFeatureFlagsRequest())
        }
        , 5)
    }
    _reloadFeatureFlagsRequest() {
        if (!this.instance.config.advanced_disable_feature_flags) {
            this.setReloadingPaused(!0);
            var e = this.instance.config.token
              , t = this.instance.get_property(Ec)
              , n = this.instance.get_property(ia)
              , s = {
                token: e,
                distinct_id: this.instance.get_distinct_id(),
                groups: this.instance.getGroups(),
                $anon_distinct_id: this.$anon_distinct_id,
                person_properties: t,
                group_properties: n,
                disable_flags: this.instance.config.advanced_disable_feature_flags || void 0
            };
            this.instance._send_request({
                method: "POST",
                url: this.instance.requestRouter.endpointFor("api", "/decide/?v=3"),
                data: s,
                compression: this.instance.config.disable_compression ? void 0 : cr.Base64,
                timeout: this.instance.config.feature_flag_request_timeout_ms,
                callback: r => {
                    var o;
                    this.setReloadingPaused(!1);
                    var a = !0;
                    r.statusCode === 200 && (this.$anon_distinct_id = void 0,
                    a = !1),
                    this.receivedFeatureFlags((o = r.json) !== null && o !== void 0 ? o : {}, a),
                    this._startReloadTimer()
                }
            })
        }
    }
    getFeatureFlag(e) {
        var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        if (this.instance.decideEndpointWasHit || this.getFlags() && this.getFlags().length > 0) {
            var n, s = this.getFlagVariants()[e], r = "".concat(s), o = this.instance.get_property(sp) || {};
            return (t.send_event || !("send_event"in t)) && (!(e in o) || !o[e].includes(r)) && (Wn(o[e]) ? o[e].push(r) : o[e] = [r],
            (n = this.instance.persistence) === null || n === void 0 || n.register({
                [sp]: o
            }),
            this.instance.capture("$feature_flag_called", {
                $feature_flag: e,
                $feature_flag_response: s
            })),
            s
        }
        Fe.warn('getFeatureFlag for key "' + e + `" failed. Feature flags didn't load in time.`)
    }
    getFeatureFlagPayload(e) {
        return this.getFlagPayloads()[e]
    }
    isFeatureEnabled(e) {
        var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        if (this.instance.decideEndpointWasHit || this.getFlags() && this.getFlags().length > 0)
            return !!this.getFeatureFlag(e, t);
        Fe.warn('isFeatureEnabled for key "' + e + `" failed. Feature flags didn't load in time.`)
    }
    addFeatureFlagsHandler(e) {
        this.featureFlagEventHandlers.push(e)
    }
    removeFeatureFlagsHandler(e) {
        this.featureFlagEventHandlers = this.featureFlagEventHandlers.filter(t => t !== e)
    }
    receivedFeatureFlags(e, t) {
        if (this.instance.persistence) {
            this.instance.decideEndpointWasHit = !0;
            var n = this.getFlagVariants()
              , s = this.getFlagPayloads();
            (function(r, o) {
                var a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}
                  , l = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}
                  , c = r.featureFlags
                  , u = r.featureFlagPayloads;
                if (c)
                    if (Wn(c)) {
                        var d = {};
                        if (c)
                            for (var f = 0; f < c.length; f++)
                                d[c[f]] = !0;
                        o && o.register({
                            [s0]: c,
                            [Sc]: d
                        })
                    } else {
                        var h = c
                          , p = u;
                        r.errorsWhileComputingFlags && (h = Ze(Ze({}, a), h),
                        p = Ze(Ze({}, l), p)),
                        o && o.register({
                            [s0]: Object.keys(m2(h)),
                            [Sc]: h || {},
                            [p2]: p || {}
                        })
                    }
            }
            )(e, this.instance.persistence, n, s),
            this._fireFeatureFlagsCallbacks(t)
        }
    }
    override(e) {
        var t = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
        if (!this.instance.__loaded || !this.instance.persistence)
            return Fe.uninitializedWarning("posthog.feature_flags.override");
        if (this._override_warning = t,
        e === !1)
            this.instance.persistence.unregister(yf);
        else if (Wn(e)) {
            for (var n = {}, s = 0; s < e.length; s++)
                n[e[s]] = !0;
            this.instance.persistence.register({
                [yf]: n
            })
        } else
            this.instance.persistence.register({
                [yf]: e
            })
    }
    onFeatureFlags(e) {
        if (this.addFeatureFlagsHandler(e),
        this.instance.decideEndpointWasHit) {
            var {flags: t, flagVariants: n} = this._prepareFeatureFlagsForCallbacks();
            e(t, n)
        }
        return () => this.removeFeatureFlagsHandler(e)
    }
    updateEarlyAccessFeatureEnrollment(e, t) {
        var n, s = {
            ["$feature_enrollment/".concat(e)]: t
        };
        this.instance.capture("$feature_enrollment_update", {
            $feature_flag: e,
            $feature_enrollment: t,
            $set: s
        }),
        this.setPersonPropertiesForFlags(s, !1);
        var r = Ze(Ze({}, this.getFlagVariants()), {}, {
            [e]: t
        });
        (n = this.instance.persistence) === null || n === void 0 || n.register({
            [s0]: Object.keys(m2(r)),
            [Sc]: r
        }),
        this._fireFeatureFlagsCallbacks()
    }
    getEarlyAccessFeatures(e) {
        var t = arguments.length > 1 && arguments[1] !== void 0 && arguments[1]
          , n = this.instance.get_property(Qg);
        if (n && !t)
            return e(n);
        this.instance._send_request({
            transport: "XHR",
            url: this.instance.requestRouter.endpointFor("api", "/api/early_access_features/?token=".concat(this.instance.config.token)),
            method: "GET",
            callback: s => {
                var r;
                if (s.json) {
                    var o = s.json.earlyAccessFeatures;
                    return (r = this.instance.persistence) === null || r === void 0 || r.register({
                        [Qg]: o
                    }),
                    e(o)
                }
            }
        })
    }
    _prepareFeatureFlagsForCallbacks() {
        var e = this.getFlags()
          , t = this.getFlagVariants();
        return {
            flags: e.filter(n => t[n]),
            flagVariants: Object.keys(t).filter(n => t[n]).reduce( (n, s) => (n[s] = t[s],
            n), {})
        }
    }
    _fireFeatureFlagsCallbacks(e) {
        var {flags: t, flagVariants: n} = this._prepareFeatureFlagsForCallbacks();
        this.featureFlagEventHandlers.forEach(s => s(t, n, {
            errorsLoading: e
        }))
    }
    setPersonPropertiesForFlags(e) {
        var t = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1]
          , n = this.instance.get_property(Ec) || {};
        this.instance.register({
            [Ec]: Ze(Ze({}, n), e)
        }),
        t && this.instance.reloadFeatureFlags()
    }
    resetPersonPropertiesForFlags() {
        this.instance.unregister(Ec)
    }
    setGroupPropertiesForFlags(e) {
        var t = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1]
          , n = this.instance.get_property(ia) || {};
        Object.keys(n).length !== 0 && Object.keys(n).forEach(s => {
            n[s] = Ze(Ze({}, n[s]), e[s]),
            delete e[s]
        }
        ),
        this.instance.register({
            [ia]: Ze(Ze({}, n), e)
        }),
        t && this.instance.reloadFeatureFlags()
    }
    resetGroupPropertiesForFlags(e) {
        if (e) {
            var t = this.instance.get_property(ia) || {};
            this.instance.register({
                [ia]: Ze(Ze({}, t), {}, {
                    [e]: {}
                })
            })
        } else
            this.instance.unregister(ia)
    }
}
Math.trunc || (Math.trunc = function(i) {
    return i < 0 ? Math.ceil(i) : Math.floor(i)
}
),
Number.isInteger || (Number.isInteger = function(i) {
    return vs(i) && isFinite(i) && Math.floor(i) === i
}
);
var g2 = "0123456789abcdef";
class op {
    constructor(e) {
        if (this.bytes = e,
        e.length !== 16)
            throw new TypeError("not 128-bit length")
    }
    static fromFieldsV7(e, t, n, s) {
        if (!Number.isInteger(e) || !Number.isInteger(t) || !Number.isInteger(n) || !Number.isInteger(s) || e < 0 || t < 0 || n < 0 || s < 0 || e > 0xffffffffffff || t > 4095 || n > 1073741823 || s > 4294967295)
            throw new RangeError("invalid field value");
        var r = new Uint8Array(16);
        return r[0] = e / Math.pow(2, 40),
        r[1] = e / Math.pow(2, 32),
        r[2] = e / Math.pow(2, 24),
        r[3] = e / Math.pow(2, 16),
        r[4] = e / Math.pow(2, 8),
        r[5] = e,
        r[6] = 112 | t >>> 8,
        r[7] = t,
        r[8] = 128 | n >>> 24,
        r[9] = n >>> 16,
        r[10] = n >>> 8,
        r[11] = n,
        r[12] = s >>> 24,
        r[13] = s >>> 16,
        r[14] = s >>> 8,
        r[15] = s,
        new op(r)
    }
    toString() {
        for (var e = "", t = 0; t < this.bytes.length; t++)
            e = e + g2.charAt(this.bytes[t] >>> 4) + g2.charAt(15 & this.bytes[t]),
            t !== 3 && t !== 5 && t !== 7 && t !== 9 || (e += "-");
        if (e.length !== 36)
            throw new Error("Invalid UUIDv7 was generated");
        return e
    }
    clone() {
        return new op(this.bytes.slice(0))
    }
    equals(e) {
        return this.compareTo(e) === 0
    }
    compareTo(e) {
        for (var t = 0; t < 16; t++) {
            var n = this.bytes[t] - e.bytes[t];
            if (n !== 0)
                return Math.sign(n)
        }
        return 0
    }
}
class YP {
    constructor() {
        ot(this, "timestamp", 0),
        ot(this, "counter", 0),
        ot(this, "random", new ZP)
    }
    generate() {
        var e = this.generateOrAbort();
        if (Et(e)) {
            this.timestamp = 0;
            var t = this.generateOrAbort();
            if (Et(t))
                throw new Error("Could not generate UUID after timestamp reset");
            return t
        }
        return e
    }
    generateOrAbort() {
        var e = Date.now();
        if (e > this.timestamp)
            this.timestamp = e,
            this.resetCounter();
        else {
            if (!(e + 1e4 > this.timestamp))
                return;
            this.counter++,
            this.counter > 4398046511103 && (this.timestamp++,
            this.resetCounter())
        }
        return op.fromFieldsV7(this.timestamp, Math.trunc(this.counter / Math.pow(2, 30)), this.counter & Math.pow(2, 30) - 1, this.random.nextUint32())
    }
    resetCounter() {
        this.counter = 1024 * this.random.nextUint32() + (1023 & this.random.nextUint32())
    }
}
var v2, jT = i => {
    if (typeof UUIDV7_DENY_WEAK_RNG < "u" && UUIDV7_DENY_WEAK_RNG)
        throw new Error("no cryptographically strong RNG available");
    for (var e = 0; e < i.length; e++)
        i[e] = 65536 * Math.trunc(65536 * Math.random()) + Math.trunc(65536 * Math.random());
    return i
}
;
pe && !Et(pe.crypto) && crypto.getRandomValues && (jT = i => crypto.getRandomValues(i));
class ZP {
    constructor() {
        ot(this, "buffer", new Uint32Array(8)),
        ot(this, "cursor", 1 / 0)
    }
    nextUint32() {
        return this.cursor >= this.buffer.length && (jT(this.buffer),
        this.cursor = 0),
        this.buffer[this.cursor++]
    }
}
var la = () => JP().toString()
  , JP = () => (v2 || (v2 = new YP)).generate()
  , QP = "Thu, 01 Jan 1970 00:00:00 GMT"
  , Iu = ""
  , eD = /[a-z0-9][a-z0-9-]+\.[a-z]{2,}$/i;
function tD(i, e) {
    if (e) {
        var t = function(s) {
            var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : dt;
            if (Iu)
                return Iu;
            if (!r || ["localhost", "127.0.0.1"].includes(s))
                return "";
            for (var o = s.split("."), a = Math.min(o.length, 8), l = "dmn_chk_" + la(), c = new RegExp("(^|;)\\s*" + l + "=1"); !Iu && a--; ) {
                var u = o.slice(a).join(".")
                  , d = l + "=1;domain=." + u;
                r.cookie = d,
                c.test(r.cookie) && (r.cookie = d + ";expires=" + QP,
                Iu = u)
            }
            return Iu
        }(i);
        if (!t) {
            var n = (s => {
                var r = s.match(eD);
                return r ? r[0] : ""
            }
            )(i);
            n !== t && Fe.info("Warning: cookie subdomain discovery mismatch", n, t),
            t = n
        }
        return t ? "; domain=." + t : ""
    }
    return ""
}
var Po = {
    is_supported: () => !!dt,
    error: function(i) {
        Fe.error("cookieStore error: " + i)
    },
    get: function(i) {
        if (dt) {
            try {
                for (var e = i + "=", t = dt.cookie.split(";").filter(r => r.length), n = 0; n < t.length; n++) {
                    for (var s = t[n]; s.charAt(0) == " "; )
                        s = s.substring(1, s.length);
                    if (s.indexOf(e) === 0)
                        return decodeURIComponent(s.substring(e.length, s.length))
                }
            } catch {}
            return null
        }
    },
    parse: function(i) {
        var e;
        try {
            e = JSON.parse(Po.get(i)) || {}
        } catch {}
        return e
    },
    set: function(i, e, t, n, s) {
        if (dt)
            try {
                var r = ""
                  , o = ""
                  , a = tD(dt.location.hostname, n);
                if (t) {
                    var l = new Date;
                    l.setTime(l.getTime() + 24 * t * 60 * 60 * 1e3),
                    r = "; expires=" + l.toUTCString()
                }
                s && (o = "; secure");
                var c = i + "=" + encodeURIComponent(JSON.stringify(e)) + r + "; SameSite=Lax; path=/" + a + o;
                return c.length > 3686.4 && Fe.warn("cookieStore warning: large cookie, len=" + c.length),
                dt.cookie = c,
                c
            } catch {
                return
            }
    },
    remove: function(i, e) {
        try {
            Po.set(i, "", -1, e)
        } catch {
            return
        }
    }
}
  , r0 = null
  , ri = {
    is_supported: function() {
        if (!Ia(r0))
            return r0;
        var i = !0;
        if (Et(pe))
            i = !1;
        else
            try {
                var e = "__mplssupport__";
                ri.set(e, "xyz"),
                ri.get(e) !== '"xyz"' && (i = !1),
                ri.remove(e)
            } catch {
                i = !1
            }
        return i || Fe.error("localStorage unsupported; falling back to cookie store"),
        r0 = i,
        i
    },
    error: function(i) {
        Fe.error("localStorage error: " + i)
    },
    get: function(i) {
        try {
            return pe == null ? void 0 : pe.localStorage.getItem(i)
        } catch (e) {
            ri.error(e)
        }
        return null
    },
    parse: function(i) {
        try {
            return JSON.parse(ri.get(i)) || {}
        } catch {}
        return null
    },
    set: function(i, e) {
        try {
            pe == null || pe.localStorage.setItem(i, JSON.stringify(e))
        } catch (t) {
            ri.error(t)
        }
    },
    remove: function(i) {
        try {
            pe == null || pe.localStorage.removeItem(i)
        } catch (e) {
            ri.error(e)
        }
    }
}
  , nD = ["distinct_id", ip, ju, rp, r1]
  , bf = Ze(Ze({}, ri), {}, {
    parse: function(i) {
        try {
            var e = {};
            try {
                e = Po.parse(i) || {}
            } catch {}
            var t = Gi(e, JSON.parse(ri.get(i) || "{}"));
            return ri.set(i, t),
            t
        } catch {}
        return null
    },
    set: function(i, e, t, n, s, r) {
        try {
            ri.set(i, e, void 0, void 0, r);
            var o = {};
            nD.forEach(a => {
                e[a] && (o[a] = e[a])
            }
            ),
            Object.keys(o).length && Po.set(i, o, t, n, s, r)
        } catch (a) {
            ri.error(a)
        }
    },
    remove: function(i, e) {
        try {
            pe == null || pe.localStorage.removeItem(i),
            Po.remove(i, e)
        } catch (t) {
            ri.error(t)
        }
    }
})
  , Sf = {}
  , iD = {
    is_supported: function() {
        return !0
    },
    error: function(i) {
        Fe.error("memoryStorage error: " + i)
    },
    get: function(i) {
        return Sf[i] || null
    },
    parse: function(i) {
        return Sf[i] || null
    },
    set: function(i, e) {
        Sf[i] = e
    },
    remove: function(i) {
        delete Sf[i]
    }
}
  , Ba = null
  , wi = {
    is_supported: function() {
        if (!Ia(Ba))
            return Ba;
        if (Ba = !0,
        Et(pe))
            Ba = !1;
        else
            try {
                var i = "__support__";
                wi.set(i, "xyz"),
                wi.get(i) !== '"xyz"' && (Ba = !1),
                wi.remove(i)
            } catch {
                Ba = !1
            }
        return Ba
    },
    error: function(i) {
        Fe.error("sessionStorage error: ", i)
    },
    get: function(i) {
        try {
            return pe == null ? void 0 : pe.sessionStorage.getItem(i)
        } catch (e) {
            wi.error(e)
        }
        return null
    },
    parse: function(i) {
        try {
            return JSON.parse(wi.get(i)) || null
        } catch {}
        return null
    },
    set: function(i, e) {
        try {
            pe == null || pe.sessionStorage.setItem(i, JSON.stringify(e))
        } catch (t) {
            wi.error(t)
        }
    },
    remove: function(i) {
        try {
            pe == null || pe.sessionStorage.removeItem(i)
        } catch (e) {
            wi.error(e)
        }
    }
}
  , sD = ["localhost", "127.0.0.1"]
  , Uc = i => {
    var e = dt == null ? void 0 : dt.createElement("a");
    return Et(e) ? null : (e.href = i,
    e)
}
  , tu = function(i, e) {
    return !!function(t) {
        try {
            new RegExp(t)
        } catch {
            return !1
        }
        return !0
    }(e) && new RegExp(e).test(i)
}
  , rD = function(i) {
    var e, t, n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "&", s = [];
    return bn(i, function(r, o) {
        Et(r) || Et(o) || o === "undefined" || (e = encodeURIComponent((a => a instanceof File)(r) ? r.name : r.toString()),
        t = encodeURIComponent(o),
        s[s.length] = t + "=" + e)
    }),
    s.join(n)
}
  , ap = function(i, e) {
    for (var t, n = ((i.split("#")[0] || "").split("?")[1] || "").split("&"), s = 0; s < n.length; s++) {
        var r = n[s].split("=");
        if (r[0] === e) {
            t = r;
            break
        }
    }
    if (!Wn(t) || t.length < 2)
        return "";
    var o = t[1];
    try {
        o = decodeURIComponent(o)
    } catch {
        Fe.error("Skipping decoding for malformed query param: " + o)
    }
    return o.replace(/\+/g, " ")
}
  , lp = function(i, e) {
    var t = i.match(new RegExp(e + "=([^&]*)"));
    return t ? t[1] : null
}
  , Hs = "Mobile"
  , cp = "iOS"
  , Or = "Android"
  , Md = "Tablet"
  , KT = Or + " " + Md
  , XT = "iPad"
  , YT = "Apple"
  , ZT = YT + " Watch"
  , Rd = "Safari"
  , nu = "BlackBerry"
  , JT = "Samsung"
  , QT = JT + "Browser"
  , eA = JT + " Internet"
  , ma = "Chrome"
  , oD = ma + " OS"
  , tA = ma + " " + cp
  , w_ = "Internet Explorer"
  , nA = w_ + " " + Hs
  , T_ = "Opera"
  , aD = T_ + " Mini"
  , A_ = "Edge"
  , iA = "Microsoft " + A_
  , Nc = "Firefox"
  , sA = Nc + " " + cp
  , Ld = "Nintendo"
  , Id = "PlayStation"
  , Bc = "Xbox"
  , rA = Or + " " + Hs
  , oA = Hs + " " + Rd
  , Ku = "Windows"
  , o1 = Ku + " Phone"
  , _2 = "Nokia"
  , a1 = "Ouya"
  , aA = "Generic"
  , lD = aA + " " + Hs.toLowerCase()
  , lA = aA + " " + Md.toLowerCase()
  , l1 = "Konqueror"
  , Bi = "(\\d+(\\.\\d+)?)"
  , o0 = new RegExp("Version/" + Bi)
  , cD = new RegExp(Bc,"i")
  , uD = new RegExp(Id + " \\w+","i")
  , dD = new RegExp(Ld + " \\w+","i")
  , C_ = new RegExp(nu + "|PlayBook|BB10","i")
  , fD = {
    "NT3.51": "NT 3.11",
    "NT4.0": "NT 4.0",
    "5.0": "2000",
    5.1: "XP",
    5.2: "XP",
    "6.0": "Vista",
    6.1: "7",
    6.2: "8",
    6.3: "8.1",
    6.4: "10",
    "10.0": "10"
}
  , hD = (i, e) => e && Zt(e, YT) || function(t) {
    return Zt(t, Rd) && !Zt(t, ma) && !Zt(t, Or)
}(i)
  , x2 = function(i, e) {
    return e = e || "",
    Zt(i, " OPR/") && Zt(i, "Mini") ? aD : Zt(i, " OPR/") ? T_ : C_.test(i) ? nu : Zt(i, "IE" + Hs) || Zt(i, "WPDesktop") ? nA : Zt(i, QT) ? eA : Zt(i, A_) || Zt(i, "Edg/") ? iA : Zt(i, "FBIOS") ? "Facebook " + Hs : Zt(i, "UCWEB") || Zt(i, "UCBrowser") ? "UC Browser" : Zt(i, "CriOS") ? tA : Zt(i, "CrMo") ? ma : Zt(i, Or) && Zt(i, Rd) ? rA : Zt(i, ma) ? ma : Zt(i, "FxiOS") ? sA : Zt(i.toLowerCase(), l1.toLowerCase()) ? l1 : hD(i, e) ? Zt(i, Hs) ? oA : Rd : Zt(i, Nc) ? Nc : Zt(i, "MSIE") || Zt(i, "Trident/") ? w_ : Zt(i, "Gecko") ? Nc : ""
}
  , pD = {
    [nA]: [new RegExp("rv:" + Bi)],
    [iA]: [new RegExp(A_ + "?\\/" + Bi)],
    [ma]: [new RegExp("(" + ma + "|CrMo)\\/" + Bi)],
    [tA]: [new RegExp("CriOS\\/" + Bi)],
    "UC Browser": [new RegExp("(UCBrowser|UCWEB)\\/" + Bi)],
    [Rd]: [o0],
    [oA]: [o0],
    [T_]: [new RegExp("(Opera|OPR)\\/" + Bi)],
    [Nc]: [new RegExp(Nc + "\\/" + Bi)],
    [sA]: [new RegExp("FxiOS\\/" + Bi)],
    [l1]: [new RegExp("Konqueror[:/]?" + Bi,"i")],
    [nu]: [new RegExp(nu + " " + Bi), o0],
    [rA]: [new RegExp("android\\s" + Bi,"i")],
    [eA]: [new RegExp(QT + "\\/" + Bi)],
    [w_]: [new RegExp("(rv:|MSIE )" + Bi)],
    Mozilla: [new RegExp("rv:" + Bi)]
}
  , y2 = [[new RegExp(Bc + "; " + Bc + " (.*?)[);]","i"), i => [Bc, i && i[1] || ""]], [new RegExp(Ld,"i"), [Ld, ""]], [new RegExp(Id,"i"), [Id, ""]], [C_, [nu, ""]], [new RegExp(Ku,"i"), (i, e) => {
    if (/Phone/.test(e) || /WPDesktop/.test(e))
        return [o1, ""];
    if (new RegExp(Hs).test(e) && !/IEMobile\b/.test(e))
        return [Ku + " " + Hs, ""];
    var t = /Windows NT ([0-9.]+)/i.exec(e);
    if (t && t[1]) {
        var n = t[1]
          , s = fD[n] || "";
        return /arm/i.test(e) && (s = "RT"),
        [Ku, s]
    }
    return [Ku, ""]
}
], [/((iPhone|iPad|iPod).*?OS (\d+)_(\d+)_?(\d+)?|iPhone)/, i => {
    if (i && i[3]) {
        var e = [i[3], i[4], i[5] || "0"];
        return [cp, e.join(".")]
    }
    return [cp, ""]
}
], [/(watch.*\/(\d+\.\d+\.\d+)|watch os,(\d+\.\d+),)/i, i => {
    var e = "";
    return i && i.length >= 3 && (e = Et(i[2]) ? i[3] : i[2]),
    ["watchOS", e]
}
], [new RegExp("(" + Or + " (\\d+)\\.(\\d+)\\.?(\\d+)?|" + Or + ")","i"), i => {
    if (i && i[2]) {
        var e = [i[2], i[3], i[4] || "0"];
        return [Or, e.join(".")]
    }
    return [Or, ""]
}
], [/Mac OS X (\d+)[_.](\d+)[_.]?(\d+)?/i, i => {
    var e = ["Mac OS X", ""];
    if (i && i[1]) {
        var t = [i[1], i[2], i[3] || "0"];
        e[1] = t.join(".")
    }
    return e
}
], [/Mac/i, ["Mac OS X", ""]], [/CrOS/, [oD, ""]], [/Linux|debian/i, ["Linux", ""]]]
  , b2 = function(i) {
    return dD.test(i) ? Ld : uD.test(i) ? Id : cD.test(i) ? Bc : new RegExp(a1,"i").test(i) ? a1 : new RegExp("(" + o1 + "|WPDesktop)","i").test(i) ? o1 : /iPad/.test(i) ? XT : /iPod/.test(i) ? "iPod Touch" : /iPhone/.test(i) ? "iPhone" : /(watch)(?: ?os[,/]|\d,\d\/)[\d.]+/i.test(i) ? ZT : C_.test(i) ? nu : /(kobo)\s(ereader|touch)/i.test(i) ? "Kobo" : new RegExp(_2,"i").test(i) ? _2 : /(kf[a-z]{2}wi|aeo[c-r]{2})( bui|\))/i.test(i) || /(kf[a-z]+)( bui|\)).+silk\//i.test(i) ? "Kindle Fire" : /(Android|ZTE)/i.test(i) ? !new RegExp(Hs).test(i) || /(9138B|TB782B|Nexus [97]|pixel c|HUAWEISHT|BTV|noble nook|smart ultra 6)/i.test(i) ? /pixel[\daxl ]{1,6}/i.test(i) && !/pixel c/i.test(i) || /(huaweimed-al00|tah-|APA|SM-G92|i980|zte|U304AA)/i.test(i) || /lmy47v/i.test(i) && !/QTAQZ3/i.test(i) ? Or : KT : Or : new RegExp("(pda|" + Hs + ")","i").test(i) ? lD : new RegExp(Md,"i").test(i) && !new RegExp(Md + " pc","i").test(i) ? lA : ""
}
  , Ef = "https?://(.*)"
  , mD = ["utm_source", "utm_medium", "utm_campaign", "utm_content", "utm_term", "gclid", "gad_source", "gclsrc", "dclid", "gbraid", "wbraid", "fbclid", "msclkid", "twclid", "li_fat_id", "mc_cid", "igshid", "ttclid", "rdt_cid"]
  , Xn = {
    campaignParams: function(i) {
        return dt ? this._campaignParamsFromUrl(dt.URL, i) : {}
    },
    _campaignParamsFromUrl: function(i, e) {
        var t = mD.concat(e || [])
          , n = {};
        return bn(t, function(s) {
            var r = ap(i, s);
            n[s] = r || null
        }),
        n
    },
    _searchEngine: function(i) {
        return i ? i.search(Ef + "google.([^/?]*)") === 0 ? "google" : i.search(Ef + "bing.com") === 0 ? "bing" : i.search(Ef + "yahoo.com") === 0 ? "yahoo" : i.search(Ef + "duckduckgo.com") === 0 ? "duckduckgo" : null : null
    },
    _searchInfoFromReferrer: function(i) {
        var e = Xn._searchEngine(i)
          , t = e != "yahoo" ? "q" : "p"
          , n = {};
        if (!Ia(e)) {
            n.$search_engine = e;
            var s = dt ? ap(dt.referrer, t) : "";
            s.length && (n.ph_keyword = s)
        }
        return n
    },
    searchInfo: function() {
        var i = dt == null ? void 0 : dt.referrer;
        return i ? this._searchInfoFromReferrer(i) : {}
    },
    browser: x2,
    browserVersion: function(i, e) {
        var t = x2(i, e)
          , n = pD[t];
        if (Et(n))
            return null;
        for (var s = 0; s < n.length; s++) {
            var r = n[s]
              , o = i.match(r);
            if (o)
                return parseFloat(o[o.length - 2])
        }
        return null
    },
    browserLanguage: function() {
        return navigator.language || navigator.userLanguage
    },
    os: function(i) {
        for (var e = 0; e < y2.length; e++) {
            var [t,n] = y2[e]
              , s = t.exec(i)
              , r = s && (Os(n) ? n(s, i) : n);
            if (r)
                return r
        }
        return ["", ""]
    },
    device: b2,
    deviceType: function(i) {
        var e = b2(i);
        return e === XT || e === KT || e === "Kobo" || e === "Kindle Fire" || e === lA ? Md : e === Ld || e === Bc || e === Id || e === a1 ? "Console" : e === ZT ? "Wearable" : e ? Hs : "Desktop"
    },
    referrer: function() {
        return (dt == null ? void 0 : dt.referrer) || "$direct"
    },
    referringDomain: function() {
        var i;
        return dt != null && dt.referrer && ((i = Uc(dt.referrer)) === null || i === void 0 ? void 0 : i.host) || "$direct"
    },
    referrerInfo: function() {
        return {
            $referrer: this.referrer(),
            $referring_domain: this.referringDomain()
        }
    },
    initialPersonInfo: function() {
        return {
            r: this.referrer().substring(0, 1e3),
            u: es == null ? void 0 : es.href.substring(0, 1e3)
        }
    },
    initialPersonPropsFromInfo: function(i) {
        var e, {r: t, u: n} = i, s = {
            $initial_referrer: t,
            $initial_referring_domain: t == null ? void 0 : t == "$direct" ? "$direct" : (e = Uc(t)) === null || e === void 0 ? void 0 : e.host
        };
        if (n) {
            s.$initial_current_url = n;
            var r = Uc(n);
            s.$initial_host = r == null ? void 0 : r.host,
            s.$initial_pathname = r == null ? void 0 : r.pathname,
            bn(this._campaignParamsFromUrl(n), function(o, a) {
                s["$initial_" + Yg(a)] = o
            })
        }
        return t && bn(this._searchInfoFromReferrer(t), function(o, a) {
            s["$initial_" + Yg(a)] = o
        }),
        s
    },
    timezone: function() {
        try {
            return Intl.DateTimeFormat().resolvedOptions().timeZone
        } catch {
            return
        }
    },
    properties: function() {
        if (!mi)
            return {};
        var [i,e] = Xn.os(mi);
        return Gi(np({
            $os: i,
            $os_version: e,
            $browser: Xn.browser(mi, navigator.vendor),
            $device: Xn.device(mi),
            $device_type: Xn.deviceType(mi),
            $timezone: Xn.timezone()
        }), {
            $current_url: es == null ? void 0 : es.href,
            $host: es == null ? void 0 : es.host,
            $pathname: es == null ? void 0 : es.pathname,
            $raw_user_agent: mi.length > 1e3 ? mi.substring(0, 997) + "..." : mi,
            $browser_version: Xn.browserVersion(mi, navigator.vendor),
            $browser_language: Xn.browserLanguage(),
            $screen_height: pe == null ? void 0 : pe.screen.height,
            $screen_width: pe == null ? void 0 : pe.screen.width,
            $viewport_height: pe == null ? void 0 : pe.innerHeight,
            $viewport_width: pe == null ? void 0 : pe.innerWidth,
            $lib: "web",
            $lib_version: na.LIB_VERSION,
            $insert_id: Math.random().toString(36).substring(2, 10) + Math.random().toString(36).substring(2, 10),
            $time: Date.now() / 1e3
        })
    },
    people_properties: function() {
        if (!mi)
            return {};
        var [i,e] = Xn.os(mi);
        return Gi(np({
            $os: i,
            $os_version: e,
            $browser: Xn.browser(mi, navigator.vendor)
        }), {
            $browser_version: Xn.browserVersion(mi, navigator.vendor)
        })
    }
}
  , gD = ["cookie", "localstorage", "localstorage+cookie", "sessionstorage", "memory"];
class a0 {
    constructor(e) {
        this.config = e,
        this.props = {},
        this.campaign_params_saved = !1,
        this.name = (t => {
            var n = "";
            return t.token && (n = t.token.replace(/\+/g, "PL").replace(/\//g, "SL").replace(/=/g, "EQ")),
            t.persistence_name ? "ph_" + t.persistence_name : "ph_" + n + "_posthog"
        }
        )(e),
        this.storage = this.buildStorage(e),
        this.load(),
        e.debug && Fe.info("Persistence loaded", e.persistence, Ze({}, this.props)),
        this.update_config(e, e),
        this.save()
    }
    buildStorage(e) {
        gD.indexOf(e.persistence.toLowerCase()) === -1 && (Fe.critical("Unknown persistence type " + e.persistence + "; falling back to localStorage+cookie"),
        e.persistence = "localStorage+cookie");
        var t = e.persistence.toLowerCase();
        return t === "localstorage" && ri.is_supported() ? ri : t === "localstorage+cookie" && bf.is_supported() ? bf : t === "sessionstorage" && wi.is_supported() ? wi : t === "memory" ? iD : t === "cookie" ? Po : bf.is_supported() ? bf : Po
    }
    properties() {
        var e = {};
        return bn(this.props, function(t, n) {
            if (n === Sc && Zn(t))
                for (var s = Object.keys(t), r = 0; r < s.length; r++)
                    e["$feature/".concat(s[r])] = t[s[r]];
            else
                a = n,
                l = !1,
                (Ia(o = KP) ? l : Jy && o.indexOf === Jy ? o.indexOf(a) != -1 : (bn(o, function(c) {
                    if (l || (l = c === a))
                        return tp
                }),
                l)) || (e[n] = t);
            var o, a, l
        }),
        e
    }
    load() {
        if (!this.disabled) {
            var e = this.storage.parse(this.name);
            e && (this.props = Gi({}, e))
        }
    }
    save() {
        this.disabled || this.storage.set(this.name, this.props, this.expire_days, this.cross_subdomain, this.secure, this.config.debug)
    }
    remove() {
        this.storage.remove(this.name, !1),
        this.storage.remove(this.name, !0)
    }
    clear() {
        this.remove(),
        this.props = {}
    }
    register_once(e, t, n) {
        if (Zn(e)) {
            Et(t) && (t = "None"),
            this.expire_days = Et(n) ? this.default_expiry : n;
            var s = !1;
            if (bn(e, (r, o) => {
                this.props.hasOwnProperty(o) && this.props[o] !== t || (this.props[o] = r,
                s = !0)
            }
            ),
            s)
                return this.save(),
                !0
        }
        return !1
    }
    register(e, t) {
        if (Zn(e)) {
            this.expire_days = Et(t) ? this.default_expiry : t;
            var n = !1;
            if (bn(e, (s, r) => {
                e.hasOwnProperty(r) && this.props[r] !== s && (this.props[r] = s,
                n = !0)
            }
            ),
            n)
                return this.save(),
                !0
        }
        return !1
    }
    unregister(e) {
        e in this.props && (delete this.props[e],
        this.save())
    }
    update_campaign_params() {
        if (!this.campaign_params_saved) {
            var e = Xn.campaignParams(this.config.custom_campaign_params);
            bc(np(e)) || this.register(e),
            this.campaign_params_saved = !0
        }
    }
    update_search_keyword() {
        this.register(Xn.searchInfo())
    }
    update_referrer_info() {
        this.register_once(Xn.referrerInfo(), void 0)
    }
    set_initial_person_info() {
        this.props[i1] || this.props[s1] || this.register_once({
            [r1]: Xn.initialPersonInfo()
        }, void 0)
    }
    get_referrer_info() {
        return np({
            $referrer: this.props.$referrer,
            $referring_domain: this.props.$referring_domain
        })
    }
    get_initial_props() {
        var e = {};
        bn([s1, i1], s => {
            var r = this.props[s];
            r && bn(r, function(o, a) {
                e["$initial_" + Yg(a)] = o
            })
        }
        );
        var t = this.props[r1];
        if (t) {
            var n = Xn.initialPersonPropsFromInfo(t);
            Gi(e, n)
        }
        return e
    }
    safe_merge(e) {
        return bn(this.props, function(t, n) {
            n in e || (e[n] = t)
        }),
        e
    }
    update_config(e, t) {
        if (this.default_expiry = this.expire_days = e.cookie_expiration,
        this.set_disabled(e.disable_persistence),
        this.set_cross_subdomain(e.cross_subdomain_cookie),
        this.set_secure(e.secure_cookie),
        e.persistence !== t.persistence) {
            var n = this.buildStorage(e)
              , s = this.props;
            this.clear(),
            this.storage = n,
            this.props = s,
            this.save()
        }
    }
    set_disabled(e) {
        this.disabled = e,
        this.disabled ? this.remove() : this.save()
    }
    set_cross_subdomain(e) {
        e !== this.cross_subdomain && (this.cross_subdomain = e,
        this.remove(),
        this.save())
    }
    get_cross_subdomain() {
        return !!this.cross_subdomain
    }
    set_secure(e) {
        e !== this.secure && (this.secure = e,
        this.remove(),
        this.save())
    }
    set_event_timer(e, t) {
        var n = this.props[qu] || {};
        n[e] = t,
        this.props[qu] = n,
        this.save()
    }
    remove_event_timer(e) {
        var t = (this.props[qu] || {})[e];
        return Et(t) || (delete this.props[qu][e],
        this.save()),
        t
    }
    get_property(e) {
        return this.props[e]
    }
    set_property(e, t) {
        this.props[e] = t,
        this.save()
    }
}
function up(i) {
    var e, t;
    return ((e = JSON.stringify(i, (t = [],
    function(n, s) {
        if (Zn(s)) {
            for (; t.length > 0 && t[t.length - 1] !== this; )
                t.pop();
            return t.includes(s) ? "[Circular]" : (t.push(s),
            s)
        }
        return s
    }
    ))) === null || e === void 0 ? void 0 : e.length) || 0
}
function c1(i) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66060288e-1;
    if (i.size >= e && i.data.length > 1) {
        var t = Math.floor(i.data.length / 2)
          , n = i.data.slice(0, t)
          , s = i.data.slice(t);
        return [c1({
            size: up(n),
            data: n,
            sessionId: i.sessionId,
            windowId: i.windowId
        }), c1({
            size: up(s),
            data: s,
            sessionId: i.sessionId,
            windowId: i.windowId
        })].flatMap(r => r)
    }
    return [i]
}
var go = (i => (i[i.DomContentLoaded = 0] = "DomContentLoaded",
i[i.Load = 1] = "Load",
i[i.FullSnapshot = 2] = "FullSnapshot",
i[i.IncrementalSnapshot = 3] = "IncrementalSnapshot",
i[i.Meta = 4] = "Meta",
i[i.Custom = 5] = "Custom",
i[i.Plugin = 6] = "Plugin",
i))(go || {})
  , sr = (i => (i[i.Mutation = 0] = "Mutation",
i[i.MouseMove = 1] = "MouseMove",
i[i.MouseInteraction = 2] = "MouseInteraction",
i[i.Scroll = 3] = "Scroll",
i[i.ViewportResize = 4] = "ViewportResize",
i[i.Input = 5] = "Input",
i[i.TouchMove = 6] = "TouchMove",
i[i.MediaInteraction = 7] = "MediaInteraction",
i[i.StyleSheetRule = 8] = "StyleSheetRule",
i[i.CanvasMutation = 9] = "CanvasMutation",
i[i.Font = 10] = "Font",
i[i.Log = 11] = "Log",
i[i.Drag = 12] = "Drag",
i[i.StyleDeclaration = 13] = "StyleDeclaration",
i[i.Selection = 14] = "Selection",
i[i.AdoptedStyleSheet = 15] = "AdoptedStyleSheet",
i[i.CustomElement = 16] = "CustomElement",
i))(sr || {});
function S2(i) {
    var e;
    return i.id === qT || !((e = i.closest) === null || e === void 0 || !e.call(i, ".toolbar-global-fade-container"))
}
function um(i) {
    return !!i && i.nodeType === 1
}
function ga(i, e) {
    return !!i && !!i.tagName && i.tagName.toLowerCase() === e.toLowerCase()
}
function cA(i) {
    return !!i && i.nodeType === 3
}
function uA(i) {
    return !!i && i.nodeType === 11
}
function M_(i) {
    return i ? lm(i).split(/\s+/) : []
}
function E2(i) {
    var e = pe == null ? void 0 : pe.location.href;
    return !!(e && i && i.some(t => e.match(t)))
}
function dp(i) {
    var e = "";
    switch (typeof i.className) {
    case "string":
        e = i.className;
        break;
    case "object":
        e = (i.className && "baseVal"in i.className ? i.className.baseVal : null) || i.getAttribute("class") || "";
        break;
    default:
        e = ""
    }
    return M_(e)
}
function dA(i) {
    return Mn(i) ? null : lm(i).split(/(\s+)/).filter(e => iu(e)).join("").replace(/[\r\n]/g, " ").replace(/[ ]+/g, " ").substring(0, 255)
}
function dm(i) {
    var e = "";
    return d1(i) && !pA(i) && i.childNodes && i.childNodes.length && bn(i.childNodes, function(t) {
        var n;
        cA(t) && t.textContent && (e += (n = dA(t.textContent)) !== null && n !== void 0 ? n : "")
    }),
    lm(e)
}
function fA(i) {
    return Et(i.target) ? i.srcElement || null : (e = i.target) !== null && e !== void 0 && e.shadowRoot ? i.composedPath()[0] || null : i.target || null;
    var e
}
var u1 = ["a", "button", "form", "input", "select", "textarea", "label"];
function hA(i) {
    var e = i.parentNode;
    return !(!e || !um(e)) && e
}
function vD(i, e) {
    var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0
      , n = arguments.length > 3 ? arguments[3] : void 0
      , s = arguments.length > 4 ? arguments[4] : void 0;
    if (!pe || !i || ga(i, "html") || !um(i) || t != null && t.url_allowlist && !E2(t.url_allowlist) || t != null && t.url_ignorelist && E2(t.url_ignorelist))
        return !1;
    if (t != null && t.dom_event_allowlist) {
        var r = t.dom_event_allowlist;
        if (r && !r.some(h => e.type === h))
            return !1
    }
    for (var o = !1, a = [i], l = !0, c = i; c.parentNode && !ga(c, "body"); )
        if (uA(c.parentNode))
            a.push(c.parentNode.host),
            c = c.parentNode.host;
        else {
            if (!(l = hA(c)))
                break;
            if (n || u1.indexOf(l.tagName.toLowerCase()) > -1)
                o = !0;
            else {
                var u = pe.getComputedStyle(l);
                u && u.getPropertyValue("cursor") === "pointer" && (o = !0)
            }
            a.push(l),
            c = l
        }
    if (!function(h, p) {
        var g = p == null ? void 0 : p.element_allowlist;
        if (Et(g))
            return !0;
        var m = function(y) {
            if (g.some(b => y.tagName.toLowerCase() === b))
                return {
                    v: !0
                }
        };
        for (var v of h) {
            var _ = m(v);
            if (typeof _ == "object")
                return _.v
        }
        return !1
    }(a, t) || !function(h, p) {
        var g = p == null ? void 0 : p.css_selector_allowlist;
        if (Et(g))
            return !0;
        var m = function(y) {
            if (g.some(b => y.matches(b)))
                return {
                    v: !0
                }
        };
        for (var v of h) {
            var _ = m(v);
            if (typeof _ == "object")
                return _.v
        }
        return !1
    }(a, t))
        return !1;
    var d = pe.getComputedStyle(i);
    if (d && d.getPropertyValue("cursor") === "pointer" && e.type === "click")
        return !0;
    var f = i.tagName.toLowerCase();
    switch (f) {
    case "html":
        return !1;
    case "form":
        return (s || ["submit"]).indexOf(e.type) >= 0;
    case "input":
    case "select":
    case "textarea":
        return (s || ["change", "click"]).indexOf(e.type) >= 0;
    default:
        return o ? (s || ["click"]).indexOf(e.type) >= 0 : (s || ["click"]).indexOf(e.type) >= 0 && (u1.indexOf(f) > -1 || i.getAttribute("contenteditable") === "true")
    }
}
function d1(i) {
    for (var e = i; e.parentNode && !ga(e, "body"); e = e.parentNode) {
        var t = dp(e);
        if (Zt(t, "ph-sensitive") || Zt(t, "ph-no-capture"))
            return !1
    }
    if (Zt(dp(i), "ph-include"))
        return !0;
    var n = i.type || "";
    if (Di(n))
        switch (n.toLowerCase()) {
        case "hidden":
        case "password":
            return !1
        }
    var s = i.name || i.id || "";
    return !(Di(s) && /^cc|cardnum|ccnum|creditcard|csc|cvc|cvv|exp|pass|pwd|routing|seccode|securitycode|securitynum|socialsec|socsec|ssn/i.test(s.replace(/[^a-zA-Z0-9]/g, "")))
}
function pA(i) {
    return !!(ga(i, "input") && !["button", "checkbox", "submit", "reset"].includes(i.type) || ga(i, "select") || ga(i, "textarea") || i.getAttribute("contenteditable") === "true")
}
var mA = "(4[0-9]{12}(?:[0-9]{3})?)|(5[1-5][0-9]{14})|(6(?:011|5[0-9]{2})[0-9]{12})|(3[47][0-9]{13})|(3(?:0[0-5]|[68][0-9])[0-9]{11})|((?:2131|1800|35[0-9]{3})[0-9]{11})"
  , _D = new RegExp("^(?:".concat(mA, ")$"))
  , xD = new RegExp(mA)
  , gA = "\\d{3}-?\\d{2}-?\\d{4}"
  , yD = new RegExp("^(".concat(gA, ")$"))
  , bD = new RegExp("(".concat(gA, ")"));
function iu(i) {
    var e = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1];
    return !(Mn(i) || Di(i) && (i = lm(i),
    (e ? _D : xD).test((i || "").replace(/[- ]/g, "")) || (e ? yD : bD).test(i)))
}
function vA(i) {
    var e = dm(i);
    return iu(e = "".concat(e, " ").concat(_A(i)).trim()) ? e : ""
}
function _A(i) {
    var e = "";
    return i && i.childNodes && i.childNodes.length && bn(i.childNodes, function(t) {
        var n;
        if (t && ((n = t.tagName) === null || n === void 0 ? void 0 : n.toLowerCase()) === "span")
            try {
                var s = dm(t);
                e = "".concat(e, " ").concat(s).trim(),
                t.childNodes && t.childNodes.length && (e = "".concat(e, " ").concat(_A(t)).trim())
            } catch (r) {
                Fe.error(r)
            }
    }),
    e
}
function SD(i) {
    return function(e) {
        var t = e.map(n => {
            var s, r, o = "";
            if (n.tag_name && (o += n.tag_name),
            n.attr_class)
                for (var a of (n.attr_class.sort(),
                n.attr_class))
                    o += ".".concat(a.replace(/"/g, ""));
            var l = Ze(Ze(Ze(Ze({}, n.text ? {
                text: n.text
            } : {}), {}, {
                "nth-child": (s = n.nth_child) !== null && s !== void 0 ? s : 0,
                "nth-of-type": (r = n.nth_of_type) !== null && r !== void 0 ? r : 0
            }, n.href ? {
                href: n.href
            } : {}), n.attr_id ? {
                attr_id: n.attr_id
            } : {}), n.attributes)
              , c = {};
            return xh(l).sort( (u, d) => {
                var [f] = u
                  , [h] = d;
                return f.localeCompare(h)
            }
            ).forEach(u => {
                var [d,f] = u;
                return c[w2(d.toString())] = w2(f.toString())
            }
            ),
            o += ":",
            o += xh(l).map(u => {
                var [d,f] = u;
                return "".concat(d, '="').concat(f, '"')
            }
            ).join("")
        }
        );
        return t.join(";")
    }(function(e) {
        return e.map(t => {
            var n, s, r = {
                text: (n = t.$el_text) === null || n === void 0 ? void 0 : n.slice(0, 400),
                tag_name: t.tag_name,
                href: (s = t.attr__href) === null || s === void 0 ? void 0 : s.slice(0, 2048),
                attr_class: ED(t),
                attr_id: t.attr__id,
                nth_child: t.nth_child,
                nth_of_type: t.nth_of_type,
                attributes: {}
            };
            return xh(t).filter(o => {
                var [a] = o;
                return a.indexOf("attr__") === 0
            }
            ).forEach(o => {
                var [a,l] = o;
                return r.attributes[a] = l
            }
            ),
            r
        }
        )
    }(i))
}
function w2(i) {
    return i.replace(/"|\\"/g, '\\"')
}
function ED(i) {
    var e = i.attr__class;
    return e ? Wn(e) ? e : M_(e) : void 0
}
var f1 = "[SessionRecording]"
  , h1 = "redacted"
  , wf = {
    initiatorTypes: ["audio", "beacon", "body", "css", "early-hint", "embed", "fetch", "frame", "iframe", "icon", "image", "img", "input", "link", "navigation", "object", "ping", "script", "track", "video", "xmlhttprequest"],
    maskRequestFn: i => i,
    recordHeaders: !1,
    recordBody: !1,
    recordInitialRequests: !1,
    recordPerformance: !1,
    performanceEntryTypeToObserve: ["first-input", "navigation", "paint", "resource"],
    payloadSizeLimitBytes: 1e6,
    payloadHostDenyList: [".lr-ingest.io", ".ingest.sentry.io"]
}
  , wD = ["authorization", "x-forwarded-for", "authorization", "cookie", "set-cookie", "x-api-key", "x-real-ip", "remote-addr", "forwarded", "proxy-authorization", "x-csrf-token", "x-csrftoken", "x-xsrf-token"]
  , TD = ["password", "secret", "passwd", "api_key", "apikey", "auth", "credentials", "mysql_pwd", "privatekey", "private_key", "token"]
  , AD = ["/s/", "/e/", "/i/"];
function T2(i, e, t, n) {
    if (Mn(i))
        return i;
    var s = (e == null ? void 0 : e["content-length"]) || function(r) {
        return new Blob([r]).size
    }(i);
    return Di(s) && (s = parseInt(s)),
    s > t ? f1 + " ".concat(n, " body too large to record (").concat(s, " bytes)") : i
}
function A2(i, e) {
    if (Mn(i))
        return i;
    var t = i;
    return iu(t, !1) || (t = f1 + " " + e + " body " + h1),
    bn(TD, n => {
        var s, r;
        (s = t) !== null && s !== void 0 && s.length && ((r = t) === null || r === void 0 ? void 0 : r.indexOf(n)) !== -1 && (t = f1 + " " + e + " body " + h1 + " as might contain: " + n)
    }
    ),
    t
}
var CD = (i, e) => {
    var t, n, s, r = {
        payloadSizeLimitBytes: wf.payloadSizeLimitBytes,
        performanceEntryTypeToObserve: [...wf.performanceEntryTypeToObserve],
        payloadHostDenyList: [...e.payloadHostDenyList || [], ...wf.payloadHostDenyList]
    }, o = i.session_recording.recordHeaders !== !1 && e.recordHeaders, a = i.session_recording.recordBody !== !1 && e.recordBody, l = i.capture_performance !== !1 && e.recordPerformance, c = (t = r,
    s = Math.min(1e6, (n = t.payloadSizeLimitBytes) !== null && n !== void 0 ? n : 1e6),
    f => (f != null && f.requestBody && (f.requestBody = T2(f.requestBody, f.requestHeaders, s, "Request")),
    f != null && f.responseBody && (f.responseBody = T2(f.responseBody, f.responseHeaders, s, "Response")),
    f)), u = f => {
        return c(( (g, m) => {
            var v, _ = Uc(g.name), y = m.indexOf("http") === 0 ? (v = Uc(m)) === null || v === void 0 ? void 0 : v.pathname : m;
            y === "/" && (y = "");
            var b = _ == null ? void 0 : _.pathname.replace(y || "", "");
            if (!(_ && b && AD.some(S => b.indexOf(S) === 0)))
                return g
        }
        )((p = (h = f).requestHeaders,
        Mn(p) || bn(Object.keys(p != null ? p : {}), g => {
            wD.includes(g.toLowerCase()) && (p[g] = h1)
        }
        ),
        h), i.api_host));
        var h, p
    }
    , d = Os(i.session_recording.maskNetworkRequestFn);
    return d && Os(i.session_recording.maskCapturedNetworkRequestFn) && Fe.warn("Both `maskNetworkRequestFn` and `maskCapturedNetworkRequestFn` are defined. `maskNetworkRequestFn` will be ignored."),
    d && (i.session_recording.maskCapturedNetworkRequestFn = f => {
        var h = i.session_recording.maskNetworkRequestFn({
            url: f.name
        });
        return Ze(Ze({}, f), {}, {
            name: h == null ? void 0 : h.url
        })
    }
    ),
    r.maskRequestFn = Os(i.session_recording.maskCapturedNetworkRequestFn) ? f => {
        var h, p, g, m = u(f);
        return m && (h = (p = (g = i.session_recording).maskCapturedNetworkRequestFn) === null || p === void 0 ? void 0 : p.call(g, m)) !== null && h !== void 0 ? h : void 0
    }
    : f => function(h) {
        if (!Et(h))
            return h.requestBody = A2(h.requestBody, "Request"),
            h.responseBody = A2(h.responseBody, "Response"),
            h
    }(u(f)),
    Ze(Ze(Ze({}, wf), r), {}, {
        recordHeaders: o,
        recordBody: a,
        recordPerformance: l,
        recordInitialRequests: l
    })
}
;
function Co(i, e, t, n) {
    return e > t && (Fe.warn("min cannot be greater than max."),
    e = t),
    vs(i) ? i > t ? (n && Fe.warn(n + " cannot be  greater than max: " + t + ". Using max value instead."),
    t) : i < e ? (n && Fe.warn(n + " cannot be less than min: " + e + ". Using min value instead."),
    e) : i : (n && Fe.warn(n + " must be a number. Defaulting to max value:" + t),
    t)
}
class MD {
    constructor(e) {
        var t, n, s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        ot(this, "bucketSize", 100),
        ot(this, "refillRate", 10),
        ot(this, "mutationBuckets", {}),
        ot(this, "loggedTracker", {}),
        ot(this, "refillBuckets", () => {
            Object.keys(this.mutationBuckets).forEach(r => {
                this.mutationBuckets[r] = this.mutationBuckets[r] + this.refillRate,
                this.mutationBuckets[r] >= this.bucketSize && delete this.mutationBuckets[r]
            }
            )
        }
        ),
        ot(this, "getNodeOrRelevantParent", r => {
            var o = this.rrweb.mirror.getNode(r);
            if ((o == null ? void 0 : o.nodeName) !== "svg" && o instanceof Element) {
                var a = o.closest("svg");
                if (a)
                    return [this.rrweb.mirror.getId(a), a]
            }
            return [r, o]
        }
        ),
        ot(this, "numberOfChanges", r => {
            var o, a, l, c, u, d, f, h;
            return ((o = (a = r.removes) === null || a === void 0 ? void 0 : a.length) !== null && o !== void 0 ? o : 0) + ((l = (c = r.attributes) === null || c === void 0 ? void 0 : c.length) !== null && l !== void 0 ? l : 0) + ((u = (d = r.texts) === null || d === void 0 ? void 0 : d.length) !== null && u !== void 0 ? u : 0) + ((f = (h = r.adds) === null || h === void 0 ? void 0 : h.length) !== null && f !== void 0 ? f : 0)
        }
        ),
        ot(this, "throttleMutations", r => {
            if (r.type !== 3 || r.data.source !== 0)
                return r;
            var o = r.data
              , a = this.numberOfChanges(o);
            o.attributes && (o.attributes = o.attributes.filter(c => {
                var u, d, f, [h,p] = this.getNodeOrRelevantParent(c.id);
                return this.mutationBuckets[h] === 0 ? !1 : (this.mutationBuckets[h] = (u = this.mutationBuckets[h]) !== null && u !== void 0 ? u : this.bucketSize,
                this.mutationBuckets[h] = Math.max(this.mutationBuckets[h] - 1, 0),
                this.mutationBuckets[h] === 0 && (this.loggedTracker[h] || (this.loggedTracker[h] = !0,
                (d = (f = this.options).onBlockedNode) === null || d === void 0 || d.call(f, h, p))),
                c)
            }
            ));
            var l = this.numberOfChanges(o);
            return l !== 0 || a === l ? r : void 0
        }
        ),
        this.rrweb = e,
        this.options = s,
        this.refillRate = Co((t = this.options.refillRate) !== null && t !== void 0 ? t : this.refillRate, 0, 100, "mutation throttling refill rate"),
        this.bucketSize = Co((n = this.options.bucketSize) !== null && n !== void 0 ? n : this.bucketSize, 0, 100, "mutation throttling bucket size"),
        setInterval( () => {
            this.refillBuckets()
        }
        , 1e3)
    }
}
var zs = Uint8Array
  , qi = Uint16Array
  , su = Uint32Array
  , R_ = new zs([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0])
  , L_ = new zs([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0])
  , C2 = new zs([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  , xA = function(i, e) {
    for (var t = new qi(31), n = 0; n < 31; ++n)
        t[n] = e += 1 << i[n - 1];
    var s = new su(t[30]);
    for (n = 1; n < 30; ++n)
        for (var r = t[n]; r < t[n + 1]; ++r)
            s[r] = r - t[n] << 5 | n;
    return [t, s]
}
  , yA = xA(R_, 2)
  , RD = yA[0]
  , p1 = yA[1];
RD[28] = 258,
p1[258] = 28;
for (var M2 = xA(L_, 0)[1], m1 = new qi(32768), kn = 0; kn < 32768; ++kn) {
    var Va = (43690 & kn) >>> 1 | (21845 & kn) << 1;
    Va = (61680 & (Va = (52428 & Va) >>> 2 | (13107 & Va) << 2)) >>> 4 | (3855 & Va) << 4,
    m1[kn] = ((65280 & Va) >>> 8 | (255 & Va) << 8) >>> 1
}
var cd = function(i, e, t) {
    for (var n = i.length, s = 0, r = new qi(e); s < n; ++s)
        ++r[i[s] - 1];
    var o, a = new qi(e);
    for (s = 0; s < e; ++s)
        a[s] = a[s - 1] + r[s - 1] << 1;
    if (t) {
        o = new qi(1 << e);
        var l = 15 - e;
        for (s = 0; s < n; ++s)
            if (i[s])
                for (var c = s << 4 | i[s], u = e - i[s], d = a[i[s] - 1]++ << u, f = d | (1 << u) - 1; d <= f; ++d)
                    o[m1[d] >>> l] = c
    } else
        for (o = new qi(n),
        s = 0; s < n; ++s)
            o[s] = m1[a[i[s] - 1]++] >>> 15 - i[s];
    return o
}
  , Ll = new zs(288);
for (kn = 0; kn < 144; ++kn)
    Ll[kn] = 8;
for (kn = 144; kn < 256; ++kn)
    Ll[kn] = 9;
for (kn = 256; kn < 280; ++kn)
    Ll[kn] = 7;
for (kn = 280; kn < 288; ++kn)
    Ll[kn] = 8;
var fp = new zs(32);
for (kn = 0; kn < 32; ++kn)
    fp[kn] = 5;
var LD = cd(Ll, 9, 0)
  , ID = cd(fp, 5, 0)
  , bA = function(i) {
    return (i / 8 >> 0) + (7 & i && 1)
}
  , SA = function(i, e, t) {
    (t == null || t > i.length) && (t = i.length);
    var n = new (i instanceof qi ? qi : i instanceof su ? su : zs)(t - e);
    return n.set(i.subarray(e, t)),
    n
}
  , no = function(i, e, t) {
    t <<= 7 & e;
    var n = e / 8 >> 0;
    i[n] |= t,
    i[n + 1] |= t >>> 8
}
  , ku = function(i, e, t) {
    t <<= 7 & e;
    var n = e / 8 >> 0;
    i[n] |= t,
    i[n + 1] |= t >>> 8,
    i[n + 2] |= t >>> 16
}
  , l0 = function(i, e) {
    for (var t = [], n = 0; n < i.length; ++n)
        i[n] && t.push({
            s: n,
            f: i[n]
        });
    var s = t.length
      , r = t.slice();
    if (!s)
        return [new zs(0), 0];
    if (s == 1) {
        var o = new zs(t[0].s + 1);
        return o[t[0].s] = 1,
        [o, 1]
    }
    t.sort(function(S, C) {
        return S.f - C.f
    }),
    t.push({
        s: -1,
        f: 25001
    });
    var a = t[0]
      , l = t[1]
      , c = 0
      , u = 1
      , d = 2;
    for (t[0] = {
        s: -1,
        f: a.f + l.f,
        l: a,
        r: l
    }; u != s - 1; )
        a = t[t[c].f < t[d].f ? c++ : d++],
        l = t[c != u && t[c].f < t[d].f ? c++ : d++],
        t[u++] = {
            s: -1,
            f: a.f + l.f,
            l: a,
            r: l
        };
    var f = r[0].s;
    for (n = 1; n < s; ++n)
        r[n].s > f && (f = r[n].s);
    var h = new qi(f + 1)
      , p = g1(t[u - 1], h, 0);
    if (p > e) {
        n = 0;
        var g = 0
          , m = p - e
          , v = 1 << m;
        for (r.sort(function(S, C) {
            return h[C.s] - h[S.s] || S.f - C.f
        }); n < s; ++n) {
            var _ = r[n].s;
            if (!(h[_] > e))
                break;
            g += v - (1 << p - h[_]),
            h[_] = e
        }
        for (g >>>= m; g > 0; ) {
            var y = r[n].s;
            h[y] < e ? g -= 1 << e - h[y]++ - 1 : ++n
        }
        for (; n >= 0 && g; --n) {
            var b = r[n].s;
            h[b] == e && (--h[b],
            ++g)
        }
        p = e
    }
    return [new zs(h), p]
}
  , g1 = function(i, e, t) {
    return i.s == -1 ? Math.max(g1(i.l, e, t + 1), g1(i.r, e, t + 1)) : e[i.s] = t
}
  , R2 = function(i) {
    for (var e = i.length; e && !i[--e]; )
        ;
    for (var t = new qi(++e), n = 0, s = i[0], r = 1, o = function(l) {
        t[n++] = l
    }, a = 1; a <= e; ++a)
        if (i[a] == s && a != e)
            ++r;
        else {
            if (!s && r > 2) {
                for (; r > 138; r -= 138)
                    o(32754);
                r > 2 && (o(r > 10 ? r - 11 << 5 | 28690 : r - 3 << 5 | 12305),
                r = 0)
            } else if (r > 3) {
                for (o(s),
                --r; r > 6; r -= 6)
                    o(8304);
                r > 2 && (o(r - 3 << 5 | 8208),
                r = 0)
            }
            for (; r--; )
                o(s);
            r = 1,
            s = i[a]
        }
    return [t.subarray(0, n), e]
}
  , Pu = function(i, e) {
    for (var t = 0, n = 0; n < e.length; ++n)
        t += i[n] * e[n];
    return t
}
  , v1 = function(i, e, t) {
    var n = t.length
      , s = bA(e + 2);
    i[s] = 255 & n,
    i[s + 1] = n >>> 8,
    i[s + 2] = 255 ^ i[s],
    i[s + 3] = 255 ^ i[s + 1];
    for (var r = 0; r < n; ++r)
        i[s + r + 4] = t[r];
    return 8 * (s + 4 + n)
}
  , L2 = function(i, e, t, n, s, r, o, a, l, c, u) {
    no(e, u++, t),
    ++s[256];
    for (var d = l0(s, 15), f = d[0], h = d[1], p = l0(r, 15), g = p[0], m = p[1], v = R2(f), _ = v[0], y = v[1], b = R2(g), S = b[0], C = b[1], M = new qi(19), L = 0; L < _.length; ++L)
        M[31 & _[L]]++;
    for (L = 0; L < S.length; ++L)
        M[31 & S[L]]++;
    for (var T = l0(M, 7), A = T[0], k = T[1], D = 19; D > 4 && !A[C2[D - 1]]; --D)
        ;
    var F, z, G, H, X = c + 5 << 3, K = Pu(s, Ll) + Pu(r, fp) + o, ce = Pu(s, f) + Pu(r, g) + o + 14 + 3 * D + Pu(M, A) + (2 * M[16] + 3 * M[17] + 7 * M[18]);
    if (X <= K && X <= ce)
        return v1(e, u, i.subarray(l, l + c));
    if (no(e, u, 1 + (ce < K)),
    u += 2,
    ce < K) {
        F = cd(f, h, 0),
        z = f,
        G = cd(g, m, 0),
        H = g;
        var ue = cd(A, k, 0);
        for (no(e, u, y - 257),
        no(e, u + 5, C - 1),
        no(e, u + 10, D - 4),
        u += 14,
        L = 0; L < D; ++L)
            no(e, u + 3 * L, A[C2[L]]);
        u += 3 * D;
        for (var Ie = [_, S], ke = 0; ke < 2; ++ke) {
            var We = Ie[ke];
            for (L = 0; L < We.length; ++L) {
                var se = 31 & We[L];
                no(e, u, ue[se]),
                u += A[se],
                se > 15 && (no(e, u, We[L] >>> 5 & 127),
                u += We[L] >>> 12)
            }
        }
    } else
        F = LD,
        z = Ll,
        G = ID,
        H = fp;
    for (L = 0; L < a; ++L)
        if (n[L] > 255) {
            se = n[L] >>> 18 & 31,
            ku(e, u, F[se + 257]),
            u += z[se + 257],
            se > 7 && (no(e, u, n[L] >>> 23 & 31),
            u += R_[se]);
            var Se = 31 & n[L];
            ku(e, u, G[Se]),
            u += H[Se],
            Se > 3 && (ku(e, u, n[L] >>> 5 & 8191),
            u += L_[Se])
        } else
            ku(e, u, F[n[L]]),
            u += z[n[L]];
    return ku(e, u, F[256]),
    u + z[256]
}
  , kD = new su([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632])
  , PD = function() {
    for (var i = new su(256), e = 0; e < 256; ++e) {
        for (var t = e, n = 9; --n; )
            t = (1 & t && 3988292384) ^ t >>> 1;
        i[e] = t
    }
    return i
}()
  , DD = function() {
    var i = 4294967295;
    return {
        p: function(e) {
            for (var t = i, n = 0; n < e.length; ++n)
                t = PD[255 & t ^ e[n]] ^ t >>> 8;
            i = t
        },
        d: function() {
            return 4294967295 ^ i
        }
    }
}
  , FD = function(i, e, t, n, s) {
    return function(r, o, a, l, c, u) {
        var d = r.length
          , f = new zs(l + d + 5 * (1 + Math.floor(d / 7e3)) + c)
          , h = f.subarray(l, f.length - c)
          , p = 0;
        if (!o || d < 8)
            for (var g = 0; g <= d; g += 65535) {
                var m = g + 65535;
                m < d ? p = v1(h, p, r.subarray(g, m)) : (h[g] = u,
                p = v1(h, p, r.subarray(g, d)))
            }
        else {
            for (var v = kD[o - 1], _ = v >>> 13, y = 8191 & v, b = (1 << a) - 1, S = new qi(32768), C = new qi(b + 1), M = Math.ceil(a / 3), L = 2 * M, T = function(Ee) {
                return (r[Ee] ^ r[Ee + 1] << M ^ r[Ee + 2] << L) & b
            }, A = new su(25e3), k = new qi(288), D = new qi(32), F = 0, z = 0, G = (g = 0,
            0), H = 0, X = 0; g < d; ++g) {
                var K = T(g)
                  , ce = 32767 & g
                  , ue = C[K];
                if (S[ce] = ue,
                C[K] = ce,
                H <= g) {
                    var Ie = d - g;
                    if ((F > 7e3 || G > 24576) && Ie > 423) {
                        p = L2(r, h, 0, A, k, D, z, G, X, g - X, p),
                        G = F = z = 0,
                        X = g;
                        for (var ke = 0; ke < 286; ++ke)
                            k[ke] = 0;
                        for (ke = 0; ke < 30; ++ke)
                            D[ke] = 0
                    }
                    var We = 2
                      , se = 0
                      , Se = y
                      , be = ce - ue & 32767;
                    if (Ie > 2 && K == T(g - be))
                        for (var q = Math.min(_, Ie) - 1, me = Math.min(32767, g), Ce = Math.min(258, Ie); be <= me && --Se && ce != ue; ) {
                            if (r[g + We] == r[g + We - be]) {
                                for (var Pe = 0; Pe < Ce && r[g + Pe] == r[g + Pe - be]; ++Pe)
                                    ;
                                if (Pe > We) {
                                    if (We = Pe,
                                    se = be,
                                    Pe > q)
                                        break;
                                    var vt = Math.min(be, Pe - 2)
                                      , j = 0;
                                    for (ke = 0; ke < vt; ++ke) {
                                        var B = g - be + ke + 32768 & 32767
                                          , V = B - S[B] + 32768 & 32767;
                                        V > j && (j = V,
                                        ue = B)
                                    }
                                }
                            }
                            be += (ce = ue) - (ue = S[ce]) + 32768 & 32767
                        }
                    if (se) {
                        A[G++] = 268435456 | p1[We] << 18 | M2[se];
                        var Q = 31 & p1[We]
                          , he = 31 & M2[se];
                        z += R_[Q] + L_[he],
                        ++k[257 + Q],
                        ++D[he],
                        H = g + We,
                        ++F
                    } else
                        A[G++] = r[g],
                        ++k[r[g]]
                }
            }
            p = L2(r, h, u, A, k, D, z, G, X, g - X, p)
        }
        return SA(f, 0, l + bA(p) + c)
    }(i, e.level == null ? 6 : e.level, e.mem == null ? Math.ceil(1.5 * Math.max(8, Math.min(13, Math.log(i.length)))) : 12 + e.mem, t, n, !s)
}
  , _1 = function(i, e, t) {
    for (; t; ++e)
        i[e] = t,
        t >>>= 8
}
  , OD = function(i, e) {
    var t = e.filename;
    if (i[0] = 31,
    i[1] = 139,
    i[2] = 8,
    i[8] = e.level < 2 ? 4 : e.level == 9 ? 2 : 0,
    i[9] = 3,
    e.mtime != 0 && _1(i, 4, Math.floor(new Date(e.mtime || Date.now()) / 1e3)),
    t) {
        i[3] = 8;
        for (var n = 0; n <= t.length; ++n)
            i[n + 10] = t.charCodeAt(n)
    }
}
  , UD = function(i) {
    return 10 + (i.filename && i.filename.length + 1 || 0)
};
function EA(i, e) {
    e === void 0 && (e = {});
    var t = DD()
      , n = i.length;
    t.p(i);
    var s = FD(i, e, UD(e), 8)
      , r = s.length;
    return OD(s, e),
    _1(s, r - 8, t.d()),
    _1(s, r - 4, n),
    s
}
function wA(i, e) {
    var t = i.length;
    if (typeof TextEncoder < "u")
        return new TextEncoder().encode(i);
    for (var n = new zs(i.length + (i.length >>> 1)), s = 0, r = function(c) {
        n[s++] = c
    }, o = 0; o < t; ++o) {
        if (s + 5 > n.length) {
            var a = new zs(s + 8 + (t - o << 1));
            a.set(n),
            n = a
        }
        var l = i.charCodeAt(o);
        l < 128 || e ? r(l) : l < 2048 ? (r(192 | l >>> 6),
        r(128 | 63 & l)) : l > 55295 && l < 57344 ? (r(240 | (l = 65536 + (1047552 & l) | 1023 & i.charCodeAt(++o)) >>> 18),
        r(128 | l >>> 12 & 63),
        r(128 | l >>> 6 & 63),
        r(128 | 63 & l)) : (r(224 | l >>> 12),
        r(128 | l >>> 6 & 63),
        r(128 | 63 & l))
    }
    return SA(n, 0, s)
}
var ND = 3e5
  , BD = [sr.MouseMove, sr.MouseInteraction, sr.Scroll, sr.ViewportResize, sr.Input, sr.TouchMove, sr.MediaInteraction, sr.Drag]
  , I2 = i => ({
    rrwebMethod: i,
    enqueuedAt: Date.now(),
    attempt: 1
})
  , Si = "[SessionRecording]";
function $a(i) {
    return function(e, t) {
        for (var n = "", s = 0; s < e.length; ) {
            var r = e[s++];
            r < 128 || t ? n += String.fromCharCode(r) : r < 224 ? n += String.fromCharCode((31 & r) << 6 | 63 & e[s++]) : r < 240 ? n += String.fromCharCode((15 & r) << 12 | (63 & e[s++]) << 6 | 63 & e[s++]) : (r = ((15 & r) << 18 | (63 & e[s++]) << 12 | (63 & e[s++]) << 6 | 63 & e[s++]) - 65536,
            n += String.fromCharCode(55296 | r >> 10, 56320 | 1023 & r))
        }
        return n
    }(EA(wA(JSON.stringify(i))), !0)
}
function k2(i) {
    return i.type === go.Custom && i.data.tag === "sessionIdle"
}
function P2(i, e) {
    return e.some(t => t.matching === "regex" && new RegExp(t.url).test(i))
}
class VD {
    get sessionIdleThresholdMilliseconds() {
        return this.instance.config.session_recording.session_idle_threshold_ms || 3e5
    }
    get rrwebRecord() {
        var e, t;
        return Gt == null || (e = Gt.__PosthogExtensions__) === null || e === void 0 || (t = e.rrweb) === null || t === void 0 ? void 0 : t.record
    }
    get started() {
        return this._captureStarted
    }
    get sessionManager() {
        if (!this.instance.sessionManager)
            throw new Error(Si + " must be started with a valid sessionManager.");
        return this.instance.sessionManager
    }
    get fullSnapshotIntervalMillis() {
        var e, t;
        return this.triggerStatus === "trigger_pending" ? 6e4 : (e = (t = this.instance.config.session_recording) === null || t === void 0 ? void 0 : t.full_snapshot_interval_millis) !== null && e !== void 0 ? e : ND
    }
    get isSampled() {
        var e = this.instance.get_property(ju);
        return cl(e) ? e : null
    }
    get sessionDuration() {
        var e, t, n = (e = this.buffer) === null || e === void 0 ? void 0 : e.data[((t = this.buffer) === null || t === void 0 ? void 0 : t.data.length) - 1], {sessionStartTimestamp: s} = this.sessionManager.checkAndGetSessionAndWindowId(!0);
        return n ? n.timestamp - s : null
    }
    get isRecordingEnabled() {
        var e = !!this.instance.get_property(Jg)
          , t = !this.instance.config.disable_session_recording;
        return pe && e && t
    }
    get isConsoleLogCaptureEnabled() {
        var e = !!this.instance.get_property(c2)
          , t = this.instance.config.enable_recording_console_log;
        return t != null ? t : e
    }
    get canvasRecording() {
        var e, t, n, s, r, o, a = this.instance.config.session_recording.captureCanvas, l = this.instance.get_property(d2), c = (e = (t = a == null ? void 0 : a.recordCanvas) !== null && t !== void 0 ? t : l == null ? void 0 : l.enabled) !== null && e !== void 0 && e, u = (n = (s = a == null ? void 0 : a.canvasFps) !== null && s !== void 0 ? s : l == null ? void 0 : l.fps) !== null && n !== void 0 ? n : 0, d = (r = (o = a == null ? void 0 : a.canvasQuality) !== null && o !== void 0 ? o : l == null ? void 0 : l.quality) !== null && r !== void 0 ? r : 0;
        return {
            enabled: c,
            fps: Co(u, 0, 12, "canvas recording fps"),
            quality: Co(d, 0, 1, "canvas recording quality")
        }
    }
    get networkPayloadCapture() {
        var e, t, n = this.instance.get_property(u2), s = {
            recordHeaders: (e = this.instance.config.session_recording) === null || e === void 0 ? void 0 : e.recordHeaders,
            recordBody: (t = this.instance.config.session_recording) === null || t === void 0 ? void 0 : t.recordBody
        }, r = (s == null ? void 0 : s.recordHeaders) || (n == null ? void 0 : n.recordHeaders), o = (s == null ? void 0 : s.recordBody) || (n == null ? void 0 : n.recordBody), a = Zn(this.instance.config.capture_performance) ? this.instance.config.capture_performance.network_timing : this.instance.config.capture_performance, l = !!(cl(a) ? a : n == null ? void 0 : n.capturePerformance);
        return r || o || l ? {
            recordHeaders: r,
            recordBody: o,
            recordPerformance: l
        } : void 0
    }
    get sampleRate() {
        var e = this.instance.get_property(f2);
        return vs(e) ? e : null
    }
    get minimumDuration() {
        var e = this.instance.get_property(h2);
        return vs(e) ? e : null
    }
    get status() {
        return this.receivedDecide ? this.isRecordingEnabled ? Mn(this._linkedFlag) || this._linkedFlagSeen ? this.triggerStatus === "trigger_pending" ? "buffering" : this._urlBlocked ? "paused" : cl(this.isSampled) ? this.isSampled ? "sampled" : "disabled" : "active" : "buffering" : "disabled" : "buffering"
    }
    get urlTriggerStatus() {
        var e;
        return this._urlTriggers.length === 0 ? "trigger_disabled" : ((e = this.instance) === null || e === void 0 ? void 0 : e.get_property(n0)) === this.sessionId ? "trigger_activated" : "trigger_pending"
    }
    get eventTriggerStatus() {
        var e;
        return this._eventTriggers.length === 0 ? "trigger_disabled" : ((e = this.instance) === null || e === void 0 ? void 0 : e.get_property(i0)) === this.sessionId ? "trigger_activated" : "trigger_pending"
    }
    get triggerStatus() {
        var e = this.eventTriggerStatus === "trigger_activated" || this.urlTriggerStatus === "trigger_activated"
          , t = this.eventTriggerStatus === "trigger_pending" || this.urlTriggerStatus === "trigger_pending";
        return e ? "trigger_activated" : t ? "trigger_pending" : "trigger_disabled"
    }
    constructor(e) {
        if (ot(this, "queuedRRWebEvents", []),
        ot(this, "isIdle", !1),
        ot(this, "_linkedFlagSeen", !1),
        ot(this, "_lastActivityTimestamp", Date.now()),
        ot(this, "_linkedFlag", null),
        ot(this, "_removePageViewCaptureHook", void 0),
        ot(this, "_onSessionIdListener", void 0),
        ot(this, "_persistDecideOnSessionListener", void 0),
        ot(this, "_samplingSessionListener", void 0),
        ot(this, "_urlTriggers", []),
        ot(this, "_urlBlocklist", []),
        ot(this, "_urlBlocked", !1),
        ot(this, "_eventTriggers", []),
        ot(this, "_removeEventTriggerCaptureHook", void 0),
        ot(this, "_forceAllowLocalhostNetworkCapture", !1),
        ot(this, "_onBeforeUnload", () => {
            this._flushBuffer()
        }
        ),
        ot(this, "_onOffline", () => {
            this._tryAddCustomEvent("browser offline", {})
        }
        ),
        ot(this, "_onOnline", () => {
            this._tryAddCustomEvent("browser online", {})
        }
        ),
        ot(this, "_onVisibilityChange", () => {
            if (dt != null && dt.visibilityState) {
                var s = "window " + dt.visibilityState;
                this._tryAddCustomEvent(s, {})
            }
        }
        ),
        this.instance = e,
        this._captureStarted = !1,
        this._endpoint = "/s/",
        this.stopRrweb = void 0,
        this.receivedDecide = !1,
        !this.instance.sessionManager)
            throw Fe.error(Si + " started without valid sessionManager"),
            new Error(Si + " started without valid sessionManager. This is a bug.");
        var {sessionId: t, windowId: n} = this.sessionManager.checkAndGetSessionAndWindowId();
        this.sessionId = t,
        this.windowId = n,
        this.buffer = this.clearBuffer(),
        this.sessionIdleThresholdMilliseconds >= this.sessionManager.sessionTimeoutMs && Fe.warn(Si + " session_idle_threshold_ms (".concat(this.sessionIdleThresholdMilliseconds, ") is greater than the session timeout (").concat(this.sessionManager.sessionTimeoutMs, "). Session will never be detected as idle"))
    }
    startIfEnabledOrStop(e) {
        this.isRecordingEnabled ? (this._startCapture(e),
        pe == null || pe.addEventListener("beforeunload", this._onBeforeUnload),
        pe == null || pe.addEventListener("offline", this._onOffline),
        pe == null || pe.addEventListener("online", this._onOnline),
        pe == null || pe.addEventListener("visibilitychange", this._onVisibilityChange),
        this._setupSampling(),
        this._addEventTriggerListener(),
        Mn(this._removePageViewCaptureHook) && (this._removePageViewCaptureHook = this.instance._addCaptureHook(t => {
            try {
                if (t === "$pageview") {
                    var n = pe ? this._maskUrl(pe.location.href) : "";
                    if (!n)
                        return;
                    this._tryAddCustomEvent("$pageview", {
                        href: n
                    })
                }
            } catch (s) {
                Fe.error("Could not add $pageview to rrweb session", s)
            }
        }
        )),
        this._onSessionIdListener || (this._onSessionIdListener = this.sessionManager.onSessionId( (t, n, s) => {
            var r, o, a, l;
            s && (this._tryAddCustomEvent("$session_id_change", {
                sessionId: t,
                windowId: n,
                changeReason: s
            }),
            (r = this.instance) === null || r === void 0 || (o = r.persistence) === null || o === void 0 || o.unregister(i0),
            (a = this.instance) === null || a === void 0 || (l = a.persistence) === null || l === void 0 || l.unregister(n0))
        }
        ))) : this.stopRecording()
    }
    stopRecording() {
        var e, t, n, s;
        this._captureStarted && this.stopRrweb && (this.stopRrweb(),
        this.stopRrweb = void 0,
        this._captureStarted = !1,
        pe == null || pe.removeEventListener("beforeunload", this._onBeforeUnload),
        pe == null || pe.removeEventListener("offline", this._onOffline),
        pe == null || pe.removeEventListener("online", this._onOnline),
        pe == null || pe.removeEventListener("visibilitychange", this._onVisibilityChange),
        this.clearBuffer(),
        clearInterval(this._fullSnapshotTimer),
        (e = this._removePageViewCaptureHook) === null || e === void 0 || e.call(this),
        this._removePageViewCaptureHook = void 0,
        (t = this._removeEventTriggerCaptureHook) === null || t === void 0 || t.call(this),
        this._removeEventTriggerCaptureHook = void 0,
        (n = this._onSessionIdListener) === null || n === void 0 || n.call(this),
        this._onSessionIdListener = void 0,
        (s = this._samplingSessionListener) === null || s === void 0 || s.call(this),
        this._samplingSessionListener = void 0,
        Fe.info(Si + " stopped"))
    }
    makeSamplingDecision(e) {
        var t, n = this.sessionId !== e, s = this.sampleRate;
        if (vs(s)) {
            var r, o = this.isSampled, a = n || !cl(o);
            a ? r = Math.random() < s : r = o,
            a && (r ? this._reportStarted("sampled") : Fe.warn(Si + " Sample rate (".concat(s, ") has determined that this sessionId (").concat(e, ") will not be sent to the server.")),
            this._tryAddCustomEvent("samplingDecisionMade", {
                sampleRate: s,
                isSampled: r
            })),
            (t = this.instance.persistence) === null || t === void 0 || t.register({
                [ju]: r
            })
        } else {
            var l;
            (l = this.instance.persistence) === null || l === void 0 || l.register({
                [ju]: null
            })
        }
    }
    afterDecideResponse(e) {
        var t, n, s, r, o, a;
        if (this._persistDecideResponse(e),
        this._linkedFlag = ((t = e.sessionRecording) === null || t === void 0 ? void 0 : t.linkedFlag) || null,
        (n = e.sessionRecording) !== null && n !== void 0 && n.endpoint && (this._endpoint = (a = e.sessionRecording) === null || a === void 0 ? void 0 : a.endpoint),
        this._setupSampling(),
        !Mn(this._linkedFlag) && !this._linkedFlagSeen) {
            var l = Di(this._linkedFlag) ? this._linkedFlag : this._linkedFlag.flag
              , c = Di(this._linkedFlag) ? null : this._linkedFlag.variant;
            this.instance.onFeatureFlags( (u, d) => {
                var f = Zn(d) && l in d
                  , h = c ? d[l] === c : f;
                h && this._reportStarted("linked_flag_matched", {
                    linkedFlag: l,
                    linkedVariant: c
                }),
                this._linkedFlagSeen = h
            }
            )
        }
        (s = e.sessionRecording) !== null && s !== void 0 && s.urlTriggers && (this._urlTriggers = e.sessionRecording.urlTriggers),
        (r = e.sessionRecording) !== null && r !== void 0 && r.urlBlocklist && (this._urlBlocklist = e.sessionRecording.urlBlocklist),
        (o = e.sessionRecording) !== null && o !== void 0 && o.eventTriggers && (this._eventTriggers = e.sessionRecording.eventTriggers),
        this.receivedDecide = !0,
        this.startIfEnabledOrStop()
    }
    _setupSampling() {
        vs(this.sampleRate) && Mn(this._samplingSessionListener) && (this._samplingSessionListener = this.sessionManager.onSessionId(e => {
            this.makeSamplingDecision(e)
        }
        ))
    }
    _persistDecideResponse(e) {
        if (this.instance.persistence) {
            var t, n = this.instance.persistence, s = () => {
                var r, o, a, l, c, u, d, f = (r = e.sessionRecording) === null || r === void 0 ? void 0 : r.sampleRate, h = Mn(f) ? null : parseFloat(f), p = (o = e.sessionRecording) === null || o === void 0 ? void 0 : o.minimumDurationMilliseconds;
                n.register({
                    [Jg]: !!e.sessionRecording,
                    [c2]: (a = e.sessionRecording) === null || a === void 0 ? void 0 : a.consoleLogRecordingEnabled,
                    [u2]: Ze({
                        capturePerformance: e.capturePerformance
                    }, (l = e.sessionRecording) === null || l === void 0 ? void 0 : l.networkPayloadCapture),
                    [d2]: {
                        enabled: (c = e.sessionRecording) === null || c === void 0 ? void 0 : c.recordCanvas,
                        fps: (u = e.sessionRecording) === null || u === void 0 ? void 0 : u.canvasFps,
                        quality: (d = e.sessionRecording) === null || d === void 0 ? void 0 : d.canvasQuality
                    },
                    [f2]: h,
                    [h2]: Et(p) ? null : p
                })
            }
            ;
            s(),
            (t = this._persistDecideOnSessionListener) === null || t === void 0 || t.call(this),
            this._persistDecideOnSessionListener = this.sessionManager.onSessionId(s)
        }
    }
    log(e) {
        var t, n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "log";
        (t = this.instance.sessionRecording) === null || t === void 0 || t.onRRwebEmit({
            type: 6,
            data: {
                plugin: "rrweb/console@1",
                payload: {
                    level: n,
                    trace: [],
                    payload: [JSON.stringify(e)]
                }
            },
            timestamp: Date.now()
        })
    }
    _startCapture(e) {
        if (!Et(Object.assign) && !Et(Array.from) && !(this._captureStarted || this.instance.config.disable_session_recording || this.instance.consent.isOptedOut())) {
            var t, n;
            this._captureStarted = !0,
            this.sessionManager.checkAndGetSessionAndWindowId(),
            this.rrwebRecord ? this._onScriptLoaded() : (t = Gt.__PosthogExtensions__) === null || t === void 0 || (n = t.loadExternalDependency) === null || n === void 0 || n.call(t, this.instance, "recorder", s => {
                if (s)
                    return Fe.error(Si + " could not load recorder", s);
                this._onScriptLoaded()
            }
            ),
            Fe.info(Si + " starting"),
            this.status === "active" && this._reportStarted(e || "recording_initialized")
        }
    }
    isInteractiveEvent(e) {
        var t;
        return e.type === 3 && BD.indexOf((t = e.data) === null || t === void 0 ? void 0 : t.source) !== -1
    }
    _updateWindowAndSessionIds(e) {
        var t = this.isInteractiveEvent(e);
        t || this.isIdle || e.timestamp - this._lastActivityTimestamp > this.sessionIdleThresholdMilliseconds && (this.isIdle = !0,
        clearInterval(this._fullSnapshotTimer),
        this._tryAddCustomEvent("sessionIdle", {
            eventTimestamp: e.timestamp,
            lastActivityTimestamp: this._lastActivityTimestamp,
            threshold: this.sessionIdleThresholdMilliseconds,
            bufferLength: this.buffer.data.length,
            bufferSize: this.buffer.size
        }),
        this._flushBuffer());
        var n = !1;
        if (t && (this._lastActivityTimestamp = e.timestamp,
        this.isIdle && (this.isIdle = !1,
        this._tryAddCustomEvent("sessionNoLongerIdle", {
            reason: "user activity",
            type: e.type
        }),
        n = !0)),
        !this.isIdle) {
            var {windowId: s, sessionId: r} = this.sessionManager.checkAndGetSessionAndWindowId(!t, e.timestamp)
              , o = this.sessionId !== r
              , a = this.windowId !== s;
            this.windowId = s,
            this.sessionId = r,
            o || a ? (this.stopRecording(),
            this.startIfEnabledOrStop("session_id_changed")) : n && this._scheduleFullSnapshot()
        }
    }
    _tryRRWebMethod(e) {
        try {
            return e.rrwebMethod(),
            !0
        } catch (t) {
            return this.queuedRRWebEvents.length < 10 ? this.queuedRRWebEvents.push({
                enqueuedAt: e.enqueuedAt || Date.now(),
                attempt: e.attempt++,
                rrwebMethod: e.rrwebMethod
            }) : Fe.warn(Si + " could not emit queued rrweb event.", t, e),
            !1
        }
    }
    _tryAddCustomEvent(e, t) {
        return this._tryRRWebMethod(I2( () => this.rrwebRecord.addCustomEvent(e, t)))
    }
    _tryTakeFullSnapshot() {
        return this._tryRRWebMethod(I2( () => this.rrwebRecord.takeFullSnapshot()))
    }
    _onScriptLoaded() {
        var e, t = {
            blockClass: "ph-no-capture",
            blockSelector: void 0,
            ignoreClass: "ph-ignore-input",
            maskTextClass: "ph-mask",
            maskTextSelector: void 0,
            maskTextFn: void 0,
            maskAllInputs: !0,
            maskInputOptions: {
                password: !0
            },
            maskInputFn: void 0,
            slimDOMOptions: {},
            collectFonts: !1,
            inlineStylesheet: !0,
            recordCrossOriginIframes: !1
        }, n = this.instance.config.session_recording;
        for (var [s,r] of Object.entries(n || {}))
            s in t && (s === "maskInputOptions" ? t.maskInputOptions = Ze({
                password: !0
            }, r) : t[s] = r);
        if (this.canvasRecording && this.canvasRecording.enabled && (t.recordCanvas = !0,
        t.sampling = {
            canvas: this.canvasRecording.fps
        },
        t.dataURLOptions = {
            type: "image/webp",
            quality: this.canvasRecording.quality
        }),
        this.rrwebRecord) {
            this.mutationRateLimiter = (e = this.mutationRateLimiter) !== null && e !== void 0 ? e : new MD(this.rrwebRecord,{
                refillRate: this.instance.config.session_recording.__mutationRateLimiterRefillRate,
                bucketSize: this.instance.config.session_recording.__mutationRateLimiterBucketSize,
                onBlockedNode: (a, l) => {
                    var c = "Too many mutations on node '".concat(a, "'. Rate limiting. This could be due to SVG animations or something similar");
                    Fe.info(c, {
                        node: l
                    }),
                    this.log(Si + " " + c, "warn")
                }
            });
            var o = this._gatherRRWebPlugins();
            this.stopRrweb = this.rrwebRecord(Ze({
                emit: a => {
                    this.onRRwebEmit(a)
                }
                ,
                plugins: o
            }, t)),
            this._lastActivityTimestamp = Date.now(),
            this.isIdle = !1,
            this._tryAddCustomEvent("$session_options", {
                sessionRecordingOptions: t,
                activePlugins: o.map(a => a == null ? void 0 : a.name)
            }),
            this._tryAddCustomEvent("$posthog_config", {
                config: this.instance.config
            })
        } else
            Fe.error(Si + "onScriptLoaded was called but rrwebRecord is not available. This indicates something has gone wrong.")
    }
    _scheduleFullSnapshot() {
        if (this._fullSnapshotTimer && clearInterval(this._fullSnapshotTimer),
        !this.isIdle) {
            var e = this.fullSnapshotIntervalMillis;
            e && (this._fullSnapshotTimer = setInterval( () => {
                this._tryTakeFullSnapshot()
            }
            , e))
        }
    }
    _gatherRRWebPlugins() {
        var e, t, n, s, r = [], o = (e = Gt.__PosthogExtensions__) === null || e === void 0 || (t = e.rrwebPlugins) === null || t === void 0 ? void 0 : t.getRecordConsolePlugin;
        o && this.isConsoleLogCaptureEnabled && r.push(o());
        var a = (n = Gt.__PosthogExtensions__) === null || n === void 0 || (s = n.rrwebPlugins) === null || s === void 0 ? void 0 : s.getRecordNetworkPlugin;
        return this.networkPayloadCapture && Os(a) && (!sD.includes(location.hostname) || this._forceAllowLocalhostNetworkCapture ? r.push(a(CD(this.instance.config, this.networkPayloadCapture))) : Fe.info(Si + " NetworkCapture not started because we are on localhost.")),
        r
    }
    onRRwebEmit(e) {
        var t;
        if (this._processQueuedEvents(),
        e && Zn(e)) {
            if (e.type === go.Meta) {
                var n = this._maskUrl(e.data.href);
                if (this._lastHref = n,
                !n)
                    return;
                e.data.href = n
            } else
                this._pageViewFallBack();
            if (this._checkUrlTriggerConditions(),
            this.status !== "paused" || function(d) {
                return d.type === go.Custom && d.data.tag === "recording paused"
            }(e)) {
                e.type === go.FullSnapshot && this._scheduleFullSnapshot(),
                e.type === go.FullSnapshot && this.triggerStatus === "trigger_pending" && this.clearBuffer();
                var s = this.mutationRateLimiter ? this.mutationRateLimiter.throttleMutations(e) : e;
                if (s) {
                    var r = function(d) {
                        var f = d;
                        if (f && Zn(f) && f.type === 6 && Zn(f.data) && f.data.plugin === "rrweb/console@1") {
                            f.data.payload.payload.length > 10 && (f.data.payload.payload = f.data.payload.payload.slice(0, 10),
                            f.data.payload.payload.push("...[truncated]"));
                            for (var h = [], p = 0; p < f.data.payload.payload.length; p++)
                                f.data.payload.payload[p] && f.data.payload.payload[p].length > 2e3 ? h.push(f.data.payload.payload[p].slice(0, 2e3) + "...[truncated]") : h.push(f.data.payload.payload[p]);
                            return f.data.payload.payload = h,
                            d
                        }
                        return d
                    }(s);
                    if (this._updateWindowAndSessionIds(r),
                    !this.isIdle || k2(r)) {
                        if (k2(r)) {
                            var o = r.data.payload;
                            if (o) {
                                var a = o.lastActivityTimestamp
                                  , l = o.threshold;
                                r.timestamp = a + l
                            }
                        }
                        var c = (t = this.instance.config.session_recording.compress_events) === null || t === void 0 || t ? function(d) {
                            if (up(d) < 1024)
                                return d;
                            try {
                                if (d.type === go.FullSnapshot)
                                    return Ze(Ze({}, d), {}, {
                                        data: $a(d.data),
                                        cv: "2024-10"
                                    });
                                if (d.type === go.IncrementalSnapshot && d.data.source === sr.Mutation)
                                    return Ze(Ze({}, d), {}, {
                                        cv: "2024-10",
                                        data: Ze(Ze({}, d.data), {}, {
                                            texts: $a(d.data.texts),
                                            attributes: $a(d.data.attributes),
                                            removes: $a(d.data.removes),
                                            adds: $a(d.data.adds)
                                        })
                                    });
                                if (d.type === go.IncrementalSnapshot && d.data.source === sr.StyleSheetRule)
                                    return Ze(Ze({}, d), {}, {
                                        cv: "2024-10",
                                        data: Ze(Ze({}, d.data), {}, {
                                            adds: $a(d.data.adds),
                                            removes: $a(d.data.removes)
                                        })
                                    })
                            } catch (f) {
                                Fe.error(Si + " could not compress event - will use uncompressed event", f)
                            }
                            return d
                        }(r) : r
                          , u = {
                            $snapshot_bytes: up(c),
                            $snapshot_data: c,
                            $session_id: this.sessionId,
                            $window_id: this.windowId
                        };
                        this.status !== "disabled" ? this._captureSnapshotBuffered(u) : this.clearBuffer()
                    }
                }
            }
        }
    }
    _pageViewFallBack() {
        if (!this.instance.config.capture_pageview && pe) {
            var e = this._maskUrl(pe.location.href);
            this._lastHref !== e && (this._tryAddCustomEvent("$url_changed", {
                href: e
            }),
            this._lastHref = e)
        }
    }
    _processQueuedEvents() {
        if (this.queuedRRWebEvents.length) {
            var e = [...this.queuedRRWebEvents];
            this.queuedRRWebEvents = [],
            e.forEach(t => {
                Date.now() - t.enqueuedAt <= 2e3 && this._tryRRWebMethod(t)
            }
            )
        }
    }
    _maskUrl(e) {
        var t = this.instance.config.session_recording;
        if (t.maskNetworkRequestFn) {
            var n, s = {
                url: e
            };
            return (n = s = t.maskNetworkRequestFn(s)) === null || n === void 0 ? void 0 : n.url
        }
        return e
    }
    clearBuffer() {
        return this.buffer = {
            size: 0,
            data: [],
            sessionId: this.sessionId,
            windowId: this.windowId
        },
        this.buffer
    }
    _flushBuffer() {
        this.flushBufferTimer && (clearTimeout(this.flushBufferTimer),
        this.flushBufferTimer = void 0);
        var e = this.minimumDuration
          , t = this.sessionDuration
          , n = vs(t) && t >= 0
          , s = vs(e) && n && t < e;
        return this.status === "buffering" || s ? (this.flushBufferTimer = setTimeout( () => {
            this._flushBuffer()
        }
        , 2e3),
        this.buffer) : (this.buffer.data.length > 0 && c1(this.buffer).forEach(r => {
            this._captureSnapshot({
                $snapshot_bytes: r.size,
                $snapshot_data: r.data,
                $session_id: r.sessionId,
                $window_id: r.windowId
            })
        }
        ),
        this.clearBuffer())
    }
    _captureSnapshotBuffered(e) {
        var t, n = 2 + (((t = this.buffer) === null || t === void 0 ? void 0 : t.data.length) || 0);
        !this.isIdle && (this.buffer.size + e.$snapshot_bytes + n > 943718.4 || this.buffer.sessionId !== this.sessionId) && (this.buffer = this._flushBuffer()),
        this.buffer.size += e.$snapshot_bytes,
        this.buffer.data.push(e.$snapshot_data),
        this.flushBufferTimer || this.isIdle || (this.flushBufferTimer = setTimeout( () => {
            this._flushBuffer()
        }
        , 2e3))
    }
    _captureSnapshot(e) {
        this.instance.capture("$snapshot", e, {
            _url: this.instance.requestRouter.endpointFor("api", this._endpoint),
            _noTruncate: !0,
            _batchKey: "recordings",
            skip_client_rate_limiting: !0
        })
    }
    _checkUrlTriggerConditions() {
        if (pe !== void 0 && pe.location.href) {
            var e = pe.location.href
              , t = this.status === "paused"
              , n = P2(e, this._urlBlocklist);
            n && !t ? this._pauseRecording() : !n && t && this._resumeRecording(),
            P2(e, this._urlTriggers) && this._activateTrigger("url")
        }
    }
    _activateTrigger(e) {
        var t, n;
        this.triggerStatus === "trigger_pending" && ((t = this.instance) === null || t === void 0 || (n = t.persistence) === null || n === void 0 || n.register({
            [e === "url" ? n0 : i0]: this.sessionId
        }),
        this._flushBuffer(),
        this._reportStarted(e + "_trigger_matched"))
    }
    _pauseRecording() {
        var e, t;
        this.status !== "paused" && (this._urlBlocked = !0,
        dt == null || (e = dt.body) === null || e === void 0 || (t = e.classList) === null || t === void 0 || t.add("ph-no-capture"),
        clearInterval(this._fullSnapshotTimer),
        setTimeout( () => {
            this._flushBuffer()
        }
        , 100),
        Fe.info(Si + " recording paused due to URL blocker"),
        this._tryAddCustomEvent("recording paused", {
            reason: "url blocker"
        }))
    }
    _resumeRecording() {
        var e, t;
        this.status === "paused" && (this._urlBlocked = !1,
        dt == null || (e = dt.body) === null || e === void 0 || (t = e.classList) === null || t === void 0 || t.remove("ph-no-capture"),
        this._tryTakeFullSnapshot(),
        this._scheduleFullSnapshot(),
        this._tryAddCustomEvent("recording resumed", {
            reason: "left blocked url"
        }),
        Fe.info(Si + " recording resumed"))
    }
    _addEventTriggerListener() {
        this._eventTriggers.length !== 0 && Mn(this._removeEventTriggerCaptureHook) && (this._removeEventTriggerCaptureHook = this.instance.on("eventCaptured", e => {
            try {
                this._eventTriggers.includes(e.event) && this._activateTrigger("event")
            } catch (t) {
                Fe.error(Si + "Could not activate event trigger", t)
            }
        }
        ))
    }
    overrideLinkedFlag() {
        this._linkedFlagSeen = !0,
        this._reportStarted("linked_flag_overridden")
    }
    overrideSampling() {
        var e;
        (e = this.instance.persistence) === null || e === void 0 || e.register({
            [ju]: !0
        }),
        this._reportStarted("sampling_overridden")
    }
    overrideTrigger(e) {
        this._activateTrigger(e)
    }
    _reportStarted(e, t) {
        this.instance.register_for_session({
            $session_recording_start_reason: e
        }),
        Fe.info(Si + " " + e.replace("_", " "), t),
        Zt(["recording_initialized", "session_id_changed"], e) || this._tryAddCustomEvent(e, t)
    }
}
class $D {
    constructor(e) {
        this.instance = e,
        this.instance.decideEndpointWasHit = this.instance._hasBootstrappedFeatureFlags()
    }
    call() {
        var e = {
            token: this.instance.config.token,
            distinct_id: this.instance.get_distinct_id(),
            groups: this.instance.getGroups(),
            person_properties: this.instance.get_property(Ec),
            group_properties: this.instance.get_property(ia),
            disable_flags: this.instance.config.advanced_disable_feature_flags || this.instance.config.advanced_disable_feature_flags_on_first_load || void 0
        };
        this.instance._send_request({
            method: "POST",
            url: this.instance.requestRouter.endpointFor("api", "/decide/?v=3"),
            data: e,
            compression: this.instance.config.disable_compression ? void 0 : cr.Base64,
            timeout: this.instance.config.feature_flag_request_timeout_ms,
            callback: t => this.parseDecideResponse(t.json)
        })
    }
    parseDecideResponse(e) {
        this.instance.featureFlags.setReloadingPaused(!1),
        this.instance.featureFlags._startReloadTimer();
        var t = !e;
        if (this.instance.config.advanced_disable_feature_flags_on_first_load || this.instance.config.advanced_disable_feature_flags || this.instance.featureFlags.receivedFeatureFlags(e != null ? e : {}, t),
        !t)
            return dt && dt.body ? void this.instance._afterDecideResponse(e) : (Fe.info("document not ready yet, trying again in 500 milliseconds..."),
            void setTimeout( () => {
                this.parseDecideResponse(e)
            }
            , 500));
        Fe.error("Failed to fetch feature flags from PostHog.")
    }
}
var vo, HD = pe != null && pe.location ? lp(pe.location.hash, "__posthog") || lp(location.hash, "state") : null, D2 = "_postHogToolbarParams";
(function(i) {
    i[i.UNINITIALIZED = 0] = "UNINITIALIZED",
    i[i.LOADING = 1] = "LOADING",
    i[i.LOADED = 2] = "LOADED"
}
)(vo || (vo = {}));
class zD {
    constructor(e) {
        this.instance = e
    }
    setToolbarState(e) {
        Gt.ph_toolbar_state = e
    }
    getToolbarState() {
        var e;
        return (e = Gt.ph_toolbar_state) !== null && e !== void 0 ? e : vo.UNINITIALIZED
    }
    maybeLoadToolbar() {
        var e, t, n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0, s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
        if (!pe || !dt)
            return !1;
        n = (e = n) !== null && e !== void 0 ? e : pe.location,
        r = (t = r) !== null && t !== void 0 ? t : pe.history;
        try {
            if (!s) {
                try {
                    pe.localStorage.setItem("test", "test"),
                    pe.localStorage.removeItem("test")
                } catch {
                    return !1
                }
                s = pe == null ? void 0 : pe.localStorage
            }
            var o, a = HD || lp(n.hash, "__posthog") || lp(n.hash, "state"), l = a ? e2( () => JSON.parse(atob(decodeURIComponent(a)))) || e2( () => JSON.parse(decodeURIComponent(a))) : null;
            return l && l.action === "ph_authorize" ? ((o = l).source = "url",
            o && Object.keys(o).length > 0 && (l.desiredHash ? n.hash = l.desiredHash : r ? r.replaceState(r.state, "", n.pathname + n.search) : n.hash = "")) : ((o = JSON.parse(s.getItem(D2) || "{}")).source = "localstorage",
            delete o.userIntent),
            !(!o.token || this.instance.config.token !== o.token) && (this.loadToolbar(o),
            !0)
        } catch {
            return !1
        }
    }
    _callLoadToolbar(e) {
        (Gt.ph_load_toolbar || Gt.ph_load_editor)(e, this.instance)
    }
    loadToolbar(e) {
        var t = !(dt == null || !dt.getElementById(qT));
        if (!pe || t)
            return !1;
        var n = this.instance.requestRouter.region === "custom" && this.instance.config.advanced_disable_toolbar_metrics
          , s = Ze(Ze({
            token: this.instance.config.token
        }, e), {}, {
            apiURL: this.instance.requestRouter.endpointFor("ui")
        }, n ? {
            instrument: !1
        } : {});
        if (pe.localStorage.setItem(D2, JSON.stringify(Ze(Ze({}, s), {}, {
            source: void 0
        }))),
        this.getToolbarState() === vo.LOADED)
            this._callLoadToolbar(s);
        else if (this.getToolbarState() === vo.UNINITIALIZED) {
            var r, o;
            this.setToolbarState(vo.LOADING),
            (r = Gt.__PosthogExtensions__) === null || r === void 0 || (o = r.loadExternalDependency) === null || o === void 0 || o.call(r, this.instance, "toolbar", a => {
                if (a)
                    return Fe.error("Failed to load toolbar", a),
                    void this.setToolbarState(vo.UNINITIALIZED);
                this.setToolbarState(vo.LOADED),
                this._callLoadToolbar(s)
            }
            ),
            To(pe, "turbolinks:load", () => {
                this.setToolbarState(vo.UNINITIALIZED),
                this.loadToolbar(s)
            }
            )
        }
        return !0
    }
    _loadEditor(e) {
        return this.loadToolbar(e)
    }
    maybeLoadEditor() {
        var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0
          , t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0
          , n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
        return this.maybeLoadToolbar(e, t, n)
    }
}
class GD {
    constructor(e) {
        ot(this, "isPaused", !0),
        ot(this, "queue", []),
        ot(this, "flushTimeoutMs", 3e3),
        this.sendRequest = e
    }
    enqueue(e) {
        this.queue.push(e),
        this.flushTimeout || this.setFlushTimeout()
    }
    unload() {
        this.clearFlushTimeout();
        var e = this.queue.length > 0 ? this.formatQueue() : {}
          , t = Object.values(e)
          , n = [...t.filter(s => s.url.indexOf("/e") === 0), ...t.filter(s => s.url.indexOf("/e") !== 0)];
        n.map(s => {
            this.sendRequest(Ze(Ze({}, s), {}, {
                transport: "sendBeacon"
            }))
        }
        )
    }
    enable() {
        this.isPaused = !1,
        this.setFlushTimeout()
    }
    setFlushTimeout() {
        var e = this;
        this.isPaused || (this.flushTimeout = setTimeout( () => {
            if (this.clearFlushTimeout(),
            this.queue.length > 0) {
                var t = this.formatQueue()
                  , n = function(r) {
                    var o = t[r]
                      , a = new Date().getTime();
                    o.data && Wn(o.data) && bn(o.data, l => {
                        l.offset = Math.abs(l.timestamp - a),
                        delete l.timestamp
                    }
                    ),
                    e.sendRequest(o)
                };
                for (var s in t)
                    n(s)
            }
        }
        , this.flushTimeoutMs))
    }
    clearFlushTimeout() {
        clearTimeout(this.flushTimeout),
        this.flushTimeout = void 0
    }
    formatQueue() {
        var e = {};
        return bn(this.queue, t => {
            var n, s = t, r = (s ? s.batchKey : null) || s.url;
            Et(e[r]) && (e[r] = Ze(Ze({}, s), {}, {
                data: []
            })),
            (n = e[r].data) === null || n === void 0 || n.push(s.data)
        }
        ),
        this.queue = [],
        e
    }
}
var WD = !!Xg || !!Kg
  , F2 = "text/plain"
  , hp = (i, e) => {
    var [t,n] = i.split("?")
      , s = Ze({}, e);
    n == null || n.split("&").forEach(o => {
        var [a] = o.split("=");
        delete s[a]
    }
    );
    var r = rD(s);
    return r = r ? (n ? n + "&" : "") + r : n,
    "".concat(t, "?").concat(r)
}
  , c0 = i => {
    var {data: e, compression: t} = i;
    if (e) {
        if (t === cr.GZipJS) {
            var n = EA(wA(JSON.stringify(e)), {
                mtime: 0
            })
              , s = new Blob([n],{
                type: F2
            });
            return {
                contentType: F2,
                body: s,
                estimatedSize: s.size
            }
        }
        if (t === cr.Base64) {
            var r = function(l) {
                var c, u, d, f, h, p = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", g = 0, m = 0, v = "", _ = [];
                if (!l)
                    return l;
                l = zP(l);
                do
                    c = (h = l.charCodeAt(g++) << 16 | l.charCodeAt(g++) << 8 | l.charCodeAt(g++)) >> 18 & 63,
                    u = h >> 12 & 63,
                    d = h >> 6 & 63,
                    f = 63 & h,
                    _[m++] = p.charAt(c) + p.charAt(u) + p.charAt(d) + p.charAt(f);
                while (g < l.length);
                switch (v = _.join(""),
                l.length % 3) {
                case 1:
                    v = v.slice(0, -2) + "==";
                    break;
                case 2:
                    v = v.slice(0, -1) + "="
                }
                return v
            }(JSON.stringify(e))
              , o = (l => "data=" + encodeURIComponent(typeof l == "string" ? l : JSON.stringify(l)))(r);
            return {
                contentType: "application/x-www-form-urlencoded",
                body: o,
                estimatedSize: new Blob([o]).size
            }
        }
        var a = JSON.stringify(e);
        return {
            contentType: "application/json",
            body: a,
            estimatedSize: new Blob([a]).size
        }
    }
}
  , ud = [];
Xg && ud.push({
    transport: "XHR",
    method: i => {
        var e, t = new Xg;
        t.open(i.method || "GET", i.url, !0);
        var {contentType: n, body: s} = (e = c0(i)) !== null && e !== void 0 ? e : {};
        bn(i.headers, function(r, o) {
            t.setRequestHeader(o, r)
        }),
        n && t.setRequestHeader("Content-Type", n),
        i.timeout && (t.timeout = i.timeout),
        t.withCredentials = !0,
        t.onreadystatechange = () => {
            if (t.readyState === 4) {
                var r, o = {
                    statusCode: t.status,
                    text: t.responseText
                };
                if (t.status === 200)
                    try {
                        o.json = JSON.parse(t.responseText)
                    } catch {}
                (r = i.callback) === null || r === void 0 || r.call(i, o)
            }
        }
        ,
        t.send(s)
    }
}),
Kg && ud.push({
    transport: "fetch",
    method: i => {
        var e, t, {contentType: n, body: s, estimatedSize: r} = (e = c0(i)) !== null && e !== void 0 ? e : {}, o = new Headers;
        bn(i.headers, function(u, d) {
            o.append(d, u)
        }),
        n && o.append("Content-Type", n);
        var a = i.url
          , l = null;
        if (Qy) {
            var c = new Qy;
            l = {
                signal: c.signal,
                timeout: setTimeout( () => c.abort(), i.timeout)
            }
        }
        Kg(a, {
            method: (i == null ? void 0 : i.method) || "GET",
            headers: o,
            keepalive: i.method === "POST" && (r || 0) < 52428.8,
            body: s,
            signal: (t = l) === null || t === void 0 ? void 0 : t.signal
        }).then(u => u.text().then(d => {
            var f, h = {
                statusCode: u.status,
                text: d
            };
            if (u.status === 200)
                try {
                    h.json = JSON.parse(d)
                } catch (p) {
                    Fe.error(p)
                }
            (f = i.callback) === null || f === void 0 || f.call(i, h)
        }
        )).catch(u => {
            var d;
            Fe.error(u),
            (d = i.callback) === null || d === void 0 || d.call(i, {
                statusCode: 0,
                text: u
            })
        }
        ).finally( () => l ? clearTimeout(l.timeout) : null)
    }
}),
bs != null && bs.sendBeacon && ud.push({
    transport: "sendBeacon",
    method: i => {
        var e = hp(i.url, {
            beacon: "1"
        });
        try {
            var t, {contentType: n, body: s} = (t = c0(i)) !== null && t !== void 0 ? t : {}, r = typeof s == "string" ? new Blob([s],{
                type: n
            }) : s;
            bs.sendBeacon(e, r)
        } catch {}
    }
});
var qD = ["retriesPerformedSoFar"];
class jD {
    constructor(e) {
        ot(this, "isPolling", !1),
        ot(this, "pollIntervalMs", 3e3),
        ot(this, "queue", []),
        this.instance = e,
        this.queue = [],
        this.areWeOnline = !0,
        !Et(pe) && "onLine"in pe.navigator && (this.areWeOnline = pe.navigator.onLine,
        pe.addEventListener("online", () => {
            this.areWeOnline = !0,
            this.flush()
        }
        ),
        pe.addEventListener("offline", () => {
            this.areWeOnline = !1
        }
        ))
    }
    retriableRequest(e) {
        var {retriesPerformedSoFar: t} = e
          , n = zT(e, qD);
        vs(t) && t > 0 && (n.url = hp(n.url, {
            retry_count: t
        })),
        this.instance._send_request(Ze(Ze({}, n), {}, {
            callback: s => {
                var r;
                s.statusCode !== 200 && (s.statusCode < 400 || s.statusCode >= 500) && (t != null ? t : 0) < 10 ? this.enqueue(Ze({
                    retriesPerformedSoFar: t
                }, n)) : (r = n.callback) === null || r === void 0 || r.call(n, s)
            }
        }))
    }
    enqueue(e) {
        var t = e.retriesPerformedSoFar || 0;
        e.retriesPerformedSoFar = t + 1;
        var n = function(o) {
            var a = 3e3 * Math.pow(2, o)
              , l = a / 2
              , c = Math.min(18e5, a)
              , u = (Math.random() - .5) * (c - l);
            return Math.ceil(c + u)
        }(t)
          , s = Date.now() + n;
        this.queue.push({
            retryAt: s,
            requestOptions: e
        });
        var r = "Enqueued failed request for retry in ".concat(n);
        navigator.onLine || (r += " (Browser is offline)"),
        Fe.warn(r),
        this.isPolling || (this.isPolling = !0,
        this.poll())
    }
    poll() {
        this.poller && clearTimeout(this.poller),
        this.poller = setTimeout( () => {
            this.areWeOnline && this.queue.length > 0 && this.flush(),
            this.poll()
        }
        , this.pollIntervalMs)
    }
    flush() {
        var e = Date.now()
          , t = []
          , n = this.queue.filter(r => r.retryAt < e || (t.push(r),
        !1));
        if (this.queue = t,
        n.length > 0)
            for (var {requestOptions: s} of n)
                this.retriableRequest(s)
    }
    unload() {
        for (var {requestOptions: e} of (this.poller && (clearTimeout(this.poller),
        this.poller = void 0),
        this.queue))
            try {
                this.instance._send_request(Ze(Ze({}, e), {}, {
                    transport: "sendBeacon"
                }))
            } catch (t) {
                Fe.error(t)
            }
        this.queue = []
    }
}
var ul;
class KD {
    constructor(e, t, n, s) {
        var r;
        ot(this, "_sessionIdChangedHandlers", []),
        this.config = e,
        this.persistence = t,
        this._windowId = void 0,
        this._sessionId = void 0,
        this._sessionStartTimestamp = null,
        this._sessionActivityTimestamp = null,
        this._sessionIdGenerator = n || la,
        this._windowIdGenerator = s || la;
        var o = e.persistence_name || e.token
          , a = e.session_idle_timeout_seconds || 1800;
        if (this._sessionTimeoutMs = 1e3 * Co(a, 60, 1800, "session_idle_timeout_seconds"),
        this._window_id_storage_key = "ph_" + o + "_window_id",
        this._primary_window_exists_storage_key = "ph_" + o + "_primary_window_exists",
        this._canUseSessionStorage()) {
            var l = wi.parse(this._window_id_storage_key)
              , c = wi.parse(this._primary_window_exists_storage_key);
            l && !c ? this._windowId = l : wi.remove(this._window_id_storage_key),
            wi.set(this._primary_window_exists_storage_key, !0)
        }
        if ((r = this.config.bootstrap) !== null && r !== void 0 && r.sessionID)
            try {
                var u = (d => {
                    var f = d.replace(/-/g, "");
                    if (f.length !== 32)
                        throw new Error("Not a valid UUID");
                    if (f[12] !== "7")
                        throw new Error("Not a UUIDv7");
                    return parseInt(f.substring(0, 12), 16)
                }
                )(this.config.bootstrap.sessionID);
                this._setSessionId(this.config.bootstrap.sessionID, new Date().getTime(), u)
            } catch (d) {
                Fe.error("Invalid sessionID in bootstrap", d)
            }
        this._listenToReloadWindow()
    }
    get sessionTimeoutMs() {
        return this._sessionTimeoutMs
    }
    onSessionId(e) {
        return Et(this._sessionIdChangedHandlers) && (this._sessionIdChangedHandlers = []),
        this._sessionIdChangedHandlers.push(e),
        this._sessionId && e(this._sessionId, this._windowId),
        () => {
            this._sessionIdChangedHandlers = this._sessionIdChangedHandlers.filter(t => t !== e)
        }
    }
    _canUseSessionStorage() {
        return this.config.persistence !== "memory" && !this.persistence.disabled && wi.is_supported()
    }
    _setWindowId(e) {
        e !== this._windowId && (this._windowId = e,
        this._canUseSessionStorage() && wi.set(this._window_id_storage_key, e))
    }
    _getWindowId() {
        return this._windowId ? this._windowId : this._canUseSessionStorage() ? wi.parse(this._window_id_storage_key) : null
    }
    _setSessionId(e, t, n) {
        e === this._sessionId && t === this._sessionActivityTimestamp && n === this._sessionStartTimestamp || (this._sessionStartTimestamp = n,
        this._sessionActivityTimestamp = t,
        this._sessionId = e,
        this.persistence.register({
            [ip]: [t, e, n]
        }))
    }
    _getSessionId() {
        if (this._sessionId && this._sessionActivityTimestamp && this._sessionStartTimestamp)
            return [this._sessionActivityTimestamp, this._sessionId, this._sessionStartTimestamp];
        var e = this.persistence.props[ip];
        return Wn(e) && e.length === 2 && e.push(e[0]),
        e || [0, null, 0]
    }
    resetSessionId() {
        this._setSessionId(null, null, null)
    }
    _listenToReloadWindow() {
        pe == null || pe.addEventListener("beforeunload", () => {
            this._canUseSessionStorage() && wi.remove(this._primary_window_exists_storage_key)
        }
        )
    }
    checkAndGetSessionAndWindowId() {
        var e = arguments.length > 0 && arguments[0] !== void 0 && arguments[0]
          , t = (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null) || new Date().getTime()
          , [n,s,r] = this._getSessionId()
          , o = this._getWindowId()
          , a = vs(r) && r > 0 && Math.abs(t - r) > 864e5
          , l = !1
          , c = !s
          , u = !e && Math.abs(t - n) > this.sessionTimeoutMs;
        c || u || a ? (s = this._sessionIdGenerator(),
        o = this._windowIdGenerator(),
        Fe.info("[SessionId] new session ID generated", {
            sessionId: s,
            windowId: o,
            changeReason: {
                noSessionId: c,
                activityTimeout: u,
                sessionPastMaximumLength: a
            }
        }),
        r = t,
        l = !0) : o || (o = this._windowIdGenerator(),
        l = !0);
        var d = n === 0 || !e || a ? t : n
          , f = r === 0 ? new Date().getTime() : r;
        return this._setWindowId(o),
        this._setSessionId(s, d, f),
        l && this._sessionIdChangedHandlers.forEach(h => h(s, o, l ? {
            noSessionId: c,
            activityTimeout: u,
            sessionPastMaximumLength: a
        } : void 0)),
        {
            sessionId: s,
            windowId: o,
            sessionStartTimestamp: f,
            changeReason: l ? {
                noSessionId: c,
                activityTimeout: u,
                sessionPastMaximumLength: a
            } : void 0,
            lastActivityTimestamp: n
        }
    }
}
(function(i) {
    i.US = "us",
    i.EU = "eu",
    i.CUSTOM = "custom"
}
)(ul || (ul = {}));
var O2 = "i.posthog.com";
class XD {
    constructor(e) {
        ot(this, "_regionCache", {}),
        this.instance = e
    }
    get apiHost() {
        var e = this.instance.config.api_host.trim().replace(/\/$/, "");
        return e === "https://app.posthog.com" ? "https://us.i.posthog.com" : e
    }
    get uiHost() {
        var e, t = (e = this.instance.config.ui_host) === null || e === void 0 ? void 0 : e.replace(/\/$/, "");
        return t || (t = this.apiHost.replace(".".concat(O2), ".posthog.com")),
        t === "https://app.posthog.com" ? "https://us.posthog.com" : t
    }
    get region() {
        return this._regionCache[this.apiHost] || (/https:\/\/(app|us|us-assets)(\.i)?\.posthog\.com/i.test(this.apiHost) ? this._regionCache[this.apiHost] = ul.US : /https:\/\/(eu|eu-assets)(\.i)?\.posthog\.com/i.test(this.apiHost) ? this._regionCache[this.apiHost] = ul.EU : this._regionCache[this.apiHost] = ul.CUSTOM),
        this._regionCache[this.apiHost]
    }
    endpointFor(e) {
        var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
        if (t && (t = t[0] === "/" ? t : "/".concat(t)),
        e === "ui")
            return this.uiHost + t;
        if (this.region === ul.CUSTOM)
            return this.apiHost + t;
        var n = O2 + t;
        switch (e) {
        case "assets":
            return "https://".concat(this.region, "-assets.").concat(n);
        case "api":
            return "https://".concat(this.region, ".").concat(n)
        }
    }
}
var TA = "posthog-js";
function AA(i) {
    var {organization: e, projectId: t, prefix: n, severityAllowList: s=["error"]} = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return r => {
        var o, a, l, c, u;
        if (!(s === "*" || s.includes(r.level)) || !i.__loaded)
            return r;
        r.tags || (r.tags = {});
        var d = i.requestRouter.endpointFor("ui", "/project/".concat(i.config.token, "/person/").concat(i.get_distinct_id()));
        r.tags["PostHog Person URL"] = d,
        i.sessionRecordingStarted() && (r.tags["PostHog Recording URL"] = i.get_session_replay_url({
            withTimestamp: !0
        }));
        var f = ((o = r.exception) === null || o === void 0 ? void 0 : o.values) || [];
        f.map(p => {
            p.stacktrace && (p.stacktrace.type = "raw")
        }
        );
        var h = {
            $exception_message: ((a = f[0]) === null || a === void 0 ? void 0 : a.value) || r.message,
            $exception_type: (l = f[0]) === null || l === void 0 ? void 0 : l.type,
            $exception_personURL: d,
            $exception_level: r.level,
            $exception_list: f,
            $sentry_event_id: r.event_id,
            $sentry_exception: r.exception,
            $sentry_exception_message: ((c = f[0]) === null || c === void 0 ? void 0 : c.value) || r.message,
            $sentry_exception_type: (u = f[0]) === null || u === void 0 ? void 0 : u.type,
            $sentry_tags: r.tags
        };
        return e && t && (h.$sentry_url = (n || "https://sentry.io/organizations/") + e + "/issues/?project=" + t + "&query=" + r.event_id),
        i.exceptions.sendExceptionEvent(h),
        r
    }
}
class YD {
    constructor(e, t, n, s, r) {
        this.name = TA,
        this.setupOnce = function(o) {
            o(AA(e, {
                organization: t,
                projectId: n,
                prefix: s,
                severityAllowList: r
            }))
        }
    }
}
var U2, pp, nr;
function ZD(i, e) {
    var t = i.config.segment;
    if (!t)
        return e();
    (function(n, s) {
        var r = n.config.segment;
        if (!r)
            return s();
        var o = l => {
            var c = () => l.anonymousId() || la();
            n.config.get_device_id = c,
            l.id() && (n.register({
                distinct_id: l.id(),
                $device_id: c()
            }),
            n.persistence.set_property(mo, "identified")),
            s()
        }
          , a = r.user();
        "then"in a && Os(a.then) ? a.then(l => o(l)) : o(a)
    }
    )(i, () => {
        t.register((n => {
            Promise && Promise.resolve || Fe.warn("This browser does not have Promise support, and can not use the segment integration");
            var s = (r, o) => {
                var a;
                if (!o)
                    return r;
                r.event.userId || r.event.anonymousId === n.get_distinct_id() || (Fe.info("Segment integration does not have a userId set, resetting PostHog"),
                n.reset()),
                r.event.userId && r.event.userId !== n.get_distinct_id() && (Fe.info("Segment integration has a userId set, identifying with PostHog"),
                n.identify(r.event.userId));
                var l = n._calculate_event_properties(o, (a = r.event.properties) !== null && a !== void 0 ? a : {}, new Date);
                return r.event.properties = Object.assign({}, l, r.event.properties),
                r
            }
            ;
            return {
                name: "PostHog JS",
                type: "enrichment",
                version: "1.0.0",
                isLoaded: () => !0,
                load: () => Promise.resolve(),
                track: r => s(r, r.event.event),
                page: r => s(r, "$pageview"),
                identify: r => s(r, "$identify"),
                screen: r => s(r, "$screen")
            }
        }
        )(i)).then( () => {
            e()
        }
        )
    }
    )
}
class JD {
    constructor(e) {
        this._instance = e
    }
    doPageView(e) {
        var t, n = this._previousPageViewProperties(e);
        return this._currentPath = (t = pe == null ? void 0 : pe.location.pathname) !== null && t !== void 0 ? t : "",
        this._instance.scrollManager.resetContext(),
        this._prevPageviewTimestamp = e,
        n
    }
    doPageLeave(e) {
        return this._previousPageViewProperties(e)
    }
    _previousPageViewProperties(e) {
        var t = this._currentPath
          , n = this._prevPageviewTimestamp
          , s = this._instance.scrollManager.getContext();
        if (!n)
            return {};
        var r = {};
        if (s) {
            var {maxScrollHeight: o, lastScrollY: a, maxScrollY: l, maxContentHeight: c, lastContentY: u, maxContentY: d} = s;
            Et(o) || Et(a) || Et(l) || Et(c) || Et(u) || Et(d) || (o = Math.ceil(o),
            a = Math.ceil(a),
            l = Math.ceil(l),
            c = Math.ceil(c),
            u = Math.ceil(u),
            d = Math.ceil(d),
            r = {
                $prev_pageview_last_scroll: a,
                $prev_pageview_last_scroll_percentage: o <= 1 ? 1 : Co(a / o, 0, 1),
                $prev_pageview_max_scroll: l,
                $prev_pageview_max_scroll_percentage: o <= 1 ? 1 : Co(l / o, 0, 1),
                $prev_pageview_last_content: u,
                $prev_pageview_last_content_percentage: c <= 1 ? 1 : Co(u / c, 0, 1),
                $prev_pageview_max_content: d,
                $prev_pageview_max_content_percentage: c <= 1 ? 1 : Co(d / c, 0, 1)
            })
        }
        return t && (r.$prev_pageview_pathname = t),
        n && (r.$prev_pageview_duration = (e.getTime() - n.getTime()) / 1e3),
        r
    }
}
(function(i) {
    i.Popover = "popover",
    i.API = "api",
    i.Widget = "widget"
}
)(U2 || (U2 = {})),
function(i) {
    i.Open = "open",
    i.MultipleChoice = "multiple_choice",
    i.SingleChoice = "single_choice",
    i.Rating = "rating",
    i.Link = "link"
}(pp || (pp = {})),
function(i) {
    i.NextQuestion = "next_question",
    i.End = "end",
    i.ResponseBased = "response_based",
    i.SpecificQuestion = "specific_question"
}(nr || (nr = {}));
class CA {
    constructor() {
        ot(this, "events", {}),
        this.events = {}
    }
    on(e, t) {
        return this.events[e] || (this.events[e] = []),
        this.events[e].push(t),
        () => {
            this.events[e] = this.events[e].filter(n => n !== t)
        }
    }
    emit(e, t) {
        for (var n of this.events[e] || [])
            n(t);
        for (var s of this.events["*"] || [])
            s(e, t)
    }
}
class rl {
    constructor(e) {
        ot(this, "_debugEventEmitter", new CA),
        ot(this, "checkStep", (t, n) => this.checkStepEvent(t, n) && this.checkStepUrl(t, n) && this.checkStepElement(t, n)),
        ot(this, "checkStepEvent", (t, n) => n == null || !n.event || (t == null ? void 0 : t.event) === (n == null ? void 0 : n.event)),
        this.instance = e,
        this.actionEvents = new Set,
        this.actionRegistry = new Set
    }
    init() {
        var e;
        if (!Et((e = this.instance) === null || e === void 0 ? void 0 : e._addCaptureHook)) {
            var t;
            (t = this.instance) === null || t === void 0 || t._addCaptureHook( (n, s) => {
                this.on(n, s)
            }
            )
        }
    }
    register(e) {
        var t, n;
        if (!Et((t = this.instance) === null || t === void 0 ? void 0 : t._addCaptureHook) && (e.forEach(o => {
            var a, l;
            (a = this.actionRegistry) === null || a === void 0 || a.add(o),
            (l = o.steps) === null || l === void 0 || l.forEach(c => {
                var u;
                (u = this.actionEvents) === null || u === void 0 || u.add((c == null ? void 0 : c.event) || "")
            }
            )
        }
        ),
        (n = this.instance) !== null && n !== void 0 && n.autocapture)) {
            var s, r = new Set;
            e.forEach(o => {
                var a;
                (a = o.steps) === null || a === void 0 || a.forEach(l => {
                    l != null && l.selector && r.add(l == null ? void 0 : l.selector)
                }
                )
            }
            ),
            (s = this.instance) === null || s === void 0 || s.autocapture.setElementSelectors(r)
        }
    }
    on(e, t) {
        var n;
        t != null && e.length != 0 && (this.actionEvents.has(e) || this.actionEvents.has(t == null ? void 0 : t.event)) && this.actionRegistry && ((n = this.actionRegistry) === null || n === void 0 ? void 0 : n.size) > 0 && this.actionRegistry.forEach(s => {
            this.checkAction(t, s) && this._debugEventEmitter.emit("actionCaptured", s.name)
        }
        )
    }
    _addActionHook(e) {
        this.onAction("actionCaptured", t => e(t))
    }
    checkAction(e, t) {
        if ((t == null ? void 0 : t.steps) == null)
            return !1;
        for (var n of t.steps)
            if (this.checkStep(e, n))
                return !0;
        return !1
    }
    onAction(e, t) {
        return this._debugEventEmitter.on(e, t)
    }
    checkStepUrl(e, t) {
        if (t != null && t.url) {
            var n, s = e == null || (n = e.properties) === null || n === void 0 ? void 0 : n.$current_url;
            if (!s || typeof s != "string" || !rl.matchString(s, t == null ? void 0 : t.url, (t == null ? void 0 : t.url_matching) || "contains"))
                return !1
        }
        return !0
    }
    static matchString(e, t, n) {
        switch (n) {
        case "regex":
            return !!pe && tu(e, t);
        case "exact":
            return t === e;
        case "contains":
            var s = rl.escapeStringRegexp(t).replace(/_/g, ".").replace(/%/g, ".*");
            return tu(e, s);
        default:
            return !1
        }
    }
    static escapeStringRegexp(e) {
        return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d")
    }
    checkStepElement(e, t) {
        if ((t != null && t.href || t != null && t.tag_name || t != null && t.text) && !this.getElementsList(e).some(r => !(t != null && t.href && !rl.matchString(r.href || "", t == null ? void 0 : t.href, (t == null ? void 0 : t.href_matching) || "exact")) && (t == null || !t.tag_name || r.tag_name === (t == null ? void 0 : t.tag_name)) && !(t != null && t.text && !rl.matchString(r.text || "", t == null ? void 0 : t.text, (t == null ? void 0 : t.text_matching) || "exact") && !rl.matchString(r.$el_text || "", t == null ? void 0 : t.text, (t == null ? void 0 : t.text_matching) || "exact"))))
            return !1;
        if (t != null && t.selector) {
            var n, s = e == null || (n = e.properties) === null || n === void 0 ? void 0 : n.$element_selectors;
            if (!s || !s.includes(t == null ? void 0 : t.selector))
                return !1
        }
        return !0
    }
    getElementsList(e) {
        return (e == null ? void 0 : e.properties.$elements) == null ? [] : e == null ? void 0 : e.properties.$elements
    }
}
class kd {
    constructor(e) {
        this.instance = e,
        this.eventToSurveys = new Map,
        this.actionToSurveys = new Map
    }
    register(e) {
        var t;
        Et((t = this.instance) === null || t === void 0 ? void 0 : t._addCaptureHook) || (this.setupEventBasedSurveys(e),
        this.setupActionBasedSurveys(e))
    }
    setupActionBasedSurveys(e) {
        var t = e.filter(n => {
            var s, r, o, a;
            return ((s = n.conditions) === null || s === void 0 ? void 0 : s.actions) && ((r = n.conditions) === null || r === void 0 || (o = r.actions) === null || o === void 0 || (a = o.values) === null || a === void 0 ? void 0 : a.length) > 0
        }
        );
        t.length !== 0 && (this.actionMatcher == null && (this.actionMatcher = new rl(this.instance),
        this.actionMatcher.init(),
        this.actionMatcher._addActionHook(n => {
            this.onAction(n)
        }
        )),
        t.forEach(n => {
            var s, r, o, a, l, c, u, d, f, h;
            n.conditions && (s = n.conditions) !== null && s !== void 0 && s.actions && (r = n.conditions) !== null && r !== void 0 && (o = r.actions) !== null && o !== void 0 && o.values && ((a = n.conditions) === null || a === void 0 || (l = a.actions) === null || l === void 0 || (c = l.values) === null || c === void 0 ? void 0 : c.length) > 0 && ((u = this.actionMatcher) === null || u === void 0 || u.register(n.conditions.actions.values),
            (d = n.conditions) === null || d === void 0 || (f = d.actions) === null || f === void 0 || (h = f.values) === null || h === void 0 || h.forEach(p => {
                if (p && p.name) {
                    var g = this.actionToSurveys.get(p.name);
                    g && g.push(n.id),
                    this.actionToSurveys.set(p.name, g || [n.id])
                }
            }
            ))
        }
        ))
    }
    setupEventBasedSurveys(e) {
        var t;
        e.filter(n => {
            var s, r, o, a;
            return ((s = n.conditions) === null || s === void 0 ? void 0 : s.events) && ((r = n.conditions) === null || r === void 0 || (o = r.events) === null || o === void 0 || (a = o.values) === null || a === void 0 ? void 0 : a.length) > 0
        }
        ).length !== 0 && ((t = this.instance) === null || t === void 0 || t._addCaptureHook( (n, s) => {
            this.onEvent(n, s)
        }
        ),
        e.forEach(n => {
            var s, r, o;
            (s = n.conditions) === null || s === void 0 || (r = s.events) === null || r === void 0 || (o = r.values) === null || o === void 0 || o.forEach(a => {
                if (a && a.name) {
                    var l = this.eventToSurveys.get(a.name);
                    l && l.push(n.id),
                    this.eventToSurveys.set(a.name, l || [n.id])
                }
            }
            )
        }
        ))
    }
    onEvent(e, t) {
        var n, s, r = ((n = this.instance) === null || n === void 0 || (s = n.persistence) === null || s === void 0 ? void 0 : s.props[xf]) || [];
        if (kd.SURVEY_SHOWN_EVENT_NAME == e && t && r.length > 0) {
            var o, a = t == null || (o = t.properties) === null || o === void 0 ? void 0 : o.$survey_id;
            if (a) {
                var l = r.indexOf(a);
                l >= 0 && (r.splice(l, 1),
                this._updateActivatedSurveys(r))
            }
        } else
            this.eventToSurveys.has(e) && this._updateActivatedSurveys(r.concat(this.eventToSurveys.get(e) || []))
    }
    onAction(e) {
        var t, n, s = ((t = this.instance) === null || t === void 0 || (n = t.persistence) === null || n === void 0 ? void 0 : n.props[xf]) || [];
        this.actionToSurveys.has(e) && this._updateActivatedSurveys(s.concat(this.actionToSurveys.get(e) || []))
    }
    _updateActivatedSurveys(e) {
        var t, n;
        (t = this.instance) === null || t === void 0 || (n = t.persistence) === null || n === void 0 || n.register({
            [xf]: [...new Set(e)]
        })
    }
    getSurveys() {
        var e, t, n = (e = this.instance) === null || e === void 0 || (t = e.persistence) === null || t === void 0 ? void 0 : t.props[xf];
        return n || []
    }
    getEventToSurveys() {
        return this.eventToSurveys
    }
    _getActionMatcher() {
        return this.actionMatcher
    }
}
ot(kd, "SURVEY_SHOWN_EVENT_NAME", "survey shown");
var MA, Hn, RA, ol, N2, LA, x1, IA, y1 = {}, kA = [], QD = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i, I_ = Array.isArray;
function ca(i, e) {
    for (var t in e)
        i[t] = e[t];
    return i
}
function PA(i) {
    var e = i.parentNode;
    e && e.removeChild(i)
}
function u0(i, e, t, n, s) {
    var r = {
        type: i,
        props: e,
        key: t,
        ref: n,
        __k: null,
        __: null,
        __b: 0,
        __e: null,
        __d: void 0,
        __c: null,
        constructor: void 0,
        __v: s == null ? ++RA : s,
        __i: -1,
        __u: 0
    };
    return s == null && Hn.vnode != null && Hn.vnode(r),
    r
}
function k_(i) {
    return i.children
}
function yh(i, e) {
    this.props = i,
    this.context = e
}
function ru(i, e) {
    if (e == null)
        return i.__ ? ru(i.__, i.__i + 1) : null;
    for (var t; e < i.__k.length; e++)
        if ((t = i.__k[e]) != null && t.__e != null)
            return t.__e;
    return typeof i.type == "function" ? ru(i) : null
}
function DA(i) {
    var e, t;
    if ((i = i.__) != null && i.__c != null) {
        for (i.__e = i.__c.base = null,
        e = 0; e < i.__k.length; e++)
            if ((t = i.__k[e]) != null && t.__e != null) {
                i.__e = i.__c.base = t.__e;
                break
            }
        return DA(i)
    }
}
function b1(i) {
    (!i.__d && (i.__d = !0) && ol.push(i) && !mp.__r++ || N2 !== Hn.debounceRendering) && ((N2 = Hn.debounceRendering) || LA)(mp)
}
function mp() {
    var i, e, t, n, s, r, o, a, l;
    for (ol.sort(x1); i = ol.shift(); )
        i.__d && (e = ol.length,
        n = void 0,
        r = (s = (t = i).__v).__e,
        a = [],
        l = [],
        (o = t.__P) && ((n = ca({}, s)).__v = s.__v + 1,
        Hn.vnode && Hn.vnode(n),
        UA(o, n, s, t.__n, o.ownerSVGElement !== void 0, 32 & s.__u ? [r] : null, a, r == null ? ru(s) : r, !!(32 & s.__u), l),
        n.__.__k[n.__i] = n,
        n8(a, n, l),
        n.__e != r && DA(n)),
        ol.length > e && ol.sort(x1));
    mp.__r = 0
}
function FA(i, e, t, n, s, r, o, a, l, c, u) {
    var d, f, h, p, g, m = n && n.__k || kA, v = e.length;
    for (t.__d = l,
    e8(t, e, m),
    l = t.__d,
    d = 0; d < v; d++)
        (h = t.__k[d]) != null && typeof h != "boolean" && typeof h != "function" && (f = h.__i === -1 ? y1 : m[h.__i] || y1,
        h.__i = d,
        UA(i, h, f, s, r, o, a, l, c, u),
        p = h.__e,
        h.ref && f.ref != h.ref && (f.ref && P_(f.ref, null, h),
        u.push(h.ref, h.__c || p, h)),
        g == null && p != null && (g = p),
        65536 & h.__u || f.__k === h.__k ? l = OA(h, l, i) : typeof h.type == "function" && h.__d !== void 0 ? l = h.__d : p && (l = p.nextSibling),
        h.__d = void 0,
        h.__u &= -196609);
    t.__d = l,
    t.__e = g
}
function e8(i, e, t) {
    var n, s, r, o, a, l = e.length, c = t.length, u = c, d = 0;
    for (i.__k = [],
    n = 0; n < l; n++)
        (s = i.__k[n] = (s = e[n]) == null || typeof s == "boolean" || typeof s == "function" ? null : typeof s == "string" || typeof s == "number" || typeof s == "bigint" || s.constructor == String ? u0(null, s, null, null, s) : I_(s) ? u0(k_, {
            children: s
        }, null, null, null) : s.constructor === void 0 && s.__b > 0 ? u0(s.type, s.props, s.key, s.ref ? s.ref : null, s.__v) : s) != null ? (s.__ = i,
        s.__b = i.__b + 1,
        a = t8(s, t, o = n + d, u),
        s.__i = a,
        r = null,
        a !== -1 && (u--,
        (r = t[a]) && (r.__u |= 131072)),
        r == null || r.__v === null ? (a == -1 && d--,
        typeof s.type != "function" && (s.__u |= 65536)) : a !== o && (a === o + 1 ? d++ : a > o ? u > l - o ? d += a - o : d-- : d = a < o && a == o - 1 ? a - o : 0,
        a !== n + d && (s.__u |= 65536))) : (r = t[n]) && r.key == null && r.__e && (r.__e == i.__d && (i.__d = ru(r)),
        S1(r, r, !1),
        t[n] = null,
        u--);
    if (u)
        for (n = 0; n < c; n++)
            (r = t[n]) != null && (131072 & r.__u) == 0 && (r.__e == i.__d && (i.__d = ru(r)),
            S1(r, r))
}
function OA(i, e, t) {
    var n, s;
    if (typeof i.type == "function") {
        for (n = i.__k,
        s = 0; n && s < n.length; s++)
            n[s] && (n[s].__ = i,
            e = OA(n[s], e, t));
        return e
    }
    return i.__e != e && (t.insertBefore(i.__e, e || null),
    e = i.__e),
    e && e.nextSibling
}
function t8(i, e, t, n) {
    var s = i.key
      , r = i.type
      , o = t - 1
      , a = t + 1
      , l = e[t];
    if (l === null || l && s == l.key && r === l.type)
        return t;
    if (n > (l != null && (131072 & l.__u) == 0 ? 1 : 0))
        for (; o >= 0 || a < e.length; ) {
            if (o >= 0) {
                if ((l = e[o]) && (131072 & l.__u) == 0 && s == l.key && r === l.type)
                    return o;
                o--
            }
            if (a < e.length) {
                if ((l = e[a]) && (131072 & l.__u) == 0 && s == l.key && r === l.type)
                    return a;
                a++
            }
        }
    return -1
}
function B2(i, e, t) {
    e[0] === "-" ? i.setProperty(e, t == null ? "" : t) : i[e] = t == null ? "" : typeof t != "number" || QD.test(e) ? t : t + "px"
}
function Tf(i, e, t, n, s) {
    var r;
    e: if (e === "style")
        if (typeof t == "string")
            i.style.cssText = t;
        else {
            if (typeof n == "string" && (i.style.cssText = n = ""),
            n)
                for (e in n)
                    t && e in t || B2(i.style, e, "");
            if (t)
                for (e in t)
                    n && t[e] === n[e] || B2(i.style, e, t[e])
        }
    else if (e[0] === "o" && e[1] === "n")
        r = e !== (e = e.replace(/(PointerCapture)$|Capture$/, "$1")),
        e = e.toLowerCase()in i ? e.toLowerCase().slice(2) : e.slice(2),
        i.l || (i.l = {}),
        i.l[e + r] = t,
        t ? n ? t.u = n.u : (t.u = Date.now(),
        i.addEventListener(e, r ? $2 : V2, r)) : i.removeEventListener(e, r ? $2 : V2, r);
    else {
        if (s)
            e = e.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
        else if (e !== "width" && e !== "height" && e !== "href" && e !== "list" && e !== "form" && e !== "tabIndex" && e !== "download" && e !== "rowSpan" && e !== "colSpan" && e !== "role" && e in i)
            try {
                i[e] = t == null ? "" : t;
                break e
            } catch {}
        typeof t == "function" || (t == null || t === !1 && e[4] !== "-" ? i.removeAttribute(e) : i.setAttribute(e, t))
    }
}
function V2(i) {
    var e = this.l[i.type + !1];
    if (i.t) {
        if (i.t <= e.u)
            return
    } else
        i.t = Date.now();
    return e(Hn.event ? Hn.event(i) : i)
}
function $2(i) {
    return this.l[i.type + !0](Hn.event ? Hn.event(i) : i)
}
function UA(i, e, t, n, s, r, o, a, l, c) {
    var u, d, f, h, p, g, m, v, _, y, b, S, C, M, L, T = e.type;
    if (e.constructor !== void 0)
        return null;
    128 & t.__u && (l = !!(32 & t.__u),
    r = [a = e.__e = t.__e]),
    (u = Hn.__b) && u(e);
    e: if (typeof T == "function")
        try {
            if (v = e.props,
            _ = (u = T.contextType) && n[u.__c],
            y = u ? _ ? _.props.value : u.__ : n,
            t.__c ? m = (d = e.__c = t.__c).__ = d.__E : ("prototype"in T && T.prototype.render ? e.__c = d = new T(v,y) : (e.__c = d = new yh(v,y),
            d.constructor = T,
            d.render = s8),
            _ && _.sub(d),
            d.props = v,
            d.state || (d.state = {}),
            d.context = y,
            d.__n = n,
            f = d.__d = !0,
            d.__h = [],
            d._sb = []),
            d.__s == null && (d.__s = d.state),
            T.getDerivedStateFromProps != null && (d.__s == d.state && (d.__s = ca({}, d.__s)),
            ca(d.__s, T.getDerivedStateFromProps(v, d.__s))),
            h = d.props,
            p = d.state,
            d.__v = e,
            f)
                T.getDerivedStateFromProps == null && d.componentWillMount != null && d.componentWillMount(),
                d.componentDidMount != null && d.__h.push(d.componentDidMount);
            else {
                if (T.getDerivedStateFromProps == null && v !== h && d.componentWillReceiveProps != null && d.componentWillReceiveProps(v, y),
                !d.__e && (d.shouldComponentUpdate != null && d.shouldComponentUpdate(v, d.__s, y) === !1 || e.__v === t.__v)) {
                    for (e.__v !== t.__v && (d.props = v,
                    d.state = d.__s,
                    d.__d = !1),
                    e.__e = t.__e,
                    e.__k = t.__k,
                    e.__k.forEach(function(A) {
                        A && (A.__ = e)
                    }),
                    b = 0; b < d._sb.length; b++)
                        d.__h.push(d._sb[b]);
                    d._sb = [],
                    d.__h.length && o.push(d);
                    break e
                }
                d.componentWillUpdate != null && d.componentWillUpdate(v, d.__s, y),
                d.componentDidUpdate != null && d.__h.push(function() {
                    d.componentDidUpdate(h, p, g)
                })
            }
            if (d.context = y,
            d.props = v,
            d.__P = i,
            d.__e = !1,
            S = Hn.__r,
            C = 0,
            "prototype"in T && T.prototype.render) {
                for (d.state = d.__s,
                d.__d = !1,
                S && S(e),
                u = d.render(d.props, d.state, d.context),
                M = 0; M < d._sb.length; M++)
                    d.__h.push(d._sb[M]);
                d._sb = []
            } else
                do
                    d.__d = !1,
                    S && S(e),
                    u = d.render(d.props, d.state, d.context),
                    d.state = d.__s;
                while (d.__d && ++C < 25);
            d.state = d.__s,
            d.getChildContext != null && (n = ca(ca({}, n), d.getChildContext())),
            f || d.getSnapshotBeforeUpdate == null || (g = d.getSnapshotBeforeUpdate(h, p)),
            FA(i, I_(L = u != null && u.type === k_ && u.key == null ? u.props.children : u) ? L : [L], e, t, n, s, r, o, a, l, c),
            d.base = e.__e,
            e.__u &= -161,
            d.__h.length && o.push(d),
            m && (d.__E = d.__ = null)
        } catch (A) {
            e.__v = null,
            l || r != null ? (e.__e = a,
            e.__u |= l ? 160 : 32,
            r[r.indexOf(a)] = null) : (e.__e = t.__e,
            e.__k = t.__k),
            Hn.__e(A, e, t)
        }
    else
        r == null && e.__v === t.__v ? (e.__k = t.__k,
        e.__e = t.__e) : e.__e = i8(t.__e, e, t, n, s, r, o, l, c);
    (u = Hn.diffed) && u(e)
}
function n8(i, e, t) {
    e.__d = void 0;
    for (var n = 0; n < t.length; n++)
        P_(t[n], t[++n], t[++n]);
    Hn.__c && Hn.__c(e, i),
    i.some(function(s) {
        try {
            i = s.__h,
            s.__h = [],
            i.some(function(r) {
                r.call(s)
            })
        } catch (r) {
            Hn.__e(r, s.__v)
        }
    })
}
function i8(i, e, t, n, s, r, o, a, l) {
    var c, u, d, f, h, p, g, m = t.props, v = e.props, _ = e.type;
    if (_ === "svg" && (s = !0),
    r != null) {
        for (c = 0; c < r.length; c++)
            if ((h = r[c]) && "setAttribute"in h == !!_ && (_ ? h.localName === _ : h.nodeType === 3)) {
                i = h,
                r[c] = null;
                break
            }
    }
    if (i == null) {
        if (_ === null)
            return document.createTextNode(v);
        i = s ? document.createElementNS("http://www.w3.org/2000/svg", _) : document.createElement(_, v.is && v),
        r = null,
        a = !1
    }
    if (_ === null)
        m === v || a && i.data === v || (i.data = v);
    else {
        if (r = r && MA.call(i.childNodes),
        m = t.props || y1,
        !a && r != null)
            for (m = {},
            c = 0; c < i.attributes.length; c++)
                m[(h = i.attributes[c]).name] = h.value;
        for (c in m)
            h = m[c],
            c == "children" || (c == "dangerouslySetInnerHTML" ? d = h : c === "key" || c in v || Tf(i, c, null, h, s));
        for (c in v)
            h = v[c],
            c == "children" ? f = h : c == "dangerouslySetInnerHTML" ? u = h : c == "value" ? p = h : c == "checked" ? g = h : c === "key" || a && typeof h != "function" || m[c] === h || Tf(i, c, h, m[c], s);
        if (u)
            a || d && (u.__html === d.__html || u.__html === i.innerHTML) || (i.innerHTML = u.__html),
            e.__k = [];
        else if (d && (i.innerHTML = ""),
        FA(i, I_(f) ? f : [f], e, t, n, s && _ !== "foreignObject", r, o, r ? r[0] : t.__k && ru(t, 0), a, l),
        r != null)
            for (c = r.length; c--; )
                r[c] != null && PA(r[c]);
        a || (c = "value",
        p !== void 0 && (p !== i[c] || _ === "progress" && !p || _ === "option" && p !== m[c]) && Tf(i, c, p, m[c], !1),
        c = "checked",
        g !== void 0 && g !== i[c] && Tf(i, c, g, m[c], !1))
    }
    return i
}
function P_(i, e, t) {
    try {
        typeof i == "function" ? i(e) : i.current = e
    } catch (n) {
        Hn.__e(n, t)
    }
}
function S1(i, e, t) {
    var n, s;
    if (Hn.unmount && Hn.unmount(i),
    (n = i.ref) && (n.current && n.current !== i.__e || P_(n, null, e)),
    (n = i.__c) != null) {
        if (n.componentWillUnmount)
            try {
                n.componentWillUnmount()
            } catch (r) {
                Hn.__e(r, e)
            }
        n.base = n.__P = null,
        i.__c = void 0
    }
    if (n = i.__k)
        for (s = 0; s < n.length; s++)
            n[s] && S1(n[s], e, t || typeof i.type != "function");
    t || i.__e == null || PA(i.__e),
    i.__ = i.__e = i.__d = void 0
}
function s8(i, e, t) {
    return this.constructor(i, t)
}
MA = kA.slice,
Hn = {
    __e: function(i, e, t, n) {
        for (var s, r, o; e = e.__; )
            if ((s = e.__c) && !s.__)
                try {
                    if ((r = s.constructor) && r.getDerivedStateFromError != null && (s.setState(r.getDerivedStateFromError(i)),
                    o = s.__d),
                    s.componentDidCatch != null && (s.componentDidCatch(i, n || {}),
                    o = s.__d),
                    o)
                        return s.__E = s
                } catch (a) {
                    i = a
                }
        throw i
    }
},
RA = 0,
yh.prototype.setState = function(i, e) {
    var t;
    t = this.__s != null && this.__s !== this.state ? this.__s : this.__s = ca({}, this.state),
    typeof i == "function" && (i = i(ca({}, t), this.props)),
    i && ca(t, i),
    i != null && this.__v && (e && this._sb.push(e),
    b1(this))
}
,
yh.prototype.forceUpdate = function(i) {
    this.__v && (this.__e = !0,
    i && this.__h.push(i),
    b1(this))
}
,
yh.prototype.render = k_,
ol = [],
LA = typeof Promise == "function" ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout,
x1 = function(i, e) {
    return i.__v.__b - e.__v.__b
}
,
mp.__r = 0,
IA = 0;
(function(i, e) {
    var t = {
        __c: e = "__cC" + IA++,
        __: i,
        Consumer: function(n, s) {
            return n.children(s)
        },
        Provider: function(n) {
            var s, r;
            return this.getChildContext || (s = [],
            (r = {})[e] = this,
            this.getChildContext = function() {
                return r
            }
            ,
            this.shouldComponentUpdate = function(o) {
                this.props.value !== o.value && s.some(function(a) {
                    a.__e = !0,
                    b1(a)
                })
            }
            ,
            this.sub = function(o) {
                s.push(o);
                var a = o.componentWillUnmount;
                o.componentWillUnmount = function() {
                    s.splice(s.indexOf(o), 1),
                    a && a.call(o)
                }
            }
            ),
            n.children
        }
    };
    t.Provider.__ = t.Consumer.contextType = t
}
)({
    isPreviewMode: !1,
    previewPageIndex: 0,
    handleCloseSurveyPopup: () => {}
    ,
    isPopup: !0
});
var Du = "[Surveys]"
  , r8 = {
    icontains: i => !!pe && pe.location.href.toLowerCase().indexOf(i.toLowerCase()) > -1,
    not_icontains: i => !!pe && pe.location.href.toLowerCase().indexOf(i.toLowerCase()) === -1,
    regex: i => !!pe && tu(pe.location.href, i),
    not_regex: i => !!pe && !tu(pe.location.href, i),
    exact: i => (pe == null ? void 0 : pe.location.href) === i,
    is_not: i => (pe == null ? void 0 : pe.location.href) !== i
};
class o8 {
    constructor(e) {
        this.instance = e,
        this._surveyEventReceiver = null
    }
    afterDecideResponse(e) {
        this._decideServerResponse = !!e.surveys,
        this.loadIfEnabled()
    }
    reset() {
        localStorage.removeItem("lastSeenSurveyDate");
        var e = ( () => {
            for (var t = [], n = 0; n < localStorage.length; n++) {
                var s = localStorage.key(n);
                s != null && s.startsWith("seenSurvey_") && t.push(s)
            }
            return t
        }
        )();
        e.forEach(t => localStorage.removeItem(t))
    }
    loadIfEnabled() {
        var e, t, n, s = Gt == null || (e = Gt.__PosthogExtensions__) === null || e === void 0 ? void 0 : e.generateSurveys;
        this.instance.config.disable_surveys || !this._decideServerResponse || s || (this._surveyEventReceiver == null && (this._surveyEventReceiver = new kd(this.instance)),
        (t = Gt.__PosthogExtensions__) === null || t === void 0 || (n = t.loadExternalDependency) === null || n === void 0 || n.call(t, this.instance, "surveys", r => {
            var o, a;
            if (r)
                return Fe.error(Du, "Could not load surveys script", r);
            this._surveyManager = (o = Gt.__PosthogExtensions__) === null || o === void 0 || (a = o.generateSurveys) === null || a === void 0 ? void 0 : a.call(o, this.instance)
        }
        ))
    }
    getSurveys(e) {
        var t = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
        if (this.instance.config.disable_surveys)
            return e([]);
        this._surveyEventReceiver == null && (this._surveyEventReceiver = new kd(this.instance));
        var n = this.instance.get_property(e1);
        if (n && !t)
            return e(n);
        this.instance._send_request({
            url: this.instance.requestRouter.endpointFor("api", "/api/surveys/?token=".concat(this.instance.config.token)),
            method: "GET",
            transport: "XHR",
            callback: s => {
                var r;
                if (s.statusCode !== 200 || !s.json)
                    return e([]);
                var o, a = s.json.surveys || [], l = a.filter(c => {
                    var u, d, f, h, p, g, m, v, _, y, b, S;
                    return ((u = c.conditions) === null || u === void 0 ? void 0 : u.events) && ((d = c.conditions) === null || d === void 0 || (f = d.events) === null || f === void 0 ? void 0 : f.values) && ((h = c.conditions) === null || h === void 0 || (p = h.events) === null || p === void 0 || (g = p.values) === null || g === void 0 ? void 0 : g.length) > 0 || ((m = c.conditions) === null || m === void 0 ? void 0 : m.actions) && ((v = c.conditions) === null || v === void 0 || (_ = v.actions) === null || _ === void 0 ? void 0 : _.values) && ((y = c.conditions) === null || y === void 0 || (b = y.actions) === null || b === void 0 || (S = b.values) === null || S === void 0 ? void 0 : S.length) > 0
                }
                );
                return l.length > 0 && ((o = this._surveyEventReceiver) === null || o === void 0 || o.register(l)),
                (r = this.instance.persistence) === null || r === void 0 || r.register({
                    [e1]: a
                }),
                e(a)
            }
        })
    }
    getActiveMatchingSurveys(e) {
        var t = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
        this.getSurveys(n => {
            var s, r = n.filter(l => !(!l.start_date || l.end_date)).filter(l => {
                var c, u, d, f;
                if (!l.conditions)
                    return !0;
                var h = (c = l.conditions) === null || c === void 0 || !c.url || r8[(u = (d = l.conditions) === null || d === void 0 ? void 0 : d.urlMatchType) !== null && u !== void 0 ? u : "icontains"](l.conditions.url)
                  , p = (f = l.conditions) === null || f === void 0 || !f.selector || (dt == null ? void 0 : dt.querySelector(l.conditions.selector));
                return h && p
            }
            ), o = (s = this._surveyEventReceiver) === null || s === void 0 ? void 0 : s.getSurveys(), a = r.filter(l => {
                var c, u, d, f, h, p, g, m, v, _, y;
                if (!(l.linked_flag_key || l.targeting_flag_key || l.internal_targeting_flag_key || (c = l.feature_flag_keys) !== null && c !== void 0 && c.length))
                    return !0;
                var b = !l.linked_flag_key || this.instance.featureFlags.isFeatureEnabled(l.linked_flag_key)
                  , S = !l.targeting_flag_key || this.instance.featureFlags.isFeatureEnabled(l.targeting_flag_key)
                  , C = ((u = l.conditions) === null || u === void 0 ? void 0 : u.events) && ((d = l.conditions) === null || d === void 0 || (f = d.events) === null || f === void 0 ? void 0 : f.values) && ((h = l.conditions) === null || h === void 0 || (p = h.events) === null || p === void 0 ? void 0 : p.values.length) > 0
                  , M = ((g = l.conditions) === null || g === void 0 ? void 0 : g.actions) && ((m = l.conditions) === null || m === void 0 || (v = m.actions) === null || v === void 0 ? void 0 : v.values) && ((_ = l.conditions) === null || _ === void 0 || (y = _.actions) === null || y === void 0 ? void 0 : y.values.length) > 0
                  , L = !C && !M || (o == null ? void 0 : o.includes(l.id))
                  , T = this._canActivateRepeatedly(l)
                  , A = !(l.internal_targeting_flag_key && !T) || this.instance.featureFlags.isFeatureEnabled(l.internal_targeting_flag_key)
                  , k = this.checkFlags(l);
                return b && S && A && L && k
            }
            );
            return e(a)
        }
        , t)
    }
    checkFlags(e) {
        var t;
        return (t = e.feature_flag_keys) === null || t === void 0 || !t.length || e.feature_flag_keys.every(n => {
            var {key: s, value: r} = n;
            return !s || !r || this.instance.featureFlags.isFeatureEnabled(r)
        }
        )
    }
    getNextSurveyStep(e, t, n) {
        var s, r = e.questions[t], o = t + 1;
        if ((s = r.branching) === null || s === void 0 || !s.type)
            return t === e.questions.length - 1 ? nr.End : o;
        if (r.branching.type === nr.End)
            return nr.End;
        if (r.branching.type === nr.SpecificQuestion) {
            if (Number.isInteger(r.branching.index))
                return r.branching.index
        } else if (r.branching.type === nr.ResponseBased) {
            if (r.type === pp.SingleChoice) {
                var a, l, c = r.choices.indexOf("".concat(n));
                if ((a = r.branching) !== null && a !== void 0 && (l = a.responseValues) !== null && l !== void 0 && l.hasOwnProperty(c)) {
                    var u = r.branching.responseValues[c];
                    return Number.isInteger(u) ? u : u === nr.End ? nr.End : o
                }
            } else if (r.type === pp.Rating) {
                var d, f;
                if (typeof n != "number" || !Number.isInteger(n))
                    throw new Error("The response type must be an integer");
                var h = function(g, m) {
                    if (m === 3) {
                        if (g < 1 || g > 3)
                            throw new Error("The response must be in range 1-3");
                        return g === 1 ? "negative" : g === 2 ? "neutral" : "positive"
                    }
                    if (m === 5) {
                        if (g < 1 || g > 5)
                            throw new Error("The response must be in range 1-5");
                        return g <= 2 ? "negative" : g === 3 ? "neutral" : "positive"
                    }
                    if (m === 7) {
                        if (g < 1 || g > 7)
                            throw new Error("The response must be in range 1-7");
                        return g <= 3 ? "negative" : g === 4 ? "neutral" : "positive"
                    }
                    if (m === 10) {
                        if (g < 0 || g > 10)
                            throw new Error("The response must be in range 0-10");
                        return g <= 6 ? "detractors" : g <= 8 ? "passives" : "promoters"
                    }
                    throw new Error("The scale must be one of: 3, 5, 7, 10")
                }(n, r.scale);
                if ((d = r.branching) !== null && d !== void 0 && (f = d.responseValues) !== null && f !== void 0 && f.hasOwnProperty(h)) {
                    var p = r.branching.responseValues[h];
                    return Number.isInteger(p) ? p : p === nr.End ? nr.End : o
                }
            }
            return o
        }
        return Fe.warn(Du, "Falling back to next question index due to unexpected branching type"),
        o
    }
    _canActivateRepeatedly(e) {
        var t;
        return Mn((t = Gt.__PosthogExtensions__) === null || t === void 0 ? void 0 : t.canActivateRepeatedly) ? (Fe.warn(Du, "canActivateRepeatedly is not defined, must init before calling"),
        !1) : Gt.__PosthogExtensions__.canActivateRepeatedly(e)
    }
    canRenderSurvey(e) {
        Mn(this._surveyManager) ? Fe.warn(Du, "canActivateRepeatedly is not defined, must init before calling") : this.getSurveys(t => {
            var n = t.filter(s => s.id === e)[0];
            this._surveyManager.canRenderSurvey(n)
        }
        )
    }
    renderSurvey(e, t) {
        Mn(this._surveyManager) ? Fe.warn(Du, "canActivateRepeatedly is not defined, must init before calling") : this.getSurveys(n => {
            var s = n.filter(r => r.id === e)[0];
            this._surveyManager.renderSurvey(s, dt == null ? void 0 : dt.querySelector(t))
        }
        )
    }
}
class a8 {
    constructor(e) {
        var t, n;
        ot(this, "serverLimits", {}),
        ot(this, "lastEventRateLimited", !1),
        ot(this, "checkForLimiting", s => {
            var r = s.text;
            if (r && r.length)
                try {
                    (JSON.parse(r).quota_limited || []).forEach(o => {
                        Fe.info("[RateLimiter] ".concat(o || "events", " is quota limited.")),
                        this.serverLimits[o] = new Date().getTime() + 6e4
                    }
                    )
                } catch (o) {
                    return void Fe.warn('[RateLimiter] could not rate limit - continuing. Error: "'.concat(o == null ? void 0 : o.message, '"'), {
                        text: r
                    })
                }
        }
        ),
        this.instance = e,
        this.captureEventsPerSecond = ((t = e.config.rate_limiting) === null || t === void 0 ? void 0 : t.events_per_second) || 10,
        this.captureEventsBurstLimit = Math.max(((n = e.config.rate_limiting) === null || n === void 0 ? void 0 : n.events_burst_limit) || 10 * this.captureEventsPerSecond, this.captureEventsPerSecond),
        this.lastEventRateLimited = this.clientRateLimitContext(!0).isRateLimited
    }
    clientRateLimitContext() {
        var e, t, n, s = arguments.length > 0 && arguments[0] !== void 0 && arguments[0], r = new Date().getTime(), o = (e = (t = this.instance.persistence) === null || t === void 0 ? void 0 : t.get_property(n1)) !== null && e !== void 0 ? e : {
            tokens: this.captureEventsBurstLimit,
            last: r
        };
        o.tokens += (r - o.last) / 1e3 * this.captureEventsPerSecond,
        o.last = r,
        o.tokens > this.captureEventsBurstLimit && (o.tokens = this.captureEventsBurstLimit);
        var a = o.tokens < 1;
        return a || s || (o.tokens = Math.max(0, o.tokens - 1)),
        !a || this.lastEventRateLimited || s || this.instance.capture("$$client_ingestion_warning", {
            $$client_ingestion_warning_message: "posthog-js client rate limited. Config is set to ".concat(this.captureEventsPerSecond, " events per second and ").concat(this.captureEventsBurstLimit, " events burst limit.")
        }, {
            skip_client_rate_limiting: !0
        }),
        this.lastEventRateLimited = a,
        (n = this.instance.persistence) === null || n === void 0 || n.set_property(n1, o),
        {
            isRateLimited: a,
            remainingTokens: o.tokens
        }
    }
    isServerRateLimited(e) {
        var t = this.serverLimits[e || "events"] || !1;
        return t !== !1 && new Date().getTime() < t
    }
}
var l8 = () => Ze({
    initialPathName: (es == null ? void 0 : es.pathname) || "",
    referringDomain: Xn.referringDomain()
}, Xn.campaignParams());
class c8 {
    constructor(e, t, n) {
        ot(this, "_onSessionIdCallback", s => {
            var r = this._getStoredProps();
            if (!r || r.sessionId !== s) {
                var o = {
                    sessionId: s,
                    props: this._sessionSourceParamGenerator()
                };
                this._persistence.register({
                    [t1]: o
                })
            }
        }
        ),
        this._sessionIdManager = e,
        this._persistence = t,
        this._sessionSourceParamGenerator = n || l8,
        this._sessionIdManager.onSessionId(this._onSessionIdCallback)
    }
    _getStoredProps() {
        return this._persistence.props[t1]
    }
    getSessionProps() {
        var e, t = (e = this._getStoredProps()) === null || e === void 0 ? void 0 : e.props;
        return t ? {
            $client_session_initial_referring_host: t.referringDomain,
            $client_session_initial_pathname: t.initialPathName,
            $client_session_initial_utm_source: t.utm_source,
            $client_session_initial_utm_campaign: t.utm_campaign,
            $client_session_initial_utm_medium: t.utm_medium,
            $client_session_initial_utm_content: t.utm_content,
            $client_session_initial_utm_term: t.utm_term
        } : {}
    }
}
var u8 = ["ahrefsbot", "ahrefssiteaudit", "applebot", "baiduspider", "bingbot", "bingpreview", "bot.htm", "bot.php", "crawler", "deepscan", "duckduckbot", "facebookexternal", "facebookcatalog", "gptbot", "http://yandex.com/bots", "hubspot", "ia_archiver", "linkedinbot", "mj12bot", "msnbot", "nessus", "petalbot", "pinterest", "prerender", "rogerbot", "screaming frog", "semrushbot", "sitebulb", "slurp", "turnitin", "twitterbot", "vercelbot", "yahoo! slurp", "yandexbot", "headlesschrome", "cypress", "Google-HotelAdsVerifier", "adsbot-google", "apis-google", "duplexweb-google", "feedfetcher-google", "google favicon", "google web preview", "google-read-aloud", "googlebot", "googleweblight", "mediapartners-google", "storebot-google", "Bytespider;"]
  , H2 = function(i, e) {
    if (!i)
        return !1;
    var t = i.toLowerCase();
    return u8.concat(e || []).some(n => {
        var s = n.toLowerCase();
        return t.indexOf(s) !== -1
    }
    )
}
  , NA = function(i, e) {
    if (!i)
        return !1;
    var t = i.userAgent;
    if (t && H2(t, e))
        return !0;
    try {
        var n = i == null ? void 0 : i.userAgentData;
        if (n != null && n.brands && n.brands.some(s => H2(s == null ? void 0 : s.brand, e)))
            return !0
    } catch {}
    return !!i.webdriver
};
class BA {
    constructor() {
        this.clicks = []
    }
    isRageClick(e, t, n) {
        var s = this.clicks[this.clicks.length - 1];
        if (s && Math.abs(e - s.x) + Math.abs(t - s.y) < 30 && n - s.timestamp < 1e3) {
            if (this.clicks.push({
                x: e,
                y: t,
                timestamp: n
            }),
            this.clicks.length === 3)
                return !0
        } else
            this.clicks = [{
                x: e,
                y: t,
                timestamp: n
            }];
        return !1
    }
}
var Af = "[Dead Clicks]"
  , d8 = () => !0
  , f8 = i => {
    var e, t = !((e = i.instance.persistence) === null || e === void 0 || !e.get_property(WT)), n = i.instance.config.capture_dead_clicks;
    return cl(n) ? n : t
}
;
class VA {
    get lazyLoadedDeadClicksAutocapture() {
        return this._lazyLoadedDeadClicksAutocapture
    }
    constructor(e, t, n) {
        this.instance = e,
        this.isEnabled = t,
        this.onCapture = n,
        this.startIfEnabled()
    }
    afterDecideResponse(e) {
        this.instance.persistence && this.instance.persistence.register({
            [WT]: e == null ? void 0 : e.captureDeadClicks
        }),
        this.startIfEnabled()
    }
    startIfEnabled() {
        this.isEnabled(this) && this.loadScript( () => {
            this.start()
        }
        )
    }
    loadScript(e) {
        var t, n, s;
        (t = Gt.__PosthogExtensions__) !== null && t !== void 0 && t.initDeadClicksAutocapture && e(),
        (n = Gt.__PosthogExtensions__) === null || n === void 0 || (s = n.loadExternalDependency) === null || s === void 0 || s.call(n, this.instance, "dead-clicks-autocapture", r => {
            r ? Fe.error(Af + " failed to load script", r) : e()
        }
        )
    }
    start() {
        var e;
        if (dt) {
            if (!this._lazyLoadedDeadClicksAutocapture && (e = Gt.__PosthogExtensions__) !== null && e !== void 0 && e.initDeadClicksAutocapture) {
                var t = Zn(this.instance.config.capture_dead_clicks) ? this.instance.config.capture_dead_clicks : {};
                t.__onCapture = this.onCapture,
                this._lazyLoadedDeadClicksAutocapture = Gt.__PosthogExtensions__.initDeadClicksAutocapture(this.instance, t),
                this._lazyLoadedDeadClicksAutocapture.start(dt),
                Fe.info("".concat(Af, " starting..."))
            }
        } else
            Fe.error(Af + " `document` not found. Cannot start.")
    }
    stop() {
        this._lazyLoadedDeadClicksAutocapture && (this._lazyLoadedDeadClicksAutocapture.stop(),
        this._lazyLoadedDeadClicksAutocapture = void 0,
        Fe.info("".concat(Af, " stopping...")))
    }
}
class h8 {
    constructor(e) {
        var t;
        ot(this, "rageclicks", new BA),
        ot(this, "_enabledServerSide", !1),
        ot(this, "_initialized", !1),
        ot(this, "_flushInterval", null),
        this.instance = e,
        this._enabledServerSide = !((t = this.instance.persistence) === null || t === void 0 || !t.props[Zg]),
        pe == null || pe.addEventListener("beforeunload", () => {
            this.flush()
        }
        )
    }
    get flushIntervalMilliseconds() {
        var e = 5e3;
        return Zn(this.instance.config.capture_heatmaps) && this.instance.config.capture_heatmaps.flush_interval_milliseconds && (e = this.instance.config.capture_heatmaps.flush_interval_milliseconds),
        e
    }
    get isEnabled() {
        return Et(this.instance.config.capture_heatmaps) ? Et(this.instance.config.enable_heatmaps) ? this._enabledServerSide : this.instance.config.enable_heatmaps : this.instance.config.capture_heatmaps !== !1
    }
    startIfEnabled() {
        if (this.isEnabled) {
            if (this._initialized)
                return;
            Fe.info("[heatmaps] starting..."),
            this._setupListeners(),
            this._flushInterval = setInterval(this.flush.bind(this), this.flushIntervalMilliseconds)
        } else {
            var e, t;
            clearInterval((e = this._flushInterval) !== null && e !== void 0 ? e : void 0),
            (t = this.deadClicksCapture) === null || t === void 0 || t.stop(),
            this.getAndClearBuffer()
        }
    }
    afterDecideResponse(e) {
        var t = !!e.heatmaps;
        this.instance.persistence && this.instance.persistence.register({
            [Zg]: t
        }),
        this._enabledServerSide = t,
        this.startIfEnabled()
    }
    getAndClearBuffer() {
        var e = this.buffer;
        return this.buffer = void 0,
        e
    }
    _onDeadClick(e) {
        this._onClick(e.originalEvent, "deadclick")
    }
    _setupListeners() {
        pe && dt && (To(dt, "click", e => this._onClick(e || (pe == null ? void 0 : pe.event)), !1, !0),
        To(dt, "mousemove", e => this._onMouseMove(e || (pe == null ? void 0 : pe.event)), !1, !0),
        this.deadClicksCapture = new VA(this.instance,d8,this._onDeadClick.bind(this)),
        this.deadClicksCapture.startIfEnabled(),
        this._initialized = !0)
    }
    _getProperties(e, t) {
        var n = this.instance.scrollManager.scrollY()
          , s = this.instance.scrollManager.scrollX()
          , r = this.instance.scrollManager.scrollElement()
          , o = function(a, l, c) {
            for (var u = a; u && um(u) && !ga(u, "body"); ) {
                if (u === c)
                    return !1;
                if (Zt(l, pe == null ? void 0 : pe.getComputedStyle(u).position))
                    return !0;
                u = hA(u)
            }
            return !1
        }(fA(e), ["fixed", "sticky"], r);
        return {
            x: e.clientX + (o ? 0 : s),
            y: e.clientY + (o ? 0 : n),
            target_fixed: o,
            type: t
        }
    }
    _onClick(e) {
        var t, n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "click";
        if (!S2(e.target)) {
            var s = this._getProperties(e, n);
            (t = this.rageclicks) !== null && t !== void 0 && t.isRageClick(e.clientX, e.clientY, new Date().getTime()) && this._capture(Ze(Ze({}, s), {}, {
                type: "rageclick"
            })),
            this._capture(s)
        }
    }
    _onMouseMove(e) {
        S2(e.target) || (clearTimeout(this._mouseMoveTimeout),
        this._mouseMoveTimeout = setTimeout( () => {
            this._capture(this._getProperties(e, "mousemove"))
        }
        , 500))
    }
    _capture(e) {
        if (pe) {
            var t = pe.location.href;
            this.buffer = this.buffer || {},
            this.buffer[t] || (this.buffer[t] = []),
            this.buffer[t].push(e)
        }
    }
    flush() {
        this.buffer && !bc(this.buffer) && this.instance.capture("$$heatmap", {
            $heatmap_data: this.getAndClearBuffer()
        })
    }
}
class p8 {
    constructor(e) {
        ot(this, "_updateScrollData", () => {
            var t, n, s, r;
            this.context || (this.context = {});
            var o = this.scrollElement()
              , a = this.scrollY()
              , l = o ? Math.max(0, o.scrollHeight - o.clientHeight) : 0
              , c = a + ((o == null ? void 0 : o.clientHeight) || 0)
              , u = (o == null ? void 0 : o.scrollHeight) || 0;
            this.context.lastScrollY = Math.ceil(a),
            this.context.maxScrollY = Math.max(a, (t = this.context.maxScrollY) !== null && t !== void 0 ? t : 0),
            this.context.maxScrollHeight = Math.max(l, (n = this.context.maxScrollHeight) !== null && n !== void 0 ? n : 0),
            this.context.lastContentY = c,
            this.context.maxContentY = Math.max(c, (s = this.context.maxContentY) !== null && s !== void 0 ? s : 0),
            this.context.maxContentHeight = Math.max(u, (r = this.context.maxContentHeight) !== null && r !== void 0 ? r : 0)
        }
        ),
        this.instance = e
    }
    getContext() {
        return this.context
    }
    resetContext() {
        var e = this.context;
        return setTimeout(this._updateScrollData, 0),
        e
    }
    startMeasuringScrollPosition() {
        pe == null || pe.addEventListener("scroll", this._updateScrollData, !0),
        pe == null || pe.addEventListener("scrollend", this._updateScrollData, !0),
        pe == null || pe.addEventListener("resize", this._updateScrollData)
    }
    scrollElement() {
        if (!this.instance.config.scroll_root_selector)
            return pe == null ? void 0 : pe.document.documentElement;
        var e = Wn(this.instance.config.scroll_root_selector) ? this.instance.config.scroll_root_selector : [this.instance.config.scroll_root_selector];
        for (var t of e) {
            var n = pe == null ? void 0 : pe.document.querySelector(t);
            if (n)
                return n
        }
    }
    scrollY() {
        if (this.instance.config.scroll_root_selector) {
            var e = this.scrollElement();
            return e && e.scrollTop || 0
        }
        return pe && (pe.scrollY || pe.pageYOffset || pe.document.documentElement.scrollTop) || 0
    }
    scrollX() {
        if (this.instance.config.scroll_root_selector) {
            var e = this.scrollElement();
            return e && e.scrollLeft || 0
        }
        return pe && (pe.scrollX || pe.pageXOffset || pe.document.documentElement.scrollLeft) || 0
    }
}
function d0(i, e) {
    return e.length > i ? e.slice(0, i) + "..." : e
}
function m8(i) {
    if (i.previousElementSibling)
        return i.previousElementSibling;
    var e = i;
    do
        e = e.previousSibling;
    while (e && !um(e));
    return e
}
function g8(i, e, t, n) {
    var s = i.tagName.toLowerCase()
      , r = {
        tag_name: s
    };
    u1.indexOf(s) > -1 && !t && (s.toLowerCase() === "a" || s.toLowerCase() === "button" ? r.$el_text = d0(1024, vA(i)) : r.$el_text = d0(1024, dm(i)));
    var o = dp(i);
    o.length > 0 && (r.classes = o.filter(function(u) {
        return u !== ""
    })),
    bn(i.attributes, function(u) {
        var d;
        if ((!pA(i) || ["name", "id", "class", "aria-label"].indexOf(u.name) !== -1) && (n == null || !n.includes(u.name)) && !e && iu(u.value) && (d = u.name,
        !Di(d) || d.substring(0, 10) !== "_ngcontent" && d.substring(0, 7) !== "_nghost")) {
            var f = u.value;
            u.name === "class" && (f = M_(f).join(" ")),
            r["attr__" + u.name] = d0(1024, f)
        }
    });
    for (var a = 1, l = 1, c = i; c = m8(c); )
        a++,
        c.tagName === i.tagName && l++;
    return r.nth_child = a,
    r.nth_of_type = l,
    r
}
function v8(i, e) {
    for (var t, n, {e: s, maskAllElementAttributes: r, maskAllText: o, elementAttributeIgnoreList: a, elementsChainAsString: l} = e, c = [i], u = i; u.parentNode && !ga(u, "body"); )
        uA(u.parentNode) ? (c.push(u.parentNode.host),
        u = u.parentNode.host) : (c.push(u.parentNode),
        u = u.parentNode);
    var d, f = [], h = {}, p = !1, g = !1;
    if (bn(c, b => {
        var S = d1(b);
        b.tagName.toLowerCase() === "a" && (p = b.getAttribute("href"),
        p = S && p && iu(p) && p),
        Zt(dp(b), "ph-no-capture") && (g = !0),
        f.push(g8(b, r, o, a));
        var C = function(M) {
            if (!d1(M))
                return {};
            var L = {};
            return bn(M.attributes, function(T) {
                if (T.name && T.name.indexOf("data-ph-capture-attribute") === 0) {
                    var A = T.name.replace("data-ph-capture-attribute-", "")
                      , k = T.value;
                    A && k && iu(k) && (L[A] = k)
                }
            }),
            L
        }(b);
        Gi(h, C)
    }
    ),
    g)
        return {
            props: {},
            explicitNoCapture: g
        };
    if (o || (i.tagName.toLowerCase() === "a" || i.tagName.toLowerCase() === "button" ? f[0].$el_text = vA(i) : f[0].$el_text = dm(i)),
    p) {
        var m, v;
        f[0].attr__href = p;
        var _ = (m = Uc(p)) === null || m === void 0 ? void 0 : m.host
          , y = pe == null || (v = pe.location) === null || v === void 0 ? void 0 : v.host;
        _ && y && _ !== y && (d = p)
    }
    return {
        props: Gi({
            $event_type: s.type,
            $ce_version: 1
        }, l ? {} : {
            $elements: f
        }, {
            $elements_chain: SD(f)
        }, (t = f[0]) !== null && t !== void 0 && t.$el_text ? {
            $el_text: (n = f[0]) === null || n === void 0 ? void 0 : n.$el_text
        } : {}, d && s.type === "click" ? {
            $external_click_url: d
        } : {}, h)
    }
}
class _8 {
    constructor(e) {
        ot(this, "_initialized", !1),
        ot(this, "_isDisabledServerSide", null),
        ot(this, "rageclicks", new BA),
        ot(this, "_elementsChainAsString", !1),
        this.instance = e,
        this._elementSelectors = null
    }
    get config() {
        var e, t, n = Zn(this.instance.config.autocapture) ? this.instance.config.autocapture : {};
        return n.url_allowlist = (e = n.url_allowlist) === null || e === void 0 ? void 0 : e.map(s => new RegExp(s)),
        n.url_ignorelist = (t = n.url_ignorelist) === null || t === void 0 ? void 0 : t.map(s => new RegExp(s)),
        n
    }
    _addDomEventHandlers() {
        if (this.isBrowserSupported()) {
            if (pe && dt) {
                var e = n => {
                    n = n || (pe == null ? void 0 : pe.event);
                    try {
                        this._captureEvent(n)
                    } catch (s) {
                        Fe.error("Failed to capture event", s)
                    }
                }
                  , t = n => {
                    n = n || (pe == null ? void 0 : pe.event),
                    this._captureEvent(n, t0)
                }
                ;
                To(dt, "submit", e, !1, !0),
                To(dt, "change", e, !1, !0),
                To(dt, "click", e, !1, !0),
                this.config.capture_copied_text && (To(dt, "copy", t, !1, !0),
                To(dt, "cut", t, !1, !0))
            }
        } else
            Fe.info("Disabling Automatic Event Collection because this browser is not supported")
    }
    startIfEnabled() {
        this.isEnabled && !this._initialized && (this._addDomEventHandlers(),
        this._initialized = !0)
    }
    afterDecideResponse(e) {
        e.elementsChainAsString && (this._elementsChainAsString = e.elementsChainAsString),
        this.instance.persistence && this.instance.persistence.register({
            [r2]: !!e.autocapture_opt_out
        }),
        this._isDisabledServerSide = !!e.autocapture_opt_out,
        this.startIfEnabled()
    }
    setElementSelectors(e) {
        this._elementSelectors = e
    }
    getElementSelectors(e) {
        var t, n = [];
        return (t = this._elementSelectors) === null || t === void 0 || t.forEach(s => {
            var r = dt == null ? void 0 : dt.querySelectorAll(s);
            r == null || r.forEach(o => {
                e === o && n.push(s)
            }
            )
        }
        ),
        n
    }
    get isEnabled() {
        var e, t, n = (e = this.instance.persistence) === null || e === void 0 ? void 0 : e.props[r2], s = this._isDisabledServerSide;
        if (Ia(s) && !cl(n) && !this.instance.config.advanced_disable_decide)
            return !1;
        var r = (t = this._isDisabledServerSide) !== null && t !== void 0 ? t : !!n;
        return !!this.instance.config.autocapture && !r
    }
    _captureEvent(e) {
        var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "$autocapture";
        if (this.isEnabled) {
            var n, s = fA(e);
            cA(s) && (s = s.parentNode || null),
            t === "$autocapture" && e.type === "click" && e instanceof MouseEvent && this.instance.config.rageclick && (n = this.rageclicks) !== null && n !== void 0 && n.isRageClick(e.clientX, e.clientY, new Date().getTime()) && this._captureEvent(e, "$rageclick");
            var r = t === t0;
            if (s && vD(s, e, this.config, r, r ? ["copy", "cut"] : void 0)) {
                var {props: o, explicitNoCapture: a} = v8(s, {
                    e,
                    maskAllElementAttributes: this.instance.config.mask_all_element_attributes,
                    maskAllText: this.instance.config.mask_all_text,
                    elementAttributeIgnoreList: this.config.element_attribute_ignorelist,
                    elementsChainAsString: this._elementsChainAsString
                });
                if (a)
                    return !1;
                var l = this.getElementSelectors(s);
                if (l && l.length > 0 && (o.$element_selectors = l),
                t === t0) {
                    var c, u = dA(pe == null || (c = pe.getSelection()) === null || c === void 0 ? void 0 : c.toString()), d = e.type || "clipboard";
                    if (!u)
                        return !1;
                    o.$selected_content = u,
                    o.$copy_type = d
                }
                return this.instance.capture(t, o),
                !0
            }
        }
    }
    isBrowserSupported() {
        return Os(dt == null ? void 0 : dt.querySelectorAll)
    }
}
class x8 {
    constructor(e) {
        ot(this, "_restoreXHRPatch", void 0),
        ot(this, "_restoreFetchPatch", void 0),
        ot(this, "_startCapturing", () => {
            var t, n, s, r;
            Et(this._restoreXHRPatch) && ((t = Gt.__PosthogExtensions__) === null || t === void 0 || (n = t.tracingHeadersPatchFns) === null || n === void 0 || n._patchXHR(this.instance.sessionManager)),
            Et(this._restoreFetchPatch) && ((s = Gt.__PosthogExtensions__) === null || s === void 0 || (r = s.tracingHeadersPatchFns) === null || r === void 0 || r._patchFetch(this.instance.sessionManager))
        }
        ),
        this.instance = e
    }
    _loadScript(e) {
        var t, n, s;
        (t = Gt.__PosthogExtensions__) !== null && t !== void 0 && t.tracingHeadersPatchFns && e(),
        (n = Gt.__PosthogExtensions__) === null || n === void 0 || (s = n.loadExternalDependency) === null || s === void 0 || s.call(n, this.instance, "tracing-headers", r => {
            if (r)
                return Fe.error("[TRACING-HEADERS] failed to load script", r);
            e()
        }
        )
    }
    startIfEnabledOrStop() {
        var e, t;
        this.instance.config.__add_tracing_headers ? this._loadScript(this._startCapturing) : ((e = this._restoreXHRPatch) === null || e === void 0 || e.call(this),
        (t = this._restoreFetchPatch) === null || t === void 0 || t.call(this),
        this._restoreXHRPatch = void 0,
        this._restoreFetchPatch = void 0)
    }
}
var sa;
(function(i) {
    i[i.PENDING = -1] = "PENDING",
    i[i.DENIED = 0] = "DENIED",
    i[i.GRANTED = 1] = "GRANTED"
}
)(sa || (sa = {}));
class y8 {
    constructor(e) {
        this.instance = e
    }
    get config() {
        return this.instance.config
    }
    get consent() {
        return this.getDnt() ? sa.DENIED : this.storedConsent
    }
    isOptedOut() {
        return this.consent === sa.DENIED || this.consent === sa.PENDING && this.config.opt_out_capturing_by_default
    }
    isOptedIn() {
        return !this.isOptedOut()
    }
    optInOut(e) {
        this.storage.set(this.storageKey, e ? 1 : 0, this.config.cookie_expiration, this.config.cross_subdomain_cookie, this.config.secure_cookie)
    }
    reset() {
        this.storage.remove(this.storageKey, this.config.cross_subdomain_cookie)
    }
    get storageKey() {
        var {token: e, opt_out_capturing_cookie_prefix: t} = this.instance.config;
        return (t || "__ph_opt_in_out_") + e
    }
    get storedConsent() {
        var e = this.storage.get(this.storageKey);
        return e === "1" ? sa.GRANTED : e === "0" ? sa.DENIED : sa.PENDING
    }
    get storage() {
        if (!this._storage) {
            var e = this.config.opt_out_capturing_persistence_type;
            this._storage = e === "localStorage" ? ri : Po;
            var t = e === "localStorage" ? Po : ri;
            t.get(this.storageKey) && (this._storage.get(this.storageKey) || this.optInOut(t.get(this.storageKey) === "1"),
            t.remove(this.storageKey, this.config.cross_subdomain_cookie))
        }
        return this._storage
    }
    getDnt() {
        return !!this.config.respect_dnt && !!VT([bs == null ? void 0 : bs.doNotTrack, bs == null ? void 0 : bs.msDoNotTrack, Gt.doNotTrack], e => Zt([!0, 1, "1", "yes"], e))
    }
}
var Cf = "[Exception Autocapture]";
class b8 {
    constructor(e) {
        var t;
        ot(this, "originalOnUnhandledRejectionHandler", void 0),
        ot(this, "startCapturing", () => {
            var n, s, r, o;
            if (pe && this.isEnabled && !this.hasHandlers && !this.isCapturing) {
                var a = (n = Gt.__PosthogExtensions__) === null || n === void 0 || (s = n.errorWrappingFunctions) === null || s === void 0 ? void 0 : s.wrapOnError
                  , l = (r = Gt.__PosthogExtensions__) === null || r === void 0 || (o = r.errorWrappingFunctions) === null || o === void 0 ? void 0 : o.wrapUnhandledRejection;
                if (a && l)
                    try {
                        this.unwrapOnError = a(this.captureException.bind(this)),
                        this.unwrapUnhandledRejection = l(this.captureException.bind(this))
                    } catch (c) {
                        Fe.error(Cf + " failed to start", c),
                        this.stopCapturing()
                    }
                else
                    Fe.error(Cf + " failed to load error wrapping functions - cannot start")
            }
        }
        ),
        this.instance = e,
        this.remoteEnabled = !((t = this.instance.persistence) === null || t === void 0 || !t.props[o2]),
        this.startIfEnabled()
    }
    get isEnabled() {
        var e;
        return (e = this.remoteEnabled) !== null && e !== void 0 && e
    }
    get isCapturing() {
        var e;
        return !(pe == null || (e = pe.onerror) === null || e === void 0 || !e.__POSTHOG_INSTRUMENTED__)
    }
    get hasHandlers() {
        return this.originalOnUnhandledRejectionHandler || this.unwrapOnError
    }
    startIfEnabled() {
        this.isEnabled && !this.isCapturing && (Fe.info(Cf + " enabled, starting..."),
        this.loadScript(this.startCapturing))
    }
    loadScript(e) {
        var t, n;
        this.hasHandlers && e(),
        (t = Gt.__PosthogExtensions__) === null || t === void 0 || (n = t.loadExternalDependency) === null || n === void 0 || n.call(t, this.instance, "exception-autocapture", s => {
            if (s)
                return Fe.error(Cf + " failed to load script", s);
            e()
        }
        )
    }
    stopCapturing() {
        var e, t;
        (e = this.unwrapOnError) === null || e === void 0 || e.call(this),
        (t = this.unwrapUnhandledRejection) === null || t === void 0 || t.call(this)
    }
    afterDecideResponse(e) {
        var t = e.autocaptureExceptions;
        this.remoteEnabled = !!t || !1,
        this.instance.persistence && this.instance.persistence.register({
            [o2]: this.remoteEnabled
        }),
        this.startIfEnabled()
    }
    captureException(e) {
        var t = this.instance.requestRouter.endpointFor("ui");
        e.$exception_personURL = "".concat(t, "/project/").concat(this.instance.config.token, "/person/").concat(this.instance.get_distinct_id()),
        this.instance.exceptions.sendExceptionEvent(e)
    }
}
var z2 = 9e5
  , Ha = "[Web Vitals]";
class S8 {
    constructor(e) {
        var t;
        ot(this, "_enabledServerSide", !1),
        ot(this, "_initialized", !1),
        ot(this, "buffer", {
            url: void 0,
            metrics: [],
            firstMetricTimestamp: void 0
        }),
        ot(this, "_flushToCapture", () => {
            clearTimeout(this._delayedFlushTimer),
            this.buffer.metrics.length !== 0 && (this.instance.capture("$web_vitals", this.buffer.metrics.reduce( (n, s) => Ze(Ze({}, n), {}, {
                ["$web_vitals_".concat(s.name, "_event")]: Ze({}, s),
                ["$web_vitals_".concat(s.name, "_value")]: s.value
            }), {})),
            this.buffer = {
                url: void 0,
                metrics: [],
                firstMetricTimestamp: void 0
            })
        }
        ),
        ot(this, "_addToBuffer", n => {
            var s, r = (s = this.instance.sessionManager) === null || s === void 0 ? void 0 : s.checkAndGetSessionAndWindowId(!0);
            if (Et(r))
                Fe.error(Ha + "Could not read session ID. Dropping metrics!");
            else {
                this.buffer = this.buffer || {
                    url: void 0,
                    metrics: [],
                    firstMetricTimestamp: void 0
                };
                var o = this._currentURL();
                Et(o) || (Mn(n == null ? void 0 : n.name) || Mn(n == null ? void 0 : n.value) ? Fe.error(Ha + "Invalid metric received", n) : this._maxAllowedValue && n.value >= this._maxAllowedValue ? Fe.error(Ha + "Ignoring metric with value >= " + this._maxAllowedValue, n) : (this.buffer.url !== o && (this._flushToCapture(),
                this._delayedFlushTimer = setTimeout(this._flushToCapture, this.flushToCaptureTimeoutMs)),
                Et(this.buffer.url) && (this.buffer.url = o),
                this.buffer.firstMetricTimestamp = Et(this.buffer.firstMetricTimestamp) ? Date.now() : this.buffer.firstMetricTimestamp,
                n.attribution && n.attribution.interactionTargetElement && (n.attribution.interactionTargetElement = void 0),
                this.buffer.metrics.push(Ze(Ze({}, n), {}, {
                    $current_url: o,
                    $session_id: r.sessionId,
                    $window_id: r.windowId,
                    timestamp: Date.now()
                })),
                this.buffer.metrics.length === this.allowedMetrics.length && this._flushToCapture()))
            }
        }
        ),
        ot(this, "_startCapturing", () => {
            var n, s, r, o, a = Gt.__PosthogExtensions__;
            Et(a) || Et(a.postHogWebVitalsCallbacks) || ({onLCP: n, onCLS: s, onFCP: r, onINP: o} = a.postHogWebVitalsCallbacks),
            n && s && r && o ? (this.allowedMetrics.indexOf("LCP") > -1 && n(this._addToBuffer.bind(this)),
            this.allowedMetrics.indexOf("CLS") > -1 && s(this._addToBuffer.bind(this)),
            this.allowedMetrics.indexOf("FCP") > -1 && r(this._addToBuffer.bind(this)),
            this.allowedMetrics.indexOf("INP") > -1 && o(this._addToBuffer.bind(this)),
            this._initialized = !0) : Fe.error(Ha + "web vitals callbacks not loaded - not starting")
        }
        ),
        this.instance = e,
        this._enabledServerSide = !((t = this.instance.persistence) === null || t === void 0 || !t.props[a2]),
        this.startIfEnabled()
    }
    get allowedMetrics() {
        var e, t, n = Zn(this.instance.config.capture_performance) ? (e = this.instance.config.capture_performance) === null || e === void 0 ? void 0 : e.web_vitals_allowed_metrics : void 0;
        return Et(n) ? ((t = this.instance.persistence) === null || t === void 0 ? void 0 : t.props[l2]) || ["CLS", "FCP", "INP", "LCP"] : n
    }
    get flushToCaptureTimeoutMs() {
        return (Zn(this.instance.config.capture_performance) ? this.instance.config.capture_performance.web_vitals_delayed_flush_ms : void 0) || 5e3
    }
    get _maxAllowedValue() {
        var e = Zn(this.instance.config.capture_performance) && vs(this.instance.config.capture_performance.__web_vitals_max_value) ? this.instance.config.capture_performance.__web_vitals_max_value : z2;
        return 0 < e && e <= 6e4 ? z2 : e
    }
    get isEnabled() {
        var e = Zn(this.instance.config.capture_performance) ? this.instance.config.capture_performance.web_vitals : void 0;
        return cl(e) ? e : this._enabledServerSide
    }
    startIfEnabled() {
        this.isEnabled && !this._initialized && (Fe.info(Ha + " enabled, starting..."),
        this.loadScript(this._startCapturing))
    }
    afterDecideResponse(e) {
        var t = Zn(e.capturePerformance) && !!e.capturePerformance.web_vitals
          , n = Zn(e.capturePerformance) ? e.capturePerformance.web_vitals_allowed_metrics : void 0;
        this.instance.persistence && (this.instance.persistence.register({
            [a2]: t
        }),
        this.instance.persistence.register({
            [l2]: n
        })),
        this._enabledServerSide = t,
        this.startIfEnabled()
    }
    loadScript(e) {
        var t, n, s;
        (t = Gt.__PosthogExtensions__) !== null && t !== void 0 && t.postHogWebVitalsCallbacks && e(),
        (n = Gt.__PosthogExtensions__) === null || n === void 0 || (s = n.loadExternalDependency) === null || s === void 0 || s.call(n, this.instance, "web-vitals", r => {
            r ? Fe.error(Ha + " failed to load script", r) : e()
        }
        )
    }
    _currentURL() {
        var e = pe ? pe.location.href : void 0;
        return e || Fe.error(Ha + "Could not determine current URL"),
        e
    }
}
var E8 = {
    icontains: (i, e) => !!pe && e.href.toLowerCase().indexOf(i.toLowerCase()) > -1,
    not_icontains: (i, e) => !!pe && e.href.toLowerCase().indexOf(i.toLowerCase()) === -1,
    regex: (i, e) => !!pe && tu(e.href, i),
    not_regex: (i, e) => !!pe && !tu(e.href, i),
    exact: (i, e) => e.href === i,
    is_not: (i, e) => e.href !== i
};
class pi {
    constructor(e) {
        var t = this;
        ot(this, "getWebExperimentsAndEvaluateDisplayLogic", function() {
            var n = arguments.length > 0 && arguments[0] !== void 0 && arguments[0];
            t.getWebExperiments(s => {
                pi.logInfo("retrieved web experiments from the server"),
                t._flagToExperiments = new Map,
                s.forEach(r => {
                    if (r.feature_flag_key && t._featureFlags && t._featureFlags[r.feature_flag_key]) {
                        var o;
                        t._flagToExperiments && (pi.logInfo("setting flag key ", r.feature_flag_key, " to web experiment ", r),
                        (o = t._flagToExperiments) === null || o === void 0 || o.set(r.feature_flag_key, r));
                        var a = t._featureFlags[r.feature_flag_key];
                        a && r.variants[a] && t.applyTransforms(r.name, a, r.variants[a].transforms)
                    } else if (r.variants)
                        for (var l in r.variants) {
                            var c = r.variants[l];
                            pi.matchesTestVariant(c) && t.applyTransforms(r.name, l, c.transforms)
                        }
                }
                )
            }
            , n)
        }),
        this.instance = e,
        this.instance.onFeatureFlags && this.instance.onFeatureFlags(n => {
            this.applyFeatureFlagChanges(n)
        }
        ),
        this._flagToExperiments = new Map
    }
    applyFeatureFlagChanges(e) {
        Mn(this._flagToExperiments) || this.instance.config.disable_web_experiments || (pi.logInfo("applying feature flags", e),
        e.forEach(t => {
            var n;
            if (this._flagToExperiments && (n = this._flagToExperiments) !== null && n !== void 0 && n.has(t)) {
                var s, r = this.instance.getFeatureFlag(t), o = (s = this._flagToExperiments) === null || s === void 0 ? void 0 : s.get(t);
                r && o != null && o.variants[r] && this.applyTransforms(o.name, r, o.variants[r].transforms)
            }
        }
        ))
    }
    afterDecideResponse(e) {
        this._is_bot() ? pi.logInfo("Refusing to render web experiment since the viewer is a likely bot") : (this._featureFlags = e.featureFlags,
        this.loadIfEnabled(),
        this.previewWebExperiment())
    }
    previewWebExperiment() {
        var e = pi.getWindowLocation();
        if (e != null && e.search) {
            var t = ap(e == null ? void 0 : e.search, "__experiment_id")
              , n = ap(e == null ? void 0 : e.search, "__experiment_variant");
            t && n && (pi.logInfo("previewing web experiments ".concat(t, " && ").concat(n)),
            this.getWebExperiments(s => {
                this.showPreviewWebExperiment(parseInt(t), n, s)
            }
            , !1, !0))
        }
    }
    loadIfEnabled() {
        this.instance.config.disable_web_experiments || this.getWebExperimentsAndEvaluateDisplayLogic()
    }
    getWebExperiments(e, t, n) {
        if (this.instance.config.disable_web_experiments && !n)
            return e([]);
        var s = this.instance.get_property("$web_experiments");
        if (s && !t)
            return e(s);
        this.instance._send_request({
            url: this.instance.requestRouter.endpointFor("api", "/api/web_experiments/?token=".concat(this.instance.config.token)),
            method: "GET",
            transport: "XHR",
            callback: r => {
                if (r.statusCode !== 200 || !r.json)
                    return e([]);
                var o = r.json.experiments || [];
                return e(o)
            }
        })
    }
    showPreviewWebExperiment(e, t, n) {
        var s = n.filter(r => r.id === e);
        s && s.length > 0 && (pi.logInfo("Previewing web experiment [".concat(s[0].name, "] with variant [").concat(t, "]")),
        this.applyTransforms(s[0].name, t, s[0].variants[t].transforms, !0))
    }
    static matchesTestVariant(e) {
        return !Mn(e.conditions) && pi.matchUrlConditions(e) && pi.matchUTMConditions(e)
    }
    static matchUrlConditions(e) {
        var t;
        if (Mn(e.conditions) || Mn((t = e.conditions) === null || t === void 0 ? void 0 : t.url))
            return !0;
        var n, s, r, o = pi.getWindowLocation();
        return !!o && ((n = e.conditions) === null || n === void 0 || !n.url || E8[(s = (r = e.conditions) === null || r === void 0 ? void 0 : r.urlMatchType) !== null && s !== void 0 ? s : "icontains"](e.conditions.url, o))
    }
    static getWindowLocation() {
        return pe == null ? void 0 : pe.location
    }
    static matchUTMConditions(e) {
        var t;
        if (Mn(e.conditions) || Mn((t = e.conditions) === null || t === void 0 ? void 0 : t.utm))
            return !0;
        var n = Xn.campaignParams();
        if (n.utm_source) {
            var s, r, o, a, l, c, u, d, f, h, p, g, m, v, _, y, b = (s = e.conditions) === null || s === void 0 || (r = s.utm) === null || r === void 0 || !r.utm_campaign || ((o = e.conditions) === null || o === void 0 || (a = o.utm) === null || a === void 0 ? void 0 : a.utm_campaign) == n.utm_campaign, S = (l = e.conditions) === null || l === void 0 || (c = l.utm) === null || c === void 0 || !c.utm_source || ((u = e.conditions) === null || u === void 0 || (d = u.utm) === null || d === void 0 ? void 0 : d.utm_source) == n.utm_source, C = (f = e.conditions) === null || f === void 0 || (h = f.utm) === null || h === void 0 || !h.utm_medium || ((p = e.conditions) === null || p === void 0 || (g = p.utm) === null || g === void 0 ? void 0 : g.utm_medium) == n.utm_medium, M = (m = e.conditions) === null || m === void 0 || (v = m.utm) === null || v === void 0 || !v.utm_term || ((_ = e.conditions) === null || _ === void 0 || (y = _.utm) === null || y === void 0 ? void 0 : y.utm_term) == n.utm_term;
            return b && C && M && S
        }
        return !1
    }
    static logInfo(e) {
        for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), s = 1; s < t; s++)
            n[s - 1] = arguments[s];
        Fe.info("[WebExperiments] ".concat(e), n)
    }
    applyTransforms(e, t, n, s) {
        var r;
        this._is_bot() ? pi.logInfo("Refusing to render web experiment since the viewer is a likely bot") : t !== "control" ? n.forEach(o => {
            if (o.selector) {
                var a;
                pi.logInfo("applying transform of variant ".concat(t, " for experiment ").concat(e, " "), o);
                var l, c = 0, u = (a = document) === null || a === void 0 ? void 0 : a.querySelectorAll(o.selector);
                u == null || u.forEach(d => {
                    var f = d;
                    c += 1,
                    o.attributes && o.attributes.forEach(h => {
                        switch (h.name) {
                        case "text":
                            f.innerText = h.value;
                            break;
                        case "html":
                            f.innerHTML = h.value;
                            break;
                        case "cssClass":
                            f.className = h.value;
                            break;
                        default:
                            f.setAttribute(h.name, h.value)
                        }
                    }
                    ),
                    o.text && (f.innerText = o.text),
                    o.html && (f.parentElement ? f.parentElement.innerHTML = o.html : f.innerHTML = o.html),
                    o.css && f.setAttribute("style", o.css)
                }
                ),
                this.instance && this.instance.capture && this.instance.capture("$web_experiment_applied", {
                    $web_experiment_name: e,
                    $web_experiment_variant: t,
                    $web_experiment_preview: s,
                    $web_experiment_document_url: (l = pi.getWindowLocation()) === null || l === void 0 ? void 0 : l.href,
                    $web_experiment_elements_modified: c
                })
            }
        }
        ) : (pi.logInfo("Control variants leave the page unmodified."),
        this.instance && this.instance.capture && this.instance.capture("$web_experiment_applied", {
            $web_experiment_name: e,
            $web_experiment_preview: s,
            $web_experiment_variant: t,
            $web_experiment_document_url: (r = pi.getWindowLocation()) === null || r === void 0 ? void 0 : r.href,
            $web_experiment_elements_modified: 0
        }))
    }
    _is_bot() {
        return bs && this.instance ? NA(bs, this.instance.config.custom_blocked_useragents) : void 0
    }
}
class w8 {
    constructor(e) {
        this.instance = e
    }
    sendExceptionEvent(e) {
        this.instance.capture("$exception", e, {
            _noTruncate: !0,
            _batchKey: "exceptionEvent"
        })
    }
}
var T8 = ["$set_once", "$set"];
class A8 {
    constructor(e) {
        this.instance = e,
        this.enabled = !!this.instance.config.opt_in_site_apps && !this.instance.config.advanced_disable_decide,
        this.missedInvocations = [],
        this.loaded = !1,
        this.appsLoading = new Set
    }
    eventCollector(e, t) {
        if (this.enabled && !this.loaded && t) {
            var n = this.globalsForEvent(t);
            this.missedInvocations.push(n),
            this.missedInvocations.length > 1e3 && (this.missedInvocations = this.missedInvocations.slice(10))
        }
    }
    init() {
        var e;
        (e = this.instance) === null || e === void 0 || e._addCaptureHook(this.eventCollector.bind(this))
    }
    globalsForEvent(e) {
        var t, n, s, r, o, a, l;
        if (!e)
            throw new Error("Event payload is required");
        var c = {}
          , u = this.instance.get_property("$groups") || []
          , d = this.instance.get_property("$stored_group_properties") || {};
        for (var [f,h] of Object.entries(d))
            c[f] = {
                id: u[f],
                type: f,
                properties: h
            };
        var {$set_once: p, $set: g} = e;
        return {
            event: Ze(Ze({}, zT(e, T8)), {}, {
                properties: Ze(Ze(Ze({}, e.properties), g ? {
                    $set: Ze(Ze({}, (t = (n = e.properties) === null || n === void 0 ? void 0 : n.$set) !== null && t !== void 0 ? t : {}), g)
                } : {}), p ? {
                    $set_once: Ze(Ze({}, (s = (r = e.properties) === null || r === void 0 ? void 0 : r.$set_once) !== null && s !== void 0 ? s : {}), p)
                } : {}),
                elements_chain: (o = (a = e.properties) === null || a === void 0 ? void 0 : a.$elements_chain) !== null && o !== void 0 ? o : "",
                distinct_id: (l = e.properties) === null || l === void 0 ? void 0 : l.distinct_id
            }),
            person: {
                properties: this.instance.get_property("$stored_person_properties")
            },
            groups: c
        }
    }
    afterDecideResponse(e) {
        var t = this;
        Wn(e == null ? void 0 : e.siteApps) && e.siteApps.length > 0 ? this.enabled && this.instance.config.opt_in_site_apps ? function() {
            var n = () => {
                t.appsLoading.size === 0 && (t.loaded = !0,
                t.missedInvocations = [])
            }
              , s = function(a, l) {
                var c, u;
                t.appsLoading.add(a),
                Gt["__$$ph_site_app_".concat(a, "_posthog")] = t.instance,
                Gt["__$$ph_site_app_".concat(a, "_missed_invocations")] = () => t.missedInvocations,
                Gt["__$$ph_site_app_".concat(a, "_callback")] = () => {
                    t.appsLoading.delete(a),
                    n()
                }
                ,
                (c = Gt.__PosthogExtensions__) === null || c === void 0 || (u = c.loadSiteApp) === null || u === void 0 || u.call(c, t.instance, l, d => {
                    if (d)
                        return t.appsLoading.delete(a),
                        n(),
                        Fe.error("Error while initializing PostHog app with config id ".concat(a), d)
                }
                )
            };
            for (var {id: r, url: o} of e.siteApps)
                s(r, o)
        }() : e.siteApps.length > 0 ? (Fe.error('PostHog site apps are disabled. Enable the "opt_in_site_apps" config to proceed.'),
        this.loaded = !0) : this.loaded = !0 : (this.loaded = !0,
        this.enabled = !1)
    }
}
var dd = {}
  , E1 = () => {}
  , yc = "posthog"
  , $A = !WD && (mi == null ? void 0 : mi.indexOf("MSIE")) === -1 && (mi == null ? void 0 : mi.indexOf("Mozilla")) === -1
  , G2 = () => {
    var i, e, t;
    return {
        api_host: "https://us.i.posthog.com",
        ui_host: null,
        token: "",
        autocapture: !0,
        rageclick: !0,
        cross_subdomain_cookie: (e = dt == null ? void 0 : dt.location,
        t = e == null ? void 0 : e.hostname,
        !!Di(t) && t.split(".").slice(-2).join(".") !== "herokuapp.com"),
        persistence: "localStorage+cookie",
        persistence_name: "",
        loaded: E1,
        store_google: !0,
        custom_campaign_params: [],
        custom_blocked_useragents: [],
        save_referrer: !0,
        capture_pageview: !0,
        capture_pageleave: "if_capture_pageview",
        debug: es && Di(es == null ? void 0 : es.search) && es.search.indexOf("__posthog_debug=true") !== -1 || !1,
        verbose: !1,
        cookie_expiration: 365,
        upgrade: !1,
        disable_session_recording: !1,
        disable_persistence: !1,
        disable_web_experiments: !0,
        disable_surveys: !1,
        enable_recording_console_log: void 0,
        secure_cookie: (pe == null || (i = pe.location) === null || i === void 0 ? void 0 : i.protocol) === "https:",
        ip: !0,
        opt_out_capturing_by_default: !1,
        opt_out_persistence_by_default: !1,
        opt_out_useragent_filter: !1,
        opt_out_capturing_persistence_type: "localStorage",
        opt_out_capturing_cookie_prefix: null,
        opt_in_site_apps: !1,
        property_denylist: [],
        respect_dnt: !1,
        sanitize_properties: null,
        request_headers: {},
        inapp_protocol: "//",
        inapp_link_new_window: !1,
        request_batching: !0,
        properties_string_max_length: 65535,
        session_recording: {},
        mask_all_element_attributes: !1,
        mask_all_text: !1,
        advanced_disable_decide: !1,
        advanced_disable_feature_flags: !1,
        advanced_disable_feature_flags_on_first_load: !1,
        advanced_disable_toolbar_metrics: !1,
        feature_flag_request_timeout_ms: 3e3,
        on_request_error: n => {
            var s = "Bad HTTP status: " + n.statusCode + " " + n.text;
            Fe.error(s)
        }
        ,
        get_device_id: n => n,
        _onCapture: E1,
        capture_performance: void 0,
        name: "posthog",
        bootstrap: {},
        disable_compression: !1,
        session_idle_timeout_seconds: 1800,
        person_profiles: "identified_only",
        __add_tracing_headers: !1,
        before_send: void 0
    }
}
  , W2 = i => {
    var e = {};
    Et(i.process_person) || (e.person_profiles = i.process_person),
    Et(i.xhr_headers) || (e.request_headers = i.xhr_headers),
    Et(i.cookie_name) || (e.persistence_name = i.cookie_name),
    Et(i.disable_cookie) || (e.disable_persistence = i.disable_cookie);
    var t = Gi({}, e, i);
    return Wn(i.property_blacklist) && (Et(i.property_denylist) ? t.property_denylist = i.property_blacklist : Wn(i.property_denylist) ? t.property_denylist = [...i.property_blacklist, ...i.property_denylist] : Fe.error("Invalid value for property_denylist config: " + i.property_denylist)),
    t
}
;
class C8 {
    constructor() {
        ot(this, "__forceAllowLocalhost", !1)
    }
    get _forceAllowLocalhost() {
        return this.__forceAllowLocalhost
    }
    set _forceAllowLocalhost(e) {
        Fe.error("WebPerformanceObserver is deprecated and has no impact on network capture. Use `_forceAllowLocalhostNetworkCapture` on `posthog.sessionRecording`"),
        this.__forceAllowLocalhost = e
    }
}
class fm {
    constructor() {
        ot(this, "webPerformance", new C8),
        ot(this, "version", na.LIB_VERSION),
        ot(this, "_internalEventEmitter", new CA),
        this.config = G2(),
        this.decideEndpointWasHit = !1,
        this.SentryIntegration = YD,
        this.sentryIntegration = e => function(t, n) {
            var s = AA(t, n);
            return {
                name: TA,
                processEvent: r => s(r)
            }
        }(this, e),
        this.__request_queue = [],
        this.__loaded = !1,
        this.analyticsDefaultEndpoint = "/e/",
        this._initialPageviewCaptured = !1,
        this._initialPersonProfilesConfig = null,
        this.featureFlags = new XP(this),
        this.toolbar = new zD(this),
        this.scrollManager = new p8(this),
        this.pageViewManager = new JD(this),
        this.surveys = new o8(this),
        this.experiments = new pi(this),
        this.exceptions = new w8(this),
        this.rateLimiter = new a8(this),
        this.requestRouter = new XD(this),
        this.consent = new y8(this),
        this.people = {
            set: (e, t, n) => {
                var s = Di(e) ? {
                    [e]: t
                } : e;
                this.setPersonProperties(s),
                n == null || n({})
            }
            ,
            set_once: (e, t, n) => {
                var s = Di(e) ? {
                    [e]: t
                } : e;
                this.setPersonProperties(void 0, s),
                n == null || n({})
            }
        },
        this.on("eventCaptured", e => Fe.info('send "'.concat(e == null ? void 0 : e.event, '"'), e))
    }
    init(e, t, n) {
        if (n && n !== yc) {
            var s, r = (s = dd[n]) !== null && s !== void 0 ? s : new fm;
            return r._init(e, t, n),
            dd[n] = r,
            dd[yc][n] = r,
            r
        }
        return this._init(e, t, n)
    }
    _init(e) {
        var t, n, s, r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, o = arguments.length > 2 ? arguments[2] : void 0;
        if (Et(e) || t2(e))
            return Fe.critical("PostHog was initialized without a token. This likely indicates a misconfiguration. Please check the first argument passed to posthog.init()"),
            this;
        if (this.__loaded)
            return Fe.warn("You have already initialized PostHog! Re-initializing is a no-op"),
            this;
        this.__loaded = !0,
        this.config = {},
        this._triggered_notifs = [],
        r.person_profiles && (this._initialPersonProfilesConfig = r.person_profiles),
        this.set_config(Gi({}, G2(), W2(r), {
            name: o,
            token: e
        })),
        this.config.on_xhr_error && Fe.error("[posthog] on_xhr_error is deprecated. Use on_request_error instead"),
        this.compression = r.disable_compression ? void 0 : cr.GZipJS,
        this.persistence = new a0(this.config),
        this.sessionPersistence = this.config.persistence === "sessionStorage" || this.config.persistence === "memory" ? this.persistence : new a0(Ze(Ze({}, this.config), {}, {
            persistence: "sessionStorage"
        }));
        var a = Ze({}, this.persistence.props)
          , l = Ze({}, this.sessionPersistence.props);
        if (this._requestQueue = new GD(_ => this._send_retriable_request(_)),
        this._retryQueue = new jD(this),
        this.__request_queue = [],
        this.sessionManager = new KD(this.config,this.persistence),
        this.sessionPropsManager = new c8(this.sessionManager,this.persistence),
        new x8(this).startIfEnabledOrStop(),
        this.siteApps = new A8(this),
        (t = this.siteApps) === null || t === void 0 || t.init(),
        this.sessionRecording = new VD(this),
        this.sessionRecording.startIfEnabledOrStop(),
        this.config.disable_scroll_properties || this.scrollManager.startMeasuringScrollPosition(),
        this.autocapture = new _8(this),
        this.autocapture.startIfEnabled(),
        this.surveys.loadIfEnabled(),
        this.heatmaps = new h8(this),
        this.heatmaps.startIfEnabled(),
        this.webVitalsAutocapture = new S8(this),
        this.exceptionObserver = new b8(this),
        this.exceptionObserver.startIfEnabled(),
        this.deadClicksAutocapture = new VA(this,f8),
        this.deadClicksAutocapture.startIfEnabled(),
        na.DEBUG = na.DEBUG || this.config.debug,
        na.DEBUG && Fe.info("Starting in debug mode", {
            this: this,
            config: r,
            thisC: Ze({}, this.config),
            p: a,
            s: l
        }),
        this._sync_opt_out_with_persistence(),
        ((n = r.bootstrap) === null || n === void 0 ? void 0 : n.distinctID) !== void 0) {
            var c, u, d = this.config.get_device_id(la()), f = (c = r.bootstrap) !== null && c !== void 0 && c.isIdentifiedID ? d : r.bootstrap.distinctID;
            this.persistence.set_property(mo, (u = r.bootstrap) !== null && u !== void 0 && u.isIdentifiedID ? "identified" : "anonymous"),
            this.register({
                distinct_id: r.bootstrap.distinctID,
                $device_id: f
            })
        }
        if (this._hasBootstrappedFeatureFlags()) {
            var h, p, g = Object.keys(((h = r.bootstrap) === null || h === void 0 ? void 0 : h.featureFlags) || {}).filter(_ => {
                var y, b;
                return !((y = r.bootstrap) === null || y === void 0 || (b = y.featureFlags) === null || b === void 0 || !b[_])
            }
            ).reduce( (_, y) => {
                var b, S;
                return _[y] = ((b = r.bootstrap) === null || b === void 0 || (S = b.featureFlags) === null || S === void 0 ? void 0 : S[y]) || !1,
                _
            }
            , {}), m = Object.keys(((p = r.bootstrap) === null || p === void 0 ? void 0 : p.featureFlagPayloads) || {}).filter(_ => g[_]).reduce( (_, y) => {
                var b, S, C, M;
                return (b = r.bootstrap) !== null && b !== void 0 && (S = b.featureFlagPayloads) !== null && S !== void 0 && S[y] && (_[y] = (C = r.bootstrap) === null || C === void 0 || (M = C.featureFlagPayloads) === null || M === void 0 ? void 0 : M[y]),
                _
            }
            , {});
            this.featureFlags.receivedFeatureFlags({
                featureFlags: g,
                featureFlagPayloads: m
            })
        }
        if (!this.get_distinct_id()) {
            var v = this.config.get_device_id(la());
            this.register_once({
                distinct_id: v,
                $device_id: v
            }, ""),
            this.persistence.set_property(mo, "anonymous")
        }
        return pe == null || (s = pe.addEventListener) === null || s === void 0 || s.call(pe, "onpagehide"in self ? "pagehide" : "unload", this._handle_unload.bind(this)),
        this.toolbar.maybeLoadToolbar(),
        r.segment ? ZD(this, () => this._loaded()) : this._loaded(),
        Os(this.config._onCapture) && this.config._onCapture !== E1 && (Fe.warn("onCapture is deprecated. Please use `before_send` instead"),
        this.on("eventCaptured", _ => this.config._onCapture(_.event, _))),
        this
    }
    _afterDecideResponse(e) {
        var t, n, s, r, o, a, l, c, u, d;
        this.compression = void 0,
        e.supportedCompression && !this.config.disable_compression && (this.compression = Zt(e.supportedCompression, cr.GZipJS) ? cr.GZipJS : Zt(e.supportedCompression, cr.Base64) ? cr.Base64 : void 0),
        (t = e.analytics) !== null && t !== void 0 && t.endpoint && (this.analyticsDefaultEndpoint = e.analytics.endpoint),
        this.set_config({
            person_profiles: this._initialPersonProfilesConfig ? this._initialPersonProfilesConfig : e.defaultIdentifiedOnly ? "identified_only" : "always"
        }),
        (n = this.siteApps) === null || n === void 0 || n.afterDecideResponse(e),
        (s = this.sessionRecording) === null || s === void 0 || s.afterDecideResponse(e),
        (r = this.autocapture) === null || r === void 0 || r.afterDecideResponse(e),
        (o = this.heatmaps) === null || o === void 0 || o.afterDecideResponse(e),
        (a = this.experiments) === null || a === void 0 || a.afterDecideResponse(e),
        (l = this.surveys) === null || l === void 0 || l.afterDecideResponse(e),
        (c = this.webVitalsAutocapture) === null || c === void 0 || c.afterDecideResponse(e),
        (u = this.exceptionObserver) === null || u === void 0 || u.afterDecideResponse(e),
        (d = this.deadClicksAutocapture) === null || d === void 0 || d.afterDecideResponse(e)
    }
    _loaded() {
        var e = this.config.advanced_disable_decide;
        e || this.featureFlags.setReloadingPaused(!0);
        try {
            this.config.loaded(this)
        } catch (t) {
            Fe.critical("`loaded` function failed", t)
        }
        this._start_queue_if_opted_in(),
        this.config.capture_pageview && setTimeout( () => {
            this.consent.isOptedIn() && this._captureInitialPageview()
        }
        , 1),
        e || (new $D(this).call(),
        this.featureFlags.resetRequestQueue())
    }
    _start_queue_if_opted_in() {
        var e;
        this.has_opted_out_capturing() || this.config.request_batching && ((e = this._requestQueue) === null || e === void 0 || e.enable())
    }
    _dom_loaded() {
        this.has_opted_out_capturing() || Oc(this.__request_queue, e => this._send_retriable_request(e)),
        this.__request_queue = [],
        this._start_queue_if_opted_in()
    }
    _handle_unload() {
        var e, t;
        this.config.request_batching ? (this._shouldCapturePageleave() && this.capture("$pageleave"),
        (e = this._requestQueue) === null || e === void 0 || e.unload(),
        (t = this._retryQueue) === null || t === void 0 || t.unload()) : this._shouldCapturePageleave() && this.capture("$pageleave", null, {
            transport: "sendBeacon"
        })
    }
    _send_request(e) {
        this.__loaded && ($A ? this.__request_queue.push(e) : this.rateLimiter.isServerRateLimited(e.batchKey) || (e.transport = e.transport || this.config.api_transport,
        e.url = hp(e.url, {
            ip: this.config.ip ? 1 : 0
        }),
        e.headers = Ze({}, this.config.request_headers),
        e.compression = e.compression === "best-available" ? this.compression : e.compression,
        (t => {
            var n, s, r, o = Ze({}, t);
            o.timeout = o.timeout || 6e4,
            o.url = hp(o.url, {
                _: new Date().getTime().toString(),
                ver: na.LIB_VERSION,
                compression: o.compression
            });
            var a = (n = o.transport) !== null && n !== void 0 ? n : "XHR"
              , l = (s = (r = VT(ud, c => c.transport === a)) === null || r === void 0 ? void 0 : r.method) !== null && s !== void 0 ? s : ud[0].method;
            if (!l)
                throw new Error("No available transport method");
            l(o)
        }
        )(Ze(Ze({}, e), {}, {
            callback: t => {
                var n, s, r;
                this.rateLimiter.checkForLimiting(t),
                t.statusCode >= 400 && ((s = (r = this.config).on_request_error) === null || s === void 0 || s.call(r, t)),
                (n = e.callback) === null || n === void 0 || n.call(e, t)
            }
        }))))
    }
    _send_retriable_request(e) {
        this._retryQueue ? this._retryQueue.retriableRequest(e) : this._send_request(e)
    }
    _execute_array(e) {
        var t, n = [], s = [], r = [];
        Oc(e, a => {
            a && (t = a[0],
            Wn(t) ? r.push(a) : Os(a) ? a.call(this) : Wn(a) && t === "alias" ? n.push(a) : Wn(a) && t.indexOf("capture") !== -1 && Os(this[t]) ? r.push(a) : s.push(a))
        }
        );
        var o = function(a, l) {
            Oc(a, function(c) {
                if (Wn(c[0])) {
                    var u = l;
                    bn(c, function(d) {
                        u = u[d[0]].apply(u, d.slice(1))
                    })
                } else
                    this[c[0]].apply(this, c.slice(1))
            }, l)
        };
        o(n, this),
        o(s, this),
        o(r, this)
    }
    _hasBootstrappedFeatureFlags() {
        var e, t;
        return ((e = this.config.bootstrap) === null || e === void 0 ? void 0 : e.featureFlags) && Object.keys((t = this.config.bootstrap) === null || t === void 0 ? void 0 : t.featureFlags).length > 0 || !1
    }
    push(e) {
        this._execute_array([e])
    }
    capture(e, t, n) {
        var s;
        if (this.__loaded && this.persistence && this.sessionPersistence && this._requestQueue) {
            if (!this.consent.isOptedOut())
                if (!Et(e) && Di(e)) {
                    if (this.config.opt_out_useragent_filter || !this._is_bot()) {
                        var r = n != null && n.skip_client_rate_limiting ? void 0 : this.rateLimiter.clientRateLimitContext();
                        if (r == null || !r.isRateLimited) {
                            this.sessionPersistence.update_search_keyword(),
                            this.config.store_google && this.sessionPersistence.update_campaign_params(),
                            this.config.save_referrer && this.sessionPersistence.update_referrer_info(),
                            (this.config.store_google || this.config.save_referrer) && this.persistence.set_initial_person_info();
                            var o = new Date
                              , a = (n == null ? void 0 : n.timestamp) || o
                              , l = {
                                uuid: la(),
                                event: e,
                                properties: this._calculate_event_properties(e, t || {}, a)
                            };
                            r && (l.properties.$lib_rate_limit_remaining_tokens = r.remainingTokens),
                            n != null && n.$set && (l.$set = n == null ? void 0 : n.$set);
                            var c = this._calculate_set_once_properties(n == null ? void 0 : n.$set_once);
                            c && (l.$set_once = c),
                            (l = HP(l, n != null && n._noTruncate ? null : this.config.properties_string_max_length)).timestamp = a,
                            Et(n == null ? void 0 : n.timestamp) || (l.properties.$event_time_override_provided = !0,
                            l.properties.$event_time_override_system_time = o);
                            var u = Ze(Ze({}, l.properties.$set), l.$set);
                            if (bc(u) || this.setPersonPropertiesForFlags(u),
                            !Mn(this.config.before_send)) {
                                var d = this._runBeforeSend(l);
                                if (!d)
                                    return;
                                l = d
                            }
                            this._internalEventEmitter.emit("eventCaptured", l);
                            var f = {
                                method: "POST",
                                url: (s = n == null ? void 0 : n._url) !== null && s !== void 0 ? s : this.requestRouter.endpointFor("api", this.analyticsDefaultEndpoint),
                                data: l,
                                compression: "best-available",
                                batchKey: n == null ? void 0 : n._batchKey
                            };
                            return !this.config.request_batching || n && (n == null || !n._batchKey) || n != null && n.send_instantly ? this._send_retriable_request(f) : this._requestQueue.enqueue(f),
                            l
                        }
                        Fe.critical("This capture call is ignored due to client rate limiting.")
                    }
                } else
                    Fe.error("No event name provided to posthog.capture")
        } else
            Fe.uninitializedWarning("posthog.capture")
    }
    _addCaptureHook(e) {
        return this.on("eventCaptured", t => e(t.event, t))
    }
    _calculate_event_properties(e, t, n) {
        if (n = n || new Date,
        !this.persistence || !this.sessionPersistence)
            return t;
        var s = this.persistence.remove_event_timer(e)
          , r = Ze({}, t);
        if (r.token = this.config.token,
        e === "$snapshot") {
            var o = Ze(Ze({}, this.persistence.properties()), this.sessionPersistence.properties());
            return r.distinct_id = o.distinct_id,
            (!Di(r.distinct_id) && !vs(r.distinct_id) || t2(r.distinct_id)) && Fe.error("Invalid distinct_id for replay event. This indicates a bug in your implementation"),
            r
        }
        var a = Xn.properties();
        if (this.sessionManager) {
            var {sessionId: l, windowId: c} = this.sessionManager.checkAndGetSessionAndWindowId();
            r.$session_id = l,
            r.$window_id = c
        }
        if (this.requestRouter.region === ul.CUSTOM && (r.$lib_custom_api_host = this.config.api_host),
        this.sessionPropsManager && this.config.__preview_send_client_session_params && (e === "$pageview" || e === "$pageleave" || e === "$autocapture")) {
            var u = this.sessionPropsManager.getSessionProps();
            r = Gi(r, u)
        }
        if (!this.config.disable_scroll_properties) {
            var d = {};
            e === "$pageview" ? d = this.pageViewManager.doPageView(n) : e === "$pageleave" && (d = this.pageViewManager.doPageLeave(n)),
            r = Gi(r, d)
        }
        if (e === "$pageview" && dt && (r.title = dt.title),
        !Et(s)) {
            var f = n.getTime() - s;
            r.$duration = parseFloat((f / 1e3).toFixed(3))
        }
        mi && this.config.opt_out_useragent_filter && (r.$browser_type = this._is_bot() ? "bot" : "browser"),
        (r = Gi({}, a, this.persistence.properties(), this.sessionPersistence.properties(), r)).$is_identified = this._isIdentified(),
        Wn(this.config.property_denylist) ? bn(this.config.property_denylist, function(g) {
            delete r[g]
        }) : Fe.error("Invalid value for property_denylist config: " + this.config.property_denylist + " or property_blacklist config: " + this.config.property_blacklist);
        var h = this.config.sanitize_properties;
        h && (r = h(r, e));
        var p = this._hasPersonProcessing();
        return r.$process_person_profile = p,
        p && this._requirePersonProcessing("_calculate_event_properties"),
        r
    }
    _calculate_set_once_properties(e) {
        if (!this.persistence || !this._hasPersonProcessing())
            return e;
        var t = Gi({}, this.persistence.get_initial_props(), e || {})
          , n = this.config.sanitize_properties;
        return n && (t = n(t, "$set_once")),
        bc(t) ? void 0 : t
    }
    register(e, t) {
        var n;
        (n = this.persistence) === null || n === void 0 || n.register(e, t)
    }
    register_once(e, t, n) {
        var s;
        (s = this.persistence) === null || s === void 0 || s.register_once(e, t, n)
    }
    register_for_session(e) {
        var t;
        (t = this.sessionPersistence) === null || t === void 0 || t.register(e)
    }
    unregister(e) {
        var t;
        (t = this.persistence) === null || t === void 0 || t.unregister(e)
    }
    unregister_for_session(e) {
        var t;
        (t = this.sessionPersistence) === null || t === void 0 || t.unregister(e)
    }
    _register_single(e, t) {
        this.register({
            [e]: t
        })
    }
    getFeatureFlag(e, t) {
        return this.featureFlags.getFeatureFlag(e, t)
    }
    getFeatureFlagPayload(e) {
        var t = this.featureFlags.getFeatureFlagPayload(e);
        try {
            return JSON.parse(t)
        } catch {
            return t
        }
    }
    isFeatureEnabled(e, t) {
        return this.featureFlags.isFeatureEnabled(e, t)
    }
    reloadFeatureFlags() {
        this.featureFlags.reloadFeatureFlags()
    }
    updateEarlyAccessFeatureEnrollment(e, t) {
        this.featureFlags.updateEarlyAccessFeatureEnrollment(e, t)
    }
    getEarlyAccessFeatures(e) {
        var t = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
        return this.featureFlags.getEarlyAccessFeatures(e, t)
    }
    on(e, t) {
        return this._internalEventEmitter.on(e, t)
    }
    onFeatureFlags(e) {
        return this.featureFlags.onFeatureFlags(e)
    }
    onSessionId(e) {
        var t, n;
        return (t = (n = this.sessionManager) === null || n === void 0 ? void 0 : n.onSessionId(e)) !== null && t !== void 0 ? t : () => {}
    }
    getSurveys(e) {
        var t = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
        this.surveys.getSurveys(e, t)
    }
    getActiveMatchingSurveys(e) {
        var t = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
        this.surveys.getActiveMatchingSurveys(e, t)
    }
    renderSurvey(e, t) {
        this.surveys.renderSurvey(e, t)
    }
    canRenderSurvey(e) {
        this.surveys.canRenderSurvey(e)
    }
    getNextSurveyStep(e, t, n) {
        return this.surveys.getNextSurveyStep(e, t, n)
    }
    identify(e, t, n) {
        if (!this.__loaded || !this.persistence)
            return Fe.uninitializedWarning("posthog.identify");
        if (vs(e) && (e = e.toString(),
        Fe.warn("The first argument to posthog.identify was a number, but it should be a string. It has been converted to a string.")),
        e) {
            if (["distinct_id", "distinctid"].includes(e.toLowerCase()))
                Fe.critical('The string "'.concat(e, '" was set in posthog.identify which indicates an error. This ID should be unique to the user and not a hardcoded string.'));
            else if (this._requirePersonProcessing("posthog.identify")) {
                var s = this.get_distinct_id();
                if (this.register({
                    $user_id: e
                }),
                !this.get_property("$device_id")) {
                    var r = s;
                    this.register_once({
                        $had_persisted_distinct_id: !0,
                        $device_id: r
                    }, "")
                }
                e !== s && e !== this.get_property(Wu) && (this.unregister(Wu),
                this.register({
                    distinct_id: e
                }));
                var o = (this.persistence.get_property(mo) || "anonymous") === "anonymous";
                e !== s && o ? (this.persistence.set_property(mo, "identified"),
                this.setPersonPropertiesForFlags(t || {}, !1),
                this.capture("$identify", {
                    distinct_id: e,
                    $anon_distinct_id: s
                }, {
                    $set: t || {},
                    $set_once: n || {}
                }),
                this.featureFlags.setAnonymousDistinctId(s)) : (t || n) && this.setPersonProperties(t, n),
                e !== s && (this.reloadFeatureFlags(),
                this.unregister(sp))
            }
        } else
            Fe.error("Unique user id has not been set in posthog.identify")
    }
    setPersonProperties(e, t) {
        (e || t) && this._requirePersonProcessing("posthog.setPersonProperties") && (this.setPersonPropertiesForFlags(e || {}),
        this.capture("$set", {
            $set: e || {},
            $set_once: t || {}
        }))
    }
    group(e, t, n) {
        if (e && t) {
            if (this._requirePersonProcessing("posthog.group")) {
                var s = this.getGroups();
                s[e] !== t && this.resetGroupPropertiesForFlags(e),
                this.register({
                    $groups: Ze(Ze({}, s), {}, {
                        [e]: t
                    })
                }),
                n && (this.capture("$groupidentify", {
                    $group_type: e,
                    $group_key: t,
                    $group_set: n
                }),
                this.setGroupPropertiesForFlags({
                    [e]: n
                })),
                s[e] === t || n || this.reloadFeatureFlags()
            }
        } else
            Fe.error("posthog.group requires a group type and group key")
    }
    resetGroups() {
        this.register({
            $groups: {}
        }),
        this.resetGroupPropertiesForFlags(),
        this.reloadFeatureFlags()
    }
    setPersonPropertiesForFlags(e) {
        var t = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1];
        this._requirePersonProcessing("posthog.setPersonPropertiesForFlags") && this.featureFlags.setPersonPropertiesForFlags(e, t)
    }
    resetPersonPropertiesForFlags() {
        this.featureFlags.resetPersonPropertiesForFlags()
    }
    setGroupPropertiesForFlags(e) {
        var t = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1];
        this._requirePersonProcessing("posthog.setGroupPropertiesForFlags") && this.featureFlags.setGroupPropertiesForFlags(e, t)
    }
    resetGroupPropertiesForFlags(e) {
        this.featureFlags.resetGroupPropertiesForFlags(e)
    }
    reset(e) {
        var t, n, s, r, o;
        if (Fe.info("reset"),
        !this.__loaded)
            return Fe.uninitializedWarning("posthog.reset");
        var a = this.get_property("$device_id");
        this.consent.reset(),
        (t = this.persistence) === null || t === void 0 || t.clear(),
        (n = this.sessionPersistence) === null || n === void 0 || n.clear(),
        (s = this.surveys) === null || s === void 0 || s.reset(),
        (r = this.persistence) === null || r === void 0 || r.set_property(mo, "anonymous"),
        (o = this.sessionManager) === null || o === void 0 || o.resetSessionId();
        var l = this.config.get_device_id(la());
        this.register_once({
            distinct_id: l,
            $device_id: e ? l : a
        }, "")
    }
    get_distinct_id() {
        return this.get_property("distinct_id")
    }
    getGroups() {
        return this.get_property("$groups") || {}
    }
    get_session_id() {
        var e, t;
        return (e = (t = this.sessionManager) === null || t === void 0 ? void 0 : t.checkAndGetSessionAndWindowId(!0).sessionId) !== null && e !== void 0 ? e : ""
    }
    get_session_replay_url(e) {
        if (!this.sessionManager)
            return "";
        var {sessionId: t, sessionStartTimestamp: n} = this.sessionManager.checkAndGetSessionAndWindowId(!0)
          , s = this.requestRouter.endpointFor("ui", "/project/".concat(this.config.token, "/replay/").concat(t));
        if (e != null && e.withTimestamp && n) {
            var r, o = (r = e.timestampLookBack) !== null && r !== void 0 ? r : 10;
            if (!n)
                return s;
            var a = Math.max(Math.floor((new Date().getTime() - n) / 1e3) - o, 0);
            s += "?t=".concat(a)
        }
        return s
    }
    alias(e, t) {
        return e === this.get_property(GT) ? (Fe.critical("Attempting to create alias for existing People user - aborting."),
        -2) : this._requirePersonProcessing("posthog.alias") ? (Et(t) && (t = this.get_distinct_id()),
        e !== t ? (this._register_single(Wu, e),
        this.capture("$create_alias", {
            alias: e,
            distinct_id: t
        })) : (Fe.warn("alias matches current distinct_id - skipping api call."),
        this.identify(e),
        -1)) : void 0
    }
    set_config(e) {
        var t, n, s, r, o = Ze({}, this.config);
        Zn(e) && (Gi(this.config, W2(e)),
        (t = this.persistence) === null || t === void 0 || t.update_config(this.config, o),
        this.sessionPersistence = this.config.persistence === "sessionStorage" || this.config.persistence === "memory" ? this.persistence : new a0(Ze(Ze({}, this.config), {}, {
            persistence: "sessionStorage"
        })),
        ri.is_supported() && ri.get("ph_debug") === "true" && (this.config.debug = !0),
        this.config.debug && (na.DEBUG = !0,
        Fe.info("set_config", {
            config: e,
            oldConfig: o,
            newConfig: Ze({}, this.config)
        })),
        (n = this.sessionRecording) === null || n === void 0 || n.startIfEnabledOrStop(),
        (s = this.autocapture) === null || s === void 0 || s.startIfEnabled(),
        (r = this.heatmaps) === null || r === void 0 || r.startIfEnabled(),
        this.surveys.loadIfEnabled(),
        this._sync_opt_out_with_persistence())
    }
    startSessionRecording(e) {
        var t = e === !0
          , n = {
            sampling: t || !(e == null || !e.sampling),
            linked_flag: t || !(e == null || !e.linked_flag),
            url_trigger: t || !(e == null || !e.url_trigger),
            event_trigger: t || !(e == null || !e.event_trigger)
        };
        if (Object.values(n).some(Boolean)) {
            var s, r, o, a, l;
            (s = this.sessionManager) === null || s === void 0 || s.checkAndGetSessionAndWindowId(),
            n.sampling && ((r = this.sessionRecording) === null || r === void 0 || r.overrideSampling()),
            n.linked_flag && ((o = this.sessionRecording) === null || o === void 0 || o.overrideLinkedFlag()),
            n.url_trigger && ((a = this.sessionRecording) === null || a === void 0 || a.overrideTrigger("url")),
            n.event_trigger && ((l = this.sessionRecording) === null || l === void 0 || l.overrideTrigger("event"))
        }
        this.set_config({
            disable_session_recording: !1
        })
    }
    stopSessionRecording() {
        this.set_config({
            disable_session_recording: !0
        })
    }
    sessionRecordingStarted() {
        var e;
        return !((e = this.sessionRecording) === null || e === void 0 || !e.started)
    }
    captureException(e, t) {
        var n, s = new Error("PostHog syntheticException"), r = Os((n = Gt.__PosthogExtensions__) === null || n === void 0 ? void 0 : n.parseErrorAsProperties) ? Gt.__PosthogExtensions__.parseErrorAsProperties([e.message, void 0, void 0, void 0, e], {
            syntheticException: s
        }) : Ze({
            $exception_level: "error",
            $exception_list: [{
                type: e.name,
                value: e.message,
                mechanism: {
                    handled: !0,
                    synthetic: !1
                }
            }]
        }, t);
        this.exceptions.sendExceptionEvent(r)
    }
    loadToolbar(e) {
        return this.toolbar.loadToolbar(e)
    }
    get_property(e) {
        var t;
        return (t = this.persistence) === null || t === void 0 ? void 0 : t.props[e]
    }
    getSessionProperty(e) {
        var t;
        return (t = this.sessionPersistence) === null || t === void 0 ? void 0 : t.props[e]
    }
    toString() {
        var e, t = (e = this.config.name) !== null && e !== void 0 ? e : yc;
        return t !== yc && (t = yc + "." + t),
        t
    }
    _isIdentified() {
        var e, t;
        return ((e = this.persistence) === null || e === void 0 ? void 0 : e.get_property(mo)) === "identified" || ((t = this.sessionPersistence) === null || t === void 0 ? void 0 : t.get_property(mo)) === "identified"
    }
    _hasPersonProcessing() {
        var e, t, n, s;
        return !(this.config.person_profiles === "never" || this.config.person_profiles === "identified_only" && !this._isIdentified() && bc(this.getGroups()) && ((e = this.persistence) === null || e === void 0 || (t = e.props) === null || t === void 0 || !t[Wu]) && ((n = this.persistence) === null || n === void 0 || (s = n.props) === null || s === void 0 || !s[rp]))
    }
    _shouldCapturePageleave() {
        return this.config.capture_pageleave === !0 || this.config.capture_pageleave === "if_capture_pageview" && this.config.capture_pageview
    }
    createPersonProfile() {
        this._hasPersonProcessing() || this._requirePersonProcessing("posthog.createPersonProfile") && this.setPersonProperties({}, {})
    }
    _requirePersonProcessing(e) {
        return this.config.person_profiles === "never" ? (Fe.error(e + ' was called, but process_person is set to "never". This call will be ignored.'),
        !1) : (this._register_single(rp, !0),
        !0)
    }
    _sync_opt_out_with_persistence() {
        var e, t, n, s, r = this.consent.isOptedOut(), o = this.config.opt_out_persistence_by_default, a = this.config.disable_persistence || r && !!o;
        ((e = this.persistence) === null || e === void 0 ? void 0 : e.disabled) !== a && ((n = this.persistence) === null || n === void 0 || n.set_disabled(a)),
        ((t = this.sessionPersistence) === null || t === void 0 ? void 0 : t.disabled) !== a && ((s = this.sessionPersistence) === null || s === void 0 || s.set_disabled(a))
    }
    opt_in_capturing(e) {
        var t;
        this.consent.optInOut(!0),
        this._sync_opt_out_with_persistence(),
        (Et(e == null ? void 0 : e.captureEventName) || e != null && e.captureEventName) && this.capture((t = e == null ? void 0 : e.captureEventName) !== null && t !== void 0 ? t : "$opt_in", e == null ? void 0 : e.captureProperties, {
            send_instantly: !0
        }),
        this.config.capture_pageview && this._captureInitialPageview()
    }
    opt_out_capturing() {
        this.consent.optInOut(!1),
        this._sync_opt_out_with_persistence()
    }
    has_opted_in_capturing() {
        return this.consent.isOptedIn()
    }
    has_opted_out_capturing() {
        return this.consent.isOptedOut()
    }
    clear_opt_in_out_capturing() {
        this.consent.reset(),
        this._sync_opt_out_with_persistence()
    }
    _is_bot() {
        return bs ? NA(bs, this.config.custom_blocked_useragents) : void 0
    }
    _captureInitialPageview() {
        dt && !this._initialPageviewCaptured && (this._initialPageviewCaptured = !0,
        this.capture("$pageview", {
            title: dt.title
        }, {
            send_instantly: !0
        }))
    }
    debug(e) {
        e === !1 ? (pe == null || pe.console.log("You've disabled debug mode."),
        localStorage && localStorage.removeItem("ph_debug"),
        this.set_config({
            debug: !1
        })) : (pe == null || pe.console.log("You're now in debug mode. All calls to PostHog will be logged in your console.\nYou can disable this with `posthog.debug(false)`."),
        localStorage && localStorage.setItem("ph_debug", "true"),
        this.set_config({
            debug: !0
        }))
    }
    _runBeforeSend(e) {
        if (Mn(this.config.before_send))
            return e;
        var t = Wn(this.config.before_send) ? this.config.before_send : [this.config.before_send]
          , n = e;
        for (var s of t) {
            if (n = s(n),
            Mn(n)) {
                var r = "Event '".concat(e.event, "' was rejected in beforeSend function");
                return jP(e.event) ? Fe.warn("".concat(r, ". This can cause unexpected behavior.")) : Fe.info(r),
                null
            }
            n.properties && !bc(n.properties) || Fe.warn("Event '".concat(e.event, "' has no properties after beforeSend function, this is likely an error."))
        }
        return n
    }
}
(function(i, e) {
    for (var t = 0; t < e.length; t++)
        i.prototype[e[t]] = $P(i.prototype[e[t]])
}
)(fm, ["identify"]);
var q2, hm = (q2 = dd[yc] = new fm,
function() {
    function i() {
        i.done || (i.done = !0,
        $A = !1,
        bn(dd, function(e) {
            e._dom_loaded()
        }))
    }
    dt != null && dt.addEventListener && (dt.readyState === "complete" ? i() : dt.addEventListener("DOMContentLoaded", i, !1)),
    pe && To(pe, "load", i, !0)
}(),
q2);
const it = Qd("user", () => {
    const i = xe()
      , e = xe([])
      , t = xe([])
      , n = xe(0)
      , s = Vt( () => i.value !== void 0)
      , r = Vt( () => i.value && i.value.creator)
      , o = Vt( () => i.value && i.value.admin);
    async function a(m) {
        console.log("Update ------------store"),
        i.value = m,
        m && (hm.identify(m.id),
        e.value = await ct.user.getSubscriptions(),
        t.value = await ct.notifications.getNotifications(),
        n.value = await ct.notifications.getUnreadNotificationsCount())
    }
    async function l(m) {
        !i.value || (i.value.avatar_url = await ct.user.updateAvatar(m))
    }
    async function c(m) {
        !i.value || (await ct.user.updateBio(m),
        i.value.bio = m)
    }
    async function u() {
        await ct.notifications.markNotificationsAsRead(),
        n.value = 0
    }
    async function d(m) {
        i.value ? await ct.user.updateOrientation(m) : localStorage.setItem("o", m == null ? "-1" : m.toString()),
        window.location.reload()
    }
    function f() {
        var v;
        if (i.value)
            return (v = i.value) == null ? void 0 : v.orientation;
        const m = localStorage.getItem("o");
        if (!m)
            return localStorage.setItem("o", "0"),
            f();
        switch (parseInt(m)) {
        case mn.Straight:
            return mn.Straight;
        case mn.Gay:
            return mn.Gay;
        case mn.Transgender:
            return mn.Transgender;
        default:
            return
        }
    }
    function h() {
        switch (f()) {
        case mn.Straight:
            return "orientation-straight";
        case mn.Transgender:
            return "orientation-transgender";
        case mn.Gay:
            return "orientation-gay";
        default:
            return "close"
        }
    }
    const p = !0
      , g = Vt( () => i.value && i.value.premium);
    return {
        user: i,
        setUser: a,
        isAuthorized: s,
        subscriptions: e,
        setAvatar: l,
        setBio: c,
        isCreator: r,
        isAdmin: o,
        markNotificationsAsRead: u,
        notifications: t,
        unreadNotificationsCount: n,
        setOrientation: d,
        getOrientation: f,
        getOrientationIcon: h,
        isProduction: p,
        isPremium: g
    }
}
);
class M8 {
    constructor(e) {
        tt(this, "baseUrl");
        tt(this, "products", {
            getProducts: () => this.request("/products")
        });
        tt(this, "user", {
            getSession: () => this.request("/session"),
            updateAvatar: e => this.request("/users/@me/avatar", "POST", e),
            updateBio: e => this.request("/users/@me/bio", "PUT", {
                bio: e
            }),
            updateOrientation: e => this.request("/users/@me/orientation", "PUT", {
                orientation: e
            }),
            updateProfile: e => this.request("/users/@me/profile", "POST", e),
            updateUsername: (e, t) => {
                const n = {
                    username: e,
                    verify_password: t
                };
                return this.request("/users/@me/username", "PUT", n)
            }
            ,
            getSubscriptions: () => this.request("/users/@me/subscriptions"),
            updatePassword: (e, t) => {
                const n = {
                    old_password: e,
                    new_password: t
                };
                return this.request("/users/@me/password", "PUT", n)
            }
            ,
            login: (e, t) => {
                const n = {
                    email: e,
                    password: t
                };
                return this.request("/session", "POST", n)
            }
            ,
            logout: async () => {
                await this.request("/session", "DELETE"),
                Promise.resolve()
            }
            ,
            register: (e, t, n, s) => {
                const r = {
                    email: t,
                    username: e,
                    password: n,
                    code: s
                };
                return this.request("/users", "POST", r)
            }
            ,
            getStatistics: () => this.request("/users/@me/statistics"),
            subscribe: e => this.request(`/users/${e.id}/subscribe`, "POST"),
            unsubscribe: e => this.request(`/users/${e.id}/unsubscribe`, "POST"),
            sendVerificationMail: (e, t) => this.request("/verify-mail", "POST", {
                email: e,
                captcha: t
            }),
            deleteSelf: e => this.request("/users/@me", "DELETE", {
                password: e
            }),
            sendForgotPasswordToken: e => this.request("/forgot-password", "POST", {
                email: e
            }),
            changePassword: (e, t, n) => {
                const s = {
                    email: e,
                    token: t,
                    password: n
                };
                return this.request("/verify-token-change-password", "PUT", s)
            }
        });
        tt(this, "users", {
            getUsers: () => this.request("/users"),
            getUser: e => this.request(`/users/${e}`)
        });
        tt(this, "comments", {
            createComment: (e, t, n, s) => this.request("/comments", "POST", {
                thing_id: e,
                thing_type: t,
                comment: n,
                parent_id: s
            }),
            getComments: e => this.request(`/comments?thing_id=${e}`)
        });
        tt(this, "rating", {
            setRating: (e, t) => this.request("/rating", "POST", {
                thing_id: e,
                thing_type: t
            })
        });
        tt(this, "videos", {
            getVideos: e => {
                let t = `/videos?limit=${e.limit}&page=${e.page}&order_by=${e.orderBy}.${e.asc ? "asc" : "desc"}`;
                return e.user && (t += `&user_id=${e.user}`),
                e.performer && (t += `&performer_id=${e.performer}`),
                e.tag && (t += `&tag_ids=${e.tag}`),
                e.subscriptions && (t += "&subscriptions=true"),
                e.likes && (t += "&likes=true"),
                e.query && (t += `&q=${e.query}`),
                e.from && (t += `&from=${e.from}`),
                e.speed && (t += `&speed=${e.speed}`),
                e.source && (t += `&source=${e.source}`),
                e.duration && (t += `&duration=${e.duration}`),
                e.video && (t += `&video_id=${e.video}`),
                e.orientation !== void 0 && (t += `&orientation=${e.orientation}`),
                e.tagsExclude !== void 0 && (t += `&tags_exclude=${e.tagsExclude}`),
                e.removeExcludedTags && (t += `&removeExcludedTags=${e.removeExcludedTags}`),
                this.request(t)
            }
            ,
            getVideo: e => this.request(`/videos/${e}`),
            getRelatedVideos: e => this.request(`/videos/${e}/related`),
            getScript: e => new Promise( (t, n) => {
                fetch(Gs(e)).then(s => s.text()).then(s => {
                    if (s.startsWith('{"error"'))
                        return n("Failed to fetch script");
                    const r = [];
                    s.split(`
`).forEach(a => {
                        if (a.length === 0)
                            return;
                        const l = a.split(",")
                          , c = parseInt(l[0])
                          , u = parseInt(l[1]);
                        r.push([c, u])
                    }
                    ),
                    t(r)
                }
                ).catch(s => n(s))
            }
            ),
            viewVideo: e => this.request(`/videos/${e}/view`, "POST"),
            getSources: e => this.request(`/videos/${e}/sources`),
            createVideo: e => this.request("/videos", "POST", e),
            updateVideo: e => this.request(`/videos/${e.id}`, "PUT", e),
            updateScript: (e, t) => this.request(`/videos/${e}/script`, "PUT", t),
            deleteVideo: e => this.request(`/videos/${e}`, "DELETE"),
            getMetadata: e => this.request("/get-metadata", "POST", {
                url: e
            })
        });
        tt(this, "tags", {
            getTags: e => {
                let t = `/tags?order_by=${e.orderBy}`;
                return e.query && (t += `&query=${e.query}`),
                e.user && (t += `&user=${e.user}`),
                e.performer && (t += `&performer=${e.performer}`),
                this.request(t)
            }
            ,
            getTag: e => this.request(`/tags/${e}`),
            getTopTags: (e={
                count: 30,
                order: "desc"
            }) => this.request(PP("/tags/top", e)),
            getTagSlug: e => this.request(`/tag/${e}`)
        });
        tt(this, "performers", {
            getPerformer: e => this.request(`/performers/${e}`),
            createPerformer: e => this.request("/performers", "POST", {
                name: e
            }),
            createPerformerAvatar: (e, t) => this.request(`/performers/${e}/avatar`, "POST", t),
            updatePerformerName: (e, t) => this.request(`/performers/${e}`, "PUT", {
                name: t
            }),
            getPerformers: e => {
                let t = `/performers?page=${e.page}&limit=${e.limit}`;
                return e.query && (t += `&query=${e.query}`),
                this.request(t)
            }
        });
        tt(this, "providers", {
            getProviders: () => this.request("/providers")
        });
        tt(this, "feed", {
            getFeed: e => {
                let t = "/feed";
                return e !== void 0 && (t += `?orientation=${e}`),
                this.request(t)
            }
        });
        tt(this, "notifications", {
            getNotifications: (e=1, t=10) => this.request(`/notifications?page=${e}&limit=${t}`),
            getUnreadNotificationsCount: () => this.request("/notifications/unread-count"),
            markNotificationsAsRead: () => this.request("/notifications", "POST")
        });
        tt(this, "admin", {
            findUsers: e => this.request(`/admin/users?query=${e}`),
            updateUser: (e, t) => this.request(`/admin/users/${e}`, "PATCH", t),
            deleteUser: e => this.request(`/admin/users/${e}`, "DELETE"),
            getPremiumUsers: () => this.request("/premium-users", "GET"),
            updatePremium: (e, t) => {
                const n = t.toString().split("T")[0].replace(/-/g, "/");
                return this.request("/admin/enable-premium", "POST", {
                    ExpireOn: n,
                    Email: e
                })
            }
            ,
            removePremiumUser: e => this.request("/admin/cancel-premium", "POST", {
                Email: e
            })
        });
        tt(this, "funscripts", {
            getFunscripts: e => {
                let t = `/users/@me/funscripts?limit=${e.limit}&page=${e.page}&order_by=${e.orderBy}.${e.asc ? "asc" : "desc"}`;
                return e.funscriptStatus && (t += `&funscript_status=${e.funscriptStatus}`),
                e.fromDate && (t += `&from=${e.fromDate.toISOString()}`),
                e.toDate && (t += `&to=${e.toDate.toISOString()}`),
                this.request(t)
            }
            ,
            getFunscript: e => this.request(`/users/@me/funscripts/${e}`),
            createFunscriptVideo: e => this.request("/users/@me/funscript", "POST", e),
            updateFunscriptVideo: e => this.request(`/users/@me/funscripts/${e.id}`, "PUT", e),
            deleteFunscript: e => this.request(`/users/@me/funscript/${e}`, "DELETE"),
            getQueueCount: () => this.request("/funscripts/queue-count"),
            getFunscriptCountLast24Hours: () => this.request("/users/@me/funscripts/count")
        });
        this.baseUrl = e
    }
    request(e, t="GET", n) {
        return new Promise( (s, r) => {
            n && !(n instanceof FormData) && (n = JSON.stringify(n)),
            fetch(this.baseUrl + e, {
                method: t,
                body: n || void 0
            }).then(o => o.json()).then(o => "error"in o ? r(o.error) : (it().isProduction = typeof o.ci_environment > "u" || o.ci_environment == "" || o.ci_environment !== "development",
            s(o.data))).catch(o => ["/session", "/verify-mail", "/users", "/forgot-password"].includes(e) && t === "POST" ? r(new Error("Request failed. Please try again.")) : r(o))
        }
        )
    }
}
var mn = (i => (i[i.Straight = 0] = "Straight",
i[i.Transgender = 1] = "Transgender",
i[i.Gay = 2] = "Gay",
i))(mn || {})
  , Xu = (i => (i.slow = "slow",
i.medium = "medium",
i.fast = "fast",
i.veryfast = "veryfast",
i))(Xu || {})
  , el = (i => (i.day = "day",
i.week = "week",
i.month = "month",
i.year = "year",
i))(el || {})
  , bh = (i => (i.short = "short",
i.medium = "medium",
i.long = "long",
i))(bh || {})
  , er = (i => (i.views = "views",
i.speed = "speed",
i.duration = "duration",
i.likes = "likes",
i.relevance = "relevance",
i.creation = "creation",
i))(er || {})
  , gp = (i => (i[i.Video = 0] = "Video",
i[i.Comment = 1] = "Comment",
i))(gp || {})
  , Sh = (i => (i[i.Report = 0] = "Report",
i[i.VideoComment = 1] = "VideoComment",
i[i.Video = 2] = "Video",
i[i.VideoCommentResponse = 3] = "VideoCommentResponse",
i))(Sh || {});
const R8 = `${window.location.protocol}//${window.location.hostname}${window.location.port !== "" ? `:${window.location.port}` : ""}/api/assets/`;
var tw;
const L8 = {}.FAPTAP_CAPTCHA_KEY || ((tw = window.config) == null ? void 0 : tw.FAPTAP_CAPTCHA_KEY) || "10000000-ffff-ffff-ffff-000000000001"
  , Gs = i => R8 + i
  , ct = new M8("/api")
  , Xi = Qd("dialogs", () => {
    const i = xe(!1)
      , e = xe(!1)
      , t = xe(!1);
    let n = !1;
    const s = () => {
        const o = document.getElementById("player");
        !o || o.paused || (o.pause(),
        n = !0)
    }
      , r = () => {
        if (!n)
            return;
        n = !1;
        const o = document.getElementById("player");
        !o || o.play()
    }
    ;
    return Bt( () => i.value, o => o ? s() : r()),
    Bt( () => e.value, o => o ? s() : r()),
    Bt( () => t.value, o => o ? s() : r()),
    {
        authDialog: i,
        deviceDialog: e,
        changePassword: t
    }
}
)
  , I8 = {
    key: 0,
    class: "text-center text-red-500"
}
  , k8 = ut({
    __name: "AuthLogin",
    setup(i) {
        const e = ei({
            email: "",
            password: "",
            loading: !1
        })
          , t = ti()
          , n = Ki()
          , s = it()
          , r = Xi()
          , o = async () => {
            e.error = void 0,
            e.loading = !0;
            try {
                const a = await ct.user.login(e.email, e.password);
                s.setUser(a),
                r.authDialog = !1;
                const l = n.query.redirect || "/";
                t.push(l)
            } catch (a) {
                e.error = a
            } finally {
                e.loading = !1
            }
        }
        ;
        return (a, l) => (w(),
        R("form", {
            onSubmit: Vn(o, ["prevent"]),
            class: "flex flex-col gap-y-3 items-center"
        }, [O(vn, {
            class: "w-full",
            required: "",
            disabled: e.loading,
            modelValue: e.email,
            "onUpdate:modelValue": l[0] || (l[0] = c => e.email = c),
            type: "email",
            placeholder: "E-Mail"
        }, null, 8, ["disabled", "modelValue"]), O(vn, {
            class: "w-full",
            required: "",
            disabled: e.loading,
            modelValue: e.password,
            "onUpdate:modelValue": l[1] || (l[1] = c => e.password = c),
            type: "password",
            placeholder: "Password"
        }, null, 8, ["disabled", "modelValue"]), O(je, {
            loading: e.loading,
            theme: "blue",
            class: "mt-2 w-full"
        }, {
            default: Y( () => l[2] || (l[2] = [J("Login")])),
            _: 1
        }, 8, ["loading"]), e.error ? (w(),
        R("span", I8, ee(e.error), 1)) : le("", !0)], 32))
    }
})
  , j2 = "hcaptcha-api-script-id"
  , HA = "_hcaptchaOnLoad";
let w1, zA;
const f0 = new Promise( (i, e) => {
    w1 = i,
    zA = e
}
);
function P8(i) {
    if (window.hcaptcha)
        return w1(),
        f0;
    if (document.getElementById(j2))
        return f0;
    window[HA] = w1;
    const e = D8(i)
      , t = document.createElement("script");
    return t.id = j2,
    t.src = e,
    t.async = !0,
    t.defer = !0,
    t.onerror = n => {
        console.error("Failed to load api: " + e, n),
        zA("Failed to load api.js")
    }
    ,
    document.head.appendChild(t),
    f0
}
function D8(i) {
    let e = i.apiEndpoint;
    return e = wr(e, "render", "explicit"),
    e = wr(e, "onload", HA),
    e = wr(e, "recaptchacompat", i.reCaptchaCompat === !1 ? "off" : null),
    e = wr(e, "hl", i.language),
    e = wr(e, "sentry", i.sentry),
    e = wr(e, "custom", i.custom),
    e = wr(e, "endpoint", i.endpoint),
    e = wr(e, "assethost", i.assethost),
    e = wr(e, "imghost", i.imghost),
    e = wr(e, "reportapi", i.reportapi),
    e
}
function wr(i, e, t) {
    if (t != null) {
        const n = i.includes("?") ? "&" : "?";
        return i + n + e + "=" + encodeURIComponent(t)
    }
    return i
}
var F8 = (i, e) => {
    for (const [t,n] of e)
        i[t] = n;
    return i
}
;
const O8 = {
    name: "VueHcaptcha",
    props: {
        sitekey: {
            type: String,
            required: !0
        },
        theme: {
            type: String,
            default: void 0
        },
        size: {
            type: String,
            default: void 0
        },
        tabindex: {
            type: String,
            default: void 0
        },
        language: {
            type: String,
            default: void 0
        },
        reCaptchaCompat: {
            type: Boolean,
            default: !0
        },
        challengeContainer: {
            type: String,
            default: void 0
        },
        rqdata: {
            type: String,
            default: void 0
        },
        sentry: {
            type: Boolean,
            default: !0
        },
        custom: {
            type: Boolean,
            default: void 0
        },
        apiEndpoint: {
            type: String,
            default: "https://hcaptcha.com/1/api.js"
        },
        endpoint: {
            type: String,
            default: void 0
        },
        reportapi: {
            type: String,
            default: void 0
        },
        assethost: {
            type: String,
            default: void 0
        },
        imghost: {
            type: String,
            default: void 0
        }
    },
    data: () => ({
        widgetId: null,
        hcaptcha: null,
        renderedCb: null
    }),
    mounted() {
        return P8(this.$props).then(this.onApiLoaded).catch(this.onError)
    },
    unmounted() {
        this.teardown()
    },
    destroyed() {
        this.teardown()
    },
    methods: {
        teardown() {
            this.widgetId && (this.hcaptcha.reset(this.widgetId),
            this.hcaptcha.remove(this.widgetId))
        },
        onApiLoaded() {
            this.hcaptcha = window.hcaptcha;
            const i = {
                sitekey: this.sitekey,
                theme: this.theme,
                size: this.size,
                tabindex: this.tabindex,
                callback: this.onVerify,
                "expired-callback": this.onExpired,
                "chalexpired-callback": this.onChallengeExpired,
                "error-callback": this.onError,
                "open-callback": this.onOpen,
                "close-callback": this.onClose
            };
            this.challengeContainer && (i["challenge-container"] = this.challengeContainer),
            this.widgetId = this.hcaptcha.render(this.$el, i),
            this.rqdata && this.hcaptcha.setData(this.widgetId, {
                rqdata: this.rqdata
            }),
            this.onRendered()
        },
        execute() {
            this.widgetId ? (this.hcaptcha.execute(this.widgetId),
            this.onExecuted()) : this.renderedCb = () => {
                this.renderedCb = null,
                this.execute()
            }
        },
        executeAsync() {
            if (this.widgetId)
                return this.onExecuted(),
                this.hcaptcha.execute(this.widgetId, {
                    async: !0
                });
            let i;
            const e = new Promise(t => {
                i = t
            }
            );
            return this.renderedCb = () => {
                this.renderedCb = null,
                i()
            }
            ,
            e.then(this.executeAsync)
        },
        reset() {
            this.widgetId ? (this.hcaptcha.reset(this.widgetId),
            this.onReset()) : this.$emit("error", "Element is not rendered yet and thus cannot reset it. Wait for `rendered` event to safely call reset.")
        },
        onRendered() {
            this.$emit("rendered"),
            this.renderedCb && this.renderedCb()
        },
        onExecuted() {
            this.$emit("executed")
        },
        onReset() {
            this.$emit("reset")
        },
        onError(i) {
            this.$emit("error", i),
            this.reset()
        },
        onVerify() {
            const i = this.hcaptcha.getResponse(this.widgetId)
              , e = this.hcaptcha.getRespKey(this.widgetId);
            this.$emit("verify", i, e)
        },
        onExpired() {
            this.$emit("expired")
        },
        onChallengeExpired() {
            this.$emit("challengeExpired")
        },
        onOpen() {
            this.$emit("opened")
        },
        onClose() {
            this.$emit("closed")
        }
    }
}
  , U8 = {
    id: "hcap-script"
};
function N8(i, e, t, n, s, r) {
    return w(),
    R("div", U8)
}
var B8 = F8(O8, [["render", N8]]);
function Bl(i) {
    this._maxSize = i,
    this.clear()
}
Bl.prototype.clear = function() {
    this._size = 0,
    this._values = Object.create(null)
}
;
Bl.prototype.get = function(i) {
    return this._values[i]
}
;
Bl.prototype.set = function(i, e) {
    return this._size >= this._maxSize && this.clear(),
    i in this._values || this._size++,
    this._values[i] = e
}
;
var V8 = /[^.^\]^[]+|(?=\[\]|\.\.)/g
  , GA = /^\d+$/
  , $8 = /^\d/
  , H8 = /[~`!#$%\^&*+=\-\[\]\\';,/{}|\\":<>\?]/g
  , z8 = /^\s*(['"]?)(.*?)(\1)\s*$/
  , D_ = 512
  , K2 = new Bl(D_)
  , X2 = new Bl(D_)
  , Y2 = new Bl(D_)
  , yl = {
    Cache: Bl,
    split: T1,
    normalizePath: h0,
    setter: function(i) {
        var e = h0(i);
        return X2.get(i) || X2.set(i, function(n, s) {
            for (var r = 0, o = e.length, a = n; r < o - 1; ) {
                var l = e[r];
                if (l === "__proto__" || l === "constructor" || l === "prototype")
                    return n;
                a = a[e[r++]]
            }
            a[e[r]] = s
        })
    },
    getter: function(i, e) {
        var t = h0(i);
        return Y2.get(i) || Y2.set(i, function(s) {
            for (var r = 0, o = t.length; r < o; )
                if (s != null || !e)
                    s = s[t[r++]];
                else
                    return;
            return s
        })
    },
    join: function(i) {
        return i.reduce(function(e, t) {
            return e + (F_(t) || GA.test(t) ? "[" + t + "]" : (e ? "." : "") + t)
        }, "")
    },
    forEach: function(i, e, t) {
        G8(Array.isArray(i) ? i : T1(i), e, t)
    }
};
function h0(i) {
    return K2.get(i) || K2.set(i, T1(i).map(function(e) {
        return e.replace(z8, "$2")
    }))
}
function T1(i) {
    return i.match(V8) || [""]
}
function G8(i, e, t) {
    var n = i.length, s, r, o, a;
    for (r = 0; r < n; r++)
        s = i[r],
        s && (j8(s) && (s = '"' + s + '"'),
        a = F_(s),
        o = !a && /^\d+$/.test(s),
        e.call(t, s, a, o, r, i))
}
function F_(i) {
    return typeof i == "string" && i && ["'", '"'].indexOf(i.charAt(0)) !== -1
}
function W8(i) {
    return i.match($8) && !i.match(GA)
}
function q8(i) {
    return H8.test(i)
}
function j8(i) {
    return !F_(i) && (W8(i) || q8(i))
}
const K8 = /[A-Z\xc0-\xd6\xd8-\xde]?[a-z\xdf-\xf6\xf8-\xff]+(?:['](?:d|ll|m|re|s|t|ve))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde]|$)|(?:[A-Z\xc0-\xd6\xd8-\xde]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['](?:D|LL|M|RE|S|T|VE))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde](?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])|$)|[A-Z\xc0-\xd6\xd8-\xde]?(?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['](?:d|ll|m|re|s|t|ve))?|[A-Z\xc0-\xd6\xd8-\xde]+(?:['](?:D|LL|M|RE|S|T|VE))?|\d*(?:1ST|2ND|3RD|(?![123])\dTH)(?=\b|[a-z_])|\d*(?:1st|2nd|3rd|(?![123])\dth)(?=\b|[A-Z_])|\d+|(?:[\u2700-\u27bf]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?(?:\u200d(?:[^\ud800-\udfff]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?)*/g
  , pm = i => i.match(K8) || []
  , mm = i => i[0].toUpperCase() + i.slice(1)
  , O_ = (i, e) => pm(i).join(e).toLowerCase()
  , WA = i => pm(i).reduce( (e, t) => `${e}${e ? t[0].toUpperCase() + t.slice(1).toLowerCase() : t.toLowerCase()}`, "")
  , X8 = i => mm(WA(i))
  , Y8 = i => O_(i, "_")
  , Z8 = i => O_(i, "-")
  , J8 = i => mm(O_(i, " "))
  , Q8 = i => pm(i).map(mm).join(" ");
var p0 = {
    words: pm,
    upperFirst: mm,
    camelCase: WA,
    pascalCase: X8,
    snakeCase: Y8,
    kebabCase: Z8,
    sentenceCase: J8,
    titleCase: Q8
}
  , U_ = {
    exports: {}
};
U_.exports = function(i) {
    return qA(e6(i), i)
}
;
U_.exports.array = qA;
function qA(i, e) {
    var t = i.length
      , n = new Array(t)
      , s = {}
      , r = t
      , o = t6(e)
      , a = n6(i);
    for (e.forEach(function(c) {
        if (!a.has(c[0]) || !a.has(c[1]))
            throw new Error("Unknown node. There is an unknown node in the supplied edges.")
    }); r--; )
        s[r] || l(i[r], r, new Set);
    return n;
    function l(c, u, d) {
        if (d.has(c)) {
            var f;
            try {
                f = ", node was:" + JSON.stringify(c)
            } catch {
                f = ""
            }
            throw new Error("Cyclic dependency" + f)
        }
        if (!a.has(c))
            throw new Error("Found unknown node. Make sure to provided all involved nodes. Unknown node: " + JSON.stringify(c));
        if (!s[u]) {
            s[u] = !0;
            var h = o.get(c) || new Set;
            if (h = Array.from(h),
            u = h.length) {
                d.add(c);
                do {
                    var p = h[--u];
                    l(p, a.get(p), d)
                } while (u);
                d.delete(c)
            }
            n[--t] = c
        }
    }
}
function e6(i) {
    for (var e = new Set, t = 0, n = i.length; t < n; t++) {
        var s = i[t];
        e.add(s[0]),
        e.add(s[1])
    }
    return Array.from(e)
}
function t6(i) {
    for (var e = new Map, t = 0, n = i.length; t < n; t++) {
        var s = i[t];
        e.has(s[0]) || e.set(s[0], new Set),
        e.has(s[1]) || e.set(s[1], new Set),
        e.get(s[0]).add(s[1])
    }
    return e
}
function n6(i) {
    for (var e = new Map, t = 0, n = i.length; t < n; t++)
        e.set(i[t], t);
    return e
}
const i6 = Object.prototype.toString
  , s6 = Error.prototype.toString
  , r6 = RegExp.prototype.toString
  , o6 = typeof Symbol < "u" ? Symbol.prototype.toString : () => ""
  , a6 = /^Symbol\((.*)\)(.*)$/;
function l6(i) {
    return i != +i ? "NaN" : i === 0 && 1 / i < 0 ? "-0" : "" + i
}
function Z2(i, e=!1) {
    if (i == null || i === !0 || i === !1)
        return "" + i;
    const t = typeof i;
    if (t === "number")
        return l6(i);
    if (t === "string")
        return e ? `"${i}"` : i;
    if (t === "function")
        return "[Function " + (i.name || "anonymous") + "]";
    if (t === "symbol")
        return o6.call(i).replace(a6, "Symbol($1)");
    const n = i6.call(i).slice(8, -1);
    return n === "Date" ? isNaN(i.getTime()) ? "" + i : i.toISOString(i) : n === "Error" || i instanceof Error ? "[" + s6.call(i) + "]" : n === "RegExp" ? r6.call(i) : null
}
function va(i, e) {
    let t = Z2(i, e);
    return t !== null ? t : JSON.stringify(i, function(n, s) {
        let r = Z2(this[n], e);
        return r !== null ? r : s
    }, 2)
}
function jA(i) {
    return i == null ? [] : [].concat(i)
}
let KA, XA, YA, c6 = /\$\{\s*(\w+)\s*\}/g;
KA = Symbol.toStringTag;
class J2 {
    constructor(e, t, n, s) {
        this.name = void 0,
        this.message = void 0,
        this.value = void 0,
        this.path = void 0,
        this.type = void 0,
        this.params = void 0,
        this.errors = void 0,
        this.inner = void 0,
        this[KA] = "Error",
        this.name = "ValidationError",
        this.value = t,
        this.path = n,
        this.type = s,
        this.errors = [],
        this.inner = [],
        jA(e).forEach(r => {
            if (ts.isError(r)) {
                this.errors.push(...r.errors);
                const o = r.inner.length ? r.inner : [r];
                this.inner.push(...o)
            } else
                this.errors.push(r)
        }
        ),
        this.message = this.errors.length > 1 ? `${this.errors.length} errors occurred` : this.errors[0]
    }
}
XA = Symbol.hasInstance;
YA = Symbol.toStringTag;
class ts extends Error {
    static formatError(e, t) {
        const n = t.label || t.path || "this";
        return n !== t.path && (t = Object.assign({}, t, {
            path: n
        })),
        typeof e == "string" ? e.replace(c6, (s, r) => va(t[r])) : typeof e == "function" ? e(t) : e
    }
    static isError(e) {
        return e && e.name === "ValidationError"
    }
    constructor(e, t, n, s, r) {
        const o = new J2(e,t,n,s);
        if (r)
            return o;
        super(),
        this.value = void 0,
        this.path = void 0,
        this.type = void 0,
        this.params = void 0,
        this.errors = [],
        this.inner = [],
        this[YA] = "Error",
        this.name = o.name,
        this.message = o.message,
        this.type = o.type,
        this.value = o.value,
        this.path = o.path,
        this.errors = o.errors,
        this.inner = o.inner,
        Error.captureStackTrace && Error.captureStackTrace(this, ts)
    }
    static[XA](e) {
        return J2[Symbol.hasInstance](e) || super[Symbol.hasInstance](e)
    }
}
let Mr = {
    default: "${path} is invalid",
    required: "${path} is a required field",
    defined: "${path} must be defined",
    notNull: "${path} cannot be null",
    oneOf: "${path} must be one of the following values: ${values}",
    notOneOf: "${path} must not be one of the following values: ${values}",
    notType: ({path: i, type: e, value: t, originalValue: n}) => {
        const s = n != null && n !== t ? ` (cast from the value \`${va(n, !0)}\`).` : ".";
        return e !== "mixed" ? `${i} must be a \`${e}\` type, but the final value was: \`${va(t, !0)}\`` + s : `${i} must match the configured type. The validated value was: \`${va(t, !0)}\`` + s
    }
}
  , Ji = {
    length: "${path} must be exactly ${length} characters",
    min: "${path} must be at least ${min} characters",
    max: "${path} must be at most ${max} characters",
    matches: '${path} must match the following: "${regex}"',
    email: "${path} must be a valid email",
    url: "${path} must be a valid URL",
    uuid: "${path} must be a valid UUID",
    datetime: "${path} must be a valid ISO date-time",
    datetime_precision: "${path} must be a valid ISO date-time with a sub-second precision of exactly ${precision} digits",
    datetime_offset: '${path} must be a valid ISO date-time with UTC "Z" timezone',
    trim: "${path} must be a trimmed string",
    lowercase: "${path} must be a lowercase string",
    uppercase: "${path} must be a upper case string"
}
  , u6 = {
    min: "${path} must be greater than or equal to ${min}",
    max: "${path} must be less than or equal to ${max}",
    lessThan: "${path} must be less than ${less}",
    moreThan: "${path} must be greater than ${more}",
    positive: "${path} must be a positive number",
    negative: "${path} must be a negative number",
    integer: "${path} must be an integer"
}
  , A1 = {
    min: "${path} field must be later than ${min}",
    max: "${path} field must be at earlier than ${max}"
}
  , d6 = {
    isValue: "${path} field must be ${value}"
}
  , C1 = {
    noUnknown: "${path} field has unspecified keys: ${unknown}"
}
  , f6 = {
    min: "${path} field must have at least ${min} items",
    max: "${path} field must have less than or equal to ${max} items",
    length: "${path} must have ${length} items"
}
  , h6 = {
    notType: i => {
        const {path: e, value: t, spec: n} = i
          , s = n.types.length;
        if (Array.isArray(t)) {
            if (t.length < s)
                return `${e} tuple value has too few items, expected a length of ${s} but got ${t.length} for value: \`${va(t, !0)}\``;
            if (t.length > s)
                return `${e} tuple value has too many items, expected a length of ${s} but got ${t.length} for value: \`${va(t, !0)}\``
        }
        return ts.formatError(Mr.notType, i)
    }
};
Object.assign(Object.create(null), {
    mixed: Mr,
    string: Ji,
    number: u6,
    date: A1,
    object: C1,
    array: f6,
    boolean: d6,
    tuple: h6
});
const N_ = i => i && i.__isYupSchema__;
class vp {
    static fromOptions(e, t) {
        if (!t.then && !t.otherwise)
            throw new TypeError("either `then:` or `otherwise:` is required for `when()` conditions");
        let {is: n, then: s, otherwise: r} = t
          , o = typeof n == "function" ? n : (...a) => a.every(l => l === n);
        return new vp(e, (a, l) => {
            var c;
            let u = o(...a) ? s : r;
            return (c = u == null ? void 0 : u(l)) != null ? c : l
        }
        )
    }
    constructor(e, t) {
        this.fn = void 0,
        this.refs = e,
        this.refs = e,
        this.fn = t
    }
    resolve(e, t) {
        let n = this.refs.map(r => r.getValue(t == null ? void 0 : t.value, t == null ? void 0 : t.parent, t == null ? void 0 : t.context))
          , s = this.fn(n, e, t);
        if (s === void 0 || s === e)
            return e;
        if (!N_(s))
            throw new TypeError("conditions must return a schema object");
        return s.resolve(t)
    }
}
const Mf = {
    context: "$",
    value: "."
};
class Vl {
    constructor(e, t={}) {
        if (this.key = void 0,
        this.isContext = void 0,
        this.isValue = void 0,
        this.isSibling = void 0,
        this.path = void 0,
        this.getter = void 0,
        this.map = void 0,
        typeof e != "string")
            throw new TypeError("ref must be a string, got: " + e);
        if (this.key = e.trim(),
        e === "")
            throw new TypeError("ref must be a non-empty string");
        this.isContext = this.key[0] === Mf.context,
        this.isValue = this.key[0] === Mf.value,
        this.isSibling = !this.isContext && !this.isValue;
        let n = this.isContext ? Mf.context : this.isValue ? Mf.value : "";
        this.path = this.key.slice(n.length),
        this.getter = this.path && yl.getter(this.path, !0),
        this.map = t.map
    }
    getValue(e, t, n) {
        let s = this.isContext ? n : this.isValue ? e : t;
        return this.getter && (s = this.getter(s || {})),
        this.map && (s = this.map(s)),
        s
    }
    cast(e, t) {
        return this.getValue(e, t == null ? void 0 : t.parent, t == null ? void 0 : t.context)
    }
    resolve() {
        return this
    }
    describe() {
        return {
            type: "ref",
            key: this.key
        }
    }
    toString() {
        return `Ref(${this.key})`
    }
    static isRef(e) {
        return e && e.__isYupRef
    }
}
Vl.prototype.__isYupRef = !0;
const dl = i => i == null;
function jl(i) {
    function e({value: t, path: n="", options: s, originalValue: r, schema: o}, a, l) {
        const {name: c, test: u, params: d, message: f, skipAbsent: h} = i;
        let {parent: p, context: g, abortEarly: m=o.spec.abortEarly, disableStackTrace: v=o.spec.disableStackTrace} = s;
        function _(k) {
            return Vl.isRef(k) ? k.getValue(t, p, g) : k
        }
        function y(k={}) {
            const D = Object.assign({
                value: t,
                originalValue: r,
                label: o.spec.label,
                path: k.path || n,
                spec: o.spec,
                disableStackTrace: k.disableStackTrace || v
            }, d, k.params);
            for (const z of Object.keys(D))
                D[z] = _(D[z]);
            const F = new ts(ts.formatError(k.message || f, D),t,D.path,k.type || c,D.disableStackTrace);
            return F.params = D,
            F
        }
        const b = m ? a : l;
        let S = {
            path: n,
            parent: p,
            type: c,
            from: s.from,
            createError: y,
            resolve: _,
            options: s,
            originalValue: r,
            schema: o
        };
        const C = k => {
            ts.isError(k) ? b(k) : k ? l(null) : b(y())
        }
          , M = k => {
            ts.isError(k) ? b(k) : a(k)
        }
        ;
        if (h && dl(t))
            return C(!0);
        let T;
        try {
            var A;
            if (T = u.call(S, t, S),
            typeof ((A = T) == null ? void 0 : A.then) == "function") {
                if (s.sync)
                    throw new Error(`Validation test of type: "${S.type}" returned a Promise during a synchronous validate. This test will finish after the validate call has returned`);
                return Promise.resolve(T).then(C, M)
            }
        } catch (k) {
            M(k);
            return
        }
        C(T)
    }
    return e.OPTIONS = i,
    e
}
function p6(i, e, t, n=t) {
    let s, r, o;
    return e ? (yl.forEach(e, (a, l, c) => {
        let u = l ? a.slice(1, a.length - 1) : a;
        i = i.resolve({
            context: n,
            parent: s,
            value: t
        });
        let d = i.type === "tuple"
          , f = c ? parseInt(u, 10) : 0;
        if (i.innerType || d) {
            if (d && !c)
                throw new Error(`Yup.reach cannot implicitly index into a tuple type. the path part "${o}" must contain an index to the tuple element, e.g. "${o}[0]"`);
            if (t && f >= t.length)
                throw new Error(`Yup.reach cannot resolve an array item at index: ${a}, in the path: ${e}. because there is no value at that index. `);
            s = t,
            t = t && t[f],
            i = d ? i.spec.types[f] : i.innerType
        }
        if (!c) {
            if (!i.fields || !i.fields[u])
                throw new Error(`The schema does not contain the path: ${e}. (failed at: ${o} which is a type: "${i.type}")`);
            s = t,
            t = t && t[u],
            i = i.fields[u]
        }
        r = u,
        o = l ? "[" + a + "]" : "." + a
    }
    ),
    {
        schema: i,
        parent: s,
        parentPath: r
    }) : {
        parent: s,
        parentPath: e,
        schema: i
    }
}
class _p extends Set {
    describe() {
        const e = [];
        for (const t of this.values())
            e.push(Vl.isRef(t) ? t.describe() : t);
        return e
    }
    resolveAll(e) {
        let t = [];
        for (const n of this.values())
            t.push(e(n));
        return t
    }
    clone() {
        return new _p(this.values())
    }
    merge(e, t) {
        const n = this.clone();
        return e.forEach(s => n.add(s)),
        t.forEach(s => n.delete(s)),
        n
    }
}
function wc(i, e=new Map) {
    if (N_(i) || !i || typeof i != "object")
        return i;
    if (e.has(i))
        return e.get(i);
    let t;
    if (i instanceof Date)
        t = new Date(i.getTime()),
        e.set(i, t);
    else if (i instanceof RegExp)
        t = new RegExp(i),
        e.set(i, t);
    else if (Array.isArray(i)) {
        t = new Array(i.length),
        e.set(i, t);
        for (let n = 0; n < i.length; n++)
            t[n] = wc(i[n], e)
    } else if (i instanceof Map) {
        t = new Map,
        e.set(i, t);
        for (const [n,s] of i.entries())
            t.set(n, wc(s, e))
    } else if (i instanceof Set) {
        t = new Set,
        e.set(i, t);
        for (const n of i)
            t.add(wc(n, e))
    } else if (i instanceof Object) {
        t = {},
        e.set(i, t);
        for (const [n,s] of Object.entries(i))
            t[n] = wc(s, e)
    } else
        throw Error(`Unable to clone ${i}`);
    return t
}
class qr {
    constructor(e) {
        this.type = void 0,
        this.deps = [],
        this.tests = void 0,
        this.transforms = void 0,
        this.conditions = [],
        this._mutate = void 0,
        this.internalTests = {},
        this._whitelist = new _p,
        this._blacklist = new _p,
        this.exclusiveTests = Object.create(null),
        this._typeCheck = void 0,
        this.spec = void 0,
        this.tests = [],
        this.transforms = [],
        this.withMutation( () => {
            this.typeError(Mr.notType)
        }
        ),
        this.type = e.type,
        this._typeCheck = e.check,
        this.spec = Object.assign({
            strip: !1,
            strict: !1,
            abortEarly: !0,
            recursive: !0,
            disableStackTrace: !1,
            nullable: !1,
            optional: !0,
            coerce: !0
        }, e == null ? void 0 : e.spec),
        this.withMutation(t => {
            t.nonNullable()
        }
        )
    }
    get _type() {
        return this.type
    }
    clone(e) {
        if (this._mutate)
            return e && Object.assign(this.spec, e),
            this;
        const t = Object.create(Object.getPrototypeOf(this));
        return t.type = this.type,
        t._typeCheck = this._typeCheck,
        t._whitelist = this._whitelist.clone(),
        t._blacklist = this._blacklist.clone(),
        t.internalTests = Object.assign({}, this.internalTests),
        t.exclusiveTests = Object.assign({}, this.exclusiveTests),
        t.deps = [...this.deps],
        t.conditions = [...this.conditions],
        t.tests = [...this.tests],
        t.transforms = [...this.transforms],
        t.spec = wc(Object.assign({}, this.spec, e)),
        t
    }
    label(e) {
        let t = this.clone();
        return t.spec.label = e,
        t
    }
    meta(...e) {
        if (e.length === 0)
            return this.spec.meta;
        let t = this.clone();
        return t.spec.meta = Object.assign(t.spec.meta || {}, e[0]),
        t
    }
    withMutation(e) {
        let t = this._mutate;
        this._mutate = !0;
        let n = e(this);
        return this._mutate = t,
        n
    }
    concat(e) {
        if (!e || e === this)
            return this;
        if (e.type !== this.type && this.type !== "mixed")
            throw new TypeError(`You cannot \`concat()\` schema's of different types: ${this.type} and ${e.type}`);
        let t = this
          , n = e.clone();
        const s = Object.assign({}, t.spec, n.spec);
        return n.spec = s,
        n.internalTests = Object.assign({}, t.internalTests, n.internalTests),
        n._whitelist = t._whitelist.merge(e._whitelist, e._blacklist),
        n._blacklist = t._blacklist.merge(e._blacklist, e._whitelist),
        n.tests = t.tests,
        n.exclusiveTests = t.exclusiveTests,
        n.withMutation(r => {
            e.tests.forEach(o => {
                r.test(o.OPTIONS)
            }
            )
        }
        ),
        n.transforms = [...t.transforms, ...n.transforms],
        n
    }
    isType(e) {
        return e == null ? !!(this.spec.nullable && e === null || this.spec.optional && e === void 0) : this._typeCheck(e)
    }
    resolve(e) {
        let t = this;
        if (t.conditions.length) {
            let n = t.conditions;
            t = t.clone(),
            t.conditions = [],
            t = n.reduce( (s, r) => r.resolve(s, e), t),
            t = t.resolve(e)
        }
        return t
    }
    resolveOptions(e) {
        var t, n, s, r;
        return Object.assign({}, e, {
            from: e.from || [],
            strict: (t = e.strict) != null ? t : this.spec.strict,
            abortEarly: (n = e.abortEarly) != null ? n : this.spec.abortEarly,
            recursive: (s = e.recursive) != null ? s : this.spec.recursive,
            disableStackTrace: (r = e.disableStackTrace) != null ? r : this.spec.disableStackTrace
        })
    }
    cast(e, t={}) {
        let n = this.resolve(Object.assign({
            value: e
        }, t))
          , s = t.assert === "ignore-optionality"
          , r = n._cast(e, t);
        if (t.assert !== !1 && !n.isType(r)) {
            if (s && dl(r))
                return r;
            let o = va(e)
              , a = va(r);
            throw new TypeError(`The value of ${t.path || "field"} could not be cast to a value that satisfies the schema type: "${n.type}".

attempted value: ${o}
` + (a !== o ? `result of cast: ${a}` : ""))
        }
        return r
    }
    _cast(e, t) {
        let n = e === void 0 ? e : this.transforms.reduce( (s, r) => r.call(this, s, e, this), e);
        return n === void 0 && (n = this.getDefault(t)),
        n
    }
    _validate(e, t={}, n, s) {
        let {path: r, originalValue: o=e, strict: a=this.spec.strict} = t
          , l = e;
        a || (l = this._cast(l, Object.assign({
            assert: !1
        }, t)));
        let c = [];
        for (let u of Object.values(this.internalTests))
            u && c.push(u);
        this.runTests({
            path: r,
            value: l,
            originalValue: o,
            options: t,
            tests: c
        }, n, u => {
            if (u.length)
                return s(u, l);
            this.runTests({
                path: r,
                value: l,
                originalValue: o,
                options: t,
                tests: this.tests
            }, n, s)
        }
        )
    }
    runTests(e, t, n) {
        let s = !1
          , {tests: r, value: o, originalValue: a, path: l, options: c} = e
          , u = g => {
            s || (s = !0,
            t(g, o))
        }
          , d = g => {
            s || (s = !0,
            n(g, o))
        }
          , f = r.length
          , h = [];
        if (!f)
            return d([]);
        let p = {
            value: o,
            originalValue: a,
            path: l,
            options: c,
            schema: this
        };
        for (let g = 0; g < r.length; g++) {
            const m = r[g];
            m(p, u, function(_) {
                _ && (Array.isArray(_) ? h.push(..._) : h.push(_)),
                --f <= 0 && d(h)
            })
        }
    }
    asNestedTest({key: e, index: t, parent: n, parentPath: s, originalParent: r, options: o}) {
        const a = e != null ? e : t;
        if (a == null)
            throw TypeError("Must include `key` or `index` for nested validations");
        const l = typeof a == "number";
        let c = n[a];
        const u = Object.assign({}, o, {
            strict: !0,
            parent: n,
            value: c,
            originalValue: r[a],
            key: void 0,
            [l ? "index" : "key"]: a,
            path: l || a.includes(".") ? `${s || ""}[${l ? a : `"${a}"`}]` : (s ? `${s}.` : "") + e
        });
        return (d, f, h) => this.resolve(u)._validate(c, u, f, h)
    }
    validate(e, t) {
        var n;
        let s = this.resolve(Object.assign({}, t, {
            value: e
        }))
          , r = (n = t == null ? void 0 : t.disableStackTrace) != null ? n : s.spec.disableStackTrace;
        return new Promise( (o, a) => s._validate(e, t, (l, c) => {
            ts.isError(l) && (l.value = c),
            a(l)
        }
        , (l, c) => {
            l.length ? a(new ts(l,c,void 0,void 0,r)) : o(c)
        }
        ))
    }
    validateSync(e, t) {
        var n;
        let s = this.resolve(Object.assign({}, t, {
            value: e
        })), r, o = (n = t == null ? void 0 : t.disableStackTrace) != null ? n : s.spec.disableStackTrace;
        return s._validate(e, Object.assign({}, t, {
            sync: !0
        }), (a, l) => {
            throw ts.isError(a) && (a.value = l),
            a
        }
        , (a, l) => {
            if (a.length)
                throw new ts(a,e,void 0,void 0,o);
            r = l
        }
        ),
        r
    }
    isValid(e, t) {
        return this.validate(e, t).then( () => !0, n => {
            if (ts.isError(n))
                return !1;
            throw n
        }
        )
    }
    isValidSync(e, t) {
        try {
            return this.validateSync(e, t),
            !0
        } catch (n) {
            if (ts.isError(n))
                return !1;
            throw n
        }
    }
    _getDefault(e) {
        let t = this.spec.default;
        return t == null ? t : typeof t == "function" ? t.call(this, e) : wc(t)
    }
    getDefault(e) {
        return this.resolve(e || {})._getDefault(e)
    }
    default(e) {
        return arguments.length === 0 ? this._getDefault() : this.clone({
            default: e
        })
    }
    strict(e=!0) {
        return this.clone({
            strict: e
        })
    }
    nullability(e, t) {
        const n = this.clone({
            nullable: e
        });
        return n.internalTests.nullable = jl({
            message: t,
            name: "nullable",
            test(s) {
                return s === null ? this.schema.spec.nullable : !0
            }
        }),
        n
    }
    optionality(e, t) {
        const n = this.clone({
            optional: e
        });
        return n.internalTests.optionality = jl({
            message: t,
            name: "optionality",
            test(s) {
                return s === void 0 ? this.schema.spec.optional : !0
            }
        }),
        n
    }
    optional() {
        return this.optionality(!0)
    }
    defined(e=Mr.defined) {
        return this.optionality(!1, e)
    }
    nullable() {
        return this.nullability(!0)
    }
    nonNullable(e=Mr.notNull) {
        return this.nullability(!1, e)
    }
    required(e=Mr.required) {
        return this.clone().withMutation(t => t.nonNullable(e).defined(e))
    }
    notRequired() {
        return this.clone().withMutation(e => e.nullable().optional())
    }
    transform(e) {
        let t = this.clone();
        return t.transforms.push(e),
        t
    }
    test(...e) {
        let t;
        if (e.length === 1 ? typeof e[0] == "function" ? t = {
            test: e[0]
        } : t = e[0] : e.length === 2 ? t = {
            name: e[0],
            test: e[1]
        } : t = {
            name: e[0],
            message: e[1],
            test: e[2]
        },
        t.message === void 0 && (t.message = Mr.default),
        typeof t.test != "function")
            throw new TypeError("`test` is a required parameters");
        let n = this.clone()
          , s = jl(t)
          , r = t.exclusive || t.name && n.exclusiveTests[t.name] === !0;
        if (t.exclusive && !t.name)
            throw new TypeError("Exclusive tests must provide a unique `name` identifying the test");
        return t.name && (n.exclusiveTests[t.name] = !!t.exclusive),
        n.tests = n.tests.filter(o => !(o.OPTIONS.name === t.name && (r || o.OPTIONS.test === s.OPTIONS.test))),
        n.tests.push(s),
        n
    }
    when(e, t) {
        !Array.isArray(e) && typeof e != "string" && (t = e,
        e = ".");
        let n = this.clone()
          , s = jA(e).map(r => new Vl(r));
        return s.forEach(r => {
            r.isSibling && n.deps.push(r.key)
        }
        ),
        n.conditions.push(typeof t == "function" ? new vp(s,t) : vp.fromOptions(s, t)),
        n
    }
    typeError(e) {
        let t = this.clone();
        return t.internalTests.typeError = jl({
            message: e,
            name: "typeError",
            skipAbsent: !0,
            test(n) {
                return this.schema._typeCheck(n) ? !0 : this.createError({
                    params: {
                        type: this.schema.type
                    }
                })
            }
        }),
        t
    }
    oneOf(e, t=Mr.oneOf) {
        let n = this.clone();
        return e.forEach(s => {
            n._whitelist.add(s),
            n._blacklist.delete(s)
        }
        ),
        n.internalTests.whiteList = jl({
            message: t,
            name: "oneOf",
            skipAbsent: !0,
            test(s) {
                let r = this.schema._whitelist
                  , o = r.resolveAll(this.resolve);
                return o.includes(s) ? !0 : this.createError({
                    params: {
                        values: Array.from(r).join(", "),
                        resolved: o
                    }
                })
            }
        }),
        n
    }
    notOneOf(e, t=Mr.notOneOf) {
        let n = this.clone();
        return e.forEach(s => {
            n._blacklist.add(s),
            n._whitelist.delete(s)
        }
        ),
        n.internalTests.blacklist = jl({
            message: t,
            name: "notOneOf",
            test(s) {
                let r = this.schema._blacklist
                  , o = r.resolveAll(this.resolve);
                return o.includes(s) ? this.createError({
                    params: {
                        values: Array.from(r).join(", "),
                        resolved: o
                    }
                }) : !0
            }
        }),
        n
    }
    strip(e=!0) {
        let t = this.clone();
        return t.spec.strip = e,
        t
    }
    describe(e) {
        const t = (e ? this.resolve(e) : this).clone()
          , {label: n, meta: s, optional: r, nullable: o} = t.spec;
        return {
            meta: s,
            label: n,
            optional: r,
            nullable: o,
            default: t.getDefault(e),
            type: t.type,
            oneOf: t._whitelist.describe(),
            notOneOf: t._blacklist.describe(),
            tests: t.tests.map(l => ({
                name: l.OPTIONS.name,
                params: l.OPTIONS.params
            })).filter( (l, c, u) => u.findIndex(d => d.name === l.name) === c)
        }
    }
}
qr.prototype.__isYupSchema__ = !0;
for (const i of ["validate", "validateSync"])
    qr.prototype[`${i}At`] = function(e, t, n={}) {
        const {parent: s, parentPath: r, schema: o} = p6(this, e, t, n.context);
        return o[i](s && s[r], Object.assign({}, n, {
            parent: s,
            path: e
        }))
    }
    ;
for (const i of ["equals", "is"])
    qr.prototype[i] = qr.prototype.oneOf;
for (const i of ["not", "nope"])
    qr.prototype[i] = qr.prototype.notOneOf;
const m6 = /^(\d{4}|[+-]\d{6})(?:-?(\d{2})(?:-?(\d{2}))?)?(?:[ T]?(\d{2}):?(\d{2})(?::?(\d{2})(?:[,.](\d{1,}))?)?(?:(Z)|([+-])(\d{2})(?::?(\d{2}))?)?)?$/;
function g6(i) {
    const e = M1(i);
    if (!e)
        return Date.parse ? Date.parse(i) : Number.NaN;
    if (e.z === void 0 && e.plusMinus === void 0)
        return new Date(e.year,e.month,e.day,e.hour,e.minute,e.second,e.millisecond).valueOf();
    let t = 0;
    return e.z !== "Z" && e.plusMinus !== void 0 && (t = e.hourOffset * 60 + e.minuteOffset,
    e.plusMinus === "+" && (t = 0 - t)),
    Date.UTC(e.year, e.month, e.day, e.hour, e.minute + t, e.second, e.millisecond)
}
function M1(i) {
    var e, t;
    const n = m6.exec(i);
    return n ? {
        year: io(n[1]),
        month: io(n[2], 1) - 1,
        day: io(n[3], 1),
        hour: io(n[4]),
        minute: io(n[5]),
        second: io(n[6]),
        millisecond: n[7] ? io(n[7].substring(0, 3)) : 0,
        precision: (e = (t = n[7]) == null ? void 0 : t.length) != null ? e : void 0,
        z: n[8] || void 0,
        plusMinus: n[9] || void 0,
        hourOffset: io(n[10]),
        minuteOffset: io(n[11])
    } : null
}
function io(i, e=0) {
    return Number(i) || e
}
let v6 = /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/
  , _6 = /^((https?|ftp):)?\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i
  , x6 = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i
  , y6 = "^\\d{4}-\\d{2}-\\d{2}"
  , b6 = "\\d{2}:\\d{2}:\\d{2}"
  , S6 = "(([+-]\\d{2}(:?\\d{2})?)|Z)"
  , E6 = new RegExp(`${y6}T${b6}(\\.\\d+)?${S6}$`)
  , w6 = i => dl(i) || i === i.trim()
  , T6 = {}.toString();
function Us() {
    return new ZA
}
class ZA extends qr {
    constructor() {
        super({
            type: "string",
            check(e) {
                return e instanceof String && (e = e.valueOf()),
                typeof e == "string"
            }
        }),
        this.withMutation( () => {
            this.transform( (e, t, n) => {
                if (!n.spec.coerce || n.isType(e) || Array.isArray(e))
                    return e;
                const s = e != null && e.toString ? e.toString() : e;
                return s === T6 ? e : s
            }
            )
        }
        )
    }
    required(e) {
        return super.required(e).withMutation(t => t.test({
            message: e || Mr.required,
            name: "required",
            skipAbsent: !0,
            test: n => !!n.length
        }))
    }
    notRequired() {
        return super.notRequired().withMutation(e => (e.tests = e.tests.filter(t => t.OPTIONS.name !== "required"),
        e))
    }
    length(e, t=Ji.length) {
        return this.test({
            message: t,
            name: "length",
            exclusive: !0,
            params: {
                length: e
            },
            skipAbsent: !0,
            test(n) {
                return n.length === this.resolve(e)
            }
        })
    }
    min(e, t=Ji.min) {
        return this.test({
            message: t,
            name: "min",
            exclusive: !0,
            params: {
                min: e
            },
            skipAbsent: !0,
            test(n) {
                return n.length >= this.resolve(e)
            }
        })
    }
    max(e, t=Ji.max) {
        return this.test({
            name: "max",
            exclusive: !0,
            message: t,
            params: {
                max: e
            },
            skipAbsent: !0,
            test(n) {
                return n.length <= this.resolve(e)
            }
        })
    }
    matches(e, t) {
        let n = !1, s, r;
        return t && (typeof t == "object" ? {excludeEmptyString: n=!1, message: s, name: r} = t : s = t),
        this.test({
            name: r || "matches",
            message: s || Ji.matches,
            params: {
                regex: e
            },
            skipAbsent: !0,
            test: o => o === "" && n || o.search(e) !== -1
        })
    }
    email(e=Ji.email) {
        return this.matches(v6, {
            name: "email",
            message: e,
            excludeEmptyString: !0
        })
    }
    url(e=Ji.url) {
        return this.matches(_6, {
            name: "url",
            message: e,
            excludeEmptyString: !0
        })
    }
    uuid(e=Ji.uuid) {
        return this.matches(x6, {
            name: "uuid",
            message: e,
            excludeEmptyString: !1
        })
    }
    datetime(e) {
        let t = "", n, s;
        return e && (typeof e == "object" ? {message: t="", allowOffset: n=!1, precision: s=void 0} = e : t = e),
        this.matches(E6, {
            name: "datetime",
            message: t || Ji.datetime,
            excludeEmptyString: !0
        }).test({
            name: "datetime_offset",
            message: t || Ji.datetime_offset,
            params: {
                allowOffset: n
            },
            skipAbsent: !0,
            test: r => {
                if (!r || n)
                    return !0;
                const o = M1(r);
                return o ? !!o.z : !1
            }
        }).test({
            name: "datetime_precision",
            message: t || Ji.datetime_precision,
            params: {
                precision: s
            },
            skipAbsent: !0,
            test: r => {
                if (!r || s == null)
                    return !0;
                const o = M1(r);
                return o ? o.precision === s : !1
            }
        })
    }
    ensure() {
        return this.default("").transform(e => e === null ? "" : e)
    }
    trim(e=Ji.trim) {
        return this.transform(t => t != null ? t.trim() : t).test({
            message: e,
            name: "trim",
            test: w6
        })
    }
    lowercase(e=Ji.lowercase) {
        return this.transform(t => dl(t) ? t : t.toLowerCase()).test({
            message: e,
            name: "string_case",
            exclusive: !0,
            skipAbsent: !0,
            test: t => dl(t) || t === t.toLowerCase()
        })
    }
    uppercase(e=Ji.uppercase) {
        return this.transform(t => dl(t) ? t : t.toUpperCase()).test({
            message: e,
            name: "string_case",
            exclusive: !0,
            skipAbsent: !0,
            test: t => dl(t) || t === t.toUpperCase()
        })
    }
}
Us.prototype = ZA.prototype;
let A6 = new Date("")
  , C6 = i => Object.prototype.toString.call(i) === "[object Date]";
class gm extends qr {
    constructor() {
        super({
            type: "date",
            check(e) {
                return C6(e) && !isNaN(e.getTime())
            }
        }),
        this.withMutation( () => {
            this.transform( (e, t, n) => !n.spec.coerce || n.isType(e) || e === null ? e : (e = g6(e),
            isNaN(e) ? gm.INVALID_DATE : new Date(e)))
        }
        )
    }
    prepareParam(e, t) {
        let n;
        if (Vl.isRef(e))
            n = e;
        else {
            let s = this.cast(e);
            if (!this._typeCheck(s))
                throw new TypeError(`\`${t}\` must be a Date or a value that can be \`cast()\` to a Date`);
            n = s
        }
        return n
    }
    min(e, t=A1.min) {
        let n = this.prepareParam(e, "min");
        return this.test({
            message: t,
            name: "min",
            exclusive: !0,
            params: {
                min: e
            },
            skipAbsent: !0,
            test(s) {
                return s >= this.resolve(n)
            }
        })
    }
    max(e, t=A1.max) {
        let n = this.prepareParam(e, "max");
        return this.test({
            message: t,
            name: "max",
            exclusive: !0,
            params: {
                max: e
            },
            skipAbsent: !0,
            test(s) {
                return s <= this.resolve(n)
            }
        })
    }
}
gm.INVALID_DATE = A6;
gm.prototype;
function M6(i, e=[]) {
    let t = []
      , n = new Set
      , s = new Set(e.map( ([o,a]) => `${o}-${a}`));
    function r(o, a) {
        let l = yl.split(o)[0];
        n.add(l),
        s.has(`${a}-${l}`) || t.push([a, l])
    }
    for (const o of Object.keys(i)) {
        let a = i[o];
        n.add(o),
        Vl.isRef(a) && a.isSibling ? r(a.path, o) : N_(a) && "deps"in a && a.deps.forEach(l => r(l, o))
    }
    return U_.exports.array(Array.from(n), t).reverse()
}
function Q2(i, e) {
    let t = 1 / 0;
    return i.some( (n, s) => {
        var r;
        if ((r = e.path) != null && r.includes(n))
            return t = s,
            !0
    }
    ),
    t
}
function JA(i) {
    return (e, t) => Q2(i, e) - Q2(i, t)
}
const R6 = (i, e, t) => {
    if (typeof i != "string")
        return i;
    let n = i;
    try {
        n = JSON.parse(i)
    } catch {}
    return t.isType(n) ? n : i
}
;
function Eh(i) {
    if ("fields"in i) {
        const e = {};
        for (const [t,n] of Object.entries(i.fields))
            e[t] = Eh(n);
        return i.setFields(e)
    }
    if (i.type === "array") {
        const e = i.optional();
        return e.innerType && (e.innerType = Eh(e.innerType)),
        e
    }
    return i.type === "tuple" ? i.optional().clone({
        types: i.spec.types.map(Eh)
    }) : "optional"in i ? i.optional() : i
}
const L6 = (i, e) => {
    const t = [...yl.normalizePath(e)];
    if (t.length === 1)
        return t[0]in i;
    let n = t.pop()
      , s = yl.getter(yl.join(t), !0)(i);
    return !!(s && n in s)
}
;
let eb = i => Object.prototype.toString.call(i) === "[object Object]";
function I6(i, e) {
    let t = Object.keys(i.fields);
    return Object.keys(e).filter(n => t.indexOf(n) === -1)
}
const k6 = JA([]);
function ef(i) {
    return new QA(i)
}
class QA extends qr {
    constructor(e) {
        super({
            type: "object",
            check(t) {
                return eb(t) || typeof t == "function"
            }
        }),
        this.fields = Object.create(null),
        this._sortErrors = k6,
        this._nodes = [],
        this._excludedEdges = [],
        this.withMutation( () => {
            e && this.shape(e)
        }
        )
    }
    _cast(e, t={}) {
        var n;
        let s = super._cast(e, t);
        if (s === void 0)
            return this.getDefault(t);
        if (!this._typeCheck(s))
            return s;
        let r = this.fields
          , o = (n = t.stripUnknown) != null ? n : this.spec.noUnknown
          , a = [].concat(this._nodes, Object.keys(s).filter(d => !this._nodes.includes(d)))
          , l = {}
          , c = Object.assign({}, t, {
            parent: l,
            __validating: t.__validating || !1
        })
          , u = !1;
        for (const d of a) {
            let f = r[d]
              , h = d in s;
            if (f) {
                let p, g = s[d];
                c.path = (t.path ? `${t.path}.` : "") + d,
                f = f.resolve({
                    value: g,
                    context: t.context,
                    parent: l
                });
                let m = f instanceof qr ? f.spec : void 0
                  , v = m == null ? void 0 : m.strict;
                if (m != null && m.strip) {
                    u = u || d in s;
                    continue
                }
                p = !t.__validating || !v ? f.cast(s[d], c) : s[d],
                p !== void 0 && (l[d] = p)
            } else
                h && !o && (l[d] = s[d]);
            (h !== d in l || l[d] !== s[d]) && (u = !0)
        }
        return u ? l : s
    }
    _validate(e, t={}, n, s) {
        let {from: r=[], originalValue: o=e, recursive: a=this.spec.recursive} = t;
        t.from = [{
            schema: this,
            value: o
        }, ...r],
        t.__validating = !0,
        t.originalValue = o,
        super._validate(e, t, n, (l, c) => {
            if (!a || !eb(c)) {
                s(l, c);
                return
            }
            o = o || c;
            let u = [];
            for (let d of this._nodes) {
                let f = this.fields[d];
                !f || Vl.isRef(f) || u.push(f.asNestedTest({
                    options: t,
                    key: d,
                    parent: c,
                    parentPath: t.path,
                    originalParent: o
                }))
            }
            this.runTests({
                tests: u,
                value: c,
                originalValue: o,
                options: t
            }, n, d => {
                s(d.sort(this._sortErrors).concat(l), c)
            }
            )
        }
        )
    }
    clone(e) {
        const t = super.clone(e);
        return t.fields = Object.assign({}, this.fields),
        t._nodes = this._nodes,
        t._excludedEdges = this._excludedEdges,
        t._sortErrors = this._sortErrors,
        t
    }
    concat(e) {
        let t = super.concat(e)
          , n = t.fields;
        for (let[s,r] of Object.entries(this.fields)) {
            const o = n[s];
            n[s] = o === void 0 ? r : o
        }
        return t.withMutation(s => s.setFields(n, [...this._excludedEdges, ...e._excludedEdges]))
    }
    _getDefault(e) {
        if ("default"in this.spec)
            return super._getDefault(e);
        if (!this._nodes.length)
            return;
        let t = {};
        return this._nodes.forEach(n => {
            var s;
            const r = this.fields[n];
            let o = e;
            (s = o) != null && s.value && (o = Object.assign({}, o, {
                parent: o.value,
                value: o.value[n]
            })),
            t[n] = r && "getDefault"in r ? r.getDefault(o) : void 0
        }
        ),
        t
    }
    setFields(e, t) {
        let n = this.clone();
        return n.fields = e,
        n._nodes = M6(e, t),
        n._sortErrors = JA(Object.keys(e)),
        t && (n._excludedEdges = t),
        n
    }
    shape(e, t=[]) {
        return this.clone().withMutation(n => {
            let s = n._excludedEdges;
            return t.length && (Array.isArray(t[0]) || (t = [t]),
            s = [...n._excludedEdges, ...t]),
            n.setFields(Object.assign(n.fields, e), s)
        }
        )
    }
    partial() {
        const e = {};
        for (const [t,n] of Object.entries(this.fields))
            e[t] = "optional"in n && n.optional instanceof Function ? n.optional() : n;
        return this.setFields(e)
    }
    deepPartial() {
        return Eh(this)
    }
    pick(e) {
        const t = {};
        for (const n of e)
            this.fields[n] && (t[n] = this.fields[n]);
        return this.setFields(t, this._excludedEdges.filter( ([n,s]) => e.includes(n) && e.includes(s)))
    }
    omit(e) {
        const t = [];
        for (const n of Object.keys(this.fields))
            e.includes(n) || t.push(n);
        return this.pick(t)
    }
    from(e, t, n) {
        let s = yl.getter(e, !0);
        return this.transform(r => {
            if (!r)
                return r;
            let o = r;
            return L6(r, e) && (o = Object.assign({}, r),
            n || delete o[e],
            o[t] = s(r)),
            o
        }
        )
    }
    json() {
        return this.transform(R6)
    }
    noUnknown(e=!0, t=C1.noUnknown) {
        typeof e != "boolean" && (t = e,
        e = !0);
        let n = this.test({
            name: "noUnknown",
            exclusive: !0,
            message: t,
            test(s) {
                if (s == null)
                    return !0;
                const r = I6(this.schema, s);
                return !e || r.length === 0 || this.createError({
                    params: {
                        unknown: r.join(", ")
                    }
                })
            }
        });
        return n.spec.noUnknown = e,
        n
    }
    unknown(e=!0, t=C1.noUnknown) {
        return this.noUnknown(!e, t)
    }
    transformKeys(e) {
        return this.transform(t => {
            if (!t)
                return t;
            const n = {};
            for (const s of Object.keys(t))
                n[e(s)] = t[s];
            return n
        }
        )
    }
    camelCase() {
        return this.transformKeys(p0.camelCase)
    }
    snakeCase() {
        return this.transformKeys(p0.snakeCase)
    }
    constantCase() {
        return this.transformKeys(e => p0.snakeCase(e).toUpperCase())
    }
    describe(e) {
        const t = (e ? this.resolve(e) : this).clone()
          , n = super.describe(e);
        n.fields = {};
        for (const [r,o] of Object.entries(t.fields)) {
            var s;
            let a = e;
            (s = a) != null && s.value && (a = Object.assign({}, a, {
                parent: a.value,
                value: a.value[r]
            })),
            n.fields[r] = o.describe(a)
        }
        return n
    }
}
ef.prototype = QA.prototype;
const P6 = {
    key: 0,
    class: "text-red-500 text-sm -mt-1.5"
}
  , D6 = {
    key: 1,
    class: "text-xs text-right text-zinc-400 mb-3 mt-0.5"
}
  , F6 = {
    key: 2,
    class: "text-red-500 text-sm -mt-1.5"
}
  , O6 = {
    key: 0,
    class: "flex gap-3 mt-3 mb-3"
}
  , U6 = {
    key: 0
}
  , N6 = {
    key: 1
}
  , B6 = {
    key: 1,
    class: "text-sm text-red-500 -mt-1.5"
}
  , V6 = {
    key: 2,
    class: "text-sm text-zinc-400 -mt-1.5"
}
  , $6 = {
    key: 4,
    class: "text-red-500 text-sm -mt-1.5"
}
  , H6 = {
    key: 5,
    class: "text-sm text-center text-red-500"
}
  , tb = 60
  , z6 = ut({
    __name: "AuthRegister",
    setup(i) {
        const e = xe()
          , t = ei({
            email: "",
            username: "",
            password: "",
            code: "",
            loading: !1
        })
          , n = xe({})
          , s = ef().shape({
            email: Us().email().required().test("has-tld", "Please enter a valid email address", m => {
                const [v,_] = m.split("@");
                return _ !== void 0 && _.includes(".")
            }
            ),
            username: Us().required().min(3, "Username must be at least 3 characters long").max(20, "Username can be at most 20 characters long").matches(/^[a-zA-Z0-9]+$/, "Only alphanumeric characters are allowed."),
            password: Us().required().min(6).max(60),
            code: Us().required().min(6).max(6)
        })
          , r = async m => {
            try {
                await s.validateAt(m, t),
                delete n.value[m]
            } catch (v) {
                n.value[m] = v.errors[0]
            }
        }
          , o = async () => {
            try {
                await s.validate(t, {
                    abortEarly: !1
                }),
                n.value = {}
            } catch (m) {
                n.value = m.inner.reduce( (v, _) => (v[_.path] = _.message,
                v), {})
            }
        }
          , a = xe(!1)
          , l = xe(null)
          , c = xe(tb)
          , u = async m => {
            if (a.value = !0,
            l.value) {
                a.value = !1;
                return
            }
            try {
                await r("email")
            } catch (v) {
                a.value = !1,
                n.value.code = v;
                return
            }
            try {
                await ct.user.sendVerificationMail(t.email, m)
            } catch (v) {
                n.value.code = v,
                e.value.reset();
                return
            } finally {
                a.value = !1
            }
            l.value = setInterval( () => {
                c.value--,
                c.value <= 0 && (clearInterval(l.value),
                l.value = null,
                c.value = tb)
            }
            , 1e3)
        }
          , d = ti()
          , f = Ki()
          , h = it()
          , p = Xi()
          , g = async () => {
            t.loading = !0;
            try {
                await o()
            } catch {
                t.loading = !1;
                return
            }
            try {
                const m = await ct.user.register(t.username, t.email, t.password, t.code);
                h.setUser(m),
                p.authDialog = !1;
                const v = f.query.redirect || "/";
                d.push(v)
            } catch (m) {
                n.value.general = m
            } finally {
                t.loading = !1
            }
        }
        ;
        return (m, v) => (w(),
        R("form", {
            onSubmit: g
        }, [O(vn, {
            onBlur: v[0] || (v[0] = _ => r("username")),
            onInput: v[1] || (v[1] = _ => n.value.username && r("username")),
            modelValue: t.username,
            "onUpdate:modelValue": v[2] || (v[2] = _ => t.username = _),
            type: "text",
            placeholder: "Username",
            class: "mt-3"
        }, null, 8, ["modelValue"]), n.value.username ? (w(),
        R("span", P6, ee(n.value.username), 1)) : (w(),
        R("p", D6, "This will be your publicly visible username")), O(vn, {
            onBlur: v[3] || (v[3] = _ => r("email")),
            onInput: v[4] || (v[4] = _ => n.value.email && r("email")),
            modelValue: t.email,
            "onUpdate:modelValue": v[5] || (v[5] = _ => t.email = _),
            type: "email",
            placeholder: "E-Mail"
        }, null, 8, ["modelValue"]), n.value.email ? (w(),
        R("span", F6, ee(n.value.email), 1)) : le("", !0), v[14] || (v[14] = x("p", {
            class: "text-xs text-right text-zinc-400 mt-0.5"
        }, [x("span", {
            class: "mr-0"
        }, "*"), J(" We may send the occasional email ")], -1)), t.email.length ? (w(),
        R(Ge, {
            key: 3
        }, [t.email.length ? (w(),
        R("div", O6, [O(vn, {
            onBlur: v[6] || (v[6] = _ => r("code")),
            onInput: v[7] || (v[7] = _ => n.value.code && r("code")),
            modelValue: t.code,
            "onUpdate:modelValue": v[8] || (v[8] = _ => t.code = _),
            type: "text",
            class: "flex-1",
            placeholder: "Enter 6-digit code"
        }, null, 8, ["modelValue"]), O(je, {
            type: "button",
            onClick: v[9] || (v[9] = _ => e.value.execute()),
            class: "shrink-0",
            disabled: l.value != null || n.value.email !== void 0,
            loading: a.value,
            theme: "blue"
        }, {
            default: Y( () => [l.value ? (w(),
            R("span", N6, "Resend (" + ee(c.value) + "s)", 1)) : (w(),
            R("span", U6, "Send Code"))]),
            _: 1
        }, 8, ["disabled", "loading"]), O(E(B8), {
            ref_key: "captcha",
            ref: e,
            onVerify: u,
            class: "absolute",
            size: "invisible",
            sitekey: E(L8),
            theme: "dark"
        }, null, 8, ["sitekey"])])) : le("", !0), n.value.code ? (w(),
        R("p", B6, ee(n.value.code), 1)) : (w(),
        R("p", V6, "A verification code will be sent to your email address"))], 64)) : le("", !0), O(vn, {
            onBlur: v[10] || (v[10] = _ => r("password")),
            onInput: v[11] || (v[11] = _ => n.value.password && r("password")),
            modelValue: t.password,
            "onUpdate:modelValue": v[12] || (v[12] = _ => t.password = _),
            class: "mt-3",
            type: "password",
            placeholder: "Password"
        }, null, 8, ["modelValue"]), n.value.password ? (w(),
        R("span", $6, ee(n.value.password), 1)) : le("", !0), O(je, {
            onClick: g,
            loading: t.loading,
            theme: "blue",
            class: "mt-3 w-full"
        }, {
            default: Y( () => v[13] || (v[13] = [J("Sign Up")])),
            _: 1
        }, 8, ["loading"]), n.value.general ? (w(),
        R("span", H6, ee(n.value.general), 1)) : le("", !0)], 32))
    }
})
  , G6 = {
    key: 0,
    class: "text-red-500 text-sm -mt-1.5"
}
  , W6 = {
    key: 1,
    class: "text-sm text-zinc-400 -mt-1.5"
}
  , q6 = {
    key: 2,
    class: "text-center text-red-500"
}
  , j6 = ut({
    __name: "AuthForgotPassword",
    setup(i) {
        const e = ei({
            email: "",
            loading: !1,
            success: !1
        })
          , t = ti()
          , n = it()
          , s = Xi()
          , r = xe({})
          , o = ef().shape({
            email: Us().email().required().test("has-tld", "Please enter a valid email address", u => {
                const [d,f] = u.split("@");
                return f !== void 0 && f.includes(".")
            }
            )
        })
          , a = async u => {
            try {
                await o.validateAt(u, e),
                delete r.value[u]
            } catch (d) {
                r.value[u] = d.errors[0]
            }
        }
          , l = async () => {
            t.push("/"),
            n.setUser(null),
            s.authDialog = !1,
            window.location.reload()
        }
          , c = async () => {
            e.error = void 0,
            e.loading = !0;
            try {
                await ct.user.sendForgotPasswordToken(e.email),
                e.error = void 0,
                e.success = !0,
                setTimeout( () => {
                    l()
                }
                , 2e3)
            } catch (u) {
                e.error = u
            } finally {
                e.loading = !1
            }
        }
        ;
        return (u, d) => (w(),
        R("form", {
            onSubmit: Vn(c, ["prevent"]),
            class: "flex flex-col gap-y-3"
        }, [O(vn, {
            class: "w-full",
            required: "",
            disabled: e.loading,
            modelValue: e.email,
            "onUpdate:modelValue": d[0] || (d[0] = f => e.email = f),
            type: "email",
            placeholder: "E-Mail",
            onBlur: d[1] || (d[1] = f => a("email")),
            onInput: d[2] || (d[2] = f => r.value.email && a("email"))
        }, null, 8, ["disabled", "modelValue"]), r.value.email ? (w(),
        R("span", G6, ee(r.value.email), 1)) : le("", !0), e.success ? (w(),
        R("p", W6, "A link will be sent to your email address")) : le("", !0), O(je, {
            loading: e.loading,
            theme: "blue",
            class: "mt-2 w-full"
        }, {
            default: Y( () => d[3] || (d[3] = [J("Reset Password")])),
            _: 1
        }, 8, ["loading"]), e.error ? (w(),
        R("span", q6, ee(e.error), 1)) : le("", !0)], 32))
    }
})
  , K6 = {
    class: "p-4"
}
  , X6 = {
    class: "flex gap-3 items-center"
}
  , Y6 = {
    class: "bg-zinc-800 rounded-md p-3"
}
  , Z6 = {
    class: "bg-zinc-800 rounded-md p-3"
}
  , J6 = {
    class: "bg-zinc-800 rounded-md p-3"
}
  , Q6 = {
    class: "mt-6 text-center"
}
  , nb = ut({
    __name: "Auth",
    setup(i) {
        const e = xe("login");
        return (t, n) => {
            const s = li("router-link");
            return w(),
            R("div", K6, [x("div", X6, [e.value === "login" ? (w(),
            R(Ge, {
                key: 0
            }, [x("div", Y6, [O(ze, {
                name: "account-key-outline",
                class: "h-7 w-7"
            })]), n[3] || (n[3] = x("div", null, [x("p", {
                class: "text-2xl font-medium"
            }, "Welcome Back,"), x("p", {
                class: "text-zinc-400 text-sm"
            }, "Sign in to use your account")], -1))], 64)) : e.value === "forgotpwd" ? (w(),
            R(Ge, {
                key: 1
            }, [x("div", Z6, [O(ze, {
                name: "lock-reset",
                class: "h-8 w-8"
            })]), n[4] || (n[4] = x("div", null, [x("p", {
                class: "text-2xl font-medium"
            }, "Forgot password?"), x("p", {
                class: "text-zinc-400 text-sm"
            }, "No worries, we'll send you reset instructions.")], -1))], 64)) : (w(),
            R(Ge, {
                key: 2
            }, [x("div", J6, [O(ze, {
                name: "account-plus",
                class: "h-7 w-7"
            })]), n[5] || (n[5] = x("div", null, [x("p", {
                class: "text-2xl font-medium"
            }, "Sign Up"), x("p", {
                class: "text-zinc-400 text-sm"
            }, "Create an account to continue")], -1))], 64))]), n[9] || (n[9] = x("hr", {
                class: "-mx-4 my-4 border-zinc-800"
            }, null, -1)), x("div", null, [e.value === "login" ? (w(),
            Re(k8, {
                key: 0
            })) : e.value === "forgotpwd" ? (w(),
            Re(j6, {
                key: 1
            })) : (w(),
            Re(z6, {
                key: 2
            }))]), n[10] || (n[10] = x("hr", {
                class: "-mx-4 my-4 border-zinc-800"
            }, null, -1)), x("div", Q6, [e.value === "login" ? (w(),
            Re(s, {
                key: 0,
                to: "#",
                class: "block w-full",
                onClick: n[0] || (n[0] = r => e.value = "register")
            }, {
                default: Y( () => n[6] || (n[6] = [J("Sign Up")])),
                _: 1
            })) : (w(),
            Re(s, {
                key: 1,
                to: "#",
                class: "block w-full",
                onClick: n[1] || (n[1] = r => e.value = "login")
            }, {
                default: Y( () => n[7] || (n[7] = [J("Log In")])),
                _: 1
            })), e.value === "login" ? (w(),
            Re(s, {
                key: 2,
                to: "#",
                class: "block w-full mt-6",
                onClick: n[2] || (n[2] = r => e.value = "forgotpwd")
            }, {
                default: Y( () => n[8] || (n[8] = [J("Forgot Password?")])),
                _: 1
            })) : le("", !0)])])
        }
    }
})
  , eF = {
    key: 0,
    class: "fixed inset-0 flex items-center justify-center h-full z-50 px-3"
}
  , tF = {
    class: "grid grid-cols-6 items-center"
}
  , nF = {
    class: "col-span-4 text-center"
}
  , iF = {
    class: "text-xl font-medium"
}
  , sF = {
    class: "col-span-1 flex justify-end z-50"
}
  , mr = ut({
    __name: "Dialog",
    props: {
        modelValue: {
            type: Boolean
        },
        title: {},
        wide: {
            type: Boolean
        }
    },
    emits: ["update:modelValue"],
    setup(i, {emit: e}) {
        const t = i
          , n = e;
        return Bt( () => t.modelValue, s => {
            const r = "overflow-hidden"
              , o = document.querySelector("html");
            s ? o.classList.add(r) : o.classList.remove(r)
        }
        ),
        (s, r) => (w(),
        Re(u_, {
            to: "body"
        }, [t.modelValue ? (w(),
        R("div", eF, [x("div", {
            class: "fixed inset-0 bg-black/80 overflow-hidden h-full w-full",
            onClick: r[0] || (r[0] = o => n("update:modelValue", !1))
        }), x("div", {
            class: Pt([t.wide ? ["md:max-w-sm", "lg:max-w-[820px]"] : ["md:max-w-sm", "lg:max-w-md"], "dialog origin-center relative bg-zinc-900 p-4 rounded-md shadow-md overflow-y-auto max-h-[90vh] flex-1 text-white"])
        }, [x("div", tF, [r[2] || (r[2] = x("div", {
            class: "col-span-1"
        }, null, -1)), x("div", nF, [x("h3", iF, ee(t.title), 1)]), x("div", sF, [O(je, {
            theme: "transparent",
            onClick: r[1] || (r[1] = o => n("update:modelValue", !1))
        }, {
            default: Y( () => [O(ze, {
                name: "close",
                class: "h-6 w-6 text-zinc-400"
            })]),
            _: 1
        })])]), Nl(s.$slots, "default")], 2)])) : le("", !0)]))
    }
})
  , eC = "/logo.white.svg";
class rF {
    constructor() {
        tt(this, "toyName", "Handy");
        tt(this, "storageKey", "handy");
        tt(this, "baseUrl", "https://www.handyfeeling.com/api/handy/v2");
        tt(this, "_connected", !1);
        tt(this, "_estimatedServerTimeOffset", 0);
        tt(this, "_error");
        tt(this, "_setupError");
        tt(this, "_scanning", !1);
        tt(this, "_prepared", !1);
        tt(this, "_syncInterval", -1);
        tt(this, "handler", {
            get: (e, t) => typeof e[t] == "object" && e[t] !== null ? new Proxy(e[t],this.handler) : e[t],
            set: (e, t, n) => (e[t] = n,
            localStorage.setItem(this.storageKey, JSON.stringify(e)),
            this._connected && (t === "limits" ? this.json("/slide", "PUT", {
                min: n[0],
                max: n[1]
            }).then(s => console.log(s)).catch(s => console.log(s)) : t === "offset" && this.json("/hstp/offset", "PUT", {
                offset: n
            }).then(s => console.log(s)).catch(s => console.log(s))),
            !0)
        });
        tt(this, "settings", new Proxy({
            invert: !1,
            offset: 0,
            limits: [0, 100],
            key: ""
        },this.handler));
        const e = localStorage.getItem(this.storageKey);
        if (e) {
            const t = JSON.parse(e);
            this.settings.key = t.key || "",
            this.settings.invert = t.invert || !1,
            this.settings.offset = t.offset || 0,
            this.settings.limits = t.limits || [0, 100]
        }
        if (this.settings.key === "") {
            const t = localStorage.getItem("connectionKey");
            t && (this.settings.key = t)
        }
    }
    get connected() {
        return this._connected
    }
    get scanning() {
        return this._scanning
    }
    get error() {
        return this._error
    }
    async connect() {
        if (this.settings.key.length < 5 || this._scanning)
            return;
        this._scanning = !0,
        this._error = void 0;
        let e;
        try {
            e = await this.json("/connected")
        } catch (t) {
            this._error = t,
            this._connected = !1,
            this._scanning = !1;
            return
        }
        if ("connected"in e && !e.connected) {
            this._error = "Device not connected",
            this._connected = !1,
            this._scanning = !1;
            return
        }
        try {
            e = await this.json("/info")
        } catch (t) {
            this._error = t,
            this._connected = !1,
            this._scanning = !1;
            return
        }
        if ("error"in e) {
            this._error = e.error.message,
            this._scanning = !1;
            return
        }
        if (e.fwStatus === 1) {
            this._error = "Firmware update required",
            this._scanning = !1;
            return
        }
        try {
            e = await this.json("/settings")
        } catch {
            this._error = "Couldn't get Handy settings",
            this._scanning = !1;
            return
        }
        if ("error"in e) {
            this._error = `${e.error.name} (${e.error.code})`,
            this._connected = e.error.connected,
            this._scanning = !1;
            return
        }
        this.settings.limits[0] = e.slideMin || 0,
        this.settings.limits[1] = e.slideMax || 100;
        try {
            e = await this.json("/hstp/offset")
        } catch {
            this._error = "Couldn't get Handy offset",
            this._scanning = !1;
            return
        }
        this.settings.offset = e.offset || 0;
        try {
            e = await this.json("/mode", "PUT", {
                mode: 1
            })
        } catch (t) {
            this._error = t,
            this._scanning = !1;
            return
        }
        if ("error"in e) {
            this._error = `${e.error.name} (${e.error.code})`,
            this._connected = e.error.connected,
            this._scanning = !1;
            return
        }
        try {
            await this.offset(10)
        } catch (t) {
            this._scanning = !1,
            this._error = t;
            return
        }
        this._syncInterval = setInterval(async () => {
            await this.offset(10)
        }
        , 6e4),
        this._connected = !0,
        this._scanning = !1
    }
    disconnect() {
        this._scanning = !1,
        this._error = void 0,
        this._prepared = !1,
        this._connected = !1,
        this._setupError = void 0,
        clearInterval(this._syncInterval)
    }
    prepare(e) {
        return this._prepared = !1,
        new Promise( (t, n) => {
            if (!this._connected)
                return t();
            this._setupError = void 0,
            this.settings.invert && (e += "?reverse"),
            this.json("/hssp/setup", "PUT", {
                url: e
            }).then(s => {
                if ("error"in s)
                    return this._connected = s.error.connected,
                    this._setupError = s.error.name,
                    n(`${s.error.name} (${s.error.code})`);
                this._prepared = !0,
                this._connected = !0,
                t()
            }
            ).catch(s => n(s))
        }
        )
    }
    play(e) {
        return console.log("play hitted"),
        new Promise(async (t, n) => {
            if (!this._connected || this._setupError)
                return t();
            this.json("/hssp/play", "PUT", {
                startTime: e,
                estimatedServerTime: Math.trunc(new Date().getTime() + this._estimatedServerTimeOffset)
            }).then(s => {
                if ("error"in s)
                    return this._connected = s.error.connected,
                    n(`${s.error.name} (${s.error.code})`);
                this._connected = !0,
                t()
            }
            ).catch(s => n(s))
        }
        )
    }
    stop() {
        return console.log("stop hitted"),
        new Promise( (e, t) => {
            if (!this._connected || !this._prepared)
                return e();
            this.json("/hssp/stop", "PUT").then(n => {
                if ("error"in n)
                    return this._connected = n.error.connected,
                    t(`${n.error.name} (${n.error.code})`);
                this._connected = !0,
                e(n)
            }
            ).catch(n => t(n))
        }
        )
    }
    serverTime() {
        return new Promise( (e, t) => {
            this.json("/servertime").then(n => e(n.serverTime)).catch(n => t(n))
        }
        )
    }
    async offset(e=30) {
        await this.serverTime();
        let t = [];
        for (let o = 0; o < e; o++) {
            const a = new Date().valueOf()
              , l = await this.serverTime()
              , c = new Date().valueOf()
              , u = c - a
              , f = l + u / 2 - c;
            t.push(f)
        }
        const n = t.reduce( (o, a) => o + a, 0) / t.length
          , s = t.map(o => Math.pow(o - n, 2))
          , r = Math.sqrt(s.reduce( (o, a) => o + a, 0) / s.length);
        return t = t.filter(o => Math.abs(o - n) < r),
        this._estimatedServerTimeOffset = t.reduce( (o, a) => o + a) / t.length,
        this._estimatedServerTimeOffset
    }
    json(e, t="GET", n) {
        return new Promise( (s, r) => {
            fetch(this.baseUrl + e, {
                method: t,
                body: JSON.stringify(n),
                headers: {
                    "Content-Type": "application/json",
                    Accept: "application/json",
                    "X-Connection-Key": this.settings.key
                }
            }).then(o => o.json()).then(o => {
                console.log(`[handy] url=${e} method=${t} req_body=${JSON.stringify(n)} resp_body=${JSON.stringify(o)}`),
                s(o)
            }
            ).catch(o => {
                r(o)
            }
            )
        }
        )
    }
    async slide(e, t) {
        return new Promise(async (n, s) => {
            (!this._connected || this._setupError) && s();
            try {
                const r = await this.json("/slide", "PUT", {
                    min: e,
                    max: t
                });
                console.log(`min: ${e}, max: ${t}`),
                console.log(r),
                n(r)
            } catch (r) {
                this._error = r,
                this._connected = !1,
                this._scanning = !1,
                console.log(r);
                return
            }
        }
        )
    }
    async XPVP(e, t) {
        return new Promise(async (n, s) => {
            if (!(!this._connected || this._setupError))
                try {
                    const r = await this.json("/hdsp/xpvp", "PUT", {
                        velocity: t,
                        position: e
                    });
                    r.position = e,
                    r.velocity = t,
                    n(r)
                } catch (r) {
                    this._error = r,
                    this._connected = !1,
                    this._scanning = !1,
                    s();
                    return
                }
        }
        )
    }
    start_R(e) {
        return new Promise(async (t, n) => {
            if (!this._connected || this._setupError)
                return n();
            this.json("/hssp/play", "PUT", {
                startTime: e
            }).then(s => {
                if ("error"in s)
                    return this._connected = s.error.connected,
                    n(`${s.error.name} (${s.error.code})`);
                this._connected = !0,
                t(s)
            }
            ).catch(s => {
                console.log(s),
                n(s)
            }
            )
        }
        )
    }
    stop_R() {
        return new Promise( (e, t) => {
            if (!this._connected || this._setupError)
                return t();
            this.json("/hssp/stop", "PUT").then(n => {
                if ("error"in n)
                    return this._connected = n.error.connected,
                    t(`${n.error.name} (${n.error.code})`);
                this._connected = !0,
                e(n)
            }
            ).catch(n => t(n))
        }
        )
    }
}
class oF {
    constructor() {
        tt(this, "toyName", "Autoblow");
        tt(this, "storageKey", "autoblow");
        tt(this, "baseUrl", "https://us-east-1.autoblowapi.com");
        tt(this, "_connected", !1);
        tt(this, "_estimatedServerTimeOffset", 0);
        tt(this, "_error");
        tt(this, "_setupError");
        tt(this, "_scanning", !1);
        tt(this, "_prepared", !1);
        tt(this, "_syncInterval", -1);
        tt(this, "_is_csv_sent", !1);
        tt(this, "_scriptToken");
        tt(this, "lastAction", "");
        tt(this, "handler", {
            get: (e, t) => typeof e[t] == "object" && e[t] !== null ? new Proxy(e[t],this.handler) : e[t],
            set: (e, t, n) => (e[t] = n,
            localStorage.setItem(this.storageKey, JSON.stringify(e)),
            this._connected && (t === "limits" ? this.json("/autoblow/oscillate", "PUT", {
                speed: 0,
                minY: n[0],
                maxY: n[1]
            }).then(s => console.log(s)).catch(s => console.log(s)) : t === "offset" && this.json("/autoblow/sync-script/offset", "PUT", {
                offsetTimeMs: n
            }).then(s => console.log(s)).catch(s => console.log(s))),
            !0)
        });
        tt(this, "settings", new Proxy({
            invert: !1,
            offset: 0,
            limits: [0, 100],
            key: ""
        },this.handler));
        const e = localStorage.getItem(this.storageKey);
        if (e) {
            const t = JSON.parse(e);
            this.settings.key = t.key || "",
            this.settings.invert = t.invert || !1,
            this.settings.offset = t.offset || 0,
            this.settings.limits = t.limits || [0, 100]
        }
        if (this.settings.key === "") {
            const t = localStorage.getItem("autoblow-connectionKey");
            t && (this.settings.key = t)
        }
    }
    get connected() {
        return this._connected
    }
    get iscsvsent() {
        return this._is_csv_sent && this._connected
    }
    get scanning() {
        return this._scanning
    }
    get error() {
        return this._error
    }
    async connect() {
        if (this.settings.key.length < 5 || this._scanning)
            return;
        this._scanning = !0,
        this._error = void 0;
        let e;
        try {
            e = await this.json("/autoblow/connected")
        } catch (t) {
            this._error = t,
            this._connected = !1,
            this._scanning = !1;
            return
        }
        if ("connected"in e && !e.connected) {
            this._error = "Device not connected",
            this._connected = !1,
            this._scanning = !1;
            return
        }
        this.baseUrl = "https://" + e.cluster;
        try {
            e = await this.json("/autoblow/info")
        } catch (t) {
            this._error = t,
            this._connected = !1,
            this._scanning = !1;
            return
        }
        if ("error"in e) {
            this._error = e.error.message,
            this._scanning = !1;
            return
        }
        if (e.firmwareStatus != "UP_TO_DATE") {
            this._error = "Firmware update required",
            this._scanning = !1;
            return
        }
        try {
            e = await this.json("/autoblow/state")
        } catch {
            this._error = "Couldn't get Autoblow settings",
            this._scanning = !1;
            return
        }
        if ("error"in e) {
            this._error = `${e.error.name} (${e.error.code})`,
            this._connected = e.error.connected,
            this._scanning = !1;
            return
        }
        this.settings.limits[0] = e.oscillatorLowPoint || 0,
        this.settings.limits[1] = e.oscillatorHighPoint || 100,
        this._connected = !0
    }
    disconnect() {
        this._scanning = !1,
        this._error = void 0,
        this._prepared = !1,
        this._connected = !1,
        this._setupError = void 0,
        this._is_csv_sent = !1,
        clearInterval(this._syncInterval),
        this.lastAction = "disconnect"
    }
    prepare(e) {
        return this._prepared = !1,
        this._is_csv_sent = !1,
        new Promise( (t, n) => {
            if (this.lastAction = "prepare",
            !this._connected)
                return t();
            this._setupError = void 0,
            this.settings.invert && (e += "?reverse"),
            this.json("/autoblow/sync-script/upload-csv-url", "PUT", {
                url: e
            }).then(s => {
                if ("error"in s)
                    return this._connected = s.error.connected,
                    this._setupError = s.error.name,
                    Promise.reject(new Error(`${s.error.name} (${s.error.code})`));
                this._is_csv_sent = !0,
                this._prepared = !0,
                this._connected = !0,
                t()
            }
            ).catch(s => {
                console.error(s),
                n(s)
            }
            )
        }
        )
    }
    play(e) {
        return new Promise(async (t, n) => {
            if (!this._connected || this._setupError || !this._is_csv_sent || this.lastAction == "play")
                return t();
            this.json("/autoblow/sync-script/start", "PUT", {
                startTimeMs: e
            }).then(s => {
                if ("error"in s)
                    return this._connected = s.error.connected,
                    n(`${s.error.name} (${s.error.code})`);
                this._connected = !0,
                this.lastAction = "play",
                t()
            }
            ).catch(s => n(s))
        }
        )
    }
    stop() {
        return new Promise( (e, t) => {
            if (!this._connected || !this._prepared || !this._is_csv_sent || this.lastAction == "stop")
                return e();
            this.json("/autoblow/sync-script/stop", "PUT", {}).then(n => {
                if ("error"in n)
                    return this._connected = n.error.connected,
                    t(`${n.error.name} (${n.error.code})`);
                this._connected = !0,
                this.lastAction = "stop",
                e(n)
            }
            ).catch(n => t(n))
        }
        )
    }
    json(e, t="GET", n) {
        return new Promise( (s, r) => {
            const o = {
                method: t,
                headers: {
                    "Content-Type": "application/json",
                    Accept: "application/json",
                    "x-device-token": this.settings.key
                }
            };
            t !== "GET" && t !== "HEAD" && n !== void 0 && (o.body = JSON.stringify(n)),
            fetch(this.baseUrl + e, o).then(a => a.json()).then(a => {
                console.warn(`[autoblow] url=${e} method=${t} req_body=${JSON.stringify(n)} resp_body=${JSON.stringify(a)}`),
                s(a)
            }
            ).catch(a => {
                r(a)
            }
            )
        }
        )
    }
    async goto(e, t) {
        return new Promise(async (n, s) => {
            if (!(!this._connected || this._setupError)) {
                if (e < 0 || t < 0 || !e || !t)
                    return s("Number and speed should be positive");
                try {
                    const r = await this.json("/autoblow/goto", "PUT", {
                        position: e,
                        speed: t
                    });
                    r.position = e,
                    r.oscillatorTargetSpeed = t,
                    n(r)
                } catch {
                    this._connected = !1,
                    s()
                }
            }
        }
        )
    }
    start_R(e) {
        return new Promise(async (t, n) => {
            if (!this._connected || this._setupError)
                return n();
            this.json("/autoblow/sync-script/start", "PUT", {
                startTime: e
            }).then(s => {
                if ("error"in s)
                    return this._connected = s.error.connected,
                    n(`${s.error.name} (${s.error.code})`);
                this._connected = !0,
                t(s)
            }
            ).catch(s => {
                console.log(s),
                n(s)
            }
            )
        }
        )
    }
    stop_R() {
        return new Promise( (e, t) => {
            if (!this._connected || this._setupError)
                return t();
            this.json("/autoblow/sync-script/stop", "PUT").then(n => {
                if ("error"in n)
                    return this._connected = n.error.connected,
                    t(`${n.error.name} (${n.error.code})`);
                this._connected = !0,
                e(n)
            }
            ).catch(n => t(n))
        }
        )
    }
}
const B_ = (i, e) => {
    const t = localStorage.getItem(i)
      , n = t !== null ? JSON.parse(t) : e
      , s = {
        get(r, o) {
            return r[o]
        },
        set(r, o, a) {
            return r[o] = a,
            localStorage.setItem(i, JSON.stringify(r)),
            !0
        }
    };
    return new Proxy(n,s)
}
;
class aF {
    constructor() {
        tt(this, "toyName", "OSR");
        tt(this, "_error");
        tt(this, "_port");
        tt(this, "_scanning", !1);
        tt(this, "settings", B_("osr", {
            limits: [0, 100],
            invert: !1
        }));
        if (!("serial"in navigator)) {
            this._error = "This browser does not support Web Serial";
            return
        }
        navigator.serial.addEventListener("disconnect", () => this._port = void 0)
    }
    connect() {
        this._scanning = !0,
        navigator.serial.requestPort().then(e => {
            this._port = e,
            e.open({
                baudRate: 115200
            }).then( () => {}
            ).catch(t => {
                console.log(t)
            }
            )
        }
        ).catch(e => {
            console.log(e)
        }
        ).finally( () => {
            this._scanning = !1
        }
        )
    }
    disconnect() {
        !this._port || this._port.close().catch(e => {
            console.log(e)
        }
        ).finally( () => {
            this._port = void 0
        }
        )
    }
    move(e, t) {
        if (!this._port)
            return;
        const [n,s] = this.settings.limits;
        e = e / 100 * (s - n) + n,
        e = Math.round(e),
        this.settings.invert && (e = 100 - e),
        e < 1 && (e = 1),
        e > 99 && (e = 99);
        const r = ("0" + e).slice(-2);
        console.log("[OSR][SEND]", `L0${r}I${t.toFixed(0)}`);
        const o = this._port.writable.getWriter();
        o.write(new TextEncoder().encode(`L0${r}I${t.toFixed(0)}
`)),
        o.releaseLock()
    }
    get error() {
        return this._error
    }
    get scanning() {
        return this._scanning
    }
    get connected() {
        return this._port
    }
}
function Vc(i, e) {
    return i.then(t => [null, t]).catch(t => e ? [Object.assign({}, t, e), void 0] : [t, void 0])
}
class tC {
    constructor() {
        tt(this, "_client");
        tt(this, "_scanning", !1);
        tt(this, "_devices", []);
        tt(this, "_error");
        tt(this, "buttplug", window.Buttplug);
        tt(this, "settings", B_("buttplug", {
            limits: [0, 100],
            invert: !1
        }))
    }
    registerListener() {
        !this._client || (this._client.on("deviceadded", () => {
            this._scanning = !1,
            this._devices = this._client.Devices
        }
        ),
        this._client.on("deviceremoved", () => {
            this._scanning = !1,
            this._devices = this._client.Devices
        }
        ))
    }
    get scanning() {
        return this._scanning
    }
    get error() {
        return this._error
    }
    get devices() {
        return this._devices
    }
    get connected() {
        return this._client && this._devices.length > 0
    }
    limit(e) {
        const [t,n] = this.settings.limits;
        return e = e / 100 * (n - t) + t,
        e = Math.round(e),
        this.settings.invert && (e = n - e),
        e
    }
}
class lF extends tC {
    constructor() {
        super(...arguments);
        tt(this, "toyName", "buttplug-external");
        tt(this, "_address", "");
        tt(this, "_connected", !1);
        tt(this, "_key", "intiface")
    }
    get address() {
        return this._address === "" && (this._address = localStorage.getItem(this._key) || "ws://localhost:12345"),
        this._address
    }
    set address(t) {
        this._address = t,
        localStorage.setItem(this._key, t)
    }
    async connect() {
        if (this._scanning = !0,
        this._error = void 0,
        !this._client) {
            let t;
            if ([t] = await Vc(this.buttplug.buttplugInit()),
            t) {
                this._scanning = !1,
                this._error = "This browser does not support WebAssembly";
                return
            }
            const n = new this.buttplug.ButtplugWebsocketConnectorOptions;
            if (n.Address = this.address,
            this._client = new this.buttplug.ButtplugClient("FapTap"),
            [t] = await Vc(this._client.connect(n)),
            t) {
                this._scanning = !1,
                this._client = void 0,
                this._error = t.message;
                return
            }
            this._connected = !0,
            this._devices = this._client.Devices,
            this.registerListener(),
            Vc(this._client.startScanning()).then()
        }
        this._scanning = !1
    }
    disconnect() {
        this._client && (this._client.disconnect(),
        this._client = void 0,
        this._connected = !1)
    }
    get connected() {
        return this._connected
    }
}
class cF extends tC {
    constructor() {
        super(...arguments);
        tt(this, "toyName", "buttplug-embedded")
    }
    async connect() {
        if (this._scanning = !0,
        !this._client) {
            let n;
            if ([n] = await Vc(this.buttplug.buttplugInit()),
            n) {
                this._scanning = !1,
                this._error = "This browser does not support WebAssembly";
                return
            }
            if (!this.hasWebBluetooth()) {
                this._scanning = !1,
                this._error = "This browser does not support Bluetooth";
                return
            }
            const s = new this.buttplug.ButtplugEmbeddedConnectorOptions;
            if (this._client = new this.buttplug.ButtplugClient("FapTap"),
            [n] = await Vc(this._client.connect(s)),
            n) {
                this._scanning = !1,
                this._error = n.message;
                return
            }
            this.registerListener()
        }
        const [t] = await Vc(this._client.startScanning());
        if (t) {
            this._scanning = !1,
            this._error = t.message;
            return
        }
        setTimeout( () => {
            !this._client.Connected || (this._scanning = !1,
            this._client.stopScanning().catch(n => console.log(n)))
        }
        , 2e4)
    }
    hasWebBluetooth() {
        return typeof window < "u" && typeof window.navigator < "u" && navigator.bluetooth !== void 0
    }
}
class uF {
    constructor() {
        tt(this, "toyName", "Loob");
        tt(this, "_error");
        tt(this, "_loob");
        tt(this, "_device");
        tt(this, "_scanning", !1);
        tt(this, "settings", B_("loob", {
            limits: [0, 100]
        }))
    }
    async connect() {
        var e;
        if (this._scanning = !0,
        this._error = void 0,
        !window.navigator.bluetooth) {
            this._error = "Bluetooth is not supported in this browser",
            this._scanning = !1;
            return
        }
        try {
            this._device = await navigator.bluetooth.requestDevice({
                filters: [{
                    namePrefix: "LOOB"
                }],
                optionalServices: ["b75c49d2-04a3-4071-a0b5-35853eb08307"]
            }),
            this._device.addEventListener("gattserverdisconnected", () => {
                this._loob = void 0,
                this._device = void 0
            }
            );
            const t = await ((e = this._device.gatt) == null ? void 0 : e.connect())
              , n = await (t == null ? void 0 : t.getPrimaryService("b75c49d2-04a3-4071-a0b5-35853eb08307"));
            this._loob = await (n == null ? void 0 : n.getCharacteristic("ba5c49d2-04a3-4071-a0b5-35853eb08307"))
        } catch (t) {
            this._error = t
        } finally {
            this._scanning = !1
        }
    }
    async disconnect() {
        var e, t;
        !this._loob || !this._device || (t = (e = this._device) == null ? void 0 : e.gatt) == null || t.disconnect()
    }
    intToUint8Array(e) {
        const t = new Uint8Array(4);
        return t[0] = (e & 4278190080) >> 24,
        t[1] = (e & 16711680) >> 16,
        t[2] = (e & 65280) >> 8,
        t[3] = e & 255,
        t
    }
    async move(e, t) {
        var l;
        if (!this._loob)
            return;
        const [n,s] = this.settings.limits;
        e = e / 100 * (s - n) + n,
        e = Math.round(e * 10),
        e < 1 && (e = 1),
        e > 1e3 && (e = 1e3);
        const r = this.intToUint8Array(e)
          , o = this.intToUint8Array(t)
          , a = new Uint8Array([r[2], r[3], o[2], o[3]]);
        await ((l = this._loob) == null ? void 0 : l.writeValueWithoutResponse(a))
    }
    get connected() {
        return this._loob != null
    }
    get error() {
        return this._error
    }
    get scanning() {
        return this._scanning
    }
}
class dF {
    constructor() {
        tt(this, "toyName", "Flesh Thrust Sync");
        tt(this, "_scanning", !1);
        tt(this, "_error");
        tt(this, "SERVICE_UUID", "0000ffe0-0000-1000-8000-00805f9b34fb");
        tt(this, "CHARACTERISTIC_UUID", "0000ffe1-0000-1000-8000-00805f9b34fb");
        tt(this, "characteristic", null);
        tt(this, "_device");
        tt(this, "MODE", "Normal");
        tt(this, "lastPos", null);
        tt(this, "safeMode", !0);
        tt(this, "onlyBFTConnect", !1);
        tt(this, "offset", -30)
    }
    hasWebBluetooth() {
        return typeof window < "u" && typeof window.navigator < "u" && navigator.bluetooth !== void 0
    }
    get scanning() {
        return this._scanning
    }
    get error() {
        return this._error
    }
    get connected() {
        var e, t, n, s, r, o;
        return this.characteristic && this._device ? !!(((s = (n = (t = (e = this.characteristic) == null ? void 0 : e.service) == null ? void 0 : t.device) == null ? void 0 : n.gatt) == null ? void 0 : s.connected) && ((o = (r = this._device) == null ? void 0 : r.gatt) == null ? void 0 : o.connected)) : !1
    }
    get devicename() {
        var e, t;
        return this.connected && (e = this._device) != null && e.name ? (t = this._device) == null ? void 0 : t.name : "Fleshy Thrust Sync"
    }
    get isEXTREME() {
        return this.MODE == "EXTREME"
    }
    get getSafeMode() {
        return this.safeMode
    }
    get preventJittery() {
        return this.onlyBFTConnect
    }
    async connectDeviceAndCacheCharacteristic() {
        var e;
        try {
            if (console.log("[BFT] Connecting to GATT server..."),
            !((e = this._device) != null && e.gatt))
                throw new Error("[BFT] No GATT available on the device");
            const t = await this._device.gatt.connect();
            console.log("[BFT] GATT server connected"),
            console.log("[BFT] Getting primary service...");
            const n = await t.getPrimaryService(this.SERVICE_UUID);
            if (console.log("[BFT] Service found"),
            this.characteristic = await n.getCharacteristic(this.CHARACTERISTIC_UUID),
            !this.characteristic)
                throw new Error("[BFT] Required characteristic not found");
            return console.log("[BFT] Target characteristic found:", this.characteristic.uuid),
            this._scanning = !1,
            this.characteristic
        } catch (t) {
            throw console.error("[BFT] Error in connectDeviceAndCacheCharacteristic:", t),
            this._scanning = !1,
            this._error = t,
            t
        }
    }
    async reConnection() {
        console.log("[BFT] Attempting to reconnect..."),
        this._scanning = !0,
        this.characteristic = null;
        try {
            return await this.connectDeviceAndCacheCharacteristic(),
            this.characteristic
        } catch (e) {
            console.error("[BFT] Reconnection failed:", e),
            this._error = e
        } finally {
            this._scanning = !1
        }
        return null
    }
    async connectDevice() {
        var e, t, n;
        if (this.hasWebBluetooth()) {
            if (this.connected)
                return console.log("[BFT] Already connected to device"),
                this.characteristic;
            const s = {
                acceptAllDevices: !0,
                optionalServices: [this.SERVICE_UUID]
            };
            return this._device = await navigator.bluetooth.requestDevice(s),
            console.log("[BFT] Device selected:", this._device.name),
            this._device.addEventListener("gattserverdisconnected", () => {
                this.safeMode && (console.log("[BFT] CallBack- gatt server disconnected, retry to connect ..."),
                this.reConnection())
            }
            ),
            await this.connectDeviceAndCacheCharacteristic(),
            console.log("[BFT] Successfully connected to device", (n = (t = (e = this.characteristic) == null ? void 0 : e.service) == null ? void 0 : t.device) == null ? void 0 : n.name),
            this.characteristic
        } else
            this._scanning = !1,
            this._error = "Bluetooth not supported or access denied. Please use a supported browser.";
        return null
    }
    async connect() {
        this._scanning = !0,
        this._error = void 0;
        try {
            this.connected ? (this.characteristic = null,
            console.log("[BFT] Disconnected from device")) : (console.log("[BFT] try to connection. Current state:", this.connected),
            await this.connectDevice())
        } catch (e) {
            console.error("[BFT] Error in toggleConnection:", e),
            this.characteristic = null,
            this._error = e
        } finally {
            this._scanning = !1
        }
    }
    disconnect() {
        var e, t, n, s;
        this._device && ((t = (e = this._device) == null ? void 0 : e.gatt) == null || t.disconnect(),
        (s = (n = this.characteristic) == null ? void 0 : n.service.device.gatt) == null || s.disconnect(),
        this._device = void 0,
        this.characteristic = null,
        console.log("[BFT] device disconnected"))
    }
    async sendData(e) {
        try {
            if (this.characteristic)
                console.log("Trying to send data."),
                await this.characteristic.writeValueWithoutResponse(new Uint8Array(e)),
                console.log("[BFT] Successfully sent bytes");
            else {
                this.safeMode && (console.log("[BFT] characteristic not available, try to reconnect"),
                this.characteristic = await this.reConnection(),
                this.characteristic && (await this.characteristic.writeValueWithoutResponse(new Uint8Array(e)),
                console.log("[BFT] Successfully sent bytes after reconnection")));
                return
            }
        } catch (t) {
            this._scanning = !1,
            console.log("[BFT] GATT operation writeValue failed :", t)
        }
    }
    toggleMode() {
        let e = !this.isEXTREME;
        this.MODE = e ? "EXTREME" : "Normal",
        console.log("[BFT] device mode changed", this.MODE)
    }
    numberToBytes(e) {
        try {
            const s = e.toString(2).padStart(16, "0").match(/.{1,8}/g);
            return s ? s.map(o => parseInt(o, 2)) : [0, 0]
        } catch (t) {
            return console.error("[BFT] Error in numberToBytes:", t),
            [0, 0]
        }
    }
    mapToRange(e, t, n) {
        try {
            return Math.trunc((e - t[0]) * (n[1] - n[0]) / (t[1] - t[0]) + n[0])
        } catch (s) {
            return console.error("[BFT] Error in mapToRange:", s),
            0
        }
    }
    async move(e, t) {
        try {
            if (this.lastPos === e) {
                console.log("[BFT] Move- Skipping duplicate position:", e);
                return
            }
            if (isNaN(t) || t > 65535) {
                console.log("[BFT] Move- Invalid inTime value:", t);
                return
            }
            this.MODE === "EXTREME" && this.lastPos !== null && (e > this.lastPos ? (console.log("[BFT] Move- EXTREME MODE: GOING UP"),
            e = 100) : e < this.lastPos && (console.log("[BFT] Move- EXTREME MODE: GOING DOWN"),
            e = 0)),
            e = this.mapToRange(e, [0, 100], [0, 180]),
            console.info("[BFT] Move- Mapped position:", e, "inTime:", t);
            let n = [e]
              , s = this.numberToBytes(parseInt(t.toString()))
              , r = n.concat(s);
            this.sendData(new Uint8Array(r)),
            this.lastPos = e
        } catch (n) {
            console.error("[BFT] Move- Error in parseLogsFromFapTap:", n),
            this._error = n
        }
    }
    resetPosition() {
        return new Promise( (e, t) => {
            if (!this.connected || this._error)
                return t(!1);
            console.info("[BFT] Resetting position tracking"),
            this.lastPos = null,
            e(!0)
        }
        )
    }
    toggleSafeMode() {
        this.safeMode = !this.safeMode,
        this.safeMode ? console.log("[BFT] Safe Mode: ON") : console.log("[BFT] Safe Mode: OFF")
    }
    toggleOnlyBFTConnect() {
        this.onlyBFTConnect = !this.onlyBFTConnect,
        this.onlyBFTConnect ? console.log("[BFT] Processing Jitteriness data: ON") : console.log("[BFT]  Processing Jitteriness data: OFF")
    }
    resetOffset() {
        this.offset = -30
    }
}
var cn = (i => (i.Handy = "Handy",
i.Autoblow = "Autoblow",
i.Bluetooth = "Bluetooth",
i.Intiface = "Intiface",
i.OSR = "OSR",
i.LOOB = "LOOB",
i.BluetoothFleshyThrust = "Flesh Thrust Sync",
i))(cn || {})
  , On = (i => (i[i.Start = 0] = "Start",
i[i.Handy = 1] = "Handy",
i[i.Autoblow = 2] = "Autoblow",
i[i.Bluetooth = 3] = "Bluetooth",
i[i.Osr = 4] = "Osr",
i[i.Intiface = 5] = "Intiface",
i[i.Loob = 6] = "Loob",
i[i.BluetoothFleshyThrust = 7] = "BluetoothFleshyThrust",
i))(On || {});
const Zr = Qd("device", () => {
    const i = xe(new rF)
      , e = xe(new aF)
      , t = xe(new oF)
      , n = xe(new cF)
      , s = xe(new lF)
      , r = xe(new uF)
      , o = xe(new dF)
      , a = xe({
        open: !1,
        page: 0
    })
      , l = Vt( () => {
        const u = [];
        return n.value.connected && u.push(...n.value.devices.map(d => ({
            instance: d,
            name: d.Name,
            connector: "Bluetooth"
        }))),
        s.value.connected && u.push(...s.value.devices.map(d => ({
            instance: d,
            name: d.Name,
            connector: "Intiface"
        }))),
        i.value.connected && u.push({
            name: "The Handy",
            connector: "Handy"
        }),
        t.value.connected && u.push({
            name: "Autoblow",
            connector: "Autoblow"
        }),
        e.value.connected && u.push({
            name: "OSR",
            connector: "OSR"
        }),
        r.value.connected && u.push({
            name: "LOOB",
            connector: "LOOB"
        }),
        o.value.connected && u.push({
            name: "Flesh Thrust Sync",
            connector: "Flesh Thrust Sync"
        }),
        u
    }
    );
    Bt( () => l.value, (u, d) => {
        if (d.length > u.length || u.length === 0)
            return;
        u.filter(h => !d.includes(h)).forEach(h => {
            hm.capture("toy_connected", {
                device: h.name
            })
        }
        )
    }
    );
    const c = Vt( () => i.value.scanning || e.value.scanning || n.value.scanning || s.value.scanning || o.value.scanning);
    return {
        handy: i,
        autoblow: t,
        bluetooth: n,
        intiface: s,
        osr: e,
        loob: r,
        bluetoothFleshyThrust: o,
        devices: l,
        connecting: c,
        ui: a
    }
}
);
const ou = Math.min
  , bl = Math.max
  , xp = Math.round
  , Rf = Math.floor
  , $r = i => ({
    x: i,
    y: i
});
function R1(i, e, t) {
    return bl(i, ou(e, t))
}
function vm(i, e) {
    return typeof i == "function" ? i(e) : i
}
function _m(i) {
    return i.split("-")[0]
}
function V_(i) {
    return i.split("-")[1]
}
function nC(i) {
    return i === "x" ? "y" : "x"
}
function iC(i) {
    return i === "y" ? "height" : "width"
}
function xm(i) {
    return ["top", "bottom"].includes(_m(i)) ? "y" : "x"
}
function sC(i) {
    return nC(xm(i))
}
function fF(i) {
    return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        ...i
    }
}
function rC(i) {
    return typeof i != "number" ? fF(i) : {
        top: i,
        right: i,
        bottom: i,
        left: i
    }
}
function yp(i) {
    const {x: e, y: t, width: n, height: s} = i;
    return {
        width: n,
        height: s,
        top: t,
        left: e,
        right: e + n,
        bottom: t + s,
        x: e,
        y: t
    }
}
function ib(i, e, t) {
    let {reference: n, floating: s} = i;
    const r = xm(e)
      , o = sC(e)
      , a = iC(o)
      , l = _m(e)
      , c = r === "y"
      , u = n.x + n.width / 2 - s.width / 2
      , d = n.y + n.height / 2 - s.height / 2
      , f = n[a] / 2 - s[a] / 2;
    let h;
    switch (l) {
    case "top":
        h = {
            x: u,
            y: n.y - s.height
        };
        break;
    case "bottom":
        h = {
            x: u,
            y: n.y + n.height
        };
        break;
    case "right":
        h = {
            x: n.x + n.width,
            y: d
        };
        break;
    case "left":
        h = {
            x: n.x - s.width,
            y: d
        };
        break;
    default:
        h = {
            x: n.x,
            y: n.y
        }
    }
    switch (V_(e)) {
    case "start":
        h[o] -= f * (t && c ? -1 : 1);
        break;
    case "end":
        h[o] += f * (t && c ? -1 : 1);
        break
    }
    return h
}
const hF = async (i, e, t) => {
    const {placement: n="bottom", strategy: s="absolute", middleware: r=[], platform: o} = t
      , a = r.filter(Boolean)
      , l = await (o.isRTL == null ? void 0 : o.isRTL(e));
    let c = await o.getElementRects({
        reference: i,
        floating: e,
        strategy: s
    })
      , {x: u, y: d} = ib(c, n, l)
      , f = n
      , h = {}
      , p = 0;
    for (let g = 0; g < a.length; g++) {
        const {name: m, fn: v} = a[g]
          , {x: _, y, data: b, reset: S} = await v({
            x: u,
            y: d,
            initialPlacement: n,
            placement: f,
            strategy: s,
            middlewareData: h,
            rects: c,
            platform: o,
            elements: {
                reference: i,
                floating: e
            }
        });
        u = _ != null ? _ : u,
        d = y != null ? y : d,
        h = {
            ...h,
            [m]: {
                ...h[m],
                ...b
            }
        },
        S && p <= 50 && (p++,
        typeof S == "object" && (S.placement && (f = S.placement),
        S.rects && (c = S.rects === !0 ? await o.getElementRects({
            reference: i,
            floating: e,
            strategy: s
        }) : S.rects),
        {x: u, y: d} = ib(c, f, l)),
        g = -1)
    }
    return {
        x: u,
        y: d,
        placement: f,
        strategy: s,
        middlewareData: h
    }
}
;
async function pF(i, e) {
    var t;
    e === void 0 && (e = {});
    const {x: n, y: s, platform: r, rects: o, elements: a, strategy: l} = i
      , {boundary: c="clippingAncestors", rootBoundary: u="viewport", elementContext: d="floating", altBoundary: f=!1, padding: h=0} = vm(e, i)
      , p = rC(h)
      , m = a[f ? d === "floating" ? "reference" : "floating" : d]
      , v = yp(await r.getClippingRect({
        element: (t = await (r.isElement == null ? void 0 : r.isElement(m))) == null || t ? m : m.contextElement || await (r.getDocumentElement == null ? void 0 : r.getDocumentElement(a.floating)),
        boundary: c,
        rootBoundary: u,
        strategy: l
    }))
      , _ = d === "floating" ? {
        x: n,
        y: s,
        width: o.floating.width,
        height: o.floating.height
    } : o.reference
      , y = await (r.getOffsetParent == null ? void 0 : r.getOffsetParent(a.floating))
      , b = await (r.isElement == null ? void 0 : r.isElement(y)) ? await (r.getScale == null ? void 0 : r.getScale(y)) || {
        x: 1,
        y: 1
    } : {
        x: 1,
        y: 1
    }
      , S = yp(r.convertOffsetParentRelativeRectToViewportRelativeRect ? await r.convertOffsetParentRelativeRectToViewportRelativeRect({
        elements: a,
        rect: _,
        offsetParent: y,
        strategy: l
    }) : _);
    return {
        top: (v.top - S.top + p.top) / b.y,
        bottom: (S.bottom - v.bottom + p.bottom) / b.y,
        left: (v.left - S.left + p.left) / b.x,
        right: (S.right - v.right + p.right) / b.x
    }
}
const mF = i => ({
    name: "arrow",
    options: i,
    async fn(e) {
        const {x: t, y: n, placement: s, rects: r, platform: o, elements: a, middlewareData: l} = e
          , {element: c, padding: u=0} = vm(i, e) || {};
        if (c == null)
            return {};
        const d = rC(u)
          , f = {
            x: t,
            y: n
        }
          , h = sC(s)
          , p = iC(h)
          , g = await o.getDimensions(c)
          , m = h === "y"
          , v = m ? "top" : "left"
          , _ = m ? "bottom" : "right"
          , y = m ? "clientHeight" : "clientWidth"
          , b = r.reference[p] + r.reference[h] - f[h] - r.floating[p]
          , S = f[h] - r.reference[h]
          , C = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(c));
        let M = C ? C[y] : 0;
        (!M || !await (o.isElement == null ? void 0 : o.isElement(C))) && (M = a.floating[y] || r.floating[p]);
        const L = b / 2 - S / 2
          , T = M / 2 - g[p] / 2 - 1
          , A = ou(d[v], T)
          , k = ou(d[_], T)
          , D = A
          , F = M - g[p] - k
          , z = M / 2 - g[p] / 2 + L
          , G = R1(D, z, F)
          , H = !l.arrow && V_(s) != null && z !== G && r.reference[p] / 2 - (z < D ? A : k) - g[p] / 2 < 0
          , X = H ? z < D ? z - D : z - F : 0;
        return {
            [h]: f[h] + X,
            data: {
                [h]: G,
                centerOffset: z - G - X,
                ...H && {
                    alignmentOffset: X
                }
            },
            reset: H
        }
    }
});
async function gF(i, e) {
    const {placement: t, platform: n, elements: s} = i
      , r = await (n.isRTL == null ? void 0 : n.isRTL(s.floating))
      , o = _m(t)
      , a = V_(t)
      , l = xm(t) === "y"
      , c = ["left", "top"].includes(o) ? -1 : 1
      , u = r && l ? -1 : 1
      , d = vm(e, i);
    let {mainAxis: f, crossAxis: h, alignmentAxis: p} = typeof d == "number" ? {
        mainAxis: d,
        crossAxis: 0,
        alignmentAxis: null
    } : {
        mainAxis: d.mainAxis || 0,
        crossAxis: d.crossAxis || 0,
        alignmentAxis: d.alignmentAxis
    };
    return a && typeof p == "number" && (h = a === "end" ? p * -1 : p),
    l ? {
        x: h * u,
        y: f * c
    } : {
        x: f * c,
        y: h * u
    }
}
const vF = function(i) {
    return i === void 0 && (i = 0),
    {
        name: "offset",
        options: i,
        async fn(e) {
            var t, n;
            const {x: s, y: r, placement: o, middlewareData: a} = e
              , l = await gF(e, i);
            return o === ((t = a.offset) == null ? void 0 : t.placement) && (n = a.arrow) != null && n.alignmentOffset ? {} : {
                x: s + l.x,
                y: r + l.y,
                data: {
                    ...l,
                    placement: o
                }
            }
        }
    }
}
  , _F = function(i) {
    return i === void 0 && (i = {}),
    {
        name: "shift",
        options: i,
        async fn(e) {
            const {x: t, y: n, placement: s} = e
              , {mainAxis: r=!0, crossAxis: o=!1, limiter: a={
                fn: m => {
                    let {x: v, y: _} = m;
                    return {
                        x: v,
                        y: _
                    }
                }
            }, ...l} = vm(i, e)
              , c = {
                x: t,
                y: n
            }
              , u = await pF(e, l)
              , d = xm(_m(s))
              , f = nC(d);
            let h = c[f]
              , p = c[d];
            if (r) {
                const m = f === "y" ? "top" : "left"
                  , v = f === "y" ? "bottom" : "right"
                  , _ = h + u[m]
                  , y = h - u[v];
                h = R1(_, h, y)
            }
            if (o) {
                const m = d === "y" ? "top" : "left"
                  , v = d === "y" ? "bottom" : "right"
                  , _ = p + u[m]
                  , y = p - u[v];
                p = R1(_, p, y)
            }
            const g = a.fn({
                ...e,
                [f]: h,
                [d]: p
            });
            return {
                ...g,
                data: {
                    x: g.x - t,
                    y: g.y - n,
                    enabled: {
                        [f]: r,
                        [d]: o
                    }
                }
            }
        }
    }
};
function ym() {
    return typeof window < "u"
}
function wu(i) {
    return oC(i) ? (i.nodeName || "").toLowerCase() : "#document"
}
function ws(i) {
    var e;
    return (i == null || (e = i.ownerDocument) == null ? void 0 : e.defaultView) || window
}
function Jr(i) {
    var e;
    return (e = (oC(i) ? i.ownerDocument : i.document) || window.document) == null ? void 0 : e.documentElement
}
function oC(i) {
    return ym() ? i instanceof Node || i instanceof ws(i).Node : !1
}
function br(i) {
    return ym() ? i instanceof Element || i instanceof ws(i).Element : !1
}
function jr(i) {
    return ym() ? i instanceof HTMLElement || i instanceof ws(i).HTMLElement : !1
}
function sb(i) {
    return !ym() || typeof ShadowRoot > "u" ? !1 : i instanceof ShadowRoot || i instanceof ws(i).ShadowRoot
}
function nf(i) {
    const {overflow: e, overflowX: t, overflowY: n, display: s} = Sr(i);
    return /auto|scroll|overlay|hidden|clip/.test(e + n + t) && !["inline", "contents"].includes(s)
}
function xF(i) {
    return ["table", "td", "th"].includes(wu(i))
}
function bm(i) {
    return [":popover-open", ":modal"].some(e => {
        try {
            return i.matches(e)
        } catch {
            return !1
        }
    }
    )
}
function $_(i) {
    const e = H_()
      , t = br(i) ? Sr(i) : i;
    return t.transform !== "none" || t.perspective !== "none" || (t.containerType ? t.containerType !== "normal" : !1) || !e && (t.backdropFilter ? t.backdropFilter !== "none" : !1) || !e && (t.filter ? t.filter !== "none" : !1) || ["transform", "perspective", "filter"].some(n => (t.willChange || "").includes(n)) || ["paint", "layout", "strict", "content"].some(n => (t.contain || "").includes(n))
}
function yF(i) {
    let e = Sa(i);
    for (; jr(e) && !au(e); ) {
        if ($_(e))
            return e;
        if (bm(e))
            return null;
        e = Sa(e)
    }
    return null
}
function H_() {
    return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none")
}
function au(i) {
    return ["html", "body", "#document"].includes(wu(i))
}
function Sr(i) {
    return ws(i).getComputedStyle(i)
}
function Sm(i) {
    return br(i) ? {
        scrollLeft: i.scrollLeft,
        scrollTop: i.scrollTop
    } : {
        scrollLeft: i.scrollX,
        scrollTop: i.scrollY
    }
}
function Sa(i) {
    if (wu(i) === "html")
        return i;
    const e = i.assignedSlot || i.parentNode || sb(i) && i.host || Jr(i);
    return sb(e) ? e.host : e
}
function aC(i) {
    const e = Sa(i);
    return au(e) ? i.ownerDocument ? i.ownerDocument.body : i.body : jr(e) && nf(e) ? e : aC(e)
}
function Pd(i, e, t) {
    var n;
    e === void 0 && (e = []),
    t === void 0 && (t = !0);
    const s = aC(i)
      , r = s === ((n = i.ownerDocument) == null ? void 0 : n.body)
      , o = ws(s);
    if (r) {
        const a = L1(o);
        return e.concat(o, o.visualViewport || [], nf(s) ? s : [], a && t ? Pd(a) : [])
    }
    return e.concat(s, Pd(s, [], t))
}
function L1(i) {
    return i.parent && Object.getPrototypeOf(i.parent) ? i.frameElement : null
}
function lC(i) {
    const e = Sr(i);
    let t = parseFloat(e.width) || 0
      , n = parseFloat(e.height) || 0;
    const s = jr(i)
      , r = s ? i.offsetWidth : t
      , o = s ? i.offsetHeight : n
      , a = xp(t) !== r || xp(n) !== o;
    return a && (t = r,
    n = o),
    {
        width: t,
        height: n,
        $: a
    }
}
function z_(i) {
    return br(i) ? i : i.contextElement
}
function $c(i) {
    const e = z_(i);
    if (!jr(e))
        return $r(1);
    const t = e.getBoundingClientRect()
      , {width: n, height: s, $: r} = lC(e);
    let o = (r ? xp(t.width) : t.width) / n
      , a = (r ? xp(t.height) : t.height) / s;
    return (!o || !Number.isFinite(o)) && (o = 1),
    (!a || !Number.isFinite(a)) && (a = 1),
    {
        x: o,
        y: a
    }
}
const bF = $r(0);
function cC(i) {
    const e = ws(i);
    return !H_() || !e.visualViewport ? bF : {
        x: e.visualViewport.offsetLeft,
        y: e.visualViewport.offsetTop
    }
}
function SF(i, e, t) {
    return e === void 0 && (e = !1),
    !t || e && t !== ws(i) ? !1 : e
}
function Il(i, e, t, n) {
    e === void 0 && (e = !1),
    t === void 0 && (t = !1);
    const s = i.getBoundingClientRect()
      , r = z_(i);
    let o = $r(1);
    e && (n ? br(n) && (o = $c(n)) : o = $c(i));
    const a = SF(r, t, n) ? cC(r) : $r(0);
    let l = (s.left + a.x) / o.x
      , c = (s.top + a.y) / o.y
      , u = s.width / o.x
      , d = s.height / o.y;
    if (r) {
        const f = ws(r)
          , h = n && br(n) ? ws(n) : n;
        let p = f
          , g = L1(p);
        for (; g && n && h !== p; ) {
            const m = $c(g)
              , v = g.getBoundingClientRect()
              , _ = Sr(g)
              , y = v.left + (g.clientLeft + parseFloat(_.paddingLeft)) * m.x
              , b = v.top + (g.clientTop + parseFloat(_.paddingTop)) * m.y;
            l *= m.x,
            c *= m.y,
            u *= m.x,
            d *= m.y,
            l += y,
            c += b,
            p = ws(g),
            g = L1(p)
        }
    }
    return yp({
        width: u,
        height: d,
        x: l,
        y: c
    })
}
function G_(i, e) {
    const t = Sm(i).scrollLeft;
    return e ? e.left + t : Il(Jr(i)).left + t
}
function uC(i, e, t) {
    t === void 0 && (t = !1);
    const n = i.getBoundingClientRect()
      , s = n.left + e.scrollLeft - (t ? 0 : G_(i, n))
      , r = n.top + e.scrollTop;
    return {
        x: s,
        y: r
    }
}
function EF(i) {
    let {elements: e, rect: t, offsetParent: n, strategy: s} = i;
    const r = s === "fixed"
      , o = Jr(n)
      , a = e ? bm(e.floating) : !1;
    if (n === o || a && r)
        return t;
    let l = {
        scrollLeft: 0,
        scrollTop: 0
    }
      , c = $r(1);
    const u = $r(0)
      , d = jr(n);
    if ((d || !d && !r) && ((wu(n) !== "body" || nf(o)) && (l = Sm(n)),
    jr(n))) {
        const h = Il(n);
        c = $c(n),
        u.x = h.x + n.clientLeft,
        u.y = h.y + n.clientTop
    }
    const f = o && !d && !r ? uC(o, l, !0) : $r(0);
    return {
        width: t.width * c.x,
        height: t.height * c.y,
        x: t.x * c.x - l.scrollLeft * c.x + u.x + f.x,
        y: t.y * c.y - l.scrollTop * c.y + u.y + f.y
    }
}
function wF(i) {
    return Array.from(i.getClientRects())
}
function TF(i) {
    const e = Jr(i)
      , t = Sm(i)
      , n = i.ownerDocument.body
      , s = bl(e.scrollWidth, e.clientWidth, n.scrollWidth, n.clientWidth)
      , r = bl(e.scrollHeight, e.clientHeight, n.scrollHeight, n.clientHeight);
    let o = -t.scrollLeft + G_(i);
    const a = -t.scrollTop;
    return Sr(n).direction === "rtl" && (o += bl(e.clientWidth, n.clientWidth) - s),
    {
        width: s,
        height: r,
        x: o,
        y: a
    }
}
function AF(i, e) {
    const t = ws(i)
      , n = Jr(i)
      , s = t.visualViewport;
    let r = n.clientWidth
      , o = n.clientHeight
      , a = 0
      , l = 0;
    if (s) {
        r = s.width,
        o = s.height;
        const c = H_();
        (!c || c && e === "fixed") && (a = s.offsetLeft,
        l = s.offsetTop)
    }
    return {
        width: r,
        height: o,
        x: a,
        y: l
    }
}
function CF(i, e) {
    const t = Il(i, !0, e === "fixed")
      , n = t.top + i.clientTop
      , s = t.left + i.clientLeft
      , r = jr(i) ? $c(i) : $r(1)
      , o = i.clientWidth * r.x
      , a = i.clientHeight * r.y
      , l = s * r.x
      , c = n * r.y;
    return {
        width: o,
        height: a,
        x: l,
        y: c
    }
}
function rb(i, e, t) {
    let n;
    if (e === "viewport")
        n = AF(i, t);
    else if (e === "document")
        n = TF(Jr(i));
    else if (br(e))
        n = CF(e, t);
    else {
        const s = cC(i);
        n = {
            x: e.x - s.x,
            y: e.y - s.y,
            width: e.width,
            height: e.height
        }
    }
    return yp(n)
}
function dC(i, e) {
    const t = Sa(i);
    return t === e || !br(t) || au(t) ? !1 : Sr(t).position === "fixed" || dC(t, e)
}
function MF(i, e) {
    const t = e.get(i);
    if (t)
        return t;
    let n = Pd(i, [], !1).filter(a => br(a) && wu(a) !== "body")
      , s = null;
    const r = Sr(i).position === "fixed";
    let o = r ? Sa(i) : i;
    for (; br(o) && !au(o); ) {
        const a = Sr(o)
          , l = $_(o);
        !l && a.position === "fixed" && (s = null),
        (r ? !l && !s : !l && a.position === "static" && !!s && ["absolute", "fixed"].includes(s.position) || nf(o) && !l && dC(i, o)) ? n = n.filter(u => u !== o) : s = a,
        o = Sa(o)
    }
    return e.set(i, n),
    n
}
function RF(i) {
    let {element: e, boundary: t, rootBoundary: n, strategy: s} = i;
    const o = [...t === "clippingAncestors" ? bm(e) ? [] : MF(e, this._c) : [].concat(t), n]
      , a = o[0]
      , l = o.reduce( (c, u) => {
        const d = rb(e, u, s);
        return c.top = bl(d.top, c.top),
        c.right = ou(d.right, c.right),
        c.bottom = ou(d.bottom, c.bottom),
        c.left = bl(d.left, c.left),
        c
    }
    , rb(e, a, s));
    return {
        width: l.right - l.left,
        height: l.bottom - l.top,
        x: l.left,
        y: l.top
    }
}
function LF(i) {
    const {width: e, height: t} = lC(i);
    return {
        width: e,
        height: t
    }
}
function IF(i, e, t) {
    const n = jr(e)
      , s = Jr(e)
      , r = t === "fixed"
      , o = Il(i, !0, r, e);
    let a = {
        scrollLeft: 0,
        scrollTop: 0
    };
    const l = $r(0);
    if (n || !n && !r)
        if ((wu(e) !== "body" || nf(s)) && (a = Sm(e)),
        n) {
            const f = Il(e, !0, r, e);
            l.x = f.x + e.clientLeft,
            l.y = f.y + e.clientTop
        } else
            s && (l.x = G_(s));
    const c = s && !n && !r ? uC(s, a) : $r(0)
      , u = o.left + a.scrollLeft - l.x - c.x
      , d = o.top + a.scrollTop - l.y - c.y;
    return {
        x: u,
        y: d,
        width: o.width,
        height: o.height
    }
}
function m0(i) {
    return Sr(i).position === "static"
}
function ob(i, e) {
    if (!jr(i) || Sr(i).position === "fixed")
        return null;
    if (e)
        return e(i);
    let t = i.offsetParent;
    return Jr(i) === t && (t = t.ownerDocument.body),
    t
}
function fC(i, e) {
    const t = ws(i);
    if (bm(i))
        return t;
    if (!jr(i)) {
        let s = Sa(i);
        for (; s && !au(s); ) {
            if (br(s) && !m0(s))
                return s;
            s = Sa(s)
        }
        return t
    }
    let n = ob(i, e);
    for (; n && xF(n) && m0(n); )
        n = ob(n, e);
    return n && au(n) && m0(n) && !$_(n) ? t : n || yF(i) || t
}
const kF = async function(i) {
    const e = this.getOffsetParent || fC
      , t = this.getDimensions
      , n = await t(i.floating);
    return {
        reference: IF(i.reference, await e(i.floating), i.strategy),
        floating: {
            x: 0,
            y: 0,
            width: n.width,
            height: n.height
        }
    }
};
function PF(i) {
    return Sr(i).direction === "rtl"
}
const DF = {
    convertOffsetParentRelativeRectToViewportRelativeRect: EF,
    getDocumentElement: Jr,
    getClippingRect: RF,
    getOffsetParent: fC,
    getElementRects: kF,
    getClientRects: wF,
    getDimensions: LF,
    getScale: $c,
    isElement: br,
    isRTL: PF
};
function FF(i, e) {
    let t = null, n;
    const s = Jr(i);
    function r() {
        var a;
        clearTimeout(n),
        (a = t) == null || a.disconnect(),
        t = null
    }
    function o(a, l) {
        a === void 0 && (a = !1),
        l === void 0 && (l = 1),
        r();
        const {left: c, top: u, width: d, height: f} = i.getBoundingClientRect();
        if (a || e(),
        !d || !f)
            return;
        const h = Rf(u)
          , p = Rf(s.clientWidth - (c + d))
          , g = Rf(s.clientHeight - (u + f))
          , m = Rf(c)
          , _ = {
            rootMargin: -h + "px " + -p + "px " + -g + "px " + -m + "px",
            threshold: bl(0, ou(1, l)) || 1
        };
        let y = !0;
        function b(S) {
            const C = S[0].intersectionRatio;
            if (C !== l) {
                if (!y)
                    return o();
                C ? o(!1, C) : n = setTimeout( () => {
                    o(!1, 1e-7)
                }
                , 1e3)
            }
            y = !1
        }
        try {
            t = new IntersectionObserver(b,{
                ..._,
                root: s.ownerDocument
            })
        } catch {
            t = new IntersectionObserver(b,_)
        }
        t.observe(i)
    }
    return o(!0),
    r
}
function OF(i, e, t, n) {
    n === void 0 && (n = {});
    const {ancestorScroll: s=!0, ancestorResize: r=!0, elementResize: o=typeof ResizeObserver == "function", layoutShift: a=typeof IntersectionObserver == "function", animationFrame: l=!1} = n
      , c = z_(i)
      , u = s || r ? [...c ? Pd(c) : [], ...Pd(e)] : [];
    u.forEach(v => {
        s && v.addEventListener("scroll", t, {
            passive: !0
        }),
        r && v.addEventListener("resize", t)
    }
    );
    const d = c && a ? FF(c, t) : null;
    let f = -1
      , h = null;
    o && (h = new ResizeObserver(v => {
        let[_] = v;
        _ && _.target === c && h && (h.unobserve(e),
        cancelAnimationFrame(f),
        f = requestAnimationFrame( () => {
            var y;
            (y = h) == null || y.observe(e)
        }
        )),
        t()
    }
    ),
    c && !l && h.observe(c),
    h.observe(e));
    let p, g = l ? Il(i) : null;
    l && m();
    function m() {
        const v = Il(i);
        g && (v.x !== g.x || v.y !== g.y || v.width !== g.width || v.height !== g.height) && t(),
        g = v,
        p = requestAnimationFrame(m)
    }
    return t(),
    () => {
        var v;
        u.forEach(_ => {
            s && _.removeEventListener("scroll", t),
            r && _.removeEventListener("resize", t)
        }
        ),
        d == null || d(),
        (v = h) == null || v.disconnect(),
        h = null,
        l && cancelAnimationFrame(p)
    }
}
const UF = vF
  , NF = _F
  , BF = mF
  , VF = (i, e, t) => {
    const n = new Map
      , s = {
        platform: DF,
        ...t
    }
      , r = {
        ...s.platform,
        _c: n
    };
    return hF(i, e, {
        ...s,
        platform: r
    })
}
  , ji = ut({
    __name: "Popup",
    props: {
        modelValue: {
            type: Boolean
        },
        target: {},
        placement: {
            default: "bottom"
        },
        offset: {
            default: 0
        },
        teleport: {
            type: Boolean,
            default: !0
        },
        class: {}
    },
    emits: ["update:modelValue"],
    setup(i, {emit: e}) {
        const t = i
          , n = e
          , s = xe()
          , r = xe();
        let o;
        const a = () => {
            const d = [UF(t.offset), NF(), BF({
                element: r.value,
                padding: 6
            })];
            o = OF(t.target, s.value, () => {
                VF(t.target, s.value, {
                    strategy: "fixed",
                    placement: t.placement,
                    middleware: d
                }).then( ({x: f, y: h, placement: p, middlewareData: g}) => {
                    Object.assign(s.value.style, {
                        left: `${f}px`,
                        top: `${h}px`
                    });
                    const {x: m, y: v} = g.arrow
                      , _ = {
                        top: "bottom",
                        right: "left",
                        bottom: "top",
                        left: "right"
                    }[p.split("-")[0]];
                    Object.assign(r.value.style, {
                        left: m ? `${m}px` : "",
                        top: v ? `${v}px` : "",
                        right: "",
                        bottom: "",
                        [_]: "-4px"
                    })
                }
                )
            }
            )
        }
        ;
        Ln( () => {
            window.addEventListener("mousedown", c),
            window.addEventListener("mouseup", u)
        }
        ),
        Ms( () => {
            window.removeEventListener("mousedown", c),
            window.removeEventListener("mouseup", u)
        }
        ),
        Bt( () => t.modelValue, d => {
            if (!d)
                return o();
            requestAnimationFrame( () => a())
        }
        );
        let l = !1;
        const c = d => {
            if (!t.modelValue || !t.target || !s.value) {
                l = !1;
                return
            }
            l = d.target === s.value || s.value.contains(d.target)
        }
          , u = d => {
            if (!t.modelValue || !t.target || !s.value || l)
                return;
            const f = d.target === s.value || s.value.contains(d.target)
              , h = d.target === t.target || t.target.contains(d.target);
            f || h || n("update:modelValue", !1)
        }
        ;
        return (d, f) => (w(),
        Re(u_, {
            to: "body",
            disabled: !d.teleport
        }, [t.modelValue ? (w(),
        R("div", {
            key: 0,
            ref_key: "floatingElement",
            ref: s,
            class: "rounded-md fixed bg-zinc-700 z-50"
        }, [x("div", {
            ref_key: "arrowElement",
            ref: r,
            class: "absolute bg-zinc-700 w-3 h-3 rotate-45 -z-10"
        }, null, 512), x("div", {
            class: Pt([t.class, "overflow-hidden max-h-screen overflow-y-auto rounded"])
        }, [Nl(d.$slots, "default")], 2)], 512)) : le("", !0)], 8, ["disabled"]))
    }
})
  , $F = {
    class: "flex items-center justify-center py-1.5 gap-1 text-zinc-300 text-lg md:text-base"
}
  , HF = {
    class: "font-medium"
}
  , g0 = ut({
    __name: "SettingsPopupHeader",
    props: {
        title: {},
        icon: {},
        isPremium: {
            type: Boolean
        }
    },
    setup(i) {
        const e = i;
        return (t, n) => (w(),
        R("div", $F, [O(ze, {
            name: e.icon,
            class: "h-5 w-5"
        }, null, 8, ["name"]), x("p", HF, ee(e.title), 1), e.isPremium ? (w(),
        Re(ze, {
            key: 0,
            name: "star",
            class: "h-5 w-5 text-blue-600"
        })) : le("", !0)]))
    }
})
  , zF = {
    class: "flex-1"
}
  , Ot = ut({
    __name: "SettingsPopupListItem",
    props: {
        icon: {},
        arrow: {
            type: Boolean
        },
        active: {
            type: Boolean
        }
    },
    setup(i) {
        const e = i;
        return (t, n) => (w(),
        R("div", {
            class: Pt(["flex py-1.5 md:py-1.5 px-3 items-center gap-3 hover:bg-blue-500 cursor-pointer text-lg md:text-base", {
                "bg-blue-500": e.active
            }])
        }, [e.icon ? (w(),
        Re(ze, {
            key: 0,
            name: e.icon,
            class: "h-6 md:h-5 md:w-5"
        }, null, 8, ["name"])) : le("", !0), x("div", zF, [Nl(t.$slots, "default")]), e.arrow ? (w(),
        Re(ze, {
            key: 1,
            name: "chevron-right",
            class: "h-5 w-5"
        })) : le("", !0)], 2))
    }
})
  , hC = (i, e) => {
    const t = i.__vccOpts || i;
    for (const [n,s] of e)
        t[n] = s;
    return t
}
  , GF = {}
  , WF = {
    class: "border-zinc-500 my-1"
};
function qF(i, e) {
    return w(),
    R("hr", WF)
}
const v0 = hC(GF, [["render", qF]])
  , jF = {
    key: 0,
    class: "fixed flex inset-0 w-full z-50 pt-6"
}
  , dr = ut({
    __name: "BottomSheet",
    props: {
        modelValue: {
            type: Boolean
        },
        teleport: {
            type: Boolean,
            default: !0
        }
    },
    emits: ["update:modelValue"],
    setup(i, {emit: e}) {
        const t = i
          , n = e
          , s = xe()
          , r = xe()
          , o = xe()
          , a = ei({
            transform: {
                value: 100,
                start: {
                    value: 100,
                    ms: 0
                }
            },
            dragging: !1,
            contentScrolled: !1
        })
          , l = () => {
            !s.value || !r.value || !o.value || (a.transform.value = 0,
            s.value.addEventListener("touchmove", c),
            s.value.addEventListener("touchstart", d),
            s.value.addEventListener("touchend", f),
            o.value.addEventListener("scroll", h => a.contentScrolled = !0))
        }
          , c = h => {
            if (!a.dragging || !s.value)
                return;
            const p = h.touches[0].clientY - u.clientY
              , g = h.target;
            if ((g === o.value || o.value.contains(g)) && a.transform.value === 0 && !(o.value.scrollTop === 0 && p > 0 && !a.contentScrolled))
                return;
            h.preventDefault();
            const m = s.value.offsetHeight
              , v = p / m * 100;
            let _ = a.transform.value + v;
            _ > 100 && (_ = 100),
            _ < 0 && (_ = 0),
            a.transform.value = _,
            u = h.touches[0]
        }
        ;
        let u;
        const d = h => {
            a.dragging = !0,
            a.contentScrolled = !1,
            a.transform.start.value = a.transform.value,
            a.transform.start.ms = new Date().getTime(),
            u = h.touches[0]
        }
          , f = h => {
            a.dragging = !1;
            const p = a.transform.start
              , g = {
                value: a.transform.value,
                ms: new Date().getTime()
            };
            if (g.value > p.value && g.value - p.value > 15 && g.ms - p.ms < 200) {
                a.transform.value = 100;
                return
            }
            if (g.value >= 80) {
                a.transform.value = 100;
                return
            }
            if (g.value < p.value && p.value - g.value > 5) {
                a.transform.value = 0;
                return
            }
            const m = [100, 0].reduce( (v, _) => Math.abs(_ - g.value) < Math.abs(v - g.value) ? _ : v);
            a.transform.value = m
        }
        ;
        return Bt( () => a.transform.value, h => {
            h === 100 && setTimeout( () => n("update:modelValue", !1), 150)
        }
        ),
        Bt( () => t.modelValue, h => {
            const p = "overflow-hidden"
              , g = document.querySelector("body");
            setTimeout( () => {
                h ? (g.classList.add(p),
                requestAnimationFrame(l)) : g.classList.remove(p)
            }
            , 10)
        }
        ),
        (h, p) => (w(),
        Re(u_, {
            disabled: !t.teleport,
            to: "body"
        }, [O(y_, null, {
            default: Y( () => [t.modelValue ? (w(),
            R("div", jF, [x("div", {
                class: Pt(["fixed inset-0 bg-black overflow-hidden", {
                    "transition-opacity": !a.dragging
                }]),
                style: xs(`opacity: ${(100 - a.transform.value) * .8}%`),
                onClick: p[0] || (p[0] = g => a.transform.value = 100)
            }, null, 6), x("div", {
                class: "flex flex-col flex-grow flex-1 justify-end items-center",
                ref_key: "container",
                ref: r
            }, [x("div", {
                class: Pt(["bg-zinc-900 rounded-t-md flex flex-col overflow-hidden shadow-xl w-full max-w-lg", {
                    "transition-transform": !a.dragging
                }]),
                style: xs(`transform: translateY(${a.transform.value}%)`),
                ref_key: "sheet",
                ref: s
            }, [p[1] || (p[1] = x("div", {
                class: "flex justify-center py-2.5"
            }, [x("div", {
                class: "h-2 bg-zinc-700 w-16 h-1.5 rounded-full"
            })], -1)), x("div", {
                class: "py-2.5 overflow-y-overlay",
                ref_key: "content",
                ref: o
            }, [Nl(h.$slots, "default")], 512)], 6)], 512)])) : le("", !0)]),
            _: 3
        })], 8, ["disabled"]))
    }
});
function Ks() {
    return {
        isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)
    }
}
const KF = {
    key: 0,
    class: "text-red-500 font-medium"
}
  , XF = {
    key: 0
}
  , YF = {
    key: 0,
    class: "text-red-500 font-medium"
}
  , ZF = {
    class: "font-medium"
}
  , JF = {
    key: 1
}
  , QF = {
    key: 0,
    class: "max-h-[400px] overflow-y-auto text-sm"
}
  , eO = {
    class: "font-medium text-white"
}
  , tO = {
    class: "font-medium text-white"
}
  , nO = {
    class: "font-medium text-white"
}
  , iO = {
    key: 1,
    class: "text-center py-2 px-2"
}
  , sO = {
    key: 2
}
  , pC = ut({
    __name: "SettingsPopup",
    setup(i) {
        const e = xe(!1)
          , t = it()
          , {isMobile: n} = Ks()
          , {user: s, isAuthorized: r, isCreator: o, isAdmin: a, notifications: l, unreadNotificationsCount: c, isPremium: u} = Pn(t)
          , {authDialog: d} = Pn(Xi())
          , f = ti()
          , h = xe(0)
          , p = async () => {
            f.push("/"),
            await ct.user.logout(),
            t.setUser(null),
            window.location.reload()
        }
        ;
        return Bt(u),
        (g, m) => {
            var v;
            return w(),
            R(Ge, null, [E(r) ? (w(),
            Re(je, {
                key: 0,
                ref: "profile",
                onClick: m[0] || (m[0] = _ => e.value = !e.value),
                theme: "blue",
                class: "flex gap-x-1.5 items-center"
            }, {
                default: Y( () => [m[20] || (m[20] = x("span", null, "Menu", -1)), E(c) ? (w(),
                R("span", KF, " (" + ee(E(c)) + ") ", 1)) : le("", !0), O(ze, {
                    name: "account",
                    class: "h-5 w-5"
                })]),
                _: 1
            }, 512)) : le("", !0), (w(),
            Re(ys(E(n) ? dr : ji), {
                target: (v = g.$refs.profile) == null ? void 0 : v.$el,
                modelValue: e.value,
                "onUpdate:modelValue": m[19] || (m[19] = _ => e.value = _),
                placement: "bottom-end",
                offset: 8,
                class: "text-white md:w-80 py-1"
            }, {
                default: Y( () => [O(y_, {
                    mode: "out-in"
                }, {
                    default: Y( () => [h.value === 0 ? (w(),
                    R("div", XF, [O(g0, {
                        title: "Account",
                        isPremium: E(t).isPremium,
                        icon: "account"
                    }, null, 8, ["isPremium"]), E(r) ? (w(),
                    R(Ge, {
                        key: 0
                    }, [O(Ot, {
                        icon: "notification-badge-outline",
                        arrow: !0,
                        onClick: m[1] || (m[1] = _ => (h.value = 1,
                        E(t).markNotificationsAsRead()))
                    }, {
                        default: Y( () => [m[21] || (m[21] = J(" Notifications ")), E(c) ? (w(),
                        R("span", YF, "(" + ee(E(c)) + ") ", 1)) : le("", !0)]),
                        _: 1
                    }), O(Ot, {
                        icon: "animation-play-outline",
                        onClick: m[2] || (m[2] = _ => (E(f).push("/feed"),
                        e.value = !1))
                    }, {
                        default: Y( () => m[22] || (m[22] = [J(" Subscriptions ")])),
                        _: 1
                    }), O(Ot, {
                        icon: "heart",
                        onClick: m[3] || (m[3] = _ => (E(f).push("/likes"),
                        e.value = !1))
                    }, {
                        default: Y( () => m[23] || (m[23] = [J(" Likes ")])),
                        _: 1
                    }), O(Ot, {
                        icon: "account",
                        onClick: m[4] || (m[4] = _ => (E(f).push(`/u/${E(s).username}`),
                        e.value = !1))
                    }, {
                        default: Y( () => m[24] || (m[24] = [J(" My Profile ")])),
                        _: 1
                    }), E(it)().isProduction ? (w(),
                    Re(Ot, {
                        key: 0,
                        icon: E(t).getOrientationIcon(),
                        arrow: !0,
                        onClick: m[5] || (m[5] = _ => h.value = 2)
                    }, {
                        default: Y( () => [m[25] || (m[25] = J(" Orientation: ")), x("span", ZF, ee(E(s).orientation !== void 0 ? E(mn)[E(s).orientation] : "None"), 1)]),
                        _: 1
                    }, 8, ["icon"])) : le("", !0), O(Ot, {
                        icon: "cog",
                        onClick: m[6] || (m[6] = _ => (E(f).push("/preferences"),
                        e.value = !1))
                    }, {
                        default: Y( () => m[26] || (m[26] = [J(" Preferences ")])),
                        _: 1
                    }), E(o) ? (w(),
                    R(Ge, {
                        key: 1
                    }, [O(g0, {
                        title: "Studio",
                        icon: "youtube-studio"
                    }), O(Ot, {
                        icon: "chart-timeline-sparkles",
                        onClick: m[7] || (m[7] = _ => (e.value = !1,
                        E(f).push("/studio")))
                    }, {
                        default: Y( () => m[27] || (m[27] = [J(" Analytics ")])),
                        _: 1
                    }), O(Ot, {
                        icon: "video-box",
                        onClick: m[8] || (m[8] = _ => (e.value = !1,
                        E(f).push("/studio/videos")))
                    }, {
                        default: Y( () => m[28] || (m[28] = [J(" My Videos ")])),
                        _: 1
                    })], 64)) : le("", !0), E(a) ? (w(),
                    R(Ge, {
                        key: 2
                    }, [O(g0, {
                        title: "Administration",
                        icon: "shield-crown"
                    }), O(Ot, {
                        icon: "account-group",
                        onClick: m[9] || (m[9] = _ => (e.value = !1,
                        E(f).push("/admin")))
                    }, {
                        default: Y( () => m[29] || (m[29] = [J(" User Management ")])),
                        _: 1
                    })], 64)) : le("", !0), E(a) ? (w(),
                    Re(Ot, {
                        key: 3,
                        icon: "star",
                        onClick: m[10] || (m[10] = _ => (e.value = !1,
                        E(f).push("/subscribe")))
                    }, {
                        default: Y( () => m[30] || (m[30] = [J(" Premium Users ")])),
                        _: 1
                    })) : le("", !0), O(v0), O(Ot, {
                        icon: "logout",
                        onClick: p
                    }, {
                        default: Y( () => m[31] || (m[31] = [J(" Log Out ")])),
                        _: 1
                    })], 64)) : (w(),
                    R(Ge, {
                        key: 1
                    }, [O(Ot, {
                        icon: "animation-play-outline",
                        onClick: m[11] || (m[11] = _ => d.value = !0)
                    }, {
                        default: Y( () => m[32] || (m[32] = [J(" Subscriptions ")])),
                        _: 1
                    }), O(Ot, {
                        icon: "heart",
                        onClick: m[12] || (m[12] = _ => d.value = !0)
                    }, {
                        default: Y( () => m[33] || (m[33] = [J(" Favorites ")])),
                        _: 1
                    })], 64))])) : h.value === 1 ? (w(),
                    R("div", JF, [O(Ot, {
                        icon: "chevron-left",
                        onClick: m[13] || (m[13] = _ => h.value = 0)
                    }), O(v0), E(l).length ? (w(),
                    R("div", QF, [(w(!0),
                    R(Ge, null, Ht(E(l), _ => (w(),
                    R(Ge, null, [_.type === E(Sh).Video ? (w(),
                    Re(Ot, {
                        key: 0,
                        onClick: y => (E(f).push(`/v/${_.data.id}`),
                        e.value = !1)
                    }, {
                        default: Y( () => [J(ee(_.data.username) + " uploaded a new video ", 1), x("span", eO, ee(_.data.name), 1)]),
                        _: 2
                    }, 1032, ["onClick"])) : le("", !0), _.type === E(Sh).VideoComment ? (w(),
                    Re(Ot, {
                        key: 1,
                        onClick: y => (E(f).push(`/v/${_.data.video_id}?comments=true`),
                        e.value = !1)
                    }, {
                        default: Y( () => [J(ee(_.data.username) + " commented on your video ", 1), x("span", tO, ee(_.data.video_name), 1)]),
                        _: 2
                    }, 1032, ["onClick"])) : le("", !0), _.type === E(Sh).VideoCommentResponse ? (w(),
                    Re(Ot, {
                        key: 2,
                        onClick: y => (E(f).push(`/v/${_.data.video_id}?comments=true`),
                        e.value = !1)
                    }, {
                        default: Y( () => [J(ee(_.data.username) + " responded to your comment on video ", 1), x("span", nO, ee(_.data.video_name), 1)]),
                        _: 2
                    }, 1032, ["onClick"])) : le("", !0)], 64))), 256))])) : (w(),
                    R("div", iO, m[34] || (m[34] = [x("p", null, "No notifications", -1), x("p", {
                        class: "text-sm text-zinc-300 mt-1.5"
                    }, " Subscribe to your favorite creators to get notified about their latest videos. ", -1)])))])) : h.value === 2 ? (w(),
                    R("div", sO, [O(Ot, {
                        icon: "chevron-left",
                        onClick: m[14] || (m[14] = _ => h.value = 0)
                    }), O(v0), O(Ot, {
                        active: E(t).getOrientation() === void 0,
                        icon: "close",
                        onClick: m[15] || (m[15] = _ => E(t).setOrientation(null))
                    }, {
                        default: Y( () => m[35] || (m[35] = [J(" None ")])),
                        _: 1
                    }, 8, ["active"]), O(Ot, {
                        active: E(t).getOrientation() === E(mn).Straight,
                        icon: "orientation-straight",
                        onClick: m[16] || (m[16] = _ => E(t).setOrientation(E(mn).Straight))
                    }, {
                        default: Y( () => m[36] || (m[36] = [J(" Straight ")])),
                        _: 1
                    }, 8, ["active"]), O(Ot, {
                        active: E(t).getOrientation() === E(mn).Transgender,
                        icon: "orientation-transgender",
                        onClick: m[17] || (m[17] = _ => E(t).setOrientation(E(mn).Transgender))
                    }, {
                        default: Y( () => m[37] || (m[37] = [J(" Transgender ")])),
                        _: 1
                    }, 8, ["active"]), O(Ot, {
                        active: E(t).getOrientation() === E(mn).Gay,
                        icon: "orientation-gay",
                        onClick: m[18] || (m[18] = _ => E(t).setOrientation(E(mn).Gay))
                    }, {
                        default: Y( () => m[38] || (m[38] = [J(" Gay ")])),
                        _: 1
                    }, 8, ["active"])])) : le("", !0)]),
                    _: 1
                })]),
                _: 1
            }, 8, ["target", "modelValue"]))], 64)
        }
    }
})
  , rO = "/handy.webm"
  , oO = "/assets/handy.a6649798.png"
  , aO = "/autoblow.webm"
  , lO = "/assets/autoblow.531473cf.png";
var bo;
(function(i) {
    i.Range = "range",
    i.Steps = "steps",
    i.Positions = "positions",
    i.Count = "count",
    i.Values = "values"
}
)(bo || (bo = {}));
var Vi;
(function(i) {
    i[i.None = -1] = "None",
    i[i.NoValue = 0] = "NoValue",
    i[i.LargeValue = 1] = "LargeValue",
    i[i.SmallValue = 2] = "SmallValue"
}
)(Vi || (Vi = {}));
function cO(i) {
    return bp(i) && typeof i.from == "function"
}
function bp(i) {
    return typeof i == "object" && typeof i.to == "function"
}
function ab(i) {
    i.parentElement.removeChild(i)
}
function I1(i) {
    return i != null
}
function lb(i) {
    i.preventDefault()
}
function uO(i) {
    return i.filter(function(e) {
        return this[e] ? !1 : this[e] = !0
    }, {})
}
function dO(i, e) {
    return Math.round(i / e) * e
}
function fO(i, e) {
    var t = i.getBoundingClientRect()
      , n = i.ownerDocument
      , s = n.documentElement
      , r = mC(n);
    return /webkit.*Chrome.*Mobile/i.test(navigator.userAgent) && (r.x = 0),
    e ? t.top + r.y - s.clientTop : t.left + r.x - s.clientLeft
}
function gr(i) {
    return typeof i == "number" && !isNaN(i) && isFinite(i)
}
function cb(i, e, t) {
    t > 0 && (Mi(i, e),
    setTimeout(function() {
        wh(i, e)
    }, t))
}
function ub(i) {
    return Math.max(Math.min(i, 100), 0)
}
function Em(i) {
    return Array.isArray(i) ? i : [i]
}
function hO(i) {
    i = String(i);
    var e = i.split(".");
    return e.length > 1 ? e[1].length : 0
}
function Mi(i, e) {
    i.classList && !/\s/.test(e) ? i.classList.add(e) : i.className += " " + e
}
function wh(i, e) {
    i.classList && !/\s/.test(e) ? i.classList.remove(e) : i.className = i.className.replace(new RegExp("(^|\\b)" + e.split(" ").join("|") + "(\\b|$)","gi"), " ")
}
function pO(i, e) {
    return i.classList ? i.classList.contains(e) : new RegExp("\\b" + e + "\\b").test(i.className)
}
function mC(i) {
    var e = window.pageXOffset !== void 0
      , t = (i.compatMode || "") === "CSS1Compat"
      , n = e ? window.pageXOffset : t ? i.documentElement.scrollLeft : i.body.scrollLeft
      , s = e ? window.pageYOffset : t ? i.documentElement.scrollTop : i.body.scrollTop;
    return {
        x: n,
        y: s
    }
}
function mO() {
    return window.navigator.pointerEnabled ? {
        start: "pointerdown",
        move: "pointermove",
        end: "pointerup"
    } : window.navigator.msPointerEnabled ? {
        start: "MSPointerDown",
        move: "MSPointerMove",
        end: "MSPointerUp"
    } : {
        start: "mousedown touchstart",
        move: "mousemove touchmove",
        end: "mouseup touchend"
    }
}
function gO() {
    var i = !1;
    try {
        var e = Object.defineProperty({}, "passive", {
            get: function() {
                i = !0
            }
        });
        window.addEventListener("test", null, e)
    } catch {}
    return i
}
function vO() {
    return window.CSS && CSS.supports && CSS.supports("touch-action", "none")
}
function W_(i, e) {
    return 100 / (e - i)
}
function k1(i, e, t) {
    return e * 100 / (i[t + 1] - i[t])
}
function _O(i, e) {
    return k1(i, i[0] < 0 ? e + Math.abs(i[0]) : e - i[0], 0)
}
function xO(i, e) {
    return e * (i[1] - i[0]) / 100 + i[0]
}
function Dd(i, e) {
    for (var t = 1; i >= e[t]; )
        t += 1;
    return t
}
function yO(i, e, t) {
    if (t >= i.slice(-1)[0])
        return 100;
    var n = Dd(t, i)
      , s = i[n - 1]
      , r = i[n]
      , o = e[n - 1]
      , a = e[n];
    return o + _O([s, r], t) / W_(o, a)
}
function bO(i, e, t) {
    if (t >= 100)
        return i.slice(-1)[0];
    var n = Dd(t, e)
      , s = i[n - 1]
      , r = i[n]
      , o = e[n - 1]
      , a = e[n];
    return xO([s, r], (t - o) * W_(o, a))
}
function SO(i, e, t, n) {
    if (n === 100)
        return n;
    var s = Dd(n, i)
      , r = i[s - 1]
      , o = i[s];
    return t ? n - r > (o - r) / 2 ? o : r : e[s - 1] ? i[s - 1] + dO(n - i[s - 1], e[s - 1]) : n
}
var gC = function() {
    function i(e, t, n) {
        this.xPct = [],
        this.xVal = [],
        this.xSteps = [],
        this.xNumSteps = [],
        this.xHighestCompleteStep = [],
        this.xSteps = [n || !1],
        this.xNumSteps = [!1],
        this.snap = t;
        var s, r = [];
        for (Object.keys(e).forEach(function(o) {
            r.push([Em(e[o]), o])
        }),
        r.sort(function(o, a) {
            return o[0][0] - a[0][0]
        }),
        s = 0; s < r.length; s++)
            this.handleEntryPoint(r[s][1], r[s][0]);
        for (this.xNumSteps = this.xSteps.slice(0),
        s = 0; s < this.xNumSteps.length; s++)
            this.handleStepPoint(s, this.xNumSteps[s])
    }
    return i.prototype.getDistance = function(e) {
        for (var t = [], n = 0; n < this.xNumSteps.length - 1; n++)
            t[n] = k1(this.xVal, e, n);
        return t
    }
    ,
    i.prototype.getAbsoluteDistance = function(e, t, n) {
        var s = 0;
        if (e < this.xPct[this.xPct.length - 1])
            for (; e > this.xPct[s + 1]; )
                s++;
        else
            e === this.xPct[this.xPct.length - 1] && (s = this.xPct.length - 2);
        !n && e === this.xPct[s + 1] && s++,
        t === null && (t = []);
        var r, o = 1, a = t[s], l = 0, c = 0, u = 0, d = 0;
        for (n ? r = (e - this.xPct[s]) / (this.xPct[s + 1] - this.xPct[s]) : r = (this.xPct[s + 1] - e) / (this.xPct[s + 1] - this.xPct[s]); a > 0; )
            l = this.xPct[s + 1 + d] - this.xPct[s + d],
            t[s + d] * o + 100 - r * 100 > 100 ? (c = l * r,
            o = (a - 100 * r) / t[s + d],
            r = 1) : (c = t[s + d] * l / 100 * o,
            o = 0),
            n ? (u = u - c,
            this.xPct.length + d >= 1 && d--) : (u = u + c,
            this.xPct.length - d >= 1 && d++),
            a = t[s + d] * o;
        return e + u
    }
    ,
    i.prototype.toStepping = function(e) {
        return e = yO(this.xVal, this.xPct, e),
        e
    }
    ,
    i.prototype.fromStepping = function(e) {
        return bO(this.xVal, this.xPct, e)
    }
    ,
    i.prototype.getStep = function(e) {
        return e = SO(this.xPct, this.xSteps, this.snap, e),
        e
    }
    ,
    i.prototype.getDefaultStep = function(e, t, n) {
        var s = Dd(e, this.xPct);
        return (e === 100 || t && e === this.xPct[s - 1]) && (s = Math.max(s - 1, 1)),
        (this.xVal[s] - this.xVal[s - 1]) / n
    }
    ,
    i.prototype.getNearbySteps = function(e) {
        var t = Dd(e, this.xPct);
        return {
            stepBefore: {
                startValue: this.xVal[t - 2],
                step: this.xNumSteps[t - 2],
                highestStep: this.xHighestCompleteStep[t - 2]
            },
            thisStep: {
                startValue: this.xVal[t - 1],
                step: this.xNumSteps[t - 1],
                highestStep: this.xHighestCompleteStep[t - 1]
            },
            stepAfter: {
                startValue: this.xVal[t],
                step: this.xNumSteps[t],
                highestStep: this.xHighestCompleteStep[t]
            }
        }
    }
    ,
    i.prototype.countStepDecimals = function() {
        var e = this.xNumSteps.map(hO);
        return Math.max.apply(null, e)
    }
    ,
    i.prototype.hasNoSize = function() {
        return this.xVal[0] === this.xVal[this.xVal.length - 1]
    }
    ,
    i.prototype.convert = function(e) {
        return this.getStep(this.toStepping(e))
    }
    ,
    i.prototype.handleEntryPoint = function(e, t) {
        var n;
        if (e === "min" ? n = 0 : e === "max" ? n = 100 : n = parseFloat(e),
        !gr(n) || !gr(t[0]))
            throw new Error("noUiSlider: 'range' value isn't numeric.");
        this.xPct.push(n),
        this.xVal.push(t[0]);
        var s = Number(t[1]);
        n ? this.xSteps.push(isNaN(s) ? !1 : s) : isNaN(s) || (this.xSteps[0] = s),
        this.xHighestCompleteStep.push(0)
    }
    ,
    i.prototype.handleStepPoint = function(e, t) {
        if (!!t) {
            if (this.xVal[e] === this.xVal[e + 1]) {
                this.xSteps[e] = this.xHighestCompleteStep[e] = this.xVal[e];
                return
            }
            this.xSteps[e] = k1([this.xVal[e], this.xVal[e + 1]], t, 0) / W_(this.xPct[e], this.xPct[e + 1]);
            var n = (this.xVal[e + 1] - this.xVal[e]) / this.xNumSteps[e]
              , s = Math.ceil(Number(n.toFixed(3)) - 1)
              , r = this.xVal[e] + this.xNumSteps[e] * s;
            this.xHighestCompleteStep[e] = r
        }
    }
    ,
    i
}()
  , db = {
    to: function(i) {
        return i === void 0 ? "" : i.toFixed(2)
    },
    from: Number
}
  , vC = {
    target: "target",
    base: "base",
    origin: "origin",
    handle: "handle",
    handleLower: "handle-lower",
    handleUpper: "handle-upper",
    touchArea: "touch-area",
    horizontal: "horizontal",
    vertical: "vertical",
    background: "background",
    connect: "connect",
    connects: "connects",
    ltr: "ltr",
    rtl: "rtl",
    textDirectionLtr: "txt-dir-ltr",
    textDirectionRtl: "txt-dir-rtl",
    draggable: "draggable",
    drag: "state-drag",
    tap: "state-tap",
    active: "active",
    tooltip: "tooltip",
    pips: "pips",
    pipsHorizontal: "pips-horizontal",
    pipsVertical: "pips-vertical",
    marker: "marker",
    markerHorizontal: "marker-horizontal",
    markerVertical: "marker-vertical",
    markerNormal: "marker-normal",
    markerLarge: "marker-large",
    markerSub: "marker-sub",
    value: "value",
    valueHorizontal: "value-horizontal",
    valueVertical: "value-vertical",
    valueNormal: "value-normal",
    valueLarge: "value-large",
    valueSub: "value-sub"
}
  , zo = {
    tooltips: ".__tooltips",
    aria: ".__aria"
};
function EO(i, e) {
    if (!gr(e))
        throw new Error("noUiSlider: 'step' is not numeric.");
    i.singleStep = e
}
function wO(i, e) {
    if (!gr(e))
        throw new Error("noUiSlider: 'keyboardPageMultiplier' is not numeric.");
    i.keyboardPageMultiplier = e
}
function TO(i, e) {
    if (!gr(e))
        throw new Error("noUiSlider: 'keyboardMultiplier' is not numeric.");
    i.keyboardMultiplier = e
}
function AO(i, e) {
    if (!gr(e))
        throw new Error("noUiSlider: 'keyboardDefaultStep' is not numeric.");
    i.keyboardDefaultStep = e
}
function CO(i, e) {
    if (typeof e != "object" || Array.isArray(e))
        throw new Error("noUiSlider: 'range' is not an object.");
    if (e.min === void 0 || e.max === void 0)
        throw new Error("noUiSlider: Missing 'min' or 'max' in 'range'.");
    i.spectrum = new gC(e,i.snap || !1,i.singleStep)
}
function MO(i, e) {
    if (e = Em(e),
    !Array.isArray(e) || !e.length)
        throw new Error("noUiSlider: 'start' option is incorrect.");
    i.handles = e.length,
    i.start = e
}
function RO(i, e) {
    if (typeof e != "boolean")
        throw new Error("noUiSlider: 'snap' option must be a boolean.");
    i.snap = e
}
function LO(i, e) {
    if (typeof e != "boolean")
        throw new Error("noUiSlider: 'animate' option must be a boolean.");
    i.animate = e
}
function IO(i, e) {
    if (typeof e != "number")
        throw new Error("noUiSlider: 'animationDuration' option must be a number.");
    i.animationDuration = e
}
function _C(i, e) {
    var t = [!1], n;
    if (e === "lower" ? e = [!0, !1] : e === "upper" && (e = [!1, !0]),
    e === !0 || e === !1) {
        for (n = 1; n < i.handles; n++)
            t.push(e);
        t.push(!1)
    } else {
        if (!Array.isArray(e) || !e.length || e.length !== i.handles + 1)
            throw new Error("noUiSlider: 'connect' option doesn't match handle count.");
        t = e
    }
    i.connect = t
}
function kO(i, e) {
    switch (e) {
    case "horizontal":
        i.ort = 0;
        break;
    case "vertical":
        i.ort = 1;
        break;
    default:
        throw new Error("noUiSlider: 'orientation' option is invalid.")
    }
}
function xC(i, e) {
    if (!gr(e))
        throw new Error("noUiSlider: 'margin' option must be numeric.");
    e !== 0 && (i.margin = i.spectrum.getDistance(e))
}
function PO(i, e) {
    if (!gr(e))
        throw new Error("noUiSlider: 'limit' option must be numeric.");
    if (i.limit = i.spectrum.getDistance(e),
    !i.limit || i.handles < 2)
        throw new Error("noUiSlider: 'limit' option is only supported on linear sliders with 2 or more handles.")
}
function DO(i, e) {
    var t;
    if (!gr(e) && !Array.isArray(e))
        throw new Error("noUiSlider: 'padding' option must be numeric or array of exactly 2 numbers.");
    if (Array.isArray(e) && !(e.length === 2 || gr(e[0]) || gr(e[1])))
        throw new Error("noUiSlider: 'padding' option must be numeric or array of exactly 2 numbers.");
    if (e !== 0) {
        for (Array.isArray(e) || (e = [e, e]),
        i.padding = [i.spectrum.getDistance(e[0]), i.spectrum.getDistance(e[1])],
        t = 0; t < i.spectrum.xNumSteps.length - 1; t++)
            if (i.padding[0][t] < 0 || i.padding[1][t] < 0)
                throw new Error("noUiSlider: 'padding' option must be a positive number(s).");
        var n = e[0] + e[1]
          , s = i.spectrum.xVal[0]
          , r = i.spectrum.xVal[i.spectrum.xVal.length - 1];
        if (n / (r - s) > 1)
            throw new Error("noUiSlider: 'padding' option must not exceed 100% of the range.")
    }
}
function FO(i, e) {
    switch (e) {
    case "ltr":
        i.dir = 0;
        break;
    case "rtl":
        i.dir = 1;
        break;
    default:
        throw new Error("noUiSlider: 'direction' option was not recognized.")
    }
}
function OO(i, e) {
    if (typeof e != "string")
        throw new Error("noUiSlider: 'behaviour' must be a string containing options.");
    var t = e.indexOf("tap") >= 0
      , n = e.indexOf("drag") >= 0
      , s = e.indexOf("fixed") >= 0
      , r = e.indexOf("snap") >= 0
      , o = e.indexOf("hover") >= 0
      , a = e.indexOf("unconstrained") >= 0
      , l = e.indexOf("invert-connects") >= 0
      , c = e.indexOf("drag-all") >= 0
      , u = e.indexOf("smooth-steps") >= 0;
    if (s) {
        if (i.handles !== 2)
            throw new Error("noUiSlider: 'fixed' behaviour must be used with 2 handles");
        xC(i, i.start[1] - i.start[0])
    }
    if (l && i.handles !== 2)
        throw new Error("noUiSlider: 'invert-connects' behaviour must be used with 2 handles");
    if (a && (i.margin || i.limit))
        throw new Error("noUiSlider: 'unconstrained' behaviour cannot be used with margin or limit");
    i.events = {
        tap: t || r,
        drag: n,
        dragAll: c,
        smoothSteps: u,
        fixed: s,
        snap: r,
        hover: o,
        unconstrained: a,
        invertConnects: l
    }
}
function UO(i, e) {
    if (e !== !1)
        if (e === !0 || bp(e)) {
            i.tooltips = [];
            for (var t = 0; t < i.handles; t++)
                i.tooltips.push(e)
        } else {
            if (e = Em(e),
            e.length !== i.handles)
                throw new Error("noUiSlider: must pass a formatter for all handles.");
            e.forEach(function(n) {
                if (typeof n != "boolean" && !bp(n))
                    throw new Error("noUiSlider: 'tooltips' must be passed a formatter or 'false'.")
            }),
            i.tooltips = e
        }
}
function NO(i, e) {
    if (e.length !== i.handles)
        throw new Error("noUiSlider: must pass a attributes for all handles.");
    i.handleAttributes = e
}
function BO(i, e) {
    if (!bp(e))
        throw new Error("noUiSlider: 'ariaFormat' requires 'to' method.");
    i.ariaFormat = e
}
function VO(i, e) {
    if (!cO(e))
        throw new Error("noUiSlider: 'format' requires 'to' and 'from' methods.");
    i.format = e
}
function $O(i, e) {
    if (typeof e != "boolean")
        throw new Error("noUiSlider: 'keyboardSupport' option must be a boolean.");
    i.keyboardSupport = e
}
function HO(i, e) {
    i.documentElement = e
}
function zO(i, e) {
    if (typeof e != "string" && e !== !1)
        throw new Error("noUiSlider: 'cssPrefix' must be a string or `false`.");
    i.cssPrefix = e
}
function GO(i, e) {
    if (typeof e != "object")
        throw new Error("noUiSlider: 'cssClasses' must be an object.");
    typeof i.cssPrefix == "string" ? (i.cssClasses = {},
    Object.keys(e).forEach(function(t) {
        i.cssClasses[t] = i.cssPrefix + e[t]
    })) : i.cssClasses = e
}
function yC(i) {
    var e = {
        margin: null,
        limit: null,
        padding: null,
        animate: !0,
        animationDuration: 300,
        ariaFormat: db,
        format: db
    }
      , t = {
        step: {
            r: !1,
            t: EO
        },
        keyboardPageMultiplier: {
            r: !1,
            t: wO
        },
        keyboardMultiplier: {
            r: !1,
            t: TO
        },
        keyboardDefaultStep: {
            r: !1,
            t: AO
        },
        start: {
            r: !0,
            t: MO
        },
        connect: {
            r: !0,
            t: _C
        },
        direction: {
            r: !0,
            t: FO
        },
        snap: {
            r: !1,
            t: RO
        },
        animate: {
            r: !1,
            t: LO
        },
        animationDuration: {
            r: !1,
            t: IO
        },
        range: {
            r: !0,
            t: CO
        },
        orientation: {
            r: !1,
            t: kO
        },
        margin: {
            r: !1,
            t: xC
        },
        limit: {
            r: !1,
            t: PO
        },
        padding: {
            r: !1,
            t: DO
        },
        behaviour: {
            r: !0,
            t: OO
        },
        ariaFormat: {
            r: !1,
            t: BO
        },
        format: {
            r: !1,
            t: VO
        },
        tooltips: {
            r: !1,
            t: UO
        },
        keyboardSupport: {
            r: !0,
            t: $O
        },
        documentElement: {
            r: !1,
            t: HO
        },
        cssPrefix: {
            r: !0,
            t: zO
        },
        cssClasses: {
            r: !0,
            t: GO
        },
        handleAttributes: {
            r: !1,
            t: NO
        }
    }
      , n = {
        connect: !1,
        direction: "ltr",
        behaviour: "tap",
        orientation: "horizontal",
        keyboardSupport: !0,
        cssPrefix: "noUi-",
        cssClasses: vC,
        keyboardPageMultiplier: 5,
        keyboardMultiplier: 1,
        keyboardDefaultStep: 10
    };
    i.format && !i.ariaFormat && (i.ariaFormat = i.format),
    Object.keys(t).forEach(function(l) {
        if (!I1(i[l]) && n[l] === void 0) {
            if (t[l].r)
                throw new Error("noUiSlider: '" + l + "' is required.");
            return
        }
        t[l].t(e, I1(i[l]) ? i[l] : n[l])
    }),
    e.pips = i.pips;
    var s = document.createElement("div")
      , r = s.style.msTransform !== void 0
      , o = s.style.transform !== void 0;
    e.transformRule = o ? "transform" : r ? "msTransform" : "webkitTransform";
    var a = [["left", "top"], ["right", "bottom"]];
    return e.style = a[e.dir][e.ort],
    e
}
function WO(i, e, t) {
    var n = mO(), s = vO(), r = s && gO(), o = i, a, l, c, u, d, f, h = e.spectrum, p = [], g = [], m = [], v = 0, _ = {}, y = !1, b = i.ownerDocument, S = e.documentElement || b.documentElement, C = b.body, M = b.dir === "rtl" || e.ort === 1 ? 0 : 100;
    function L($, Z) {
        var ne = b.createElement("div");
        return Z && Mi(ne, Z),
        $.appendChild(ne),
        ne
    }
    function T($, Z) {
        var ne = L($, e.cssClasses.origin)
          , Ne = L(ne, e.cssClasses.handle);
        if (L(Ne, e.cssClasses.touchArea),
        Ne.setAttribute("data-handle", String(Z)),
        e.keyboardSupport && (Ne.setAttribute("tabindex", "0"),
        Ne.addEventListener("keydown", function(Qe) {
            return we(Qe, Z)
        })),
        e.handleAttributes !== void 0) {
            var Ke = e.handleAttributes[Z];
            Object.keys(Ke).forEach(function(Qe) {
                Ne.setAttribute(Qe, Ke[Qe])
            })
        }
        return Ne.setAttribute("role", "slider"),
        Ne.setAttribute("aria-orientation", e.ort ? "vertical" : "horizontal"),
        Z === 0 ? Mi(Ne, e.cssClasses.handleLower) : Z === e.handles - 1 && Mi(Ne, e.cssClasses.handleUpper),
        ne.handle = Ne,
        ne
    }
    function A($, Z) {
        return Z ? L($, e.cssClasses.connect) : !1
    }
    function k($, Z) {
        l = L(Z, e.cssClasses.connects),
        c = [],
        u = [],
        u.push(A(l, $[0]));
        for (var ne = 0; ne < e.handles; ne++)
            c.push(T(Z, ne)),
            m[ne] = ne,
            u.push(A(l, $[ne + 1]))
    }
    function D($) {
        Mi($, e.cssClasses.target),
        e.dir === 0 ? Mi($, e.cssClasses.ltr) : Mi($, e.cssClasses.rtl),
        e.ort === 0 ? Mi($, e.cssClasses.horizontal) : Mi($, e.cssClasses.vertical);
        var Z = getComputedStyle($).direction;
        return Z === "rtl" ? Mi($, e.cssClasses.textDirectionRtl) : Mi($, e.cssClasses.textDirectionLtr),
        L($, e.cssClasses.base)
    }
    function F($, Z) {
        return !e.tooltips || !e.tooltips[Z] ? !1 : L($.firstChild, e.cssClasses.tooltip)
    }
    function z() {
        return o.hasAttribute("disabled")
    }
    function G($) {
        var Z = c[$];
        return Z.hasAttribute("disabled")
    }
    function H($) {
        $ != null ? (c[$].setAttribute("disabled", ""),
        c[$].handle.removeAttribute("tabindex")) : (o.setAttribute("disabled", ""),
        c.forEach(function(Z) {
            Z.handle.removeAttribute("tabindex")
        }))
    }
    function X($) {
        $ != null ? (c[$].removeAttribute("disabled"),
        c[$].handle.setAttribute("tabindex", "0")) : (o.removeAttribute("disabled"),
        c.forEach(function(Z) {
            Z.removeAttribute("disabled"),
            Z.handle.setAttribute("tabindex", "0")
        }))
    }
    function K() {
        f && (W("update" + zo.tooltips),
        f.forEach(function($) {
            $ && ab($)
        }),
        f = null)
    }
    function ce() {
        K(),
        f = c.map(F),
        N("update" + zo.tooltips, function($, Z, ne) {
            if (!(!f || !e.tooltips) && f[Z] !== !1) {
                var Ne = $[Z];
                e.tooltips[Z] !== !0 && (Ne = e.tooltips[Z].to(ne[Z])),
                f[Z].innerHTML = Ne
            }
        })
    }
    function ue() {
        W("update" + zo.aria),
        N("update" + zo.aria, function($, Z, ne, Ne, Ke) {
            m.forEach(function(Qe) {
                var yt = c[Qe]
                  , st = oe(g, Qe, 0, !0, !0, !0)
                  , an = oe(g, Qe, 100, !0, !0, !0)
                  , ln = Ke[Qe]
                  , Me = String(e.ariaFormat.to(ne[Qe]));
                st = h.fromStepping(st).toFixed(1),
                an = h.fromStepping(an).toFixed(1),
                ln = h.fromStepping(ln).toFixed(1),
                yt.children[0].setAttribute("aria-valuemin", st),
                yt.children[0].setAttribute("aria-valuemax", an),
                yt.children[0].setAttribute("aria-valuenow", ln),
                yt.children[0].setAttribute("aria-valuetext", Me)
            })
        })
    }
    function Ie($) {
        if ($.mode === bo.Range || $.mode === bo.Steps)
            return h.xVal;
        if ($.mode === bo.Count) {
            if ($.values < 2)
                throw new Error("noUiSlider: 'values' (>= 2) required for mode 'count'.");
            for (var Z = $.values - 1, ne = 100 / Z, Ne = []; Z--; )
                Ne[Z] = Z * ne;
            return Ne.push(100),
            ke(Ne, $.stepped)
        }
        return $.mode === bo.Positions ? ke($.values, $.stepped) : $.mode === bo.Values ? $.stepped ? $.values.map(function(Ke) {
            return h.fromStepping(h.getStep(h.toStepping(Ke)))
        }) : $.values : []
    }
    function ke($, Z) {
        return $.map(function(ne) {
            return h.fromStepping(Z ? h.getStep(ne) : ne)
        })
    }
    function We($) {
        function Z(ln, Me) {
            return Number((ln + Me).toFixed(7))
        }
        var ne = Ie($)
          , Ne = {}
          , Ke = h.xVal[0]
          , Qe = h.xVal[h.xVal.length - 1]
          , yt = !1
          , st = !1
          , an = 0;
        return ne = uO(ne.slice().sort(function(ln, Me) {
            return ln - Me
        })),
        ne[0] !== Ke && (ne.unshift(Ke),
        yt = !0),
        ne[ne.length - 1] !== Qe && (ne.push(Qe),
        st = !0),
        ne.forEach(function(ln, Me) {
            var ge, He, ft, It = ln, Yt = ne[Me + 1], sn, Yi, U, ie, _e, ye, ae, Ye = $.mode === bo.Steps;
            for (Ye && (ge = h.xNumSteps[Me]),
            ge || (ge = Yt - It),
            Yt === void 0 && (Yt = It),
            ge = Math.max(ge, 1e-7),
            He = It; He <= Yt; He = Z(He, ge)) {
                for (sn = h.toStepping(He),
                Yi = sn - an,
                _e = Yi / ($.density || 1),
                ye = Math.round(_e),
                ae = Yi / ye,
                ft = 1; ft <= ye; ft += 1)
                    U = an + ft * ae,
                    Ne[U.toFixed(5)] = [h.fromStepping(U), 0];
                ie = ne.indexOf(He) > -1 ? Vi.LargeValue : Ye ? Vi.SmallValue : Vi.NoValue,
                !Me && yt && He !== Yt && (ie = 0),
                He === Yt && st || (Ne[sn.toFixed(5)] = [He, ie]),
                an = sn
            }
        }),
        Ne
    }
    function se($, Z, ne) {
        var Ne, Ke, Qe = b.createElement("div"), yt = (Ne = {},
        Ne[Vi.None] = "",
        Ne[Vi.NoValue] = e.cssClasses.valueNormal,
        Ne[Vi.LargeValue] = e.cssClasses.valueLarge,
        Ne[Vi.SmallValue] = e.cssClasses.valueSub,
        Ne), st = (Ke = {},
        Ke[Vi.None] = "",
        Ke[Vi.NoValue] = e.cssClasses.markerNormal,
        Ke[Vi.LargeValue] = e.cssClasses.markerLarge,
        Ke[Vi.SmallValue] = e.cssClasses.markerSub,
        Ke), an = [e.cssClasses.valueHorizontal, e.cssClasses.valueVertical], ln = [e.cssClasses.markerHorizontal, e.cssClasses.markerVertical];
        Mi(Qe, e.cssClasses.pips),
        Mi(Qe, e.ort === 0 ? e.cssClasses.pipsHorizontal : e.cssClasses.pipsVertical);
        function Me(He, ft) {
            var It = ft === e.cssClasses.value
              , Yt = It ? an : ln
              , sn = It ? yt : st;
            return ft + " " + Yt[e.ort] + " " + sn[He]
        }
        function ge(He, ft, It) {
            if (It = Z ? Z(ft, It) : It,
            It !== Vi.None) {
                var Yt = L(Qe, !1);
                Yt.className = Me(It, e.cssClasses.marker),
                Yt.style[e.style] = He + "%",
                It > Vi.NoValue && (Yt = L(Qe, !1),
                Yt.className = Me(It, e.cssClasses.value),
                Yt.setAttribute("data-value", String(ft)),
                Yt.style[e.style] = He + "%",
                Yt.innerHTML = String(ne.to(ft)))
            }
        }
        return Object.keys($).forEach(function(He) {
            ge(He, $[He][0], $[He][1])
        }),
        Qe
    }
    function Se() {
        d && (ab(d),
        d = null)
    }
    function be($) {
        Se();
        var Z = We($)
          , ne = $.filter
          , Ne = $.format || {
            to: function(Ke) {
                return String(Math.round(Ke))
            }
        };
        return d = o.appendChild(se(Z, ne, Ne)),
        d
    }
    function q() {
        var $ = a.getBoundingClientRect()
          , Z = "offset" + ["Width", "Height"][e.ort];
        return e.ort === 0 ? $.width || a[Z] : $.height || a[Z]
    }
    function me($, Z, ne, Ne) {
        var Ke = function(yt) {
            var st = Ce(yt, Ne.pageOffset, Ne.target || Z);
            if (!st || z() && !Ne.doNotReject || pO(o, e.cssClasses.tap) && !Ne.doNotReject || $ === n.start && st.buttons !== void 0 && st.buttons > 1 || Ne.hover && st.buttons)
                return !1;
            r || st.preventDefault(),
            st.calcPoint = st.points[e.ort],
            ne(st, Ne)
        }
          , Qe = [];
        return $.split(" ").forEach(function(yt) {
            Z.addEventListener(yt, Ke, r ? {
                passive: !0
            } : !1),
            Qe.push([yt, Ke])
        }),
        Qe
    }
    function Ce($, Z, ne) {
        var Ne = $.type.indexOf("touch") === 0
          , Ke = $.type.indexOf("mouse") === 0
          , Qe = $.type.indexOf("pointer") === 0
          , yt = 0
          , st = 0;
        if ($.type.indexOf("MSPointer") === 0 && (Qe = !0),
        $.type === "mousedown" && !$.buttons && !$.touches)
            return !1;
        if (Ne) {
            var an = function(ge) {
                var He = ge.target;
                return He === ne || ne.contains(He) || $.composed && $.composedPath().shift() === ne
            };
            if ($.type === "touchstart") {
                var ln = Array.prototype.filter.call($.touches, an);
                if (ln.length > 1)
                    return !1;
                yt = ln[0].pageX,
                st = ln[0].pageY
            } else {
                var Me = Array.prototype.find.call($.changedTouches, an);
                if (!Me)
                    return !1;
                yt = Me.pageX,
                st = Me.pageY
            }
        }
        return Z = Z || mC(b),
        (Ke || Qe) && (yt = $.clientX + Z.x,
        st = $.clientY + Z.y),
        $.pageOffset = Z,
        $.points = [yt, st],
        $.cursor = Ke || Qe,
        $
    }
    function Pe($) {
        var Z = $ - fO(a, e.ort)
          , ne = Z * 100 / q();
        return ne = ub(ne),
        e.dir ? 100 - ne : ne
    }
    function vt($) {
        var Z = 100
          , ne = !1;
        return c.forEach(function(Ne, Ke) {
            if (!G(Ke)) {
                var Qe = g[Ke]
                  , yt = Math.abs(Qe - $)
                  , st = yt === 100 && Z === 100
                  , an = yt < Z
                  , ln = yt <= Z && $ > Qe;
                (an || ln || st) && (ne = Ke,
                Z = yt)
            }
        }),
        ne
    }
    function j($, Z) {
        $.type === "mouseout" && $.target.nodeName === "HTML" && $.relatedTarget === null && V($, Z)
    }
    function B($, Z) {
        if (navigator.appVersion.indexOf("MSIE 9") === -1 && $.buttons === 0 && Z.buttonsProperty !== 0)
            return V($, Z);
        var ne = (e.dir ? -1 : 1) * ($.calcPoint - Z.startCalcPoint)
          , Ne = ne * 100 / Z.baseSize;
        $e(ne > 0, Ne, Z.locations, Z.handleNumbers, Z.connect)
    }
    function V($, Z) {
        Z.handle && (wh(Z.handle, e.cssClasses.active),
        v -= 1),
        Z.listeners.forEach(function(ne) {
            S.removeEventListener(ne[0], ne[1])
        }),
        v === 0 && (wh(o, e.cssClasses.drag),
        nt(),
        $.cursor && (C.style.cursor = "",
        C.removeEventListener("selectstart", lb))),
        e.events.smoothSteps && (Z.handleNumbers.forEach(function(ne) {
            Be(ne, g[ne], !0, !0, !1, !1)
        }),
        Z.handleNumbers.forEach(function(ne) {
            re("update", ne)
        })),
        Z.handleNumbers.forEach(function(ne) {
            re("change", ne),
            re("set", ne),
            re("end", ne)
        })
    }
    function Q($, Z) {
        if (!Z.handleNumbers.some(G)) {
            var ne;
            if (Z.handleNumbers.length === 1) {
                var Ne = c[Z.handleNumbers[0]];
                ne = Ne.children[0],
                v += 1,
                Mi(ne, e.cssClasses.active)
            }
            $.stopPropagation();
            var Ke = []
              , Qe = me(n.move, S, B, {
                target: $.target,
                handle: ne,
                connect: Z.connect,
                listeners: Ke,
                startCalcPoint: $.calcPoint,
                baseSize: q(),
                pageOffset: $.pageOffset,
                handleNumbers: Z.handleNumbers,
                buttonsProperty: $.buttons,
                locations: g.slice()
            })
              , yt = me(n.end, S, V, {
                target: $.target,
                handle: ne,
                listeners: Ke,
                doNotReject: !0,
                handleNumbers: Z.handleNumbers
            })
              , st = me("mouseout", S, j, {
                target: $.target,
                handle: ne,
                listeners: Ke,
                doNotReject: !0,
                handleNumbers: Z.handleNumbers
            });
            Ke.push.apply(Ke, Qe.concat(yt, st)),
            $.cursor && (C.style.cursor = getComputedStyle($.target).cursor,
            c.length > 1 && Mi(o, e.cssClasses.drag),
            C.addEventListener("selectstart", lb, !1)),
            Z.handleNumbers.forEach(function(an) {
                re("start", an)
            })
        }
    }
    function he($) {
        $.stopPropagation();
        var Z = Pe($.calcPoint)
          , ne = vt(Z);
        ne !== !1 && (e.events.snap || cb(o, e.cssClasses.tap, e.animationDuration),
        Be(ne, Z, !0, !0),
        nt(),
        re("slide", ne, !0),
        re("update", ne, !0),
        e.events.snap ? Q($, {
            handleNumbers: [ne]
        }) : (re("change", ne, !0),
        re("set", ne, !0)))
    }
    function Ee($) {
        var Z = Pe($.calcPoint)
          , ne = h.getStep(Z)
          , Ne = h.fromStepping(ne);
        Object.keys(_).forEach(function(Ke) {
            Ke.split(".")[0] === "hover" && _[Ke].forEach(function(Qe) {
                Qe.call(Wt, Ne)
            })
        })
    }
    function we($, Z) {
        if (z() || G(Z))
            return !1;
        var ne = ["Left", "Right"]
          , Ne = ["Down", "Up"]
          , Ke = ["PageDown", "PageUp"]
          , Qe = ["Home", "End"];
        e.dir && !e.ort ? ne.reverse() : e.ort && !e.dir && (Ne.reverse(),
        Ke.reverse());
        var yt = $.key.replace("Arrow", "")
          , st = yt === Ke[0]
          , an = yt === Ke[1]
          , ln = yt === Ne[0] || yt === ne[0] || st
          , Me = yt === Ne[1] || yt === ne[1] || an
          , ge = yt === Qe[0]
          , He = yt === Qe[1];
        if (!ln && !Me && !ge && !He)
            return !0;
        $.preventDefault();
        var ft;
        if (Me || ln) {
            var It = ln ? 0 : 1
              , Yt = te(Z)
              , sn = Yt[It];
            if (sn === null)
                return !1;
            sn === !1 && (sn = h.getDefaultStep(g[Z], ln, e.keyboardDefaultStep)),
            an || st ? sn *= e.keyboardPageMultiplier : sn *= e.keyboardMultiplier,
            sn = Math.max(sn, 1e-7),
            sn = (ln ? -1 : 1) * sn,
            ft = p[Z] + sn
        } else
            He ? ft = e.spectrum.xVal[e.spectrum.xVal.length - 1] : ft = e.spectrum.xVal[0];
        return Be(Z, h.toStepping(ft), !0, !0),
        re("slide", Z),
        re("update", Z),
        re("change", Z),
        re("set", Z),
        !1
    }
    function Le($) {
        $.fixed || c.forEach(function(Z, ne) {
            me(n.start, Z.children[0], Q, {
                handleNumbers: [ne]
            })
        }),
        $.tap && me(n.start, a, he, {}),
        $.hover && me(n.move, a, Ee, {
            hover: !0
        }),
        $.drag && u.forEach(function(Z, ne) {
            if (!(Z === !1 || ne === 0 || ne === u.length - 1)) {
                var Ne = c[ne - 1]
                  , Ke = c[ne]
                  , Qe = [Z]
                  , yt = [Ne, Ke]
                  , st = [ne - 1, ne];
                Mi(Z, e.cssClasses.draggable),
                $.fixed && (Qe.push(Ne.children[0]),
                Qe.push(Ke.children[0])),
                $.dragAll && (yt = c,
                st = m),
                Qe.forEach(function(an) {
                    me(n.start, an, Q, {
                        handles: yt,
                        handleNumbers: st,
                        connect: Z
                    })
                })
            }
        })
    }
    function N($, Z) {
        _[$] = _[$] || [],
        _[$].push(Z),
        $.split(".")[0] === "update" && c.forEach(function(ne, Ne) {
            re("update", Ne)
        })
    }
    function I($) {
        return $ === zo.aria || $ === zo.tooltips
    }
    function W($) {
        var Z = $ && $.split(".")[0]
          , ne = Z ? $.substring(Z.length) : $;
        Object.keys(_).forEach(function(Ne) {
            var Ke = Ne.split(".")[0]
              , Qe = Ne.substring(Ke.length);
            (!Z || Z === Ke) && (!ne || ne === Qe) && (!I(Qe) || ne === Qe) && delete _[Ne]
        })
    }
    function re($, Z, ne) {
        Object.keys(_).forEach(function(Ne) {
            var Ke = Ne.split(".")[0];
            $ === Ke && _[Ne].forEach(function(Qe) {
                Qe.call(Wt, p.map(e.format.to), Z, p.slice(), ne || !1, g.slice(), Wt)
            })
        })
    }
    function oe($, Z, ne, Ne, Ke, Qe, yt) {
        var st;
        return c.length > 1 && !e.events.unconstrained && (Ne && Z > 0 && (st = h.getAbsoluteDistance($[Z - 1], e.margin, !1),
        ne = Math.max(ne, st)),
        Ke && Z < c.length - 1 && (st = h.getAbsoluteDistance($[Z + 1], e.margin, !0),
        ne = Math.min(ne, st))),
        c.length > 1 && e.limit && (Ne && Z > 0 && (st = h.getAbsoluteDistance($[Z - 1], e.limit, !1),
        ne = Math.min(ne, st)),
        Ke && Z < c.length - 1 && (st = h.getAbsoluteDistance($[Z + 1], e.limit, !0),
        ne = Math.max(ne, st))),
        e.padding && (Z === 0 && (st = h.getAbsoluteDistance(0, e.padding[0], !1),
        ne = Math.max(ne, st)),
        Z === c.length - 1 && (st = h.getAbsoluteDistance(100, e.padding[1], !0),
        ne = Math.min(ne, st))),
        yt || (ne = h.getStep(ne)),
        ne = ub(ne),
        ne === $[Z] && !Qe ? !1 : ne
    }
    function fe($, Z) {
        var ne = e.ort;
        return (ne ? Z : $) + ", " + (ne ? $ : Z)
    }
    function $e($, Z, ne, Ne, Ke) {
        var Qe = ne.slice()
          , yt = Ne[0]
          , st = e.events.smoothSteps
          , an = [!$, $]
          , ln = [$, !$];
        Ne = Ne.slice(),
        $ && Ne.reverse(),
        Ne.length > 1 ? Ne.forEach(function(ge, He) {
            var ft = oe(Qe, ge, Qe[ge] + Z, an[He], ln[He], !1, st);
            ft === !1 ? Z = 0 : (Z = ft - Qe[ge],
            Qe[ge] = ft)
        }) : an = ln = [!0];
        var Me = !1;
        Ne.forEach(function(ge, He) {
            Me = Be(ge, ne[ge] + Z, an[He], ln[He], !1, st) || Me
        }),
        Me && (Ne.forEach(function(ge) {
            re("update", ge),
            re("slide", ge)
        }),
        Ke != null && re("drag", yt))
    }
    function Oe($, Z) {
        return e.dir ? 100 - $ - Z : $
    }
    function qe($, Z) {
        g[$] = Z,
        p[$] = h.fromStepping(Z);
        var ne = Oe(Z, 0) - M
          , Ne = "translate(" + fe(ne + "%", "0") + ")";
        if (c[$].style[e.transformRule] = Ne,
        e.events.invertConnects && g.length > 1) {
            var Ke = g.every(function(Qe, yt, st) {
                return yt === 0 || Qe >= st[yt - 1]
            });
            if (y !== !Ke) {
                et();
                return
            }
        }
        Xe($),
        Xe($ + 1),
        y && (Xe($ - 1),
        Xe($ + 2))
    }
    function nt() {
        m.forEach(function($) {
            var Z = g[$] > 50 ? -1 : 1
              , ne = 3 + (c.length + Z * $);
            c[$].style.zIndex = String(ne)
        })
    }
    function Be($, Z, ne, Ne, Ke, Qe) {
        return Ke || (Z = oe(g, $, Z, ne, Ne, !1, Qe)),
        Z === !1 ? !1 : (qe($, Z),
        !0)
    }
    function Xe($) {
        if (!!u[$]) {
            var Z = g.slice();
            y && Z.sort(function(st, an) {
                return st - an
            });
            var ne = 0
              , Ne = 100;
            $ !== 0 && (ne = Z[$ - 1]),
            $ !== u.length - 1 && (Ne = Z[$]);
            var Ke = Ne - ne
              , Qe = "translate(" + fe(Oe(ne, Ke) + "%", "0") + ")"
              , yt = "scale(" + fe(Ke / 100, "1") + ")";
            u[$].style[e.transformRule] = Qe + " " + yt
        }
    }
    function Rt($, Z) {
        return $ === null || $ === !1 || $ === void 0 || (typeof $ == "number" && ($ = String($)),
        $ = e.format.from($),
        $ !== !1 && ($ = h.toStepping($)),
        $ === !1 || isNaN($)) ? g[Z] : $
    }
    function ht($, Z, ne) {
        var Ne = Em($)
          , Ke = g[0] === void 0;
        Z = Z === void 0 ? !0 : Z,
        e.animate && !Ke && cb(o, e.cssClasses.tap, e.animationDuration),
        m.forEach(function(st) {
            Be(st, Rt(Ne[st], st), !0, !1, ne)
        });
        var Qe = m.length === 1 ? 0 : 1;
        if (Ke && h.hasNoSize() && (ne = !0,
        g[0] = 0,
        m.length > 1)) {
            var yt = 100 / (m.length - 1);
            m.forEach(function(st) {
                g[st] = st * yt
            })
        }
        for (; Qe < m.length; ++Qe)
            m.forEach(function(st) {
                Be(st, g[st], !0, !0, ne)
            });
        nt(),
        m.forEach(function(st) {
            re("update", st),
            Ne[st] !== null && Z && re("set", st)
        })
    }
    function lt($) {
        ht(e.start, $)
    }
    function kt($, Z, ne, Ne) {
        if ($ = Number($),
        !($ >= 0 && $ < m.length))
            throw new Error("noUiSlider: invalid handle number, got: " + $);
        Be($, Rt(Z, $), !0, !0, Ne),
        re("update", $),
        ne && re("set", $)
    }
    function _t($) {
        if ($ === void 0 && ($ = !1),
        $)
            return p.length === 1 ? p[0] : p.slice(0);
        var Z = p.map(e.format.to);
        return Z.length === 1 ? Z[0] : Z
    }
    function Xt() {
        for (W(zo.aria),
        W(zo.tooltips),
        Object.keys(e.cssClasses).forEach(function($) {
            wh(o, e.cssClasses[$])
        }); o.firstChild; )
            o.removeChild(o.firstChild);
        delete o.noUiSlider
    }
    function te($) {
        var Z = g[$]
          , ne = h.getNearbySteps(Z)
          , Ne = p[$]
          , Ke = ne.thisStep.step
          , Qe = null;
        if (e.snap)
            return [Ne - ne.stepBefore.startValue || null, ne.stepAfter.startValue - Ne || null];
        Ke !== !1 && Ne + Ke > ne.stepAfter.startValue && (Ke = ne.stepAfter.startValue - Ne),
        Ne > ne.thisStep.startValue ? Qe = ne.thisStep.step : ne.stepBefore.step === !1 ? Qe = !1 : Qe = Ne - ne.stepBefore.highestStep,
        Z === 100 ? Ke = null : Z === 0 && (Qe = null);
        var yt = h.countStepDecimals();
        return Ke !== null && Ke !== !1 && (Ke = Number(Ke.toFixed(yt))),
        Qe !== null && Qe !== !1 && (Qe = Number(Qe.toFixed(yt))),
        [Qe, Ke]
    }
    function Je() {
        return m.map(te)
    }
    function De($, Z) {
        var ne = _t()
          , Ne = ["margin", "limit", "padding", "range", "animate", "snap", "step", "format", "pips", "tooltips", "connect"];
        Ne.forEach(function(Qe) {
            $[Qe] !== void 0 && (t[Qe] = $[Qe])
        });
        var Ke = yC(t);
        Ne.forEach(function(Qe) {
            $[Qe] !== void 0 && (e[Qe] = Ke[Qe])
        }),
        h = Ke.spectrum,
        e.margin = Ke.margin,
        e.limit = Ke.limit,
        e.padding = Ke.padding,
        e.pips ? be(e.pips) : Se(),
        e.tooltips ? ce() : K(),
        g = [],
        ht(I1($.start) ? $.start : ne, Z),
        $.connect && Ue()
    }
    function Ue() {
        for (; l.firstChild; )
            l.removeChild(l.firstChild);
        for (var $ = 0; $ <= e.handles; $++)
            u[$] = A(l, e.connect[$]),
            Xe($);
        Le({
            drag: e.events.drag,
            fixed: !0
        })
    }
    function et() {
        y = !y,
        _C(e, e.connect.map(function($) {
            return !$
        })),
        Ue()
    }
    function Lt() {
        a = D(o),
        k(e.connect, a),
        Le(e.events),
        ht(e.start),
        e.pips && be(e.pips),
        e.tooltips && ce(),
        ue()
    }
    Lt();
    var Wt = {
        destroy: Xt,
        steps: Je,
        on: N,
        off: W,
        get: _t,
        set: ht,
        setHandle: kt,
        reset: lt,
        disable: H,
        enable: X,
        __moveHandles: function($, Z, ne) {
            $e($, Z, g, ne)
        },
        options: t,
        updateOptions: De,
        target: o,
        removePips: Se,
        removeTooltips: K,
        getPositions: function() {
            return g.slice()
        },
        getTooltips: function() {
            return f
        },
        getOrigins: function() {
            return c
        },
        pips: be
    };
    return Wt
}
function qO(i, e) {
    if (!i || !i.nodeName)
        throw new Error("noUiSlider: create requires a single element, got: " + i);
    if (i.noUiSlider)
        throw new Error("noUiSlider: Slider was already initialized.");
    var t = yC(e)
      , n = WO(i, t, e);
    return i.noUiSlider = n,
    n
}
const jO = {
    __spectrum: gC,
    cssClasses: vC,
    create: qO
}
  , fo = ut({
    __name: "Slider",
    props: {
        modelValue: {},
        min: {},
        max: {},
        tooltips: {
            type: Boolean,
            default: !1
        },
        values: {},
        suffix: {}
    },
    emits: ["update:modelValue"],
    setup(i, {emit: e}) {
        const t = xe()
          , n = i
          , s = e;
        let r;
        return Ln( () => {
            r = jO.create(t.value, {
                start: n.modelValue,
                connect: typeof n.modelValue == "number" ? "lower" : !0,
                behaviour: "snap",
                range: {
                    min: n.min,
                    max: n.max
                },
                format: {
                    to: o => `${o.toFixed(0)}${n.suffix || ""}`,
                    from: o => parseInt(parseInt(o).toFixed(0))
                },
                step: 1,
                tooltips: n.tooltips,
                cssPrefix: "slider-",
                pips: {
                    mode: bo.Values,
                    values: n.values
                }
            }),
            r.on("change", (o, a, l) => {
                l.length === 1 ? s("update:modelValue", Math.round(l[0])) : s("update:modelValue", l)
            }
            ),
            t.value.addEventListener("click", o => {
                const a = o.target;
                if (a && a.classList.contains("slider-value")) {
                    const l = parseInt(a.getAttribute("data-value"));
                    if (typeof n.modelValue == "number")
                        s("update:modelValue", l);
                    else {
                        const c = Object.assign([], n.modelValue);
                        Math.abs(c[0] - l) < Math.abs(c[1] - l) ? c[0] = l : c[1] = l,
                        s("update:modelValue", c)
                    }
                }
            }
            )
        }
        ),
        Bt( () => n.modelValue, o => r.set(o)),
        (o, a) => (w(),
        R("div", {
            ref_key: "slider",
            ref: t
        }, null, 512))
    }
});
const KO = {
    class: "flex-1"
}
  , XO = {
    class: "bg-zinc-800"
}
  , Lf = ut({
    __name: "SettingsPopupCollapse",
    props: {
        title: {}
    },
    setup(i) {
        const e = i
          , t = xe(!1);
        return (n, s) => (w(),
        R("div", null, [x("div", {
            onClick: s[0] || (s[0] = r => t.value = !t.value),
            class: "flex py-1.5 md:py-1.5 px-3 items-center gap-3 hover:bg-blue-500 cursor-pointer text-lg md:text-base hover:bg-blue-500"
        }, [O(ze, {
            name: "cog",
            class: "h-6 w-6 md:h-6 md:w-5"
        }), x("span", KO, ee(e.title), 1), O(ze, {
            name: "chevron-right",
            class: Pt(["h-5 w-5 transition-transform", t.value ? "-rotate-90" : "rotate-90"])
        }, null, 8, ["class"])]), zt(x("div", XO, [Nl(n.$slots, "default")], 512), [[$n, t.value]])]))
    }
})
  , za = ut({
    __name: "Toggle",
    props: {
        modelValue: {
            type: Boolean,
            default: !0
        }
    },
    emits: ["update:modelValue", "change"],
    setup(i, {emit: e}) {
        const t = e
          , n = i;
        return (s, r) => (w(),
        R("button", {
            onClick: r[0] || (r[0] = o => {
                t("update:modelValue", !n.modelValue),
                t("change")
            }
            ),
            type: "button",
            class: Pt([n.modelValue ? "bg-blue-500" : "bg-zinc-400", "relative inline-flex flex-shrink-0 h-5 w-10 border-2 border-transparent rounded-full cursor-pointer transition-colors ease-in-out duration-200 focus:outline-none"]),
            role: "switch",
            "aria-checked": "false"
        }, [x("span", {
            "aria-hidden": "true",
            class: Pt([n.modelValue ? "translate-x-5" : "translate-x-0", "pointer-events-none inline-block h-4 w-4 rounded-full bg-white transform ring-0 transition ease-in-out duration-200"])
        }, null, 2)], 2))
    }
})
  , YO = {
    class: "text-white"
}
  , ZO = {
    key: 0,
    class: "lg:w-80"
}
  , JO = {
    class: "flex items-center justify-between"
}
  , QO = {
    key: 0,
    class: "rounded py-1 px-2.5 bg-green-500 text-xs text-green-50 font-semibold"
}
  , e7 = {
    class: "flex items-center justify-between"
}
  , t7 = {
    key: 0,
    class: "rounded py-1 px-2.5 bg-green-500 text-xs text-green-50 font-semibold"
}
  , n7 = {
    class: "flex items-center justify-between"
}
  , i7 = {
    key: 0,
    class: "rounded- py-1 px-2.5 bg-green-500 text-xs text-green-50 font-semibold"
}
  , s7 = {
    class: "flex items-center justify-between"
}
  , r7 = {
    key: 0,
    class: "rounded py-1 px-2.5 bg-green-500 text-xs text-green-50 font-semibold"
}
  , o7 = {
    class: "flex items-center justify-between"
}
  , a7 = {
    key: 0,
    class: "rounded py-1 px-2.5 bg-green-500 text-xs text-green-50 font-semibold"
}
  , l7 = {
    class: "flex items-center justify-between"
}
  , c7 = {
    key: 0,
    class: "rounded py-1 px-2.5 bg-green-500 text-xs text-green-50 font-semibold"
}
  , u7 = {
    class: "flex items-center justify-between"
}
  , d7 = {
    key: 0,
    class: "rounded py-1 px-2.5 bg-green-500 text-xs text-green-50 font-semibold ml-2"
}
  , f7 = {
    key: 1,
    class: "lg:max-w-3xl"
}
  , h7 = {
    class: "grid grid-cols-1 lg:grid-cols-2 gap-6 lg:max-w-3xl items-center p-3"
}
  , p7 = {
    key: 0,
    "data-ph-capture-attribute-connector-handy": "1",
    href: "https://www.thehandy.com/?ref=faptap&utm_source=faptap&utm_medium=affiliate&utm_campaign=The+Handy+Affiliate+program&tap_s=3539267-2a196b&tm_subid1=connector",
    target: "_blank",
    class: "leading-normal flex flex-col gap-2"
}
  , m7 = {
    key: 0,
    class: "bg-white rounded-lg w-full aspect-video overflow-hidden"
}
  , g7 = {
    key: 0,
    muted: "",
    autoplay: "",
    loop: "",
    src: rO,
    class: "w-full h-full"
}
  , v7 = {
    key: 1,
    src: oO,
    class: "w-full h-full"
}
  , _7 = {
    key: 1,
    class: "lg:text-sm text-zinc-300 flex-1 text-center lg:text-left"
}
  , x7 = {
    key: 2,
    class: "text-center font-medium"
}
  , y7 = {
    key: 1,
    class: "px-4 py-2"
}
  , b7 = {
    class: "flex items-center justify-between"
}
  , S7 = {
    class: "font-medium"
}
  , E7 = {
    class: "text-sm text-zinc-500 ml-1"
}
  , w7 = {
    class: "mt-4"
}
  , T7 = {
    class: "font-medium"
}
  , A7 = {
    class: "text-sm text-zinc-500 ml-1"
}
  , C7 = {
    class: "flex items-center justify-between"
}
  , M7 = {
    class: "flex flex-col items-center text-center text-white gap-y-3 mt-4 md:mt-0 h-full !order-first lg:!order-last"
}
  , R7 = {
    class: "flex items-center flex-1"
}
  , L7 = {
    class: "text-red-500 font-medium my-2"
}
  , I7 = {
    key: 0
}
  , k7 = {
    key: 1,
    class: "text-green-500"
}
  , P7 = {
    key: 2,
    class: "lg:max-w-3xl"
}
  , D7 = {
    class: "grid grid-cols-1 lg:grid-cols-2 gap-6 lg:max-w-3xl items-center p-3"
}
  , F7 = {
    key: 0,
    "data-ph-capture-attribute-connector-autoblow": "1",
    href: "https://autoblow.com/#autoblow-comparison",
    target: "_blank",
    class: "leading-normal flex flex-col gap-2"
}
  , O7 = {
    key: 0,
    class: "bg-white rounded-lg w-full aspect-video overflow-hidden"
}
  , U7 = {
    key: 0,
    muted: "",
    autoplay: "",
    loop: "",
    src: aO,
    class: "w-full h-full"
}
  , N7 = {
    key: 1,
    src: lO,
    class: "w-full h-full"
}
  , B7 = {
    key: 1,
    class: "lg:text-sm text-zinc-300 flex-1 text-center lg:text-left"
}
  , V7 = {
    key: 2,
    class: "text-center font-medium"
}
  , $7 = {
    key: 1,
    class: "px-4 py-2"
}
  , H7 = {
    class: "flex items-center justify-between"
}
  , z7 = {
    class: "font-medium"
}
  , G7 = {
    class: "text-sm text-zinc-500 ml-1"
}
  , W7 = {
    class: "flex items-center justify-between"
}
  , q7 = {
    class: "flex flex-col items-center text-center text-white gap-y-3 mt-4 md:mt-0 h-full !order-first lg:!order-last"
}
  , j7 = {
    class: "flex items-center flex-1"
}
  , K7 = {
    class: "text-red-500 font-medium my-2"
}
  , X7 = {
    key: 0
}
  , Y7 = {
    key: 1,
    class: "text-green-500"
}
  , Z7 = {
    key: 3,
    class: "lg:w-80"
}
  , J7 = {
    class: "flex flex-col items-center text-center text-white gap-y-3 mt-4 md:mt-0 px-3 py-2"
}
  , Q7 = {
    class: "flex items-center"
}
  , e9 = {
    key: 0,
    class: "my-3 rounded-md border border-zinc-700 overflow-hidden divide-y divide-zinc-700 w-full"
}
  , t9 = {
    class: "px-3 py-3 flex items-center justify-between"
}
  , n9 = {
    class: "font-medium"
}
  , i9 = {
    key: 0,
    class: "flex flex items-center text-zinc-300"
}
  , s9 = {
    class: "ml-1"
}
  , r9 = {
    key: 1,
    class: "font-medium text-red-500"
}
  , o9 = {
    class: "px-4 py-2"
}
  , a9 = {
    class: "mt-4"
}
  , l9 = {
    class: "flex items-center justify-between"
}
  , c9 = {
    class: "font-medium"
}
  , u9 = {
    class: "text-sm text-zinc-500 ml-1"
}
  , d9 = {
    class: "flex items-center justify-between"
}
  , f9 = {
    key: 4,
    class: "lg:w-80"
}
  , h9 = {
    class: "flex flex-col items-center text-center text-white gap-y-3 mt-4 md:mt-0 px-3 py-2"
}
  , p9 = {
    class: "flex items-center"
}
  , m9 = {
    key: 1,
    class: "font-medium text-red-500"
}
  , g9 = {
    class: "px-4 py-2"
}
  , v9 = {
    class: "mt-4"
}
  , _9 = {
    class: "flex items-center justify-between"
}
  , x9 = {
    class: "font-medium"
}
  , y9 = {
    class: "text-sm text-zinc-500 ml-1"
}
  , b9 = {
    class: "flex items-center justify-between"
}
  , S9 = {
    key: 5,
    class: "lg:w-80"
}
  , E9 = {
    class: "flex flex-col items-center text-center text-white gap-y-3 mt-4 md:mt-0 px-3 py-2"
}
  , w9 = {
    class: "flex items-center"
}
  , T9 = {
    class: "text-red-500 font-medium my-2"
}
  , A9 = {
    key: 0
}
  , C9 = {
    key: 1,
    class: "text-green-500"
}
  , M9 = {
    class: "px-4 py-2"
}
  , R9 = {
    class: "mt-4"
}
  , L9 = {
    class: "flex items-center justify-between"
}
  , I9 = {
    class: "font-medium"
}
  , k9 = {
    class: "text-sm text-zinc-500 ml-1"
}
  , P9 = {
    class: "flex items-center justify-between"
}
  , D9 = {
    key: 6,
    class: "lg:w-80"
}
  , F9 = {
    class: "flex flex-col items-center text-center text-white gap-y-3 mt-4 md:mt-0 px-3 py-2"
}
  , O9 = {
    class: "flex items-center"
}
  , U9 = {
    class: "text-red-500 font-medium my-2"
}
  , N9 = {
    key: 0
}
  , B9 = {
    key: 1,
    class: "text-green-500"
}
  , V9 = {
    class: "px-4 py-2"
}
  , $9 = {
    class: "flex items-center justify-between"
}
  , H9 = {
    class: "font-medium"
}
  , z9 = {
    class: "text-sm text-zinc-500 ml-1"
}
  , G9 = {
    key: 7,
    class: "lg:max-w-3xl"
}
  , W9 = {
    key: 0,
    class: "px-4 py-2"
}
  , q9 = {
    class: "flex items-center justify-between"
}
  , j9 = {
    class: "mt-4"
}
  , K9 = {
    class: "flex items-center justify-between"
}
  , X9 = {
    class: "font-medium"
}
  , Y9 = {
    class: "text-sm text-zinc-500 ml-1"
}
  , Z9 = {
    class: "mt-4"
}
  , J9 = {
    class: "flex gap-4"
}
  , Q9 = {
    class: "mt-4"
}
  , eU = {
    class: "flex flex-col items-center text-center text-white gap-y-3 mt-4 md:mt-0 h-full !order-first lg:!order-last"
}
  , tU = {
    class: "flex items-center flex-1"
}
  , nU = {
    class: "text-red-500 font-medium my-4"
}
  , iU = {
    key: 0
}
  , sU = {
    key: 1,
    class: "text-green-500"
}
  , rU = ut({
    __name: "DeviceConnector",
    setup(i) {
        const {isMobile: e} = Ks()
          , t = Zr();
        return (n, s) => (w(),
        R("div", YO, [O(y_, {
            mode: "out-in"
        }, {
            default: Y( () => [E(t).ui.page === E(On).Start ? (w(),
            R("div", ZO, [O(Ot, {
                icon: "thehandy",
                arrow: !0,
                onClick: s[0] || (s[0] = r => E(t).ui.page = E(On).Handy)
            }, {
                default: Y( () => [x("div", JO, [s[59] || (s[59] = J(" TheHandy ")), E(t).handy.connected ? (w(),
                R("span", QO, "Connected")) : le("", !0)])]),
                _: 1
            }), O(Ot, {
                icon: "autoblow",
                arrow: !0,
                onClick: s[1] || (s[1] = r => E(t).ui.page = E(On).Autoblow)
            }, {
                default: Y( () => [x("div", e7, [s[60] || (s[60] = J(" Autoblow (Beta) ")), E(t).autoblow.connected ? (w(),
                R("span", t7, " Connected ")) : le("", !0)])]),
                _: 1
            }), O(Ot, {
                icon: "bluetooth",
                arrow: !0,
                onClick: s[2] || (s[2] = r => E(t).ui.page = E(On).Bluetooth)
            }, {
                default: Y( () => [x("div", n7, [s[61] || (s[61] = J(" Bluetooth ")), E(t).bluetooth.connected ? (w(),
                R("span", i7, "Connected")) : le("", !0)])]),
                _: 1
            }), O(Ot, {
                icon: "loob",
                arrow: !0,
                onClick: s[3] || (s[3] = r => E(t).ui.page = E(On).Loob)
            }, {
                default: Y( () => [x("div", s7, [s[62] || (s[62] = J(" LOOB ")), E(t).loob.connected ? (w(),
                R("span", r7, "Connected")) : le("", !0)])]),
                _: 1
            }), O(Ot, {
                icon: "intiface",
                arrow: !0,
                onClick: s[4] || (s[4] = r => E(t).ui.page = E(On).Intiface)
            }, {
                default: Y( () => [x("div", o7, [s[63] || (s[63] = J(" Intiface ")), E(t).intiface.connected ? (w(),
                R("span", a7, "Connected")) : le("", !0)])]),
                _: 1
            }), O(Ot, {
                icon: "usb-port",
                arrow: !0,
                onClick: s[5] || (s[5] = r => E(t).ui.page = E(On).Osr)
            }, {
                default: Y( () => [x("div", l7, [s[64] || (s[64] = J(" OSR ")), E(t).osr.connected ? (w(),
                R("span", c7, "Connected")) : le("", !0)])]),
                _: 1
            }), O(Ot, {
                icon: "bluetooth",
                arrow: !0,
                onClick: s[6] || (s[6] = r => E(t).ui.page = E(On).BluetoothFleshyThrust)
            }, {
                default: Y( () => [x("div", u7, [s[65] || (s[65] = J(" Fleshy Thrust Sync ")), E(t).bluetoothFleshyThrust.connected ? (w(),
                R("span", d7, "Connected")) : le("", !0)])]),
                _: 1
            })])) : E(t).ui.page === E(On).Handy ? (w(),
            R("div", f7, [x("div", h7, [s[81] || (s[81] = x("hr", {
                class: "mt-2 mb-0 border-zinc-700 lg:hidden"
            }, null, -1)), E(t).handy.connected ? (w(),
            R("div", y7, [x("div", null, [x("div", b7, [x("p", S7, [s[70] || (s[70] = J(" Sync ")), x("span", E7, ee(E(t).handy.settings.offset) + "ms", 1)]), zt(x("button", {
                onClick: s[7] || (s[7] = r => E(t).handy.settings.offset = 0),
                class: "text-zinc-500 text-sm hover:text-white"
            }, "Reset ", 512), [[$n, E(t).handy.settings.offset !== 0]])]), O(fo, {
                min: -250,
                max: 250,
                tooltips: !0,
                values: [-250, -125, 0, 125, 250],
                suffix: "ms",
                modelValue: E(t).handy.settings.offset,
                "onUpdate:modelValue": s[8] || (s[8] = r => E(t).handy.settings.offset = r),
                class: "mt-1.5 mb-8"
            }, null, 8, ["modelValue"]), s[71] || (s[71] = x("label", {
                class: "text-zinc-300 text-sm"
            }, "If your sync is off, you can try to adjust this offset value.", -1))]), x("div", w7, [x("p", T7, [s[72] || (s[72] = J(" Stroke ")), x("span", A7, ee(E(t).handy.settings.limits[0]) + "-" + ee(E(t).handy.settings.limits[1]), 1)]), O(fo, {
                modelValue: E(t).handy.settings.limits,
                "onUpdate:modelValue": s[9] || (s[9] = r => E(t).handy.settings.limits = r),
                min: 0,
                max: 100,
                tooltips: !0,
                values: [0, 25, 50, 75, 100],
                class: "mt-1.5 mb-8"
            }, null, 8, ["modelValue"]), s[73] || (s[73] = x("span", {
                class: "text-zinc-300 text-sm"
            }, "You can adjust the stroke length to adjust the intensity of the script.", -1))]), x("div", {
                class: "mt-4 cursor-pointer",
                onClick: s[11] || (s[11] = r => E(t).handy.settings.invert = !E(t).handy.settings.invert)
            }, [x("div", C7, [s[74] || (s[74] = x("p", {
                class: "font-medium"
            }, "Invert", -1)), O(za, {
                class: "pointer-events-none",
                modelValue: E(t).handy.settings.invert,
                "onUpdate:modelValue": s[10] || (s[10] = r => E(t).handy.settings.invert = r)
            }, null, 8, ["modelValue"])]), s[75] || (s[75] = x("span", {
                class: "text-zinc-300 text-sm"
            }, "With this setting you can invert all script actions in a video. A page reload is required.", -1))])])) : (w(),
            R("a", p7, [E(it)().isProduction ? (w(),
            R("div", m7, [E(e) ? (w(),
            R("img", v7)) : (w(),
            R("video", g7))])) : le("", !0), E(it)().isProduction ? (w(),
            R("span", _7, s[66] || (s[66] = [J("Feel what you see with "), x("span", {
                class: "font-medium text-white"
            }, "The Handy", -1), J(" - the interactive, automatic stroker that syncs up with any "), x("span", {
                class: "font-medium text-white"
            }, "FapTap", -1), J(" video.")]))) : le("", !0), s[69] || (s[69] = x("div", {
                class: "lg:flex-1"
            }, null, -1)), E(it)().isProduction ? (w(),
            R("div", x7, s[67] || (s[67] = [J(" 10% OFF WITH CODE "), x("span", {
                class: "font-bold text-blue-400"
            }, "FAPTAP", -1)]))) : le("", !0), O(je, {
                class: "w-full",
                theme: "green"
            }, {
                default: Y( () => s[68] || (s[68] = [J("Buy Now")])),
                _: 1
            })])), x("div", M7, [O(je, {
                theme: "light",
                class: "block w-full hover:opacity-100 border border-zinc-600",
                onClick: s[12] || (s[12] = r => E(t).ui.page = E(On).Start)
            }, {
                default: Y( () => s[76] || (s[76] = [J(" Connect another device ")])),
                _: 1
            }), x("div", R7, [O(ze, {
                name: "thehandy",
                class: "h-16 w-16"
            }), s[77] || (s[77] = x("h2", {
                class: "text-2xl font-bold"
            }, "TheHandy", -1))]), s[80] || (s[80] = x("p", {
                class: "text-sm text-zinc-400"
            }, [J("To connect your Handy, please enter your connection key ("), x("a", {
                class: "text-blue-400",
                target: "_blank",
                href: "https://www.handysetup.com/en/docs/getting-started/connect-handy-to-wifi-fw3/"
            }, "I need help"), J("). ")], -1)), x("div", L7, [E(t).handy.error ? (w(),
            R("p", I7, ee(E(t).handy.error), 1)) : E(t).handy.connected ? (w(),
            R("p", k7, "Connected")) : le("", !0)]), O(vn, {
                type: "text",
                modelValue: E(t).handy.settings.key,
                "onUpdate:modelValue": s[13] || (s[13] = r => E(t).handy.settings.key = r),
                disabled: E(t).handy.connected,
                class: "text-center w-full",
                placeholder: "Enter connection key"
            }, null, 8, ["modelValue", "disabled"]), E(t).handy.connected ? (w(),
            Re(je, {
                key: 1,
                onClick: s[15] || (s[15] = Vn(r => E(t).handy.disconnect(), ["stop"])),
                class: "w-full"
            }, {
                default: Y( () => s[79] || (s[79] = [J("Disconnect")])),
                _: 1
            })) : (w(),
            Re(je, {
                key: 0,
                onClick: s[14] || (s[14] = r => E(t).handy.connect()),
                theme: "blue",
                loading: E(t).handy.scanning,
                disabled: E(t).handy.settings.key.length < 5 || E(t).handy.scanning,
                class: "w-full"
            }, {
                default: Y( () => s[78] || (s[78] = [J("Connect ")])),
                _: 1
            }, 8, ["loading", "disabled"]))])])])) : E(t).ui.page === E(On).Autoblow ? (w(),
            R("div", P7, [x("div", D7, [s[96] || (s[96] = x("hr", {
                class: "mt-2 mb-0 border-zinc-700 lg:hidden"
            }, null, -1)), E(t).autoblow.connected ? (w(),
            R("div", $7, [x("div", null, [x("div", H7, [x("p", z7, [s[86] || (s[86] = J(" Sync ")), x("span", G7, ee(E(t).autoblow.settings.offset) + "ms", 1)]), zt(x("button", {
                onClick: s[16] || (s[16] = r => E(t).autoblow.settings.offset = 0),
                class: "text-zinc-500 text-sm hover:text-white"
            }, "Reset ", 512), [[$n, E(t).autoblow.settings.offset !== 0]])]), O(fo, {
                min: -250,
                max: 250,
                tooltips: !0,
                values: [-250, -125, 0, 125, 250],
                suffix: "ms",
                modelValue: E(t).autoblow.settings.offset,
                "onUpdate:modelValue": s[17] || (s[17] = r => E(t).autoblow.settings.offset = r),
                class: "mt-1.5 mb-8"
            }, null, 8, ["modelValue"]), s[87] || (s[87] = x("label", {
                class: "text-zinc-300 text-sm"
            }, "If your sync is off, you can try to adjust this offset value.", -1))]), s[90] || (s[90] = x("div", {
                class: "mt-8"
            }, null, -1)), x("div", {
                class: "mt-4 cursor-pointer",
                onClick: s[19] || (s[19] = r => E(t).autoblow.settings.invert = !E(t).autoblow.settings.invert)
            }, [x("div", W7, [s[88] || (s[88] = x("p", {
                class: "font-medium"
            }, "Invert", -1)), O(za, {
                class: "pointer-events-none",
                modelValue: E(t).autoblow.settings.invert,
                "onUpdate:modelValue": s[18] || (s[18] = r => E(t).autoblow.settings.invert = r)
            }, null, 8, ["modelValue"])]), s[89] || (s[89] = x("span", {
                class: "text-zinc-300 text-sm"
            }, "With this setting you can invert all script actions in a video. A page reload is required.", -1))])])) : (w(),
            R("a", F7, [E(it)().isProduction ? (w(),
            R("div", O7, [E(e) ? (w(),
            R("img", N7)) : (w(),
            R("video", U7))])) : le("", !0), E(it)().isProduction ? (w(),
            R("span", B7, s[82] || (s[82] = [J("Feel what you see with "), x("span", {
                class: "font-medium text-white"
            }, "Autoblow", -1), J(" - the interactive, automatic stroker that syncs up with any "), x("span", {
                class: "font-medium text-white"
            }, "FapTap", -1), J(" video.")]))) : le("", !0), s[85] || (s[85] = x("div", {
                class: "lg:flex-1"
            }, null, -1)), E(it)().isProduction ? (w(),
            R("div", V7, s[83] || (s[83] = [J(" 10% OFF WITH CODE "), x("span", {
                class: "font-bold text-blue-400"
            }, "FAPTAP", -1)]))) : le("", !0), O(je, {
                class: "w-full",
                theme: "green"
            }, {
                default: Y( () => s[84] || (s[84] = [J("Buy Now")])),
                _: 1
            })])), x("div", q7, [O(je, {
                theme: "light",
                class: "block w-full hover:opacity-100 border border-zinc-600",
                onClick: s[20] || (s[20] = r => E(t).ui.page = E(On).Start)
            }, {
                default: Y( () => s[91] || (s[91] = [J(" Connect another device ")])),
                _: 1
            }), x("div", j7, [O(ze, {
                name: "autoblow",
                class: "h-16 w-16 pr-2"
            }), s[92] || (s[92] = x("h2", {
                class: "text-2xl font-bold"
            }, "Autoblow (Beta)", -1))]), s[95] || (s[95] = x("p", {
                class: "text-sm text-zinc-400"
            }, [J("To connect your autoblow, please enter your connection key ("), x("a", {
                class: "text-blue-400",
                target: "_blank",
                href: "https://autoblowme.com/Autoblow_AI_Internet_Setup_Guide.pdf"
            }, "I need help"), J("). ")], -1)), x("div", K7, [E(t).autoblow.error ? (w(),
            R("p", X7, ee(E(t).autoblow.error), 1)) : E(t).autoblow.connected ? (w(),
            R("p", Y7, "Connected")) : le("", !0)]), O(vn, {
                type: "text",
                modelValue: E(t).autoblow.settings.key,
                "onUpdate:modelValue": s[21] || (s[21] = r => E(t).autoblow.settings.key = r),
                disabled: E(t).autoblow.connected,
                class: "text-center w-full",
                placeholder: "Enter connection key"
            }, null, 8, ["modelValue", "disabled"]), E(t).autoblow.connected ? (w(),
            Re(je, {
                key: 1,
                onClick: s[23] || (s[23] = Vn(r => E(t).autoblow.disconnect(), ["stop"])),
                class: "w-full"
            }, {
                default: Y( () => s[94] || (s[94] = [J("Disconnect")])),
                _: 1
            })) : (w(),
            Re(je, {
                key: 0,
                onClick: s[22] || (s[22] = r => E(t).autoblow.connect()),
                theme: "blue",
                loading: E(t).autoblow.scanning,
                disabled: E(t).autoblow.settings.key.length < 5 || E(t).autoblow.scanning,
                class: "w-full"
            }, {
                default: Y( () => s[93] || (s[93] = [J("Connect ")])),
                _: 1
            }, 8, ["loading", "disabled"]))])])])) : E(t).ui.page === E(On).Bluetooth ? (w(),
            R("div", Z7, [O(Ot, {
                icon: "chevron-left",
                onClick: s[24] || (s[24] = r => E(t).ui.page = E(On).Start)
            }), x("div", J7, [x("div", Q7, [O(ze, {
                name: "bluetooth",
                class: "h-16 w-16"
            }), s[97] || (s[97] = x("h2", {
                class: "text-2xl font-bold"
            }, "Bluetooth", -1))]), s[99] || (s[99] = x("p", {
                class: "text-sm text-zinc-400 my-4"
            }, [J("FapTap supports over 250 different toys, from vibrators to strokers ("), x("a", {
                class: "text-blue-400",
                href: "https://iostindex.com/?filter0Availability=Available,DIY&filter1ButtplugSupport=4",
                target: "_blank"
            }, "supported devices"), J("). ")], -1)), E(t).bluetooth.devices.length > 0 ? (w(),
            R("div", e9, [(w(!0),
            R(Ge, null, Ht(E(t).bluetooth.devices, r => (w(),
            R("div", t9, [x("span", n9, ee(r.Name), 1), r.batteryLevel && !isNaN(r.batteryLevel) ? (w(),
            R("span", i9, [O(ze, {
                name: "energy",
                class: "h-5 w-5"
            }), x("span", s9, ee(r.batteryLevel * 100) + "%", 1)])) : le("", !0)]))), 256))])) : le("", !0), E(t).bluetooth.error ? (w(),
            R("div", r9, [x("p", null, ee(E(t).bluetooth.error), 1)])) : (w(),
            Re(je, {
                key: 2,
                loading: E(t).bluetooth.scanning,
                class: "w-full",
                theme: "blue",
                onClick: s[25] || (s[25] = r => E(t).bluetooth.connect())
            }, {
                default: Y( () => s[98] || (s[98] = [J(" Connect ")])),
                _: 1
            }, 8, ["loading"]))]), O(Lf, {
                title: "Settings",
                icon: "cog"
            }, {
                default: Y( () => [x("div", o9, [x("div", a9, [x("div", l9, [x("p", c9, [s[100] || (s[100] = J(" Stroke ")), x("span", u9, ee(E(t).bluetooth.settings.limits[0]) + "-" + ee(E(t).bluetooth.settings.limits[1]), 1)]), zt(x("button", {
                    onClick: s[26] || (s[26] = r => E(t).bluetooth.settings.limits = [0, 100]),
                    class: "text-zinc-500 text-sm hover:text-white"
                }, "Reset ", 512), [[$n, E(t).bluetooth.settings.limits[0] !== 0 || E(t).bluetooth.settings.limits[1] !== 100]])]), O(fo, {
                    modelValue: E(t).bluetooth.settings.limits,
                    "onUpdate:modelValue": s[27] || (s[27] = r => E(t).bluetooth.settings.limits = r),
                    min: 0,
                    max: 100,
                    tooltips: !0,
                    values: [0, 25, 50, 75, 100],
                    class: "mt-1.5 mb-8"
                }, null, 8, ["modelValue"]), s[101] || (s[101] = x("span", {
                    class: "text-zinc-300 text-sm"
                }, "You can adjust the stroke length to adjust the intensity of the script.", -1))]), x("div", {
                    class: "mt-4 cursor-pointer",
                    onClick: s[29] || (s[29] = r => E(t).bluetooth.settings.invert = !E(t).bluetooth.settings.invert)
                }, [x("div", d9, [s[102] || (s[102] = x("p", {
                    class: "font-medium"
                }, "Invert", -1)), O(za, {
                    class: "pointer-events-none",
                    modelValue: E(t).bluetooth.settings.invert,
                    "onUpdate:modelValue": s[28] || (s[28] = r => E(t).bluetooth.settings.invert = r)
                }, null, 8, ["modelValue"])]), s[103] || (s[103] = x("span", {
                    class: "text-zinc-300 text-sm"
                }, "With this setting you can invert all script actions in a video", -1))])])]),
                _: 1
            })])) : E(t).ui.page === E(On).Osr ? (w(),
            R("div", f9, [O(Ot, {
                icon: "chevron-left",
                onClick: s[30] || (s[30] = r => E(t).ui.page = E(On).Start)
            }), x("div", h9, [x("div", p9, [O(ze, {
                name: "usb-port",
                class: "h-16 w-16"
            }), s[104] || (s[104] = x("h2", {
                class: "text-2xl font-bold"
            }, "OSR", -1))]), s[108] || (s[108] = x("p", {
                class: "text-sm text-zinc-400 my-4"
            }, 'Simply plug in your OSR to any USB port on your PC/Laptop and click on "Connect".', -1)), E(t).osr.error ? (w(),
            R("div", m9, s[107] || (s[107] = [J(" Your browser does not support Web Serial, please use "), x("a", {
                target: "_blank",
                class: "text-blue-500",
                href: "https://www.google.com/chrome/"
            }, "Chrome", -1)]))) : (w(),
            R(Ge, {
                key: 0
            }, [E(t).osr.connected ? (w(),
            Re(je, {
                key: 1,
                class: "w-full",
                onClick: s[32] || (s[32] = r => E(t).osr.disconnect())
            }, {
                default: Y( () => s[106] || (s[106] = [J("Disconnect")])),
                _: 1
            })) : (w(),
            Re(je, {
                key: 0,
                loading: E(t).osr.scanning,
                class: "w-full",
                theme: "blue",
                onClick: s[31] || (s[31] = r => E(t).osr.connect())
            }, {
                default: Y( () => s[105] || (s[105] = [J(" Connect ")])),
                _: 1
            }, 8, ["loading"]))], 64))]), zt(O(Lf, {
                title: "Settings",
                icon: "cog"
            }, {
                default: Y( () => [x("div", g9, [x("div", v9, [x("div", _9, [x("p", x9, [s[109] || (s[109] = J(" Stroke ")), x("span", y9, ee(E(t).osr.settings.limits[0]) + "-" + ee(E(t).osr.settings.limits[1]), 1)]), zt(x("button", {
                    onClick: s[33] || (s[33] = r => E(t).osr.settings.limits = [0, 100]),
                    class: "text-zinc-500 text-sm hover:text-white"
                }, "Reset ", 512), [[$n, E(t).osr.settings.limits[0] !== 0 || E(t).osr.settings.limits[1] !== 100]])]), O(fo, {
                    modelValue: E(t).osr.settings.limits,
                    "onUpdate:modelValue": s[34] || (s[34] = r => E(t).osr.settings.limits = r),
                    min: 0,
                    max: 100,
                    tooltips: !0,
                    values: [0, 25, 50, 75, 100],
                    class: "mt-1.5 mb-8"
                }, null, 8, ["modelValue"]), s[110] || (s[110] = x("span", {
                    class: "text-zinc-300 text-sm"
                }, "You can adjust the stroke length to adjust the intensity of the script.", -1))]), x("div", {
                    class: "mt-4 cursor-pointer",
                    onClick: s[36] || (s[36] = r => E(t).osr.settings.invert = !E(t).osr.settings.invert)
                }, [x("div", b9, [s[111] || (s[111] = x("p", {
                    class: "font-medium"
                }, "Invert", -1)), O(za, {
                    class: "pointer-events-none",
                    modelValue: E(t).osr.settings.invert,
                    "onUpdate:modelValue": s[35] || (s[35] = r => E(t).osr.settings.invert = r)
                }, null, 8, ["modelValue"])]), s[112] || (s[112] = x("span", {
                    class: "text-zinc-300 text-sm"
                }, "With this setting you can invert all script actions in a video", -1))])])]),
                _: 1
            }, 512), [[$n, E(t).osr.connected]])])) : E(t).ui.page === E(On).Intiface ? (w(),
            R("div", S9, [O(Ot, {
                icon: "chevron-left",
                onClick: s[37] || (s[37] = r => E(t).ui.page = E(On).Start)
            }), x("div", E9, [x("div", w9, [O(ze, {
                name: "intiface",
                class: "h-16 w-16"
            }), s[113] || (s[113] = x("h2", {
                class: "text-2xl font-bold"
            }, "Intiface", -1))]), s[116] || (s[116] = x("p", {
                class: "text-sm text-zinc-400"
            }, [J("Connect to "), x("a", {
                class: "font-medium text-blue-400",
                target: "_blank",
                href: "https://intiface.com/"
            }, "Intiface"), J(" by entering the address below. ")], -1)), x("div", T9, [E(t).intiface.error ? (w(),
            R("p", A9, ee(E(t).intiface.error), 1)) : E(t).intiface.connected ? (w(),
            R("p", C9, "Connected")) : le("", !0)]), O(vn, {
                type: "text",
                modelValue: E(t).intiface.address,
                "onUpdate:modelValue": s[38] || (s[38] = r => E(t).intiface.address = r),
                disabled: E(t).intiface.connected,
                class: "text-center w-full",
                placeholder: "Enter Intiface address"
            }, null, 8, ["modelValue", "disabled"]), E(t).intiface.connected ? (w(),
            Re(je, {
                key: 1,
                onClick: s[40] || (s[40] = r => E(t).intiface.disconnect()),
                class: "w-full"
            }, {
                default: Y( () => s[115] || (s[115] = [J("Disconnect")])),
                _: 1
            })) : (w(),
            Re(je, {
                key: 0,
                onClick: s[39] || (s[39] = r => E(t).intiface.connect()),
                theme: "blue",
                loading: E(t).intiface.scanning,
                disabled: E(t).intiface.address.length < 1 || E(t).intiface.scanning,
                class: "w-full"
            }, {
                default: Y( () => s[114] || (s[114] = [J("Connect ")])),
                _: 1
            }, 8, ["loading", "disabled"]))]), zt(O(Lf, {
                title: "Settings",
                icon: "cog"
            }, {
                default: Y( () => [x("div", M9, [x("div", R9, [x("div", L9, [x("p", I9, [s[117] || (s[117] = J(" Stroke ")), x("span", k9, ee(E(t).intiface.settings.limits[0]) + "-" + ee(E(t).intiface.settings.limits[1]), 1)]), zt(x("button", {
                    onClick: s[41] || (s[41] = r => E(t).intiface.settings.limits = [0, 100]),
                    class: "text-zinc-500 text-sm hover:text-white"
                }, "Reset ", 512), [[$n, E(t).intiface.settings.limits[0] !== 0 || E(t).intiface.settings.limits[1] !== 100]])]), O(fo, {
                    modelValue: E(t).intiface.settings.limits,
                    "onUpdate:modelValue": s[42] || (s[42] = r => E(t).intiface.settings.limits = r),
                    min: 0,
                    max: 100,
                    tooltips: !0,
                    values: [0, 25, 50, 75, 100],
                    class: "mt-1.5 mb-8"
                }, null, 8, ["modelValue"]), s[118] || (s[118] = x("span", {
                    class: "text-zinc-300 text-sm"
                }, "You can adjust the stroke length to adjust the intensity of the script.", -1))]), x("div", {
                    class: "mt-4 cursor-pointer",
                    onClick: s[44] || (s[44] = r => E(t).intiface.settings.invert = !E(t).intiface.settings.invert)
                }, [x("div", P9, [s[119] || (s[119] = x("p", {
                    class: "font-medium"
                }, "Invert", -1)), O(za, {
                    class: "pointer-events-none",
                    modelValue: E(t).intiface.settings.invert,
                    "onUpdate:modelValue": s[43] || (s[43] = r => E(t).intiface.settings.invert = r)
                }, null, 8, ["modelValue"])]), s[120] || (s[120] = x("span", {
                    class: "text-zinc-300 text-sm"
                }, "With this setting you can invert all script actions in a video", -1))])])]),
                _: 1
            }, 512), [[$n, E(t).intiface.connected]])])) : E(t).ui.page === E(On).Loob ? (w(),
            R("div", D9, [O(Ot, {
                icon: "chevron-left",
                onClick: s[45] || (s[45] = r => E(t).ui.page = E(On).Start)
            }), x("div", F9, [x("div", O9, [O(ze, {
                name: "loob",
                class: "h-16"
            })]), s[123] || (s[123] = x("p", {
                class: "text-sm text-zinc-400"
            }, [J(" Connect to your "), x("a", {
                class: "font-medium text-blue-400",
                target: "_blank",
                href: "https://www.joyloob.com/"
            }, "LOOB")], -1)), x("div", U9, [E(t).loob.error ? (w(),
            R("p", N9, ee(E(t).loob.error), 1)) : E(t).loob.connected ? (w(),
            R("p", B9, "Connected")) : le("", !0)]), E(t).loob.connected ? (w(),
            Re(je, {
                key: 1,
                onClick: s[47] || (s[47] = r => E(t).loob.disconnect()),
                class: "w-full"
            }, {
                default: Y( () => s[122] || (s[122] = [J("Disconnect")])),
                _: 1
            })) : (w(),
            Re(je, {
                key: 0,
                onClick: s[46] || (s[46] = r => E(t).loob.connect()),
                theme: "blue",
                loading: E(t).loob.scanning,
                disabled: E(t).loob.scanning,
                class: "w-full"
            }, {
                default: Y( () => s[121] || (s[121] = [J("Connect ")])),
                _: 1
            }, 8, ["loading", "disabled"]))]), zt(O(Lf, {
                title: "Settings",
                icon: "cog"
            }, {
                default: Y( () => [x("div", V9, [x("div", null, [x("div", $9, [x("p", H9, [s[124] || (s[124] = J(" Stroke ")), x("span", z9, ee(E(t).loob.settings.limits[0]) + "-" + ee(E(t).loob.settings.limits[1]), 1)]), zt(x("button", {
                    onClick: s[48] || (s[48] = r => E(t).loob.settings.limits = [0, 100]),
                    class: "text-zinc-500 text-sm hover:text-white"
                }, "Reset ", 512), [[$n, E(t).loob.settings.limits[0] !== 0 || E(t).loob.settings.limits[1] !== 100]])]), O(fo, {
                    modelValue: E(t).loob.settings.limits,
                    "onUpdate:modelValue": s[49] || (s[49] = r => E(t).loob.settings.limits = r),
                    min: 0,
                    max: 100,
                    tooltips: !0,
                    values: [0, 25, 50, 75, 100],
                    class: "mt-1.5 mb-8"
                }, null, 8, ["modelValue"]), s[125] || (s[125] = x("span", {
                    class: "text-zinc-300 text-sm"
                }, "You can adjust the stroke length to adjust the intensity of the script.", -1))])])]),
                _: 1
            }, 512), [[$n, E(t).loob.connected]])])) : E(t).ui.page === E(On).BluetoothFleshyThrust ? (w(),
            R("div", G9, [x("div", {
                class: Pt(["grid grid-cols-1 gap-6 items-center p-3", E(t).bluetoothFleshyThrust.connected ? "lg:max-w-3xl lg:grid-cols-2" : "lg:w-80 p-4"])
            }, [s[137] || (s[137] = x("hr", {
                class: "mt-2 mb-0 border-zinc-700 lg:hidden"
            }, null, -1)), E(t).bluetoothFleshyThrust.connected ? (w(),
            R("div", W9, [x("div", null, [x("div", q9, [s[126] || (s[126] = x("p", {
                class: "font-medium"
            }, "Device Name:", -1)), J(" " + ee(E(t).bluetoothFleshyThrust.devicename), 1)])]), x("div", j9, [x("div", K9, [x("p", X9, [s[127] || (s[127] = J(" Delay: ")), x("span", Y9, ee(E(t).bluetoothFleshyThrust.offset) + " ms", 1)]), x("button", {
                class: "text-zinc-500 text-sm hover:text-white",
                onClick: s[50] || (s[50] = Vn( (...r) => E(t).bluetoothFleshyThrust.resetOffset && E(t).bluetoothFleshyThrust.resetOffset(...r), ["stop"]))
            }, "Reset")]), O(fo, {
                modelValue: E(t).bluetoothFleshyThrust.offset,
                "onUpdate:modelValue": s[51] || (s[51] = r => E(t).bluetoothFleshyThrust.offset = r),
                min: -250,
                max: 250,
                tooltips: !0,
                values: [-250, -125, 0, 125, 250],
                suffix: "ms",
                class: "mt-1.5 mb-8"
            }, null, 8, ["modelValue"]), s[128] || (s[128] = x("label", {
                class: "text-zinc-300 text-xs"
            }, "If your sync is off, you can try to adjust this offset value.", -1))]), x("div", Z9, [x("div", {
                class: "flex items-center justify-between",
                onClick: s[53] || (s[53] = (...r) => E(t).bluetoothFleshyThrust.toggleMode && E(t).bluetoothFleshyThrust.toggleMode(...r))
            }, [s[129] || (s[129] = x("p", {
                class: "font-medium"
            }, "EXTREME Mode", -1)), O(za, {
                class: "pointer-events-none",
                modelValue: E(t).bluetoothFleshyThrust.isEXTREME,
                "onUpdate:modelValue": s[52] || (s[52] = r => E(t).bluetoothFleshyThrust.isEXTREME = r)
            }, null, 8, ["modelValue"])]), s[130] || (s[130] = x("span", {
                class: "text-zinc-300 text-sm"
            }, "Enable to increase the intensity.", -1))]), x("div", J9, [x("div", Q9, [x("p", {
                class: "flex items-center gap-2 text-sm",
                onClick: s[55] || (s[55] = (...r) => E(t).bluetoothFleshyThrust.toggleSafeMode && E(t).bluetoothFleshyThrust.toggleSafeMode(...r))
            }, [O(za, {
                class: "pointer-events-none",
                modelValue: E(t).bluetoothFleshyThrust.getSafeMode,
                "onUpdate:modelValue": s[54] || (s[54] = r => E(t).bluetoothFleshyThrust.getSafeMode = r)
            }, null, 8, ["modelValue"]), s[131] || (s[131] = J(" Safe Mode "))])])])])) : le("", !0), x("div", eU, [O(je, {
                theme: "light",
                class: "block w-full hover:opacity-100 border border-zinc-600",
                onClick: s[56] || (s[56] = r => E(t).ui.page = E(On).Start)
            }, {
                default: Y( () => s[132] || (s[132] = [J(" Connect another device ")])),
                _: 1
            }), x("div", tU, [O(ze, {
                name: "bluetooth",
                class: "h-16 w-16 pr-2"
            }), s[133] || (s[133] = x("h2", {
                class: "text-2xl font-bold"
            }, "Fleshy Thrust Sync", -1))]), s[136] || (s[136] = x("p", {
                class: "text-sm text-zinc-400"
            }, [J(" Connect to your "), x("a", {
                class: "font-medium text-blue-400",
                target: "_blank",
                href: "https://getfleshy.com/products/thrust-sync?utm_source=faptap&utm_medium=web&utm_campaign=device_connect_modal"
            }, "Fleshy Thrust Sync")], -1)), x("div", nU, [E(t).bluetoothFleshyThrust.error ? (w(),
            R("p", iU, ee(E(t).bluetoothFleshyThrust.error), 1)) : E(t).bluetoothFleshyThrust.connected ? (w(),
            R("p", sU, "Connected")) : le("", !0)]), E(t).bluetoothFleshyThrust.connected ? (w(),
            Re(je, {
                key: 1,
                onClick: s[58] || (s[58] = Vn(r => E(t).bluetoothFleshyThrust.disconnect(), ["stop"])),
                class: "w-full"
            }, {
                default: Y( () => s[135] || (s[135] = [J("Disconnect")])),
                _: 1
            })) : (w(),
            Re(je, {
                key: 0,
                onClick: s[57] || (s[57] = r => E(t).bluetoothFleshyThrust.connect()),
                theme: "blue",
                loading: E(t).bluetoothFleshyThrust.scanning,
                disabled: E(t).bluetoothFleshyThrust.scanning,
                class: "w-full"
            }, {
                default: Y( () => s[134] || (s[134] = [J("Connect ")])),
                _: 1
            }, 8, ["loading", "disabled"]))])], 2)])) : le("", !0)]),
            _: 1
        })]))
    }
});
var fb;
const sf = typeof window < "u"
  , hb = i => typeof i == "function"
  , bC = i => typeof i == "string"
  , SC = () => {}
  , oU = sf && ((fb = window == null ? void 0 : window.navigator) == null ? void 0 : fb.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
function EC(i) {
    return typeof i == "function" ? i() : E(i)
}
function aU(i) {
    return i
}
function wC(i) {
    return e_() ? (dw(i),
    !0) : !1
}
function lU(i) {
    return typeof i == "function" ? Vt(i) : xe(i)
}
function cU(i, e=!0) {
    im() ? Ln(i) : e ? i() : Yd(i)
}
function Tc(i) {
    var e;
    const t = EC(i);
    return (e = t == null ? void 0 : t.$el) != null ? e : t
}
const q_ = sf ? window : void 0
  , uU = sf ? window.document : void 0;
sf && window.navigator;
sf && window.location;
function _0(...i) {
    let e, t, n, s;
    if (bC(i[0]) || Array.isArray(i[0]) ? ([t,n,s] = i,
    e = q_) : [e,t,n,s] = i,
    !e)
        return SC;
    Array.isArray(t) || (t = [t]),
    Array.isArray(n) || (n = [n]);
    const r = []
      , o = () => {
        r.forEach(u => u()),
        r.length = 0
    }
      , a = (u, d, f, h) => (u.addEventListener(d, f, h),
    () => u.removeEventListener(d, f, h))
      , l = Bt( () => [Tc(e), EC(s)], ([u,d]) => {
        o(),
        u && r.push(...t.flatMap(f => n.map(h => a(u, f, h, d))))
    }
    , {
        immediate: !0,
        flush: "post"
    })
      , c = () => {
        l(),
        o()
    }
    ;
    return wC(c),
    c
}
let pb = !1;
function dU(i, e, t={}) {
    const {window: n=q_, ignore: s=[], capture: r=!0, detectIframe: o=!1} = t;
    if (!n)
        return;
    oU && !pb && (pb = !0,
    Array.from(n.document.body.children).forEach(f => f.addEventListener("click", SC)));
    let a = !0;
    const l = f => s.some(h => {
        if (typeof h == "string")
            return Array.from(n.document.querySelectorAll(h)).some(p => p === f.target || f.composedPath().includes(p));
        {
            const p = Tc(h);
            return p && (f.target === p || f.composedPath().includes(p))
        }
    }
    )
      , u = [_0(n, "click", f => {
        const h = Tc(i);
        if (!(!h || h === f.target || f.composedPath().includes(h))) {
            if (f.detail === 0 && (a = !l(f)),
            !a) {
                a = !0;
                return
            }
            e(f)
        }
    }
    , {
        passive: !0,
        capture: r
    }), _0(n, "pointerdown", f => {
        const h = Tc(i);
        h && (a = !f.composedPath().includes(h) && !l(f))
    }
    , {
        passive: !0
    }), o && _0(n, "blur", f => {
        var h;
        const p = Tc(i);
        ((h = n.document.activeElement) == null ? void 0 : h.tagName) === "IFRAME" && !(p != null && p.contains(n.document.activeElement)) && e(f)
    }
    )].filter(Boolean);
    return () => u.forEach(f => f())
}
function fU(i, e=!1) {
    const t = xe()
      , n = () => t.value = Boolean(i());
    return n(),
    cU(n, e),
    t
}
const P1 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}
  , D1 = "__vueuse_ssr_handlers__";
P1[D1] = P1[D1] || {};
P1[D1];
var mb = Object.getOwnPropertySymbols
  , hU = Object.prototype.hasOwnProperty
  , pU = Object.prototype.propertyIsEnumerable
  , mU = (i, e) => {
    var t = {};
    for (var n in i)
        hU.call(i, n) && e.indexOf(n) < 0 && (t[n] = i[n]);
    if (i != null && mb)
        for (var n of mb(i))
            e.indexOf(n) < 0 && pU.call(i, n) && (t[n] = i[n]);
    return t
}
;
function gU(i, e, t={}) {
    const n = t
      , {window: s=q_} = n
      , r = mU(n, ["window"]);
    let o;
    const a = fU( () => s && "MutationObserver"in s)
      , l = () => {
        o && (o.disconnect(),
        o = void 0)
    }
      , c = Bt( () => Tc(i), d => {
        l(),
        a.value && s && d && (o = new MutationObserver(e),
        o.observe(d, r))
    }
    , {
        immediate: !0
    })
      , u = () => {
        l(),
        c()
    }
    ;
    return wC(u),
    {
        isSupported: a,
        stop: u
    }
}
var gb;
(function(i) {
    i.UP = "UP",
    i.RIGHT = "RIGHT",
    i.DOWN = "DOWN",
    i.LEFT = "LEFT",
    i.NONE = "NONE"
}
)(gb || (gb = {}));
function ci(i=null, e={}) {
    var t, n;
    const {document: s=uU} = e
      , r = lU((t = i != null ? i : s == null ? void 0 : s.title) != null ? t : null)
      , o = i && hb(i);
    function a(l) {
        if (!("titleTemplate"in e))
            return l;
        const c = e.titleTemplate || "%s";
        return hb(c) ? c(l) : E(c).replace(/%s/g, l)
    }
    return Bt(r, (l, c) => {
        l !== c && s && (s.title = a(bC(l) ? l : ""))
    }
    , {
        immediate: !0
    }),
    e.observe && !e.titleTemplate && s && !o && gU((n = s.head) == null ? void 0 : n.querySelector("title"), () => {
        s && s.title !== r.value && (r.value = a(s.title))
    }
    , {
        childList: !0
    }),
    r
}
var vU = Object.defineProperty
  , vb = Object.getOwnPropertySymbols
  , _U = Object.prototype.hasOwnProperty
  , xU = Object.prototype.propertyIsEnumerable
  , _b = (i, e, t) => e in i ? vU(i, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : i[e] = t
  , yU = (i, e) => {
    for (var t in e || (e = {}))
        _U.call(e, t) && _b(i, t, e[t]);
    if (vb)
        for (var t of vb(e))
            xU.call(e, t) && _b(i, t, e[t]);
    return i
}
;
const bU = {
    easeInSine: [.12, 0, .39, 0],
    easeOutSine: [.61, 1, .88, 1],
    easeInOutSine: [.37, 0, .63, 1],
    easeInQuad: [.11, 0, .5, 0],
    easeOutQuad: [.5, 1, .89, 1],
    easeInOutQuad: [.45, 0, .55, 1],
    easeInCubic: [.32, 0, .67, 0],
    easeOutCubic: [.33, 1, .68, 1],
    easeInOutCubic: [.65, 0, .35, 1],
    easeInQuart: [.5, 0, .75, 0],
    easeOutQuart: [.25, 1, .5, 1],
    easeInOutQuart: [.76, 0, .24, 1],
    easeInQuint: [.64, 0, .78, 0],
    easeOutQuint: [.22, 1, .36, 1],
    easeInOutQuint: [.83, 0, .17, 1],
    easeInExpo: [.7, 0, .84, 0],
    easeOutExpo: [.16, 1, .3, 1],
    easeInOutExpo: [.87, 0, .13, 1],
    easeInCirc: [.55, 0, 1, .45],
    easeOutCirc: [0, .55, .45, 1],
    easeInOutCirc: [.85, 0, .15, 1],
    easeInBack: [.36, 0, .66, -.56],
    easeOutBack: [.34, 1.56, .64, 1],
    easeInOutBack: [.68, -.6, .32, 1.6]
};
yU({
    linear: aU
}, bU);
const SU = ut({
    __name: "Search",
    setup(i) {
        const e = ti()
          , t = xe(!1)
          , n = xe("")
          , s = xe(null)
          , r = xe();
        dU(s, () => t.value = !1);
        const o = () => {
            var a;
            !n.value.length || (t.value = !1,
            e.push({
                path: "/videos",
                query: {
                    q: n.value
                }
            }),
            (a = r.value) == null || a.blur())
        }
        ;
        return Bt( () => t.value, () => {
            t.value && requestAnimationFrame( () => {
                var a;
                return (a = r.value) == null ? void 0 : a.focus()
            }
            )
        }
        ),
        Bt( () => e.currentRoute.value, a => {
            a.name !== "videos" && (n.value = "")
        }
        ),
        (a, l) => (w(),
        R("form", {
            ref_key: "el",
            ref: s,
            onSubmit: Vn(o, ["prevent"]),
            onClick: l[1] || (l[1] = c => t.value = !0),
            class: Pt(["flex gap-3 p-1 rounded-md border-2 border-transparent bg-zinc-800", {
                "!border-blue-500": t.value
            }])
        }, [O(ze, {
            name: "search",
            class: "h-6 w-6 text-zinc-300"
        }), zt(x("input", {
            ref_key: "input",
            ref: r,
            type: "search",
            "onUpdate:modelValue": l[0] || (l[0] = c => n.value = c),
            placeholder: "Find thousands of videos...",
            class: "flex-1 bg-transparent focus-visible:outline-none"
        }, null, 512), [[b_, n.value]])], 34))
    }
})
  , EU = {
    class: "flex justify-between"
}
  , wU = {
    class: "flex flex-col gap-2.5 mt-3"
}
  , TU = ut({
    __name: "Sidebar",
    setup(i) {
        const e = xe(!1)
          , t = ti()
          , {user: n, isAuthorized: s} = Pn(it())
          , r = [{
            name: "Home",
            path: "/",
            routes: [],
            protected: !1
        }, {
            name: "Videos",
            path: "/videos",
            routes: ["videos", "watch"],
            protected: !1
        }, {
            name: "Creators",
            path: "/creators",
            routes: ["creators", "user"],
            protected: !1
        }, {
            name: "Performers",
            path: "/performers",
            routes: ["performers", "performer"],
            protected: !1
        }, {
            name: "Tags",
            path: "/tags",
            routes: ["tags", "tag"],
            protected: !1
        }, {
            name: "FaptapAI",
            path: "/faptapai",
            routes: ["faptapai"],
            protected: !1,
            hideFromUsers: !0
        }, {
            name: "FaptapAI",
            path: "/funscripts",
            routes: ["funscripts", "funscript-watch"],
            protected: !0
        }];
        Bt( () => e.value, l => {
            const c = "overflow-hidden"
              , u = document.querySelector("html");
            l ? u.classList.add(c) : u.classList.remove(c)
        }
        ),
        Bt( () => t.currentRoute.value.path, () => {
            e.value = !1
        }
        );
        const o = it()
          , {authDialog: a} = Pn(Xi());
        return (l, c) => {
            const u = li("router-link");
            return w(),
            R("div", null, [x("button", {
                class: "p-2",
                onClick: c[0] || (c[0] = d => e.value = !0)
            }, [O(ze, {
                name: "burger",
                class: "h-8 w-8"
            })]), e.value ? (w(),
            R("div", {
                key: 0,
                class: "fixed inset-0 bg-black/60 z-40",
                onClick: c[1] || (c[1] = d => e.value = !1)
            })) : le("", !0), x("div", {
                class: Pt(["w-[85vw] h-screen bg-zinc-900 fixed inset-0 z-50 p-4 transition-transform overflow-y-auto", {
                    "translate-x-[-85vw]": !e.value
                }])
            }, [x("div", EU, [c[9] || (c[9] = x("img", {
                src: eC,
                class: "h-6"
            }, null, -1)), x("button", {
                onClick: c[2] || (c[2] = d => e.value = !1)
            }, [O(ze, {
                name: "close",
                class: "h-7 w-7"
            })])]), x("div", wU, [(w(),
            R(Ge, null, Ht(r, d => zt(O(u, {
                to: d.path,
                onClick: c[3] || (c[3] = f => e.value = !1),
                class: "bg-zinc-800/50 rounded-lg p-3"
            }, {
                default: Y( () => [J(ee(d.name), 1)]),
                _: 2
            }, 1032, ["to"]), [[$n, E(s) ? !d.hideFromUsers : !d.protected]])), 64)), E(o).isAuthorized ? le("", !0) : (w(),
            R(Ge, {
                key: 0
            }, [c[10] || (c[10] = x("hr", {
                class: "my-2 border-zinc-800"
            }, null, -1)), x("button", {
                class: "bg-blue-500 rounded-lg p-3",
                onClick: c[4] || (c[4] = d => a.value = !0)
            }, " Sign Up / Log In "), c[11] || (c[11] = x("hr", {
                class: "my-2 border-zinc-800"
            }, null, -1)), c[12] || (c[12] = x("p", null, "Orientation", -1)), x("button", {
                onClick: c[5] || (c[5] = d => E(o).setOrientation(E(mn).Straight)),
                class: Pt(["bg-zinc-800 rounded-lg p-3", {
                    "bg-blue-500": E(o).getOrientation() === E(mn).Straight
                }])
            }, " Straight ", 2), x("button", {
                onClick: c[6] || (c[6] = d => E(o).setOrientation(E(mn).Transgender)),
                class: Pt(["bg-zinc-800 rounded-lg p-3", {
                    "bg-blue-500": E(o).getOrientation() === E(mn).Transgender
                }])
            }, " Transgender ", 2), x("button", {
                onClick: c[7] || (c[7] = d => E(o).setOrientation(E(mn).Gay)),
                class: Pt(["bg-zinc-800 rounded-lg p-3", {
                    "bg-blue-500": E(o).getOrientation() === E(mn).Gay
                }])
            }, " Gay ", 2), x("button", {
                onClick: c[8] || (c[8] = d => E(o).setOrientation(null)),
                class: Pt(["bg-zinc-800 rounded-lg p-3", {
                    "bg-blue-500": E(o).getOrientation() === void 0
                }])
            }, " None ", 2)], 64)), E(o).isAuthorized ? (w(),
            Re(pC, {
                key: 1
            })) : le("", !0)])], 2)])
        }
    }
})
  , AU = {
    class: "bg-zinc-700 h-8 rounded flex items-center px-3 flex-1 mr-3 gap-3"
}
  , CU = {
    key: 0,
    class: "text-white"
}
  , MU = ut({
    __name: "MobileSearch",
    setup(i) {
        const e = xe("")
          , t = xe(!1)
          , n = ti()
          , s = xe()
          , r = () => {
            !e.value.length || (n.push({
                path: "/videos",
                query: {
                    q: e.value
                }
            }),
            t.value = !1)
        }
        ;
        return Bt( () => t.value, o => {
            const a = "overflow-hidden"
              , l = document.querySelector("html");
            o ? (l.classList.add(a),
            requestAnimationFrame( () => {
                var c;
                return (c = s.value) == null ? void 0 : c.focus()
            }
            )) : l.classList.remove(a)
        }
        ),
        (o, a) => (w(),
        R("div", null, [x("button", {
            class: "p-1",
            onClick: a[0] || (a[0] = l => t.value = !0)
        }, [O(ze, {
            name: "search",
            class: "h-7 w-7"
        })]), t.value ? (w(),
        R("div", {
            key: 0,
            class: "fixed inset-0 flex flex-col bg-black/50 z-50 text-white",
            onClick: a[5] || (a[5] = l => t.value = !1)
        }, [x("div", {
            class: "bg-zinc-850 flex items-center bg-zinc-900 py-0.5",
            onClick: a[4] || (a[4] = Vn( () => {}
            , ["stop"]))
        }, [x("button", {
            class: "p-3",
            onClick: a[1] || (a[1] = l => t.value = !1)
        }, [O(ze, {
            name: "arrow-left",
            class: "h-6 w-6"
        })]), x("div", AU, [x("form", {
            onSubmit: Vn(r, ["prevent"]),
            class: "flex-1"
        }, [zt(x("input", {
            "onUpdate:modelValue": a[2] || (a[2] = l => e.value = l),
            ref_key: "input",
            ref: s,
            placeholder: "Search FapTap",
            type: "search",
            class: "focus-visible:outline-none bg-transparent w-full text-lg"
        }, null, 512), [[b_, e.value]])], 32), e.value.length ? (w(),
        R("button", CU, [O(ze, {
            onClick: a[3] || (a[3] = l => {
                e.value = "",
                s.value.focus()
            }
            ),
            name: "close",
            class: "h-6 w-6"
        })])) : le("", !0)])])])) : le("", !0)]))
    }
})
  , Er = ut({
    __name: "Scroller",
    props: {
        gap: {}
    },
    setup(i) {
        const e = xe()
          , t = xe()
          , n = xe({
            left: !1,
            right: !1
        })
          , s = () => {
            if (!t.value || !e.value)
                return;
            const o = e.value.offsetWidth
              , a = t.value.scrollWidth
              , l = t.value.scrollLeft;
            n.value.right = a > o && t.value.offsetWidth + l < a,
            n.value.left = l > 0
        }
          , r = o => {
            let a = t.value.offsetWidth;
            o === "left" && (a *= -1),
            t.value.scroll({
                left: t.value.scrollLeft + a,
                behavior: "smooth"
            })
        }
        ;
        return Ln( () => {
            t.value.addEventListener("scroll", s),
            new ResizeObserver(s).observe(t.value),
            new MutationObserver(s).observe(t.value, {
                childList: !0,
                subtree: !0
            })
        }
        ),
        (o, a) => (w(),
        R("div", {
            class: "relative",
            ref_key: "root",
            ref: e
        }, [zt(x("button", {
            onClick: a[0] || (a[0] = l => r("left")),
            class: "hidden lg:block absolute p-1 rounded-full bg-zinc-800 z-20 -left-5 top-1/2 -translate-y-1/2 shadow-lg active:scale-[0.98] transition-transform hover:bg-zinc-700"
        }, [O(ze, {
            name: "chevron-left",
            class: "h-8 w-8"
        })], 512), [[$n, n.value.left]]), x("div", {
            class: "scroller",
            ref_key: "container",
            ref: t
        }, [x("div", {
            class: Pt(["scroller-content flex min-w-min shrink-0", o.gap])
        }, [Nl(o.$slots, "default")], 2)], 512), zt(x("button", {
            onClick: a[1] || (a[1] = l => r("right")),
            class: "hidden lg:block absolute p-1 rounded-full bg-zinc-800 z-20 -right-5 top-1/2 -translate-y-1/2 shadow-lg active:scale-[0.98] transition-transform hover:bg-zinc-700"
        }, [O(ze, {
            name: "chevron-right",
            class: "h-8 w-8"
        })], 512), [[$n, n.value.right]])], 512))
    }
});
const RU = {
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
}
  , LU = {
    fill: "currentColor"
}
  , IU = {
    fill: "currentColor",
    d: "M12 5.5C12 3.567 10.433 2 8.5 2C6.567 2 5 3.567 5 5.5H12ZM5 18.5C5 20.433 6.567 22 8.5 22C10.433 22 12 20.433 12 18.5H5ZM20 13.5C20 11.567 18.433 10 16.5 10C14.567 10 13 11.567 13 13.5H20ZM13 18.5V22H20V18.5H13ZM5 5.5V18.5H12V5.5H5ZM13 13.5V18.5H20V13.5H13Z"
}
  , Th = ut({
    __name: "HandyLogo",
    props: {
        loading: {
            type: Boolean
        }
    },
    setup(i) {
        return (e, t) => (w(),
        R("svg", RU, [zt(x("path", LU, t[0] || (t[0] = [x("animate", {
            attributeName: "d",
            dur: "1s",
            values: "M12 5.5C12 3.567 10.433 2 8.5 2C6.567 2 5 3.567 5 5.5H12ZM5 18.5C5 20.433 6.567 22 8.5 22C10.433 22 12 20.433 12 18.5H5ZM20 13.5C20 11.567 18.433 10 16.5 10C14.567 10 13 11.567 13 13.5H20ZM13 18.5V22H20V18.5H13ZM5 5.5V18.5H12V5.5H5ZM13 13.5V18.5H20V13.5H13Z; M12 13.5C12 11.567 10.433 10 8.5 10C6.567 10 5 11.567 5 13.5H12ZM5 18.5C5 20.433 6.567 22 8.5 22C10.433 22 12 20.433 12 18.5H5ZM20 5.5C20 3.567 18.433 2 16.5 2C14.567 2 13 3.567 13 5.5H20ZM13 18.5V22H20V18.5H13ZM5 13.5V18.5H12V13.5H5ZM13 5.5V18.5H20V5.5H13Z; M12 5.5C12 3.567 10.433 2 8.5 2C6.567 2 5 3.567 5 5.5H12ZM5 18.5C5 20.433 6.567 22 8.5 22C10.433 22 12 20.433 12 18.5H5ZM20 13.5C20 11.567 18.433 10 16.5 10C14.567 10 13 11.567 13 13.5H20ZM13 18.5V22H20V18.5H13ZM5 5.5V18.5H12V5.5H5ZM13 13.5V18.5H20V13.5H13Z",
            repeatCount: "indefinite",
            calcMode: "spline",
            keySplines: "0.65 0.05 0.03 1;0.65 0.05 0.03 1"
        }, null, -1)]), 512), [[$n, e.loading]]), zt(x("path", IU, null, 512), [[$n, !e.loading]])]))
    }
})
  , kU = {
    class: "flex items-center lg:gap-8 border-b border-zinc-800 px-2 lg:px-8 py-0.5 lg:py-0"
}
  , PU = {
    class: "flex items-center"
}
  , DU = {
    key: 0,
    src: eC,
    class: "h-7"
}
  , FU = {
    class: "absolute w-full bottom-0 left-0 h-[3px] bg-blue-500"
}
  , OU = {
    class: "flex justify-end gap-x-2 items-center z-10 flex-1"
}
  , UU = {
    class: "hidden lg:block"
}
  , NU = {
    class: "py-1.5"
}
  , BU = {
    key: 0,
    class: "hidden md:flex gap-x-2"
}
  , VU = {
    href: "https://discord.gg/rTk6ehTnRT"
}
  , $U = {
    href: "https://twitter.com/faptapnet"
}
  , HU = {
    key: 1,
    class: "hidden lg:block"
}
  , zU = ut({
    __name: "Header",
    setup(i) {
        const {isMobile: e} = Ks()
          , {authDialog: t} = Pn(Xi())
          , {devices: n, ui: s, connecting: r} = Pn(Zr())
          , {isAuthorized: o} = Pn(it())
          , a = Ki()
          , l = it()
          , c = xe(!1)
          , u = [{
            name: "Home",
            path: "/",
            routes: [],
            protected: !1
        }, {
            name: "Videos",
            path: "/videos",
            routes: ["videos", "watch"],
            protected: !1
        }, {
            name: "Tags",
            path: "/tags",
            routes: ["tags", "tag"],
            protected: !1
        }, {
            name: "Creators",
            path: "/creators",
            routes: ["creators", "user"],
            protected: !1
        }, {
            name: it().isProduction ? "FaptapAI" : "DemoAI",
            path: "/faptapai",
            routes: ["faptapai"],
            protected: !1,
            hideFromUsers: !0
        }, {
            name: it().isProduction ? "FaptapAI" : "DemoAI",
            path: "/funscripts",
            routes: ["funscripts", "funscript-watch"],
            protected: !0
        }]
          , d = Vt( () => {
            const f = u.find(h => h.routes.includes(a.name));
            return f || u.find(h => !h.routes.length)
        }
        );
        return (f, h) => {
            var g, m;
            const p = li("router-link");
            return w(),
            R("div", kU, [O(TU, {
                class: "lg:hidden -ml-2"
            }), x("div", PU, [O(p, {
                to: "/",
                class: "items-center inline-block shrink-0"
            }, {
                default: Y( () => [E(it)().isProduction ? (w(),
                R("img", DU)) : le("", !0)]),
                _: 1
            })]), E(it)().isProduction ? (w(),
            Re(SU, {
                key: 0,
                class: "hidden lg:flex lg:w-80"
            })) : le("", !0), O(Er, {
                gap: "gap-8",
                class: "text-zinc-300 hidden lg:flex"
            }, {
                default: Y( () => [(w(),
                R(Ge, null, Ht(u, v => zt(O(p, {
                    to: v.path,
                    class: "h-16 block relative flex items-center justify-center group"
                }, {
                    default: Y( () => [x("span", {
                        class: Pt(["group-hover:text-blue-500", d.value === v ? "text-white" : "text-zinc-400"])
                    }, ee(v.name), 3), zt(x("div", FU, null, 512), [[$n, d.value === v]])]),
                    _: 2
                }, 1032, ["to"]), [[$n, E(o) ? !v.hideFromUsers : !v.protected]])), 64))]),
                _: 1
            }), x("div", OU, [E(o) ? (w(),
            R("div", HU, [O(pC)])) : (w(),
            R(Ge, {
                key: 0
            }, [x("div", UU, [E(it)().isProduction ? (w(),
            Re(je, {
                key: 0,
                ref: "orientation",
                onClick: h[0] || (h[0] = v => c.value = !c.value),
                theme: "transparent",
                class: "flex gap-1.5 items-center"
            }, {
                default: Y( () => [O(ze, {
                    class: "h-5 w-5",
                    name: E(l).getOrientationIcon()
                }, null, 8, ["name"]), x("span", null, ee(E(l).getOrientation() >= 0 ? E(mn)[E(l).getOrientation()] : "None"), 1)]),
                _: 1
            }, 512)) : le("", !0), O(ji, {
                modelValue: c.value,
                "onUpdate:modelValue": h[5] || (h[5] = v => c.value = v),
                target: (g = f.$refs.orientation) == null ? void 0 : g.$el,
                offset: 8
            }, {
                default: Y( () => [x("div", NU, [O(Ot, {
                    active: E(l).getOrientation() === void 0,
                    icon: "close",
                    onClick: h[1] || (h[1] = v => E(l).setOrientation(null))
                }, {
                    default: Y( () => h[9] || (h[9] = [J(" All Videos ")])),
                    _: 1
                }, 8, ["active"]), O(Ot, {
                    active: E(l).getOrientation() === E(mn).Straight,
                    icon: "orientation-straight",
                    onClick: h[2] || (h[2] = v => E(l).setOrientation(E(mn).Straight))
                }, {
                    default: Y( () => h[10] || (h[10] = [J(" Straight ")])),
                    _: 1
                }, 8, ["active"]), O(Ot, {
                    active: E(l).getOrientation() === E(mn).Transgender,
                    icon: "orientation-transgender",
                    onClick: h[3] || (h[3] = v => E(l).setOrientation(E(mn).Transgender))
                }, {
                    default: Y( () => h[11] || (h[11] = [J(" Transgender ")])),
                    _: 1
                }, 8, ["active"]), O(Ot, {
                    active: E(l).getOrientation() === E(mn).Gay,
                    icon: "orientation-gay",
                    onClick: h[4] || (h[4] = v => E(l).setOrientation(E(mn).Gay))
                }, {
                    default: Y( () => h[12] || (h[12] = [J(" Gay ")])),
                    _: 1
                }, 8, ["active"])])]),
                _: 1
            }, 8, ["modelValue", "target"])]), E(it)().isProduction ? (w(),
            R("div", BU, [x("a", VU, [O(ze, {
                class: "h-5 w-5",
                name: "discord"
            })]), x("a", $U, [O(ze, {
                class: "h-5 w-5",
                name: "twitter"
            })])])) : le("", !0), O(je, {
                class: "hidden md:block shrink-0",
                onClick: h[6] || (h[6] = v => t.value = !0)
            }, {
                default: Y( () => h[13] || (h[13] = [J(" Log In ")])),
                _: 1
            })], 64)), O(MU, {
                class: "lg:hidden"
            }), O(je, {
                ref: "el",
                class: "flex items-center gap-x-1.5 shrink-0",
                theme: E(n).length ? "green" : "blue",
                onClick: h[7] || (h[7] = v => E(s).open = !E(s).open)
            }, {
                default: Y( () => [O(Th, {
                    loading: E(r),
                    class: "h-5 w-5 text-white mx-auto"
                }, null, 8, ["loading"]), x("span", null, ee(E(n).length ? "Connected" : "Connect"), 1)]),
                _: 1
            }, 8, ["theme"]), (w(),
            Re(ys(E(e) ? dr : ji), {
                placement: "bottom-end",
                modelValue: E(s).open,
                "onUpdate:modelValue": h[8] || (h[8] = v => E(s).open = v),
                target: (m = f.$refs.el) == null ? void 0 : m.$el,
                offset: 8,
                class: "py-1"
            }, {
                default: Y( () => [O(rU)]),
                _: 1
            }, 8, ["modelValue", "target"]))])])
        }
    }
})
  , GU = ["data-ph-capture-attribute-affiliate"]
  , WU = {
    key: 0,
    class: "h-full w-full transition-all group-hover:scale-[1.01] group-hover:brightness-[1.15]"
}
  , qU = {
    key: 1,
    class: "h-full w-full text-white bg:gray flex justify-center items-center"
}
  , TC = ut({
    __name: "Affiliate",
    props: {
        affiliate: {}
    },
    setup(i) {
        const {isProduction: e} = it()
          , t = i
          , n = s => {
            Object.assign(document.createElement("a"), {
                target: "_blank",
                rel: "noopener noreferrer",
                href: s
            }).click()
        }
        ;
        return (s, r) => {
            const o = Jd("lazy");
            return w(),
            R("div", {
                onClick: r[0] || (r[0] = a => n(t.affiliate.url)),
                class: "group block bg-zinc-800 cursor-pointer",
                rel: "nofollow",
                "data-ph-capture-attribute-affiliate": t.affiliate.image
            }, [E(e) ? zt((w(),
            R("img", WU, null, 512)), [[o, t.affiliate.image]]) : (w(),
            R("div", qU, " Image Disable for Development Mode "))], 8, GU)
        }
    }
})
  , x0 = [{
    url: "https://www.sexlikereal.com/tags/sex-toy-scripts-vr?a=63e4b20bb7a0b71d6e675d47",
    image: "/affiliates/sexlikereal.4.jpg"
}, {
    url: "https://www.g2fame.com/adulttime/go.php?pr=8&su=1&si=247&ad=280096&cl=/toys&ar=&campaign=457485&buffer=",
    image: "/affiliates/adulttime.3.jpg"
}, {
    url: "https://www.thehandy.com/store/?ref=faptap&utm_source=faptap&utm_medium=affiliate&utm_campaign=The+Handy+Affiliate+program",
    image: "/affiliates/handy.1.jpg"
}, {
    url: "https://natour.naughtyamerica.com/track/MTIyOTQ4LjEwMDM2LjguMzgyLjAuMC4wLjAuMA/dream-lover/theHandy",
    image: "/affiliates/naughtyamerica.2.jpg"
}, {
    url: "https://enter.tonightsgirlfriend.com/track/MTIyOTQ4LjEwMDM2LjU4LjgwLjAuMC4wLjAuMA/scenes/handy/?apc=MTk5NTI5OTU",
    image: "/affiliates/tonights.girlfriend.1.jpg"
}];
function AC() {
    return {
        random: () => x0[Math.floor(Math.random() * x0.length)],
        affiliates: x0
    }
}
const jU = {
    key: 0,
    class: "text-red-500 text-sm -mt-1.5"
}
  , KU = {
    key: 1,
    class: "text-red-500 text-sm -mt-1.5"
}
  , XU = {
    key: 2,
    class: "text-sm text-center text-red-500"
}
  , YU = {
    key: 3,
    class: "text-sm text-center text-green-400"
}
  , ZU = ut({
    __name: "ChangePassword",
    setup(i) {
        const e = Ki();
        ti();
        const t = it()
          , n = Xi()
          , s = async () => {
            t.setUser(null),
            n.changePassword = !1,
            n.authDialog = !0,
            window.location.href = "/",
            o.value = {}
        }
          , r = ei({
            fields: {
                newPassword: "",
                password: "",
                email: "",
                token: ""
            },
            loadingpassword: !1
        })
          , o = xe({})
          , a = ef().shape({
            email: Us().email().required().test("has-tld", "Please enter a valid email address", d => {
                const [f,h] = d.split("@");
                return h !== void 0 && h.includes(".")
            }
            ),
            password: Us().required().min(6).max(60),
            newPassword: Us().required().min(6).max(60)
        })
          , l = async d => {
            try {
                await a.validateAt(d, r.fields),
                delete o.value[d]
            } catch (f) {
                o.value[d] = f.errors[0]
            }
        }
          , c = async () => {
            try {
                await a.validate(r.fields, {
                    abortEarly: !1
                }),
                o.value = {}
            } catch (d) {
                o.value = d.inner.reduce( (f, h) => (f[h.path] = h.message,
                f), {})
            }
        }
          , u = async () => {
            let d = e.params.email
              , f = e.params.token;
            if (r.fields.password != r.fields.newPassword)
                return o.value.generalpassword = "Password does not match",
                !0;
            if (d != "" && f != "" && f.length >= 60) {
                r.loadingpassword = !0;
                try {
                    await c()
                } catch {
                    r.loadingpassword = !1;
                    return
                }
                try {
                    await ct.user.changePassword(d, f, r.fields.newPassword),
                    r.loadingpassword = !1,
                    r.fields.newPassword = "",
                    r.fields.password = "",
                    o.value.success = "Password updated successfully",
                    o.value.generalpassword = "",
                    setTimeout( () => {
                        s()
                    }
                    , 2e3)
                } catch (h) {
                    o.value.generalpassword = h
                } finally {
                    r.loadingpassword = !1
                }
            } else
                o.value.generalpassword = "Invalid link"
        }
        ;
        return (d, f) => (w(),
        R("form", {
            onSubmit: Vn(u, ["prevent"]),
            class: "mt-3"
        }, [O(vn, {
            required: "",
            modelValue: r.fields.password,
            "onUpdate:modelValue": f[0] || (f[0] = h => r.fields.password = h),
            light: !0,
            placeholder: "New password",
            type: "password",
            class: "w-full",
            onBlur: f[1] || (f[1] = h => l("password")),
            onInput: f[2] || (f[2] = h => o.value.password && l("password"))
        }, null, 8, ["modelValue"]), o.value.password ? (w(),
        R("span", jU, ee(o.value.password), 1)) : le("", !0), O(vn, {
            required: "",
            modelValue: r.fields.newPassword,
            "onUpdate:modelValue": f[3] || (f[3] = h => r.fields.newPassword = h),
            light: !0,
            placeholder: "New password",
            type: "password",
            class: "w-full mt-2",
            onBlur: f[4] || (f[4] = h => l("newPassword")),
            onInput: f[5] || (f[5] = h => o.value.newPassword && l("newPassword"))
        }, null, 8, ["modelValue"]), o.value.newPassword ? (w(),
        R("span", KU, ee(o.value.newPassword), 1)) : le("", !0), O(je, {
            loading: r.loadingpassword,
            theme: "blue",
            class: "mt-4 w-full"
        }, {
            default: Y( () => f[6] || (f[6] = [J("Change Password")])),
            _: 1
        }, 8, ["loading"]), o.value.generalpassword ? (w(),
        R("span", XU, ee(o.value.generalpassword), 1)) : le("", !0), o.value.success ? (w(),
        R("span", YU, ee(o.value.success), 1)) : le("", !0)], 32))
    }
})
  , JU = {
    class: "bg-zinc-900 max-w-[1570px] mx-auto flex flex-col min-h-screen relative"
}
  , QU = {
    class: "py-2 lg:py-8 lg:px-8 flex-1 flex flex-col relative"
}
  , eN = {
    class: "flex-1"
}
  , tN = {
    key: 0,
    class: "mb-8"
}
  , nN = {
    target: "_blank",
    rel: "noopener noreferrer",
    href: "https://getfleshy.com/products/thrust-sync?utm_campaign=faptap&utm_medium=banner-ad-top&utm_source=partner"
}
  , iN = {
    key: 0,
    muted: "",
    autoplay: "",
    loop: "",
    src: l4,
    class: "aspect-video rounded-md overflow-hidden h-40 bg-zinc-800 shadow"
}
  , sN = {
    class: "absolute inset-0 flex justify-center items-center"
}
  , rN = {
    key: 0
}
  , oN = {
    key: 1
}
  , aN = {
    key: 2,
    class: "px-2 lg:px-0 flex-col lg:flex-row items-center lg:items-start gap-4 mt-8 text-sm leading-none text-zinc-500 flex justify-between"
}
  , lN = {
    class: "-mt-10"
}
  , cN = {
    class: "flex gap-3 items-center"
}
  , uN = {
    class: "bg-zinc-800 rounded-md p-3"
}
  , dN = {
    class: "mt-6 text-center"
}
  , fN = ut({
    __name: "App",
    setup(i) {
        const {authDialog: e, changePassword: t} = Pn(Xi());
        it();
        const {isMobile: n} = Ks()
          , s = ti()
          , {affiliates: r} = AC()
          , o = Vt( () => n ? s.currentRoute.value.name === "home" : !0);
        return (a, l) => {
            const c = li("RouterView")
              , u = li("router-link");
            return w(),
            R(Ge, null, [x("div", JU, [O(zU, {
                class: "z-50 sticky top-0 bg-zinc-900"
            }), x("div", QU, [x("div", eN, [o.value ? (w(),
            R("div", tN, [O(Er, {
                gap: "gap-2 lg:gap-4"
            }, {
                default: Y( () => [x("a", nN, [E(it)().isProduction ? (w(),
                R("video", iN)) : le("", !0)]), E(it)().isProduction ? (w(!0),
                R(Ge, {
                    key: 0
                }, Ht(E(r), d => (w(),
                Re(TC, {
                    class: "aspect-video rounded-md overflow-hidden h-40 group flex items-center justify-center bg-zinc-800 shadow",
                    affiliate: d
                }, null, 8, ["affiliate"]))), 256)) : le("", !0)]),
                _: 1
            })])) : le("", !0), O(c, null, {
                default: Y( ({Component: d}) => [d ? (w(),
                Re(ML, {
                    key: 0,
                    max: "3",
                    exclude: "watch"
                }, [(w(),
                Re(f5, {
                    timeout: "0"
                }, {
                    fallback: Y( () => [x("div", sN, [O(ze, {
                        name: "loading",
                        class: "h-10 w-10 text-blue-500 animate-spin"
                    })])]),
                    default: Y( () => [(w(),
                    Re(ys(d), {
                        key: E(s).currentRoute.value.path
                    }))]),
                    _: 2
                }, 1024))], 1024)) : le("", !0)]),
                _: 1
            })]), E(n) ? (w(),
            R("div", rN)) : (w(),
            R("div", oN)), E(it)().isProduction ? (w(),
            R("div", aN, [x("span", null, "\xA9 " + ee(new Date().getFullYear()) + " FapTap", 1), l[4] || (l[4] = pa('<div class="flex gap-3"><a href="https://discord.gg/rTk6ehTnRT" rel="nofollow" class="hover:text-blue-500">Discord</a><a href="https://theporndude.com/" rel="nofollow" class="hover:text-blue-500">ThePornDude</a><a href="mailto:dmca@faptap.net" class="hover:text-blue-500">DMCA</a><a href="mailto:contact@faptap.net" class="hover:text-blue-500">Contact</a></div>', 1))])) : le("", !0)])]), E(n) ? (w(),
            Re(dr, {
                key: 0,
                modelValue: E(e),
                "onUpdate:modelValue": l[0] || (l[0] = d => Sn(e) ? e.value = d : null)
            }, {
                default: Y( () => [O(nb)]),
                _: 1
            }, 8, ["modelValue"])) : (w(),
            Re(mr, {
                key: 1,
                modelValue: E(e),
                "onUpdate:modelValue": l[1] || (l[1] = d => Sn(e) ? e.value = d : null)
            }, {
                default: Y( () => [O(nb, {
                    class: "-m-4 -mt-12"
                })]),
                _: 1
            }, 8, ["modelValue"])), O(mr, {
                modelValue: E(t),
                "onUpdate:modelValue": l[3] || (l[3] = d => Sn(t) ? t.value = d : null)
            }, {
                default: Y( () => [x("div", lN, [x("div", cN, [x("div", uN, [O(ze, {
                    name: "lock-reset",
                    class: "h-7 w-7"
                })]), l[5] || (l[5] = x("div", null, [x("p", {
                    class: "text-2xl font-medium"
                }, "Change Password")], -1))]), l[7] || (l[7] = x("hr", {
                    class: "-mx-4 my-4 border-zinc-800"
                }, null, -1)), x("div", null, [O(ZU)]), l[8] || (l[8] = x("hr", {
                    class: "-mx-4 my-4 border-zinc-800"
                }, null, -1)), x("div", dN, [O(u, {
                    to: "#",
                    class: "block w-full",
                    onClick: l[2] || (l[2] = d => (t.value = !1,
                    e.value = !0))
                }, {
                    default: Y( () => l[6] || (l[6] = [J("Log In")])),
                    _: 1
                })])])]),
                _: 1
            }, 8, ["modelValue"])], 64)
        }
    }
})
  , hN = "modulepreload"
  , pN = function(i) {
    return "/" + i
}
  , xb = {}
  , rf = function(e, t, n) {
    if (!t || t.length === 0)
        return e();
    const s = document.getElementsByTagName("link");
    return Promise.all(t.map(r => {
        if (r = pN(r),
        r in xb)
            return;
        xb[r] = !0;
        const o = r.endsWith(".css")
          , a = o ? '[rel="stylesheet"]' : "";
        if (!!n)
            for (let u = s.length - 1; u >= 0; u--) {
                const d = s[u];
                if (d.href === r && (!o || d.rel === "stylesheet"))
                    return
            }
        else if (document.querySelector(`link[href="${r}"]${a}`))
            return;
        const c = document.createElement("link");
        if (c.rel = o ? "stylesheet" : hN,
        o || (c.as = "script",
        c.crossOrigin = ""),
        c.href = r,
        document.head.appendChild(c),
        o)
            return new Promise( (u, d) => {
                c.addEventListener("load", u),
                c.addEventListener("error", () => d(new Error(`Unable to preload CSS for ${r}`)))
            }
            )
    }
    )).then( () => e())
}
  , fl = i => new Date(i * 1e3).toISOString().slice(i < 3600 ? 14 : 11, 19)
  , j_ = i => {
    const e = new Date
      , t = Math.floor((e.getTime() - i.getTime()) / 1e3);
    let n = t / 31536e3;
    if (n > 1) {
        const s = Math.floor(n);
        return `${s} year${s > 1 ? "s" : ""}`
    }
    if (n = t / 2592e3,
    n > 1) {
        const s = Math.floor(n);
        return `${s} month${s > 1 ? "s" : ""}`
    }
    if (n = t / 86400,
    n > 1) {
        const s = Math.floor(n);
        return `${s} day${s > 1 ? "s" : ""}`
    }
    if (n = t / 3600,
    n > 1) {
        const s = Math.floor(n);
        return `${s} hour${s > 1 ? "s" : ""}`
    }
    if (n = t / 60,
    n > 1) {
        const s = Math.floor(n);
        return `${s} minute${s > 1 ? "s" : ""}`
    }
    return "a few seconds"
}
  , CC = Qd("preview", () => {
    const i = xe()
      , e = ti();
    return Bt( () => e.currentRoute.value, () => i.value = void 0),
    {
        activeItem: i
    }
}
)
  , vr = (i, e=1) => {
    const t = [{
        value: 1,
        symbol: ""
    }, {
        value: 1e3,
        symbol: "k"
    }, {
        value: 1e6,
        symbol: "M"
    }]
      , n = /\.0+$|(\.[0-9]*[1-9])0+$/
      , s = t.slice().reverse().find(function(r) {
        return i >= r.value
    });
    return s ? (i / s.value).toFixed(e).replace(n, "$1") + s.symbol : "0"
}
  , mN = {
    key: 0,
    class: "corner-icon flex gap-x-0.5 items-center"
}
  , gN = ["poster", "src"]
  , vN = {
    key: 0,
    class: "h-full w-full object-cover"
}
  , _N = {
    key: 1,
    class: "h-full w-full text-white bg:gray flex justify-center items-center"
}
  , xN = {
    class: "absolute bottom-1.5 right-1.5 flex gap-1.5"
}
  , yN = {
    key: 0,
    class: "bg-black/90 rounded px-2 backdrop-blur py-0.5 font-medium text-sm lg:text-xs"
}
  , bN = {
    class: "bg-black/90 rounded px-2 backdrop-blur py-0.5 font-medium text-sm lg:text-xs"
}
  , SN = {
    class: "py-1 px-2 md:px-0"
}
  , EN = {
    class: "flex gap-1.5 text-zinc-400 md:text-sm"
}
  , wN = {
    class: "flex-1 justify-end shrink-0 flex gap-1.5"
}
  , TN = {
    class: "flex gap-x-0.5 items-center"
}
  , AN = {
    class: "flex gap-x-0.5 items-center"
}
  , CN = {
    class: "flex gap-x-0.5 items-center"
}
  , F1 = ut({
    __name: "VideosItem",
    props: {
        video: {},
        rounded: {
            type: Boolean
        }
    },
    setup(i) {
        const {activeItem: e} = Pn(CC())
          , t = i
          , n = Math.random();
        let s;
        const r = () => {
            s = window.setTimeout( () => {
                e.value = t.video.id + n
            }
            , 100)
        }
          , o = () => {
            window.clearTimeout(s),
            e.value = void 0
        }
          , a = Vt( () => e.value === t.video.id + n)
          , l = Vt( () => {
            var c;
            return (c = t.video.tags) == null ? void 0 : c.some(u => u.name.toLowerCase() === "faptapai" || u.name.toLowerCase() === "ai")
        }
        );
        return Ms( () => window.clearTimeout(s)),
        (c, u) => {
            const d = li("router-link")
              , f = Jd("lazy");
            return t.video ? (w(),
            R("div", {
                key: 0,
                onTouchstartPassive: u[1] || (u[1] = h => e.value = t.video.id + E(n)),
                class: "text-white overflow-hidden"
            }, [O(d, {
                to: `/v/${t.video.id}`,
                onMouseenter: r,
                onMouseleave: o,
                class: Pt(["block aspect-video w-full bg-zinc-800 relative transition-all overflow-hidden lg:rounded-md", {
                    "!bg-black": a.value,
                    "!rounded-md": t.rounded
                }])
            }, {
                default: Y( () => [l.value ? (w(),
                R("span", mN, [O(ze, {
                    name: "ai",
                    class: "h-100 w-100"
                })])) : le("", !0), t.video.preview_url && a.value ? (w(),
                R("video", {
                    key: 1,
                    onCanplay: u[0] || (u[0] = h => {
                        var p;
                        return (p = h.target) == null ? void 0 : p.play()
                    }
                    ),
                    poster: E(Gs)(t.video.thumbnail_url),
                    src: a.value ? E(Gs)(t.video.preview_url) : "",
                    autoplay: "",
                    loop: "",
                    playsinline: "",
                    muted: "",
                    class: "h-full w-full"
                }, null, 40, gN)) : (w(),
                R(Ge, {
                    key: 2
                }, [E(it)().isProduction ? zt((w(),
                R("img", vN, null, 512)), [[f, E(Gs)(t.video.thumbnail_url)]]) : (w(),
                R("div", _N, " Image Disable for Development Mode ")), x("div", xN, [t.video.vr ? (w(),
                R("div", yN, u[2] || (u[2] = [x("span", null, "VR", -1)]))) : le("", !0), x("div", bN, ee(E(fl)(t.video.duration)), 1)])], 64))]),
                _: 1
            }, 8, ["to", "class"]), x("div", SN, [x("div", EN, [O(d, {
                to: `/u/${t.video.user.username}`,
                class: "underline overflow-hidden overflow-ellipsis"
            }, {
                default: Y( () => [J(ee(t.video.user.username), 1)]),
                _: 1
            }, 8, ["to"]), x("div", wN, [x("span", TN, [O(ze, {
                name: "eye",
                class: "h-4 w-4"
            }), J(" " + ee(E(vr)(t.video.views)), 1)]), x("span", AN, [O(ze, {
                name: "heart-outline",
                class: "h-4 w-4"
            }), J(" " + ee(t.video.rating.likes), 1)]), x("span", CN, [O(ze, {
                name: "speedometer",
                class: "h-4 w-4"
            }), J(" " + ee(t.video.script.average_speed), 1)])])]), O(d, {
                to: `/v/${t.video.id}`,
                class: "break-all line-clamp-1 text-lg md:text-base",
                title: t.video.name
            }, {
                default: Y( () => [J(ee(t.video.name), 1)]),
                _: 1
            }, 8, ["to", "title"])])], 32)) : le("", !0)
        }
    }
})
  , MC = i => i.replace(/\w\S*/g, e => e.charAt(0).toUpperCase() + e.substring(1).toLowerCase())
  , MN = {
    key: 0,
    class: "welcome-message"
}
  , RN = {
    key: 0
}
  , LN = {
    class: "mb-8"
}
  , IN = {
    key: 0,
    class: "flex items-center text-white gap-x-2 mb-4"
}
  , kN = {
    class: "px-2 lg:px-0 text-xl lg:text-2xl !leading-none font-medium"
}
  , PN = {
    class: "absolute inset-0 opacity-50 group-hover:opacity-25 -z-10"
}
  , DN = {
    class: "absolute inset-0 opacity-50 group-hover:opacity-25 -z-10"
}
  , FN = {
    class: "drop-shadow"
}
  , ON = {
    key: 2,
    class: "flex flex-wrap gap-1.5 mt-1.5 max-height-2tabs overflow-hidden"
}
  , UN = {
    class: "drop-shadow truncate relative px-4 py-2"
}
  , NN = {
    key: 1,
    class: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 2xl:grid-cols-5 gap-4"
}
  , yb = ut({
    __name: "Home",
    async setup(i) {
        let e, t;
        const {isProduction: n} = it()
          , {getOrientation: s} = it()
          , r = ([e,t] = As( () => ct.feed.getFeed(s())),
        e = await e,
        t(),
        e)
          , o = ti()
          , {isMobile: a} = Ks()
          , l = xe(!localStorage.getItem("hasVisited"));
        l.value && localStorage.setItem("hasVisited", "true");
        const c = async () => {
            const u = await ct.videos.getVideo("random");
            o.push(`/v/${u.id}`)
        }
        ;
        return Ti( () => ci(n ? "FapTap - The Interactive Porn Experience" : "Demo")),
        (u, d) => {
            const f = li("router-link")
              , h = Jd("lazy");
            return w(),
            R(Ge, null, [l.value ? (w(),
            R("div", MN, [E(it)().isProduction ? (w(),
            R("div", RN, d[0] || (d[0] = [x("b", {
                class: "welcome-message-header"
            }, [J(" \u{1F44B} \xA0 Welcome to Faptap, the "), x("u", null, "biggest interactive porn site"), J(" in the world. ")], -1), J(" All of the videos here sync with any of 500 different toys, so you can feel porn instead of just watching it. Stop watching caveman porn and insert yourself into the action!"), x("br", null, null, -1), J(" Faptap is free, and the best male masturbators are just $100. That\u2019s two avocado toasts and a parking ticket you weren\u2019t going to pay anyway. Click any video to see how syncing works. ")]))) : le("", !0)])) : le("", !0), (w(!0),
            R(Ge, null, Ht(E(r), p => (w(),
            R("div", LN, [p.title && p.type !== "products" ? (w(),
            R("div", IN, [x("h2", kN, ee(p.title), 1)])) : le("", !0), p.type === "categories" ? (w(),
            Re(Er, {
                key: 1,
                gap: "gap-2 lg:gap-4"
            }, {
                default: Y( () => [x("button", {
                    onClick: c,
                    class: "aspect-video rounded-md overflow-hidden h-24 group flex items-center justify-center font-bold text-2xl relative z-10 bg-zinc-800"
                }, [zt(x("img", PN, null, 512), [[h, "/categories/random.jpg"]]), d[1] || (d[1] = x("span", {
                    class: "drop-shadow"
                }, "Random", -1))]), E(it)().isProduction ? (w(!0),
                R(Ge, {
                    key: 0
                }, Ht(p.data, g => (w(),
                Re(f, {
                    to: `/videos?q=${g.name}`,
                    class: "aspect-video rounded overflow-hidden h-24 group flex items-center justify-center font-bold text-2xl relative z-10 bg-zinc-800"
                }, {
                    default: Y( () => [zt(x("img", DN, null, 512), [[h, g.image_url]]), x("span", FN, ee(g.name), 1)]),
                    _: 2
                }, 1032, ["to"]))), 256)) : le("", !0)]),
                _: 2
            }, 1024)) : le("", !0), p.type === "tags" ? (w(),
            R("div", ON, [E(it)().isProduction ? (w(!0),
            R(Ge, {
                key: 0
            }, Ht(p.data, g => (w(),
            Re(f, {
                to: `/t/${g.slug}`,
                class: "rounded-lg overflow-hidden group flex items-center justify-center font-bold text-1xl relative z-10 bg-zinc-800"
            }, {
                default: Y( () => [x("span", UN, ee(E(MC)(g.name)), 1)]),
                _: 2
            }, 1032, ["to"]))), 256)) : le("", !0)])) : p.type === "videos" ? (w(),
            R(Ge, {
                key: 3
            }, [E(a) ? (w(),
            Re(Er, {
                key: 0,
                gap: "gap-2 lg:gap-4"
            }, {
                default: Y( () => [(w(!0),
                R(Ge, null, Ht(p.data, g => (w(),
                Re(F1, {
                    class: "!w-80",
                    rounded: !0,
                    video: g
                }, null, 8, ["video"]))), 256))]),
                _: 2
            }, 1024)) : (w(),
            R("div", NN, [(w(!0),
            R(Ge, null, Ht(p.data, g => (w(),
            Re(F1, {
                video: g
            }, null, 8, ["video"]))), 256))]))], 64)) : le("", !0)]))), 256))], 64)
        }
    }
})
  , BN = {
    class: "flex justify-between items-center"
}
  , VN = ["checked"]
  , $N = {
    class: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 2xl:grid-cols-5 gap-4 mt-2 relative"
}
  , HN = {
    key: 0
}
  , zN = {
    class: "py-1 px-2 md:px-0"
}
  , GN = {
    class: "flex gap-1.5 text-zinc-400 md:text-sm"
}
  , WN = {
    class: "flex-1 justify-end shrink-0 flex gap-1.5"
}
  , qN = {
    class: "flex gap-x-0.5 items-center"
}
  , jN = {
    class: "flex gap-x-0.5 items-center"
}
  , KN = {
    class: "flex gap-x-0.5 items-center"
}
  , XN = {
    key: 0,
    class: "text-white font-medium px-2 lg:px-0"
}
  , YN = {
    key: 1,
    class: "py-12 flex justify-center items-center"
}
  , $l = ut({
    __name: "VideosList",
    props: {
        user: {},
        performer: {},
        tag: {},
        video: {},
        subscriptions: {
            type: Boolean
        },
        likes: {
            type: Boolean
        },
        query: {},
        filters: {
            type: Boolean,
            default: !0
        },
        removeExcludedTags: {
            type: Boolean
        }
    },
    setup(i) {
        const e = i
          , {random: t} = AC()
          , {isMobile: n} = Ks()
          , {user: s, getOrientation: r} = it()
          , o = xe(!1)
          , a = xe(!1)
          , l = xe(!1)
          , c = xe(!1)
          , u = xe(!0)
          , d = xe()
          , f = xe(1)
          , h = xe(!1)
          , p = ei({
            ascending: !1,
            order: er.relevance,
            orderFilters: {
                Relevance: er.relevance,
                Views: er.views,
                Likes: er.likes,
                Duration: er.duration,
                Speed: er.speed,
                "Upload date": er.creation
            },
            fromFilters: {
                Anytime: void 0,
                "This week": el.week,
                "This month": el.month,
                "This year": el.year
            },
            sourceViewsFilters: {
                "Source | This week": el.week,
                "Source | This month": el.month,
                "Source | This year": el.year
            },
            durationFilters: {
                All: void 0,
                "Short videos (1-5min)": bh.short,
                "Medium videos (5-10min)": bh.medium,
                "Long videos (+10min)": bh.long
            },
            speedFilters: {
                All: void 0,
                "Slow (0-150)": Xu.slow,
                "Medium (151-300)": Xu.medium,
                "Fast (301-500)": Xu.fast,
                "Very fast (500+)": Xu.veryfast
            },
            source: !1
        });
        let g = !1;
        const m = async () => {
            h.value = !0;
            const S = await ct.videos.getVideos({
                page: f.value,
                limit: 40,
                orderBy: p.order,
                user: e.user,
                tag: e.tag,
                tagsExclude: e.user ? void 0 : p.excludedTags,
                performer: e.performer,
                asc: p.ascending,
                likes: e.likes,
                query: e.query,
                video: e.video,
                subscriptions: e.subscriptions,
                from: p.from,
                duration: p.duration,
                speed: p.speed,
                source: p.source,
                orientation: r(),
                removeExcludedTags: e.removeExcludedTags
            });
            d.value || (d.value = []),
            d.value = d.value.concat(S),
            S.length < 40 && (g = !0),
            h.value = !1
        }
          , v = async () => {
            h.value || g || !d.value || window.innerHeight + window.scrollY < document.body.offsetHeight - 100 || (f.value++,
            await m())
        }
        ;
        async function _() {
            const S = localStorage.getItem("aiCheckbox");
            S !== null ? (S === "true" ? p.excludedTags = "" : p.excludedTags = "faptapai,ai",
            u.value = S === "true") : (u.value = !0,
            localStorage.setItem("aiCheckbox", "true")),
            await m()
        }
        Ln(async () => {
            window.addEventListener("scroll", v),
            _()
        }
        ),
        Ms( () => {
            window.removeEventListener("scroll", v)
        }
        );
        const y = async () => {
            d.value = void 0,
            f.value = 1,
            h.value = !1,
            g = !1,
            await m()
        }
          , b = S => {
            S === er.relevance || p.order !== S ? p.ascending = !1 : p.ascending = !p.ascending,
            p.order = S
        }
        ;
        return Bt( () => e, async () => await y(), {
            deep: !0
        }),
        Bt( () => p, async () => await y(), {
            deep: !0
        }),
        Bt( () => u.value, S => {
            localStorage.setItem("aiCheckbox", S.toString())
        }
        ),
        (S, C) => (w(),
        R("div", null, [e.filters ? (w(),
        Re(Er, {
            key: 0,
            gap: "gap-1.5"
        }, {
            default: Y( () => {
                var M, L, T, A;
                return [O(je, {
                    ref: "order",
                    onClick: C[0] || (C[0] = k => a.value = !a.value),
                    theme: p.order !== E(er).relevance ? "blue" : void 0,
                    class: "flex items-center gap-1"
                }, {
                    default: Y( () => [O(ze, {
                        name: p.ascending ? "sort-ascending" : "sort-descending",
                        class: "h-5 w-5"
                    }, null, 8, ["name"]), J(" " + ee(Object.keys(p.orderFilters).find(k => p.orderFilters[k] === p.order)), 1)]),
                    _: 1
                }, 8, ["theme"]), (w(),
                Re(ys(E(n) ? dr : ji), {
                    modelValue: a.value,
                    "onUpdate:modelValue": C[1] || (C[1] = k => a.value = k),
                    placement: "bottom",
                    target: (M = S.$refs.order) == null ? void 0 : M.$el,
                    class: "text-white text-sm py-1 w-36",
                    offset: 8
                }, {
                    default: Y( () => [(w(!0),
                    R(Ge, null, Ht(p.orderFilters, (k, D) => (w(),
                    Re(Ot, {
                        active: k === p.order,
                        onClick: F => b(k)
                    }, {
                        default: Y( () => [x("div", BN, [x("span", null, ee(D), 1), p.order === k && k !== E(er).relevance ? (w(),
                        Re(ze, {
                            key: 0,
                            name: p.ascending ? "sort-ascending" : "sort-descending",
                            class: "h-5 w-5"
                        }, null, 8, ["name"])) : le("", !0)])]),
                        _: 2
                    }, 1032, ["active", "onClick"]))), 256))]),
                    _: 1
                }, 8, ["modelValue", "target"])), O(je, {
                    ref: "date",
                    onClick: C[2] || (C[2] = k => o.value = !o.value),
                    class: "flex items-center gap-1",
                    theme: p.from ? "blue" : void 0
                }, {
                    default: Y( () => [O(ze, {
                        name: "calendar",
                        class: "h-5 w-5"
                    }), J(" " + ee(p.from ? Object.keys(p.fromFilters).find(k => p.fromFilters[k] === p.from) : "Date"), 1)]),
                    _: 1
                }, 8, ["theme"]), (w(),
                Re(ys(E(n) ? dr : ji), {
                    modelValue: o.value,
                    "onUpdate:modelValue": C[3] || (C[3] = k => o.value = k),
                    placement: "bottom",
                    target: (L = S.$refs.date) == null ? void 0 : L.$el,
                    class: "text-white text-sm py-1 w-48",
                    offset: 8
                }, {
                    default: Y( () => [(w(!0),
                    R(Ge, null, Ht(p.fromFilters, (k, D) => (w(),
                    Re(Ot, {
                        active: k === p.from && p.source !== !0,
                        onClick: F => (p.from = k,
                        p.source = !1,
                        o.value = !1)
                    }, {
                        default: Y( () => [J(ee(D), 1)]),
                        _: 2
                    }, 1032, ["active", "onClick"]))), 256)), (w(!0),
                    R(Ge, null, Ht(p.sourceViewsFilters, (k, D) => (w(),
                    Re(Ot, {
                        active: k === p.from && p.source === !0,
                        onClick: F => (p.source = !0,
                        p.from = k,
                        o.value = !1)
                    }, {
                        default: Y( () => [J(ee(D), 1)]),
                        _: 2
                    }, 1032, ["active", "onClick"]))), 256))]),
                    _: 1
                }, 8, ["modelValue", "target"])), O(je, {
                    ref: "duration",
                    onClick: C[4] || (C[4] = k => l.value = !l.value),
                    class: "flex items-center gap-1",
                    theme: p.duration ? "blue" : void 0
                }, {
                    default: Y( () => [O(ze, {
                        name: "clock",
                        class: "h-5 w-5"
                    }), J(" " + ee(p.duration ? Object.keys(p.durationFilters).find(k => p.durationFilters[k] === p.duration) : "Duration"), 1)]),
                    _: 1
                }, 8, ["theme"]), (w(),
                Re(ys(E(n) ? dr : ji), {
                    modelValue: l.value,
                    "onUpdate:modelValue": C[5] || (C[5] = k => l.value = k),
                    placement: "bottom",
                    target: (T = S.$refs.duration) == null ? void 0 : T.$el,
                    class: "text-white text-sm py-1 w-52",
                    offset: 8
                }, {
                    default: Y( () => [(w(!0),
                    R(Ge, null, Ht(p.durationFilters, (k, D) => (w(),
                    Re(Ot, {
                        active: k === p.duration,
                        onClick: F => (p.duration = k,
                        l.value = !1)
                    }, {
                        default: Y( () => [J(ee(D), 1)]),
                        _: 2
                    }, 1032, ["active", "onClick"]))), 256))]),
                    _: 1
                }, 8, ["modelValue", "target"])), O(je, {
                    ref: "speed",
                    onClick: C[6] || (C[6] = k => c.value = !c.value),
                    class: "flex items-center gap-1",
                    theme: p.speed ? "blue" : void 0
                }, {
                    default: Y( () => [O(ze, {
                        name: "speedometer",
                        class: "h-5 w-5"
                    }), J(" " + ee(p.speed ? Object.keys(p.speedFilters).find(k => p.speedFilters[k] === p.speed) : "Speed"), 1)]),
                    _: 1
                }, 8, ["theme"]), (w(),
                Re(ys(E(n) ? dr : ji), {
                    modelValue: c.value,
                    "onUpdate:modelValue": C[7] || (C[7] = k => c.value = k),
                    placement: "bottom",
                    target: (A = S.$refs.speed) == null ? void 0 : A.$el,
                    class: "text-white text-sm py-1 w-40",
                    offset: 8
                }, {
                    default: Y( () => [(w(!0),
                    R(Ge, null, Ht(p.speedFilters, (k, D) => (w(),
                    Re(Ot, {
                        active: k === p.speed,
                        onClick: F => (p.speed = k,
                        c.value = !1)
                    }, {
                        default: Y( () => [J(ee(D), 1)]),
                        _: 2
                    }, 1032, ["active", "onClick"]))), 256))]),
                    _: 1
                }, 8, ["modelValue", "target"])), O(je, {
                    ref: "aiFilter",
                    class: "flex items-center gap-1",
                    onClick: C[8] || (C[8] = k => (u.value = !u.value,
                    u.value ? p.excludedTags = "" : p.excludedTags = "faptapai,ai"))
                }, {
                    default: Y( () => [x("input", {
                        type: "checkbox",
                        checked: u.value,
                        class: "cursor-pointer"
                    }, null, 8, VN), O(ze, {
                        name: "ai",
                        class: "h-5 w-5"
                    }), C[9] || (C[9] = J(" AI Generated "))]),
                    _: 1
                }, 512)]
            }
            ),
            _: 1
        })) : le("", !0), x("div", $N, [d.value ? (w(),
        R(Ge, {
            key: 0
        }, [(w(!0),
        R(Ge, null, Ht(d.value, (M, L) => (w(),
        R(Ge, null, [L % 16 === 0 ? (w(),
        R("div", HN, [O(TC, {
            affiliate: E(t)(),
            class: "aspect-video rounded overflow-hidden"
        }, null, 8, ["affiliate"]), x("div", zN, [x("div", GN, [C[13] || (C[13] = x("span", {
            class: "underline overflow-hidden overflow-ellipsis"
        }, "FapTap", -1)), x("div", WN, [x("span", qN, [O(ze, {
            name: "eye",
            class: "h-4 w-4"
        }), C[10] || (C[10] = J("173"))]), x("span", jN, [O(ze, {
            name: "heart-outline",
            class: "h-4 w-4"
        }), C[11] || (C[11] = J("47"))]), x("span", KN, [O(ze, {
            name: "speedometer",
            class: "h-4 w-4"
        }), C[12] || (C[12] = J("376"))])])]), C[14] || (C[14] = x("span", {
            class: "break-all line-clamp-1 text-lg md:text-base"
        }, "Special Offer", -1))])])) : le("", !0), O(F1, {
            video: M
        }, null, 8, ["video"])], 64))), 256)), d.value.length ? le("", !0) : (w(),
        R("p", XN, "Sorry, no videos found."))], 64)) : h.value ? (w(),
        R("div", YN, [O(ze, {
            name: "loading",
            class: "h-10 w-10 text-blue-500 animate-spin"
        })])) : le("", !0)])]))
    }
})
  , wm = ut({
    __name: "SubscriptionButton",
    props: {
        user: {}
    },
    setup(i) {
        const {authDialog: e} = Pn(Xi())
          , {isAuthorized: t, user: n, subscriptions: s} = Pn(it())
          , r = i
          , o = xe(!1)
          , a = Vt( () => s.value.findIndex(c => c.id === r.user.id) !== -1)
          , l = () => {
            o.value = !0,
            a.value ? ct.user.unsubscribe(r.user).then(async () => {
                const c = s.value.findIndex(u => u.id === r.user.id);
                s.value.splice(c, 1),
                await new Promise(u => setTimeout(u, 1e3))
            }
            ).finally( () => o.value = !1) : ct.user.subscribe(r.user).then(async () => {
                s.value.unshift(r.user),
                await new Promise(c => setTimeout(c, 1e3))
            }
            ).finally( () => o.value = !1)
        }
        ;
        return (c, u) => E(t) && E(n).id !== r.user.id ? (w(),
        Re(je, {
            key: 0,
            loading: o.value,
            onClick: l,
            theme: a.value ? "" : "blue"
        }, {
            default: Y( () => [J(ee(a.value ? "Unsubscribe" : "Subscribe"), 1)]),
            _: 1
        }, 8, ["loading", "theme"])) : E(t) ? le("", !0) : (w(),
        Re(je, {
            key: 1,
            theme: "blue",
            onClick: u[0] || (u[0] = d => e.value = !0)
        }, {
            default: Y( () => u[1] || (u[1] = [J("Subscribe ")])),
            _: 1
        }))
    }
});
function RC() {
    return {
        async: !1,
        baseUrl: null,
        breaks: !1,
        extensions: null,
        gfm: !0,
        headerIds: !0,
        headerPrefix: "",
        highlight: null,
        hooks: null,
        langPrefix: "language-",
        mangle: !0,
        pedantic: !1,
        renderer: null,
        sanitize: !1,
        sanitizer: null,
        silent: !1,
        smartypants: !1,
        tokenizer: null,
        walkTokens: null,
        xhtml: !1
    }
}
let Hl = RC();
function ZN(i) {
    Hl = i
}
const LC = /[&<>"']/
  , JN = new RegExp(LC.source,"g")
  , IC = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/
  , QN = new RegExp(IC.source,"g")
  , eB = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;"
}
  , bb = i => eB[i];
function Li(i, e) {
    if (e) {
        if (LC.test(i))
            return i.replace(JN, bb)
    } else if (IC.test(i))
        return i.replace(QN, bb);
    return i
}
const tB = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
function kC(i) {
    return i.replace(tB, (e, t) => (t = t.toLowerCase(),
    t === "colon" ? ":" : t.charAt(0) === "#" ? t.charAt(1) === "x" ? String.fromCharCode(parseInt(t.substring(2), 16)) : String.fromCharCode(+t.substring(1)) : ""))
}
const nB = /(^|[^\[])\^/g;
function En(i, e) {
    i = typeof i == "string" ? i : i.source,
    e = e || "";
    const t = {
        replace: (n, s) => (s = s.source || s,
        s = s.replace(nB, "$1"),
        i = i.replace(n, s),
        t),
        getRegex: () => new RegExp(i,e)
    };
    return t
}
const iB = /[^\w:]/g
  , sB = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
function Sb(i, e, t) {
    if (i) {
        let n;
        try {
            n = decodeURIComponent(kC(t)).replace(iB, "").toLowerCase()
        } catch {
            return null
        }
        if (n.indexOf("javascript:") === 0 || n.indexOf("vbscript:") === 0 || n.indexOf("data:") === 0)
            return null
    }
    e && !sB.test(t) && (t = lB(e, t));
    try {
        t = encodeURI(t).replace(/%25/g, "%")
    } catch {
        return null
    }
    return t
}
const If = {}
  , rB = /^[^:]+:\/*[^/]*$/
  , oB = /^([^:]+:)[\s\S]*$/
  , aB = /^([^:]+:\/*[^/]*)[\s\S]*$/;
function lB(i, e) {
    If[" " + i] || (rB.test(i) ? If[" " + i] = i + "/" : If[" " + i] = Ah(i, "/", !0)),
    i = If[" " + i];
    const t = i.indexOf(":") === -1;
    return e.substring(0, 2) === "//" ? t ? e : i.replace(oB, "$1") + e : e.charAt(0) === "/" ? t ? e : i.replace(aB, "$1") + e : i + e
}
const Sp = {
    exec: function() {}
};
function Eb(i, e) {
    const t = i.replace(/\|/g, (r, o, a) => {
        let l = !1
          , c = o;
        for (; --c >= 0 && a[c] === "\\"; )
            l = !l;
        return l ? "|" : " |"
    }
    )
      , n = t.split(/ \|/);
    let s = 0;
    if (n[0].trim() || n.shift(),
    n.length > 0 && !n[n.length - 1].trim() && n.pop(),
    n.length > e)
        n.splice(e);
    else
        for (; n.length < e; )
            n.push("");
    for (; s < n.length; s++)
        n[s] = n[s].trim().replace(/\\\|/g, "|");
    return n
}
function Ah(i, e, t) {
    const n = i.length;
    if (n === 0)
        return "";
    let s = 0;
    for (; s < n; ) {
        const r = i.charAt(n - s - 1);
        if (r === e && !t)
            s++;
        else if (r !== e && t)
            s++;
        else
            break
    }
    return i.slice(0, n - s)
}
function cB(i, e) {
    if (i.indexOf(e[1]) === -1)
        return -1;
    const t = i.length;
    let n = 0
      , s = 0;
    for (; s < t; s++)
        if (i[s] === "\\")
            s++;
        else if (i[s] === e[0])
            n++;
        else if (i[s] === e[1] && (n--,
        n < 0))
            return s;
    return -1
}
function uB(i) {
    i && i.sanitize && !i.silent && console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options")
}
function wb(i, e) {
    if (e < 1)
        return "";
    let t = "";
    for (; e > 1; )
        e & 1 && (t += i),
        e >>= 1,
        i += i;
    return t + i
}
function Tb(i, e, t, n) {
    const s = e.href
      , r = e.title ? Li(e.title) : null
      , o = i[1].replace(/\\([\[\]])/g, "$1");
    if (i[0].charAt(0) !== "!") {
        n.state.inLink = !0;
        const a = {
            type: "link",
            raw: t,
            href: s,
            title: r,
            text: o,
            tokens: n.inlineTokens(o)
        };
        return n.state.inLink = !1,
        a
    }
    return {
        type: "image",
        raw: t,
        href: s,
        title: r,
        text: Li(o)
    }
}
function dB(i, e) {
    const t = i.match(/^(\s+)(?:```)/);
    if (t === null)
        return e;
    const n = t[1];
    return e.split(`
`).map(s => {
        const r = s.match(/^\s+/);
        if (r === null)
            return s;
        const [o] = r;
        return o.length >= n.length ? s.slice(n.length) : s
    }
    ).join(`
`)
}
class K_ {
    constructor(e) {
        this.options = e || Hl
    }
    space(e) {
        const t = this.rules.block.newline.exec(e);
        if (t && t[0].length > 0)
            return {
                type: "space",
                raw: t[0]
            }
    }
    code(e) {
        const t = this.rules.block.code.exec(e);
        if (t) {
            const n = t[0].replace(/^ {1,4}/gm, "");
            return {
                type: "code",
                raw: t[0],
                codeBlockStyle: "indented",
                text: this.options.pedantic ? n : Ah(n, `
`)
            }
        }
    }
    fences(e) {
        const t = this.rules.block.fences.exec(e);
        if (t) {
            const n = t[0]
              , s = dB(n, t[3] || "");
            return {
                type: "code",
                raw: n,
                lang: t[2] ? t[2].trim().replace(this.rules.inline._escapes, "$1") : t[2],
                text: s
            }
        }
    }
    heading(e) {
        const t = this.rules.block.heading.exec(e);
        if (t) {
            let n = t[2].trim();
            if (/#$/.test(n)) {
                const s = Ah(n, "#");
                (this.options.pedantic || !s || / $/.test(s)) && (n = s.trim())
            }
            return {
                type: "heading",
                raw: t[0],
                depth: t[1].length,
                text: n,
                tokens: this.lexer.inline(n)
            }
        }
    }
    hr(e) {
        const t = this.rules.block.hr.exec(e);
        if (t)
            return {
                type: "hr",
                raw: t[0]
            }
    }
    blockquote(e) {
        const t = this.rules.block.blockquote.exec(e);
        if (t) {
            const n = t[0].replace(/^ *>[ \t]?/gm, "")
              , s = this.lexer.state.top;
            this.lexer.state.top = !0;
            const r = this.lexer.blockTokens(n);
            return this.lexer.state.top = s,
            {
                type: "blockquote",
                raw: t[0],
                tokens: r,
                text: n
            }
        }
    }
    list(e) {
        let t = this.rules.block.list.exec(e);
        if (t) {
            let n, s, r, o, a, l, c, u, d, f, h, p, g = t[1].trim();
            const m = g.length > 1
              , v = {
                type: "list",
                raw: "",
                ordered: m,
                start: m ? +g.slice(0, -1) : "",
                loose: !1,
                items: []
            };
            g = m ? `\\d{1,9}\\${g.slice(-1)}` : `\\${g}`,
            this.options.pedantic && (g = m ? g : "[*+-]");
            const _ = new RegExp(`^( {0,3}${g})((?:[	 ][^\\n]*)?(?:\\n|$))`);
            for (; e && (p = !1,
            !(!(t = _.exec(e)) || this.rules.block.hr.test(e))); ) {
                if (n = t[0],
                e = e.substring(n.length),
                u = t[2].split(`
`, 1)[0].replace(/^\t+/, b => " ".repeat(3 * b.length)),
                d = e.split(`
`, 1)[0],
                this.options.pedantic ? (o = 2,
                h = u.trimLeft()) : (o = t[2].search(/[^ ]/),
                o = o > 4 ? 1 : o,
                h = u.slice(o),
                o += t[1].length),
                l = !1,
                !u && /^ *$/.test(d) && (n += d + `
`,
                e = e.substring(d.length + 1),
                p = !0),
                !p) {
                    const b = new RegExp(`^ {0,${Math.min(3, o - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`)
                      , S = new RegExp(`^ {0,${Math.min(3, o - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`)
                      , C = new RegExp(`^ {0,${Math.min(3, o - 1)}}(?:\`\`\`|~~~)`)
                      , M = new RegExp(`^ {0,${Math.min(3, o - 1)}}#`);
                    for (; e && (f = e.split(`
`, 1)[0],
                    d = f,
                    this.options.pedantic && (d = d.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ")),
                    !(C.test(d) || M.test(d) || b.test(d) || S.test(e))); ) {
                        if (d.search(/[^ ]/) >= o || !d.trim())
                            h += `
` + d.slice(o);
                        else {
                            if (l || u.search(/[^ ]/) >= 4 || C.test(u) || M.test(u) || S.test(u))
                                break;
                            h += `
` + d
                        }
                        !l && !d.trim() && (l = !0),
                        n += f + `
`,
                        e = e.substring(f.length + 1),
                        u = d.slice(o)
                    }
                }
                v.loose || (c ? v.loose = !0 : /\n *\n *$/.test(n) && (c = !0)),
                this.options.gfm && (s = /^\[[ xX]\] /.exec(h),
                s && (r = s[0] !== "[ ] ",
                h = h.replace(/^\[[ xX]\] +/, ""))),
                v.items.push({
                    type: "list_item",
                    raw: n,
                    task: !!s,
                    checked: r,
                    loose: !1,
                    text: h
                }),
                v.raw += n
            }
            v.items[v.items.length - 1].raw = n.trimRight(),
            v.items[v.items.length - 1].text = h.trimRight(),
            v.raw = v.raw.trimRight();
            const y = v.items.length;
            for (a = 0; a < y; a++)
                if (this.lexer.state.top = !1,
                v.items[a].tokens = this.lexer.blockTokens(v.items[a].text, []),
                !v.loose) {
                    const b = v.items[a].tokens.filter(C => C.type === "space")
                      , S = b.length > 0 && b.some(C => /\n.*\n/.test(C.raw));
                    v.loose = S
                }
            if (v.loose)
                for (a = 0; a < y; a++)
                    v.items[a].loose = !0;
            return v
        }
    }
    html(e) {
        const t = this.rules.block.html.exec(e);
        if (t) {
            const n = {
                type: "html",
                raw: t[0],
                pre: !this.options.sanitizer && (t[1] === "pre" || t[1] === "script" || t[1] === "style"),
                text: t[0]
            };
            if (this.options.sanitize) {
                const s = this.options.sanitizer ? this.options.sanitizer(t[0]) : Li(t[0]);
                n.type = "paragraph",
                n.text = s,
                n.tokens = this.lexer.inline(s)
            }
            return n
        }
    }
    def(e) {
        const t = this.rules.block.def.exec(e);
        if (t) {
            const n = t[1].toLowerCase().replace(/\s+/g, " ")
              , s = t[2] ? t[2].replace(/^<(.*)>$/, "$1").replace(this.rules.inline._escapes, "$1") : ""
              , r = t[3] ? t[3].substring(1, t[3].length - 1).replace(this.rules.inline._escapes, "$1") : t[3];
            return {
                type: "def",
                tag: n,
                raw: t[0],
                href: s,
                title: r
            }
        }
    }
    table(e) {
        const t = this.rules.block.table.exec(e);
        if (t) {
            const n = {
                type: "table",
                header: Eb(t[1]).map(s => ({
                    text: s
                })),
                align: t[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
                rows: t[3] && t[3].trim() ? t[3].replace(/\n[ \t]*$/, "").split(`
`) : []
            };
            if (n.header.length === n.align.length) {
                n.raw = t[0];
                let s = n.align.length, r, o, a, l;
                for (r = 0; r < s; r++)
                    /^ *-+: *$/.test(n.align[r]) ? n.align[r] = "right" : /^ *:-+: *$/.test(n.align[r]) ? n.align[r] = "center" : /^ *:-+ *$/.test(n.align[r]) ? n.align[r] = "left" : n.align[r] = null;
                for (s = n.rows.length,
                r = 0; r < s; r++)
                    n.rows[r] = Eb(n.rows[r], n.header.length).map(c => ({
                        text: c
                    }));
                for (s = n.header.length,
                o = 0; o < s; o++)
                    n.header[o].tokens = this.lexer.inline(n.header[o].text);
                for (s = n.rows.length,
                o = 0; o < s; o++)
                    for (l = n.rows[o],
                    a = 0; a < l.length; a++)
                        l[a].tokens = this.lexer.inline(l[a].text);
                return n
            }
        }
    }
    lheading(e) {
        const t = this.rules.block.lheading.exec(e);
        if (t)
            return {
                type: "heading",
                raw: t[0],
                depth: t[2].charAt(0) === "=" ? 1 : 2,
                text: t[1],
                tokens: this.lexer.inline(t[1])
            }
    }
    paragraph(e) {
        const t = this.rules.block.paragraph.exec(e);
        if (t) {
            const n = t[1].charAt(t[1].length - 1) === `
` ? t[1].slice(0, -1) : t[1];
            return {
                type: "paragraph",
                raw: t[0],
                text: n,
                tokens: this.lexer.inline(n)
            }
        }
    }
    text(e) {
        const t = this.rules.block.text.exec(e);
        if (t)
            return {
                type: "text",
                raw: t[0],
                text: t[0],
                tokens: this.lexer.inline(t[0])
            }
    }
    escape(e) {
        const t = this.rules.inline.escape.exec(e);
        if (t)
            return {
                type: "escape",
                raw: t[0],
                text: Li(t[1])
            }
    }
    tag(e) {
        const t = this.rules.inline.tag.exec(e);
        if (t)
            return !this.lexer.state.inLink && /^<a /i.test(t[0]) ? this.lexer.state.inLink = !0 : this.lexer.state.inLink && /^<\/a>/i.test(t[0]) && (this.lexer.state.inLink = !1),
            !this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(t[0]) ? this.lexer.state.inRawBlock = !0 : this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(t[0]) && (this.lexer.state.inRawBlock = !1),
            {
                type: this.options.sanitize ? "text" : "html",
                raw: t[0],
                inLink: this.lexer.state.inLink,
                inRawBlock: this.lexer.state.inRawBlock,
                text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(t[0]) : Li(t[0]) : t[0]
            }
    }
    link(e) {
        const t = this.rules.inline.link.exec(e);
        if (t) {
            const n = t[2].trim();
            if (!this.options.pedantic && /^</.test(n)) {
                if (!/>$/.test(n))
                    return;
                const o = Ah(n.slice(0, -1), "\\");
                if ((n.length - o.length) % 2 === 0)
                    return
            } else {
                const o = cB(t[2], "()");
                if (o > -1) {
                    const l = (t[0].indexOf("!") === 0 ? 5 : 4) + t[1].length + o;
                    t[2] = t[2].substring(0, o),
                    t[0] = t[0].substring(0, l).trim(),
                    t[3] = ""
                }
            }
            let s = t[2]
              , r = "";
            if (this.options.pedantic) {
                const o = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(s);
                o && (s = o[1],
                r = o[3])
            } else
                r = t[3] ? t[3].slice(1, -1) : "";
            return s = s.trim(),
            /^</.test(s) && (this.options.pedantic && !/>$/.test(n) ? s = s.slice(1) : s = s.slice(1, -1)),
            Tb(t, {
                href: s && s.replace(this.rules.inline._escapes, "$1"),
                title: r && r.replace(this.rules.inline._escapes, "$1")
            }, t[0], this.lexer)
        }
    }
    reflink(e, t) {
        let n;
        if ((n = this.rules.inline.reflink.exec(e)) || (n = this.rules.inline.nolink.exec(e))) {
            let s = (n[2] || n[1]).replace(/\s+/g, " ");
            if (s = t[s.toLowerCase()],
            !s) {
                const r = n[0].charAt(0);
                return {
                    type: "text",
                    raw: r,
                    text: r
                }
            }
            return Tb(n, s, n[0], this.lexer)
        }
    }
    emStrong(e, t, n="") {
        let s = this.rules.inline.emStrong.lDelim.exec(e);
        if (!s || s[3] && n.match(/[\p{L}\p{N}]/u))
            return;
        const r = s[1] || s[2] || "";
        if (!r || r && (n === "" || this.rules.inline.punctuation.exec(n))) {
            const o = s[0].length - 1;
            let a, l, c = o, u = 0;
            const d = s[0][0] === "*" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
            for (d.lastIndex = 0,
            t = t.slice(-1 * e.length + o); (s = d.exec(t)) != null; ) {
                if (a = s[1] || s[2] || s[3] || s[4] || s[5] || s[6],
                !a)
                    continue;
                if (l = a.length,
                s[3] || s[4]) {
                    c += l;
                    continue
                } else if ((s[5] || s[6]) && o % 3 && !((o + l) % 3)) {
                    u += l;
                    continue
                }
                if (c -= l,
                c > 0)
                    continue;
                l = Math.min(l, l + c + u);
                const f = e.slice(0, o + s.index + (s[0].length - a.length) + l);
                if (Math.min(o, l) % 2) {
                    const p = f.slice(1, -1);
                    return {
                        type: "em",
                        raw: f,
                        text: p,
                        tokens: this.lexer.inlineTokens(p)
                    }
                }
                const h = f.slice(2, -2);
                return {
                    type: "strong",
                    raw: f,
                    text: h,
                    tokens: this.lexer.inlineTokens(h)
                }
            }
        }
    }
    codespan(e) {
        const t = this.rules.inline.code.exec(e);
        if (t) {
            let n = t[2].replace(/\n/g, " ");
            const s = /[^ ]/.test(n)
              , r = /^ /.test(n) && / $/.test(n);
            return s && r && (n = n.substring(1, n.length - 1)),
            n = Li(n, !0),
            {
                type: "codespan",
                raw: t[0],
                text: n
            }
        }
    }
    br(e) {
        const t = this.rules.inline.br.exec(e);
        if (t)
            return {
                type: "br",
                raw: t[0]
            }
    }
    del(e) {
        const t = this.rules.inline.del.exec(e);
        if (t)
            return {
                type: "del",
                raw: t[0],
                text: t[2],
                tokens: this.lexer.inlineTokens(t[2])
            }
    }
    autolink(e, t) {
        const n = this.rules.inline.autolink.exec(e);
        if (n) {
            let s, r;
            return n[2] === "@" ? (s = Li(this.options.mangle ? t(n[1]) : n[1]),
            r = "mailto:" + s) : (s = Li(n[1]),
            r = s),
            {
                type: "link",
                raw: n[0],
                text: s,
                href: r,
                tokens: [{
                    type: "text",
                    raw: s,
                    text: s
                }]
            }
        }
    }
    url(e, t) {
        let n;
        if (n = this.rules.inline.url.exec(e)) {
            let s, r;
            if (n[2] === "@")
                s = Li(this.options.mangle ? t(n[0]) : n[0]),
                r = "mailto:" + s;
            else {
                let o;
                do
                    o = n[0],
                    n[0] = this.rules.inline._backpedal.exec(n[0])[0];
                while (o !== n[0]);
                s = Li(n[0]),
                n[1] === "www." ? r = "http://" + n[0] : r = n[0]
            }
            return {
                type: "link",
                raw: n[0],
                text: s,
                href: r,
                tokens: [{
                    type: "text",
                    raw: s,
                    text: s
                }]
            }
        }
    }
    inlineText(e, t) {
        const n = this.rules.inline.text.exec(e);
        if (n) {
            let s;
            return this.lexer.state.inRawBlock ? s = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(n[0]) : Li(n[0]) : n[0] : s = Li(this.options.smartypants ? t(n[0]) : n[0]),
            {
                type: "text",
                raw: n[0],
                text: s
            }
        }
    }
}
const Mt = {
    newline: /^(?: *(?:\n|$))+/,
    code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
    fences: /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
    hr: /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,
    heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
    blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
    list: /^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/,
    html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",
    def: /^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
    table: Sp,
    lheading: /^((?:.|\n(?!\n))+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
    _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
    text: /^[^\n]+/
};
Mt._label = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
Mt._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
Mt.def = En(Mt.def).replace("label", Mt._label).replace("title", Mt._title).getRegex();
Mt.bullet = /(?:[*+-]|\d{1,9}[.)])/;
Mt.listItemStart = En(/^( *)(bull) */).replace("bull", Mt.bullet).getRegex();
Mt.list = En(Mt.list).replace(/bull/g, Mt.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + Mt.def.source + ")").getRegex();
Mt._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
Mt._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
Mt.html = En(Mt.html, "i").replace("comment", Mt._comment).replace("tag", Mt._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
Mt.paragraph = En(Mt._paragraph).replace("hr", Mt.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", Mt._tag).getRegex();
Mt.blockquote = En(Mt.blockquote).replace("paragraph", Mt.paragraph).getRegex();
Mt.normal = {
    ...Mt
};
Mt.gfm = {
    ...Mt.normal,
    table: "^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
};
Mt.gfm.table = En(Mt.gfm.table).replace("hr", Mt.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", Mt._tag).getRegex();
Mt.gfm.paragraph = En(Mt._paragraph).replace("hr", Mt.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("table", Mt.gfm.table).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", Mt._tag).getRegex();
Mt.pedantic = {
    ...Mt.normal,
    html: En(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", Mt._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
    def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
    heading: /^(#{1,6})(.*)(?:\n+|$)/,
    fences: Sp,
    lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
    paragraph: En(Mt.normal._paragraph).replace("hr", Mt.hr).replace("heading", ` *#{1,6} *[^
]`).replace("lheading", Mt.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex()
};
const mt = {
    escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
    autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
    url: Sp,
    tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
    link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
    reflink: /^!?\[(label)\]\[(ref)\]/,
    nolink: /^!?\[(ref)\](?:\[\])?/,
    reflinkSearch: "reflink|nolink(?!\\()",
    emStrong: {
        lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
        rDelimAst: /^(?:[^_*\\]|\\.)*?\_\_(?:[^_*\\]|\\.)*?\*(?:[^_*\\]|\\.)*?(?=\_\_)|(?:[^*\\]|\\.)+(?=[^*])|[punct_](\*+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|(?:[^punct*_\s\\]|\\.)(\*+)(?=[^punct*_\s])/,
        rDelimUnd: /^(?:[^_*\\]|\\.)*?\*\*(?:[^_*\\]|\\.)*?\_(?:[^_*\\]|\\.)*?(?=\*\*)|(?:[^_\\]|\\.)+(?=[^_])|[punct*](\_+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/
    },
    code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
    br: /^( {2,}|\\)\n(?!\s*$)/,
    del: Sp,
    text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
    punctuation: /^([\spunctuation])/
};
mt._punctuation = "!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~";
mt.punctuation = En(mt.punctuation).replace(/punctuation/g, mt._punctuation).getRegex();
mt.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g;
mt.escapedEmSt = /(?:^|[^\\])(?:\\\\)*\\[*_]/g;
mt._comment = En(Mt._comment).replace("(?:-->|$)", "-->").getRegex();
mt.emStrong.lDelim = En(mt.emStrong.lDelim).replace(/punct/g, mt._punctuation).getRegex();
mt.emStrong.rDelimAst = En(mt.emStrong.rDelimAst, "g").replace(/punct/g, mt._punctuation).getRegex();
mt.emStrong.rDelimUnd = En(mt.emStrong.rDelimUnd, "g").replace(/punct/g, mt._punctuation).getRegex();
mt._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
mt._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
mt._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
mt.autolink = En(mt.autolink).replace("scheme", mt._scheme).replace("email", mt._email).getRegex();
mt._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
mt.tag = En(mt.tag).replace("comment", mt._comment).replace("attribute", mt._attribute).getRegex();
mt._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
mt._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
mt._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
mt.link = En(mt.link).replace("label", mt._label).replace("href", mt._href).replace("title", mt._title).getRegex();
mt.reflink = En(mt.reflink).replace("label", mt._label).replace("ref", Mt._label).getRegex();
mt.nolink = En(mt.nolink).replace("ref", Mt._label).getRegex();
mt.reflinkSearch = En(mt.reflinkSearch, "g").replace("reflink", mt.reflink).replace("nolink", mt.nolink).getRegex();
mt.normal = {
    ...mt
};
mt.pedantic = {
    ...mt.normal,
    strong: {
        start: /^__|\*\*/,
        middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
        endAst: /\*\*(?!\*)/g,
        endUnd: /__(?!_)/g
    },
    em: {
        start: /^_|\*/,
        middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
        endAst: /\*(?!\*)/g,
        endUnd: /_(?!_)/g
    },
    link: En(/^!?\[(label)\]\((.*?)\)/).replace("label", mt._label).getRegex(),
    reflink: En(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", mt._label).getRegex()
};
mt.gfm = {
    ...mt.normal,
    escape: En(mt.escape).replace("])", "~|])").getRegex(),
    _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
    url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
    _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
    del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
    text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
};
mt.gfm.url = En(mt.gfm.url, "i").replace("email", mt.gfm._extended_email).getRegex();
mt.breaks = {
    ...mt.gfm,
    br: En(mt.br).replace("{2,}", "*").getRegex(),
    text: En(mt.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
};
function fB(i) {
    return i.replace(/---/g, "\u2014").replace(/--/g, "\u2013").replace(/(^|[-\u2014/(\[{"\s])'/g, "$1\u2018").replace(/'/g, "\u2019").replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1\u201C").replace(/"/g, "\u201D").replace(/\.{3}/g, "\u2026")
}
function Ab(i) {
    let e = "", t, n;
    const s = i.length;
    for (t = 0; t < s; t++)
        n = i.charCodeAt(t),
        Math.random() > .5 && (n = "x" + n.toString(16)),
        e += "&#" + n + ";";
    return e
}
class Ea {
    constructor(e) {
        this.tokens = [],
        this.tokens.links = Object.create(null),
        this.options = e || Hl,
        this.options.tokenizer = this.options.tokenizer || new K_,
        this.tokenizer = this.options.tokenizer,
        this.tokenizer.options = this.options,
        this.tokenizer.lexer = this,
        this.inlineQueue = [],
        this.state = {
            inLink: !1,
            inRawBlock: !1,
            top: !0
        };
        const t = {
            block: Mt.normal,
            inline: mt.normal
        };
        this.options.pedantic ? (t.block = Mt.pedantic,
        t.inline = mt.pedantic) : this.options.gfm && (t.block = Mt.gfm,
        this.options.breaks ? t.inline = mt.breaks : t.inline = mt.gfm),
        this.tokenizer.rules = t
    }
    static get rules() {
        return {
            block: Mt,
            inline: mt
        }
    }
    static lex(e, t) {
        return new Ea(t).lex(e)
    }
    static lexInline(e, t) {
        return new Ea(t).inlineTokens(e)
    }
    lex(e) {
        e = e.replace(/\r\n|\r/g, `
`),
        this.blockTokens(e, this.tokens);
        let t;
        for (; t = this.inlineQueue.shift(); )
            this.inlineTokens(t.src, t.tokens);
        return this.tokens
    }
    blockTokens(e, t=[]) {
        this.options.pedantic ? e = e.replace(/\t/g, "    ").replace(/^ +$/gm, "") : e = e.replace(/^( *)(\t+)/gm, (a, l, c) => l + "    ".repeat(c.length));
        let n, s, r, o;
        for (; e; )
            if (!(this.options.extensions && this.options.extensions.block && this.options.extensions.block.some(a => (n = a.call({
                lexer: this
            }, e, t)) ? (e = e.substring(n.raw.length),
            t.push(n),
            !0) : !1))) {
                if (n = this.tokenizer.space(e)) {
                    e = e.substring(n.raw.length),
                    n.raw.length === 1 && t.length > 0 ? t[t.length - 1].raw += `
` : t.push(n);
                    continue
                }
                if (n = this.tokenizer.code(e)) {
                    e = e.substring(n.raw.length),
                    s = t[t.length - 1],
                    s && (s.type === "paragraph" || s.type === "text") ? (s.raw += `
` + n.raw,
                    s.text += `
` + n.text,
                    this.inlineQueue[this.inlineQueue.length - 1].src = s.text) : t.push(n);
                    continue
                }
                if (n = this.tokenizer.fences(e)) {
                    e = e.substring(n.raw.length),
                    t.push(n);
                    continue
                }
                if (n = this.tokenizer.heading(e)) {
                    e = e.substring(n.raw.length),
                    t.push(n);
                    continue
                }
                if (n = this.tokenizer.hr(e)) {
                    e = e.substring(n.raw.length),
                    t.push(n);
                    continue
                }
                if (n = this.tokenizer.blockquote(e)) {
                    e = e.substring(n.raw.length),
                    t.push(n);
                    continue
                }
                if (n = this.tokenizer.list(e)) {
                    e = e.substring(n.raw.length),
                    t.push(n);
                    continue
                }
                if (n = this.tokenizer.html(e)) {
                    e = e.substring(n.raw.length),
                    t.push(n);
                    continue
                }
                if (n = this.tokenizer.def(e)) {
                    e = e.substring(n.raw.length),
                    s = t[t.length - 1],
                    s && (s.type === "paragraph" || s.type === "text") ? (s.raw += `
` + n.raw,
                    s.text += `
` + n.raw,
                    this.inlineQueue[this.inlineQueue.length - 1].src = s.text) : this.tokens.links[n.tag] || (this.tokens.links[n.tag] = {
                        href: n.href,
                        title: n.title
                    });
                    continue
                }
                if (n = this.tokenizer.table(e)) {
                    e = e.substring(n.raw.length),
                    t.push(n);
                    continue
                }
                if (n = this.tokenizer.lheading(e)) {
                    e = e.substring(n.raw.length),
                    t.push(n);
                    continue
                }
                if (r = e,
                this.options.extensions && this.options.extensions.startBlock) {
                    let a = 1 / 0;
                    const l = e.slice(1);
                    let c;
                    this.options.extensions.startBlock.forEach(function(u) {
                        c = u.call({
                            lexer: this
                        }, l),
                        typeof c == "number" && c >= 0 && (a = Math.min(a, c))
                    }),
                    a < 1 / 0 && a >= 0 && (r = e.substring(0, a + 1))
                }
                if (this.state.top && (n = this.tokenizer.paragraph(r))) {
                    s = t[t.length - 1],
                    o && s.type === "paragraph" ? (s.raw += `
` + n.raw,
                    s.text += `
` + n.text,
                    this.inlineQueue.pop(),
                    this.inlineQueue[this.inlineQueue.length - 1].src = s.text) : t.push(n),
                    o = r.length !== e.length,
                    e = e.substring(n.raw.length);
                    continue
                }
                if (n = this.tokenizer.text(e)) {
                    e = e.substring(n.raw.length),
                    s = t[t.length - 1],
                    s && s.type === "text" ? (s.raw += `
` + n.raw,
                    s.text += `
` + n.text,
                    this.inlineQueue.pop(),
                    this.inlineQueue[this.inlineQueue.length - 1].src = s.text) : t.push(n);
                    continue
                }
                if (e) {
                    const a = "Infinite loop on byte: " + e.charCodeAt(0);
                    if (this.options.silent) {
                        console.error(a);
                        break
                    } else
                        throw new Error(a)
                }
            }
        return this.state.top = !0,
        t
    }
    inline(e, t=[]) {
        return this.inlineQueue.push({
            src: e,
            tokens: t
        }),
        t
    }
    inlineTokens(e, t=[]) {
        let n, s, r, o = e, a, l, c;
        if (this.tokens.links) {
            const u = Object.keys(this.tokens.links);
            if (u.length > 0)
                for (; (a = this.tokenizer.rules.inline.reflinkSearch.exec(o)) != null; )
                    u.includes(a[0].slice(a[0].lastIndexOf("[") + 1, -1)) && (o = o.slice(0, a.index) + "[" + wb("a", a[0].length - 2) + "]" + o.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex))
        }
        for (; (a = this.tokenizer.rules.inline.blockSkip.exec(o)) != null; )
            o = o.slice(0, a.index) + "[" + wb("a", a[0].length - 2) + "]" + o.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
        for (; (a = this.tokenizer.rules.inline.escapedEmSt.exec(o)) != null; )
            o = o.slice(0, a.index + a[0].length - 2) + "++" + o.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex),
            this.tokenizer.rules.inline.escapedEmSt.lastIndex--;
        for (; e; )
            if (l || (c = ""),
            l = !1,
            !(this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some(u => (n = u.call({
                lexer: this
            }, e, t)) ? (e = e.substring(n.raw.length),
            t.push(n),
            !0) : !1))) {
                if (n = this.tokenizer.escape(e)) {
                    e = e.substring(n.raw.length),
                    t.push(n);
                    continue
                }
                if (n = this.tokenizer.tag(e)) {
                    e = e.substring(n.raw.length),
                    s = t[t.length - 1],
                    s && n.type === "text" && s.type === "text" ? (s.raw += n.raw,
                    s.text += n.text) : t.push(n);
                    continue
                }
                if (n = this.tokenizer.link(e)) {
                    e = e.substring(n.raw.length),
                    t.push(n);
                    continue
                }
                if (n = this.tokenizer.reflink(e, this.tokens.links)) {
                    e = e.substring(n.raw.length),
                    s = t[t.length - 1],
                    s && n.type === "text" && s.type === "text" ? (s.raw += n.raw,
                    s.text += n.text) : t.push(n);
                    continue
                }
                if (n = this.tokenizer.emStrong(e, o, c)) {
                    e = e.substring(n.raw.length),
                    t.push(n);
                    continue
                }
                if (n = this.tokenizer.codespan(e)) {
                    e = e.substring(n.raw.length),
                    t.push(n);
                    continue
                }
                if (n = this.tokenizer.br(e)) {
                    e = e.substring(n.raw.length),
                    t.push(n);
                    continue
                }
                if (n = this.tokenizer.del(e)) {
                    e = e.substring(n.raw.length),
                    t.push(n);
                    continue
                }
                if (n = this.tokenizer.autolink(e, Ab)) {
                    e = e.substring(n.raw.length),
                    t.push(n);
                    continue
                }
                if (!this.state.inLink && (n = this.tokenizer.url(e, Ab))) {
                    e = e.substring(n.raw.length),
                    t.push(n);
                    continue
                }
                if (r = e,
                this.options.extensions && this.options.extensions.startInline) {
                    let u = 1 / 0;
                    const d = e.slice(1);
                    let f;
                    this.options.extensions.startInline.forEach(function(h) {
                        f = h.call({
                            lexer: this
                        }, d),
                        typeof f == "number" && f >= 0 && (u = Math.min(u, f))
                    }),
                    u < 1 / 0 && u >= 0 && (r = e.substring(0, u + 1))
                }
                if (n = this.tokenizer.inlineText(r, fB)) {
                    e = e.substring(n.raw.length),
                    n.raw.slice(-1) !== "_" && (c = n.raw.slice(-1)),
                    l = !0,
                    s = t[t.length - 1],
                    s && s.type === "text" ? (s.raw += n.raw,
                    s.text += n.text) : t.push(n);
                    continue
                }
                if (e) {
                    const u = "Infinite loop on byte: " + e.charCodeAt(0);
                    if (this.options.silent) {
                        console.error(u);
                        break
                    } else
                        throw new Error(u)
                }
            }
        return t
    }
}
class X_ {
    constructor(e) {
        this.options = e || Hl
    }
    code(e, t, n) {
        const s = (t || "").match(/\S*/)[0];
        if (this.options.highlight) {
            const r = this.options.highlight(e, s);
            r != null && r !== e && (n = !0,
            e = r)
        }
        return e = e.replace(/\n$/, "") + `
`,
        s ? '<pre><code class="' + this.options.langPrefix + Li(s) + '">' + (n ? e : Li(e, !0)) + `</code></pre>
` : "<pre><code>" + (n ? e : Li(e, !0)) + `</code></pre>
`
    }
    blockquote(e) {
        return `<blockquote>
${e}</blockquote>
`
    }
    html(e) {
        return e
    }
    heading(e, t, n, s) {
        if (this.options.headerIds) {
            const r = this.options.headerPrefix + s.slug(n);
            return `<h${t} id="${r}">${e}</h${t}>
`
        }
        return `<h${t}>${e}</h${t}>
`
    }
    hr() {
        return this.options.xhtml ? `<hr/>
` : `<hr>
`
    }
    list(e, t, n) {
        const s = t ? "ol" : "ul"
          , r = t && n !== 1 ? ' start="' + n + '"' : "";
        return "<" + s + r + `>
` + e + "</" + s + `>
`
    }
    listitem(e) {
        return `<li>${e}</li>
`
    }
    checkbox(e) {
        return "<input " + (e ? 'checked="" ' : "") + 'disabled="" type="checkbox"' + (this.options.xhtml ? " /" : "") + "> "
    }
    paragraph(e) {
        return `<p>${e}</p>
`
    }
    table(e, t) {
        return t && (t = `<tbody>${t}</tbody>`),
        `<table>
<thead>
` + e + `</thead>
` + t + `</table>
`
    }
    tablerow(e) {
        return `<tr>
${e}</tr>
`
    }
    tablecell(e, t) {
        const n = t.header ? "th" : "td";
        return (t.align ? `<${n} align="${t.align}">` : `<${n}>`) + e + `</${n}>
`
    }
    strong(e) {
        return `<strong>${e}</strong>`
    }
    em(e) {
        return `<em>${e}</em>`
    }
    codespan(e) {
        return `<code>${e}</code>`
    }
    br() {
        return this.options.xhtml ? "<br/>" : "<br>"
    }
    del(e) {
        return `<del>${e}</del>`
    }
    link(e, t, n) {
        if (e = Sb(this.options.sanitize, this.options.baseUrl, e),
        e === null)
            return n;
        let s = '<a href="' + e + '"';
        return t && (s += ' title="' + t + '"'),
        s += ">" + n + "</a>",
        s
    }
    image(e, t, n) {
        if (e = Sb(this.options.sanitize, this.options.baseUrl, e),
        e === null)
            return n;
        let s = `<img src="${e}" alt="${n}"`;
        return t && (s += ` title="${t}"`),
        s += this.options.xhtml ? "/>" : ">",
        s
    }
    text(e) {
        return e
    }
}
class PC {
    strong(e) {
        return e
    }
    em(e) {
        return e
    }
    codespan(e) {
        return e
    }
    del(e) {
        return e
    }
    html(e) {
        return e
    }
    text(e) {
        return e
    }
    link(e, t, n) {
        return "" + n
    }
    image(e, t, n) {
        return "" + n
    }
    br() {
        return ""
    }
}
class DC {
    constructor() {
        this.seen = {}
    }
    serialize(e) {
        return e.toLowerCase().trim().replace(/<[!\/a-z].*?>/ig, "").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "").replace(/\s/g, "-")
    }
    getNextSafeSlug(e, t) {
        let n = e
          , s = 0;
        if (this.seen.hasOwnProperty(n)) {
            s = this.seen[e];
            do
                s++,
                n = e + "-" + s;
            while (this.seen.hasOwnProperty(n))
        }
        return t || (this.seen[e] = s,
        this.seen[n] = 0),
        n
    }
    slug(e, t={}) {
        const n = this.serialize(e);
        return this.getNextSafeSlug(n, t.dryrun)
    }
}
class wa {
    constructor(e) {
        this.options = e || Hl,
        this.options.renderer = this.options.renderer || new X_,
        this.renderer = this.options.renderer,
        this.renderer.options = this.options,
        this.textRenderer = new PC,
        this.slugger = new DC
    }
    static parse(e, t) {
        return new wa(t).parse(e)
    }
    static parseInline(e, t) {
        return new wa(t).parseInline(e)
    }
    parse(e, t=!0) {
        let n = "", s, r, o, a, l, c, u, d, f, h, p, g, m, v, _, y, b, S, C;
        const M = e.length;
        for (s = 0; s < M; s++) {
            if (h = e[s],
            this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[h.type] && (C = this.options.extensions.renderers[h.type].call({
                parser: this
            }, h),
            C !== !1 || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(h.type))) {
                n += C || "";
                continue
            }
            switch (h.type) {
            case "space":
                continue;
            case "hr":
                {
                    n += this.renderer.hr();
                    continue
                }
            case "heading":
                {
                    n += this.renderer.heading(this.parseInline(h.tokens), h.depth, kC(this.parseInline(h.tokens, this.textRenderer)), this.slugger);
                    continue
                }
            case "code":
                {
                    n += this.renderer.code(h.text, h.lang, h.escaped);
                    continue
                }
            case "table":
                {
                    for (d = "",
                    u = "",
                    a = h.header.length,
                    r = 0; r < a; r++)
                        u += this.renderer.tablecell(this.parseInline(h.header[r].tokens), {
                            header: !0,
                            align: h.align[r]
                        });
                    for (d += this.renderer.tablerow(u),
                    f = "",
                    a = h.rows.length,
                    r = 0; r < a; r++) {
                        for (c = h.rows[r],
                        u = "",
                        l = c.length,
                        o = 0; o < l; o++)
                            u += this.renderer.tablecell(this.parseInline(c[o].tokens), {
                                header: !1,
                                align: h.align[o]
                            });
                        f += this.renderer.tablerow(u)
                    }
                    n += this.renderer.table(d, f);
                    continue
                }
            case "blockquote":
                {
                    f = this.parse(h.tokens),
                    n += this.renderer.blockquote(f);
                    continue
                }
            case "list":
                {
                    for (p = h.ordered,
                    g = h.start,
                    m = h.loose,
                    a = h.items.length,
                    f = "",
                    r = 0; r < a; r++)
                        _ = h.items[r],
                        y = _.checked,
                        b = _.task,
                        v = "",
                        _.task && (S = this.renderer.checkbox(y),
                        m ? _.tokens.length > 0 && _.tokens[0].type === "paragraph" ? (_.tokens[0].text = S + " " + _.tokens[0].text,
                        _.tokens[0].tokens && _.tokens[0].tokens.length > 0 && _.tokens[0].tokens[0].type === "text" && (_.tokens[0].tokens[0].text = S + " " + _.tokens[0].tokens[0].text)) : _.tokens.unshift({
                            type: "text",
                            text: S
                        }) : v += S),
                        v += this.parse(_.tokens, m),
                        f += this.renderer.listitem(v, b, y);
                    n += this.renderer.list(f, p, g);
                    continue
                }
            case "html":
                {
                    n += this.renderer.html(h.text);
                    continue
                }
            case "paragraph":
                {
                    n += this.renderer.paragraph(this.parseInline(h.tokens));
                    continue
                }
            case "text":
                {
                    for (f = h.tokens ? this.parseInline(h.tokens) : h.text; s + 1 < M && e[s + 1].type === "text"; )
                        h = e[++s],
                        f += `
` + (h.tokens ? this.parseInline(h.tokens) : h.text);
                    n += t ? this.renderer.paragraph(f) : f;
                    continue
                }
            default:
                {
                    const L = 'Token with "' + h.type + '" type was not found.';
                    if (this.options.silent) {
                        console.error(L);
                        return
                    } else
                        throw new Error(L)
                }
            }
        }
        return n
    }
    parseInline(e, t) {
        t = t || this.renderer;
        let n = "", s, r, o;
        const a = e.length;
        for (s = 0; s < a; s++) {
            if (r = e[s],
            this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[r.type] && (o = this.options.extensions.renderers[r.type].call({
                parser: this
            }, r),
            o !== !1 || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(r.type))) {
                n += o || "";
                continue
            }
            switch (r.type) {
            case "escape":
                {
                    n += t.text(r.text);
                    break
                }
            case "html":
                {
                    n += t.html(r.text);
                    break
                }
            case "link":
                {
                    n += t.link(r.href, r.title, this.parseInline(r.tokens, t));
                    break
                }
            case "image":
                {
                    n += t.image(r.href, r.title, r.text);
                    break
                }
            case "strong":
                {
                    n += t.strong(this.parseInline(r.tokens, t));
                    break
                }
            case "em":
                {
                    n += t.em(this.parseInline(r.tokens, t));
                    break
                }
            case "codespan":
                {
                    n += t.codespan(r.text);
                    break
                }
            case "br":
                {
                    n += t.br();
                    break
                }
            case "del":
                {
                    n += t.del(this.parseInline(r.tokens, t));
                    break
                }
            case "text":
                {
                    n += t.text(r.text);
                    break
                }
            default:
                {
                    const l = 'Token with "' + r.type + '" type was not found.';
                    if (this.options.silent) {
                        console.error(l);
                        return
                    } else
                        throw new Error(l)
                }
            }
        }
        return n
    }
}
class Ep {
    constructor(e) {
        this.options = e || Hl
    }
    preprocess(e) {
        return e
    }
    postprocess(e) {
        return e
    }
}
tt(Ep, "passThroughHooks", new Set(["preprocess", "postprocess"]));
function hB(i, e, t) {
    return n => {
        if (n.message += `
Please report this to https://github.com/markedjs/marked.`,
        i) {
            const s = "<p>An error occurred:</p><pre>" + Li(n.message + "", !0) + "</pre>";
            if (e)
                return Promise.resolve(s);
            if (t) {
                t(null, s);
                return
            }
            return s
        }
        if (e)
            return Promise.reject(n);
        if (t) {
            t(n);
            return
        }
        throw n
    }
}
function FC(i, e) {
    return (t, n, s) => {
        typeof n == "function" && (s = n,
        n = null);
        const r = {
            ...n
        };
        n = {
            ...Tt.defaults,
            ...r
        };
        const o = hB(n.silent, n.async, s);
        if (typeof t > "u" || t === null)
            return o(new Error("marked(): input parameter is undefined or null"));
        if (typeof t != "string")
            return o(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(t) + ", string expected"));
        if (uB(n),
        n.hooks && (n.hooks.options = n),
        s) {
            const a = n.highlight;
            let l;
            try {
                n.hooks && (t = n.hooks.preprocess(t)),
                l = i(t, n)
            } catch (d) {
                return o(d)
            }
            const c = function(d) {
                let f;
                if (!d)
                    try {
                        n.walkTokens && Tt.walkTokens(l, n.walkTokens),
                        f = e(l, n),
                        n.hooks && (f = n.hooks.postprocess(f))
                    } catch (h) {
                        d = h
                    }
                return n.highlight = a,
                d ? o(d) : s(null, f)
            };
            if (!a || a.length < 3 || (delete n.highlight,
            !l.length))
                return c();
            let u = 0;
            Tt.walkTokens(l, function(d) {
                d.type === "code" && (u++,
                setTimeout( () => {
                    a(d.text, d.lang, function(f, h) {
                        if (f)
                            return c(f);
                        h != null && h !== d.text && (d.text = h,
                        d.escaped = !0),
                        u--,
                        u === 0 && c()
                    })
                }
                , 0))
            }),
            u === 0 && c();
            return
        }
        if (n.async)
            return Promise.resolve(n.hooks ? n.hooks.preprocess(t) : t).then(a => i(a, n)).then(a => n.walkTokens ? Promise.all(Tt.walkTokens(a, n.walkTokens)).then( () => a) : a).then(a => e(a, n)).then(a => n.hooks ? n.hooks.postprocess(a) : a).catch(o);
        try {
            n.hooks && (t = n.hooks.preprocess(t));
            const a = i(t, n);
            n.walkTokens && Tt.walkTokens(a, n.walkTokens);
            let l = e(a, n);
            return n.hooks && (l = n.hooks.postprocess(l)),
            l
        } catch (a) {
            return o(a)
        }
    }
}
function Tt(i, e, t) {
    return FC(Ea.lex, wa.parse)(i, e, t)
}
Tt.options = Tt.setOptions = function(i) {
    return Tt.defaults = {
        ...Tt.defaults,
        ...i
    },
    ZN(Tt.defaults),
    Tt
}
;
Tt.getDefaults = RC;
Tt.defaults = Hl;
Tt.use = function(...i) {
    const e = Tt.defaults.extensions || {
        renderers: {},
        childTokens: {}
    };
    i.forEach(t => {
        const n = {
            ...t
        };
        if (n.async = Tt.defaults.async || n.async || !1,
        t.extensions && (t.extensions.forEach(s => {
            if (!s.name)
                throw new Error("extension name required");
            if (s.renderer) {
                const r = e.renderers[s.name];
                r ? e.renderers[s.name] = function(...o) {
                    let a = s.renderer.apply(this, o);
                    return a === !1 && (a = r.apply(this, o)),
                    a
                }
                : e.renderers[s.name] = s.renderer
            }
            if (s.tokenizer) {
                if (!s.level || s.level !== "block" && s.level !== "inline")
                    throw new Error("extension level must be 'block' or 'inline'");
                e[s.level] ? e[s.level].unshift(s.tokenizer) : e[s.level] = [s.tokenizer],
                s.start && (s.level === "block" ? e.startBlock ? e.startBlock.push(s.start) : e.startBlock = [s.start] : s.level === "inline" && (e.startInline ? e.startInline.push(s.start) : e.startInline = [s.start]))
            }
            s.childTokens && (e.childTokens[s.name] = s.childTokens)
        }
        ),
        n.extensions = e),
        t.renderer) {
            const s = Tt.defaults.renderer || new X_;
            for (const r in t.renderer) {
                const o = s[r];
                s[r] = (...a) => {
                    let l = t.renderer[r].apply(s, a);
                    return l === !1 && (l = o.apply(s, a)),
                    l
                }
            }
            n.renderer = s
        }
        if (t.tokenizer) {
            const s = Tt.defaults.tokenizer || new K_;
            for (const r in t.tokenizer) {
                const o = s[r];
                s[r] = (...a) => {
                    let l = t.tokenizer[r].apply(s, a);
                    return l === !1 && (l = o.apply(s, a)),
                    l
                }
            }
            n.tokenizer = s
        }
        if (t.hooks) {
            const s = Tt.defaults.hooks || new Ep;
            for (const r in t.hooks) {
                const o = s[r];
                Ep.passThroughHooks.has(r) ? s[r] = a => {
                    if (Tt.defaults.async)
                        return Promise.resolve(t.hooks[r].call(s, a)).then(c => o.call(s, c));
                    const l = t.hooks[r].call(s, a);
                    return o.call(s, l)
                }
                : s[r] = (...a) => {
                    let l = t.hooks[r].apply(s, a);
                    return l === !1 && (l = o.apply(s, a)),
                    l
                }
            }
            n.hooks = s
        }
        if (t.walkTokens) {
            const s = Tt.defaults.walkTokens;
            n.walkTokens = function(r) {
                let o = [];
                return o.push(t.walkTokens.call(this, r)),
                s && (o = o.concat(s.call(this, r))),
                o
            }
        }
        Tt.setOptions(n)
    }
    )
}
;
Tt.walkTokens = function(i, e) {
    let t = [];
    for (const n of i)
        switch (t = t.concat(e.call(Tt, n)),
        n.type) {
        case "table":
            {
                for (const s of n.header)
                    t = t.concat(Tt.walkTokens(s.tokens, e));
                for (const s of n.rows)
                    for (const r of s)
                        t = t.concat(Tt.walkTokens(r.tokens, e));
                break
            }
        case "list":
            {
                t = t.concat(Tt.walkTokens(n.items, e));
                break
            }
        default:
            Tt.defaults.extensions && Tt.defaults.extensions.childTokens && Tt.defaults.extensions.childTokens[n.type] ? Tt.defaults.extensions.childTokens[n.type].forEach(function(s) {
                t = t.concat(Tt.walkTokens(n[s], e))
            }) : n.tokens && (t = t.concat(Tt.walkTokens(n.tokens, e)))
        }
    return t
}
;
Tt.parseInline = FC(Ea.lexInline, wa.parseInline);
Tt.Parser = wa;
Tt.parser = wa.parse;
Tt.Renderer = X_;
Tt.TextRenderer = PC;
Tt.Lexer = Ea;
Tt.lexer = Ea.lex;
Tt.Tokenizer = K_;
Tt.Slugger = DC;
Tt.Hooks = Ep;
Tt.parse = Tt;
Tt.options;
Tt.setOptions;
Tt.use;
Tt.walkTokens;
Tt.parseInline;
wa.parse;
Ea.lex;
const pB = ["innerHTML"]
  , mB = {
    class: "cursor-pointer bg-zinc-900"
}
  , Y_ = ut({
    __name: "ExpandableText",
    props: {
        text: {},
        height: {
            default: 100
        }
    },
    setup(i) {
        const e = xe(!1)
          , t = i
          , n = xe(!1)
          , s = xe();
        d_( () => {
            Tt.setOptions({
                gfm: !0,
                breaks: !0,
                xhtml: !1
            })
        }
        );
        const r = () => {
            !e.value || n.value || (n.value = !0)
        }
        ;
        return Ln( () => {
            e.value = s.value.offsetHeight !== s.value.scrollHeight
        }
        ),
        (o, a) => (w(),
        R("div", {
            class: Pt([{
                "cursor-pointer": e.value && !n.value
            }, "select-text prose prose-invert max-w-none expandable-text overflow-hidden relative"]),
            onClick: r
        }, [x("div", {
            ref_key: "el",
            ref: s,
            class: Pt({
                "mb-10": n.value
            }),
            style: xs(n.value ? "" : `max-height: ${t.height}px`),
            innerHTML: E(Tt).parse(t.text)
        }, null, 14, pB), e.value ? (w(),
        R("div", {
            key: 0,
            class: "text-white font-medium bt-1 block absolute left-0 bottom-0 w-full",
            onClick: a[0] || (a[0] = Vn(l => n.value = !n.value, ["stop"]))
        }, [a[1] || (a[1] = x("div", {
            class: "h-6"
        }, null, -1)), x("div", mB, ee(n.value ? "Show less" : "...more"), 1)])) : le("", !0)], 2))
    }
});
const gB = {
    class: "rounded-full bg-zinc-800 overflow-hidden relative flex items-center justify-center text-zinc-400"
}
  , vB = {
    key: 0,
    class: "h-full w-full"
}
  , Bo = ut({
    __name: "Avatar",
    props: {
        image: {},
        icon: {}
    },
    setup(i) {
        return (e, t) => {
            const n = Jd("lazy");
            return w(),
            R("div", gB, [e.image ? zt((w(),
            R("img", vB, null, 512)), [[n, E(Gs)(e.image)]]) : (w(),
            Re(ze, {
                key: 1,
                name: e.icon,
                class: "h-[50%] w-[50%]"
            }, null, 8, ["name"]))])
        }
    }
})
  , _B = {
    class: "p-4 lg:p-0 text-center lg:text-left"
}
  , xB = {
    class: "flex flex-col items-center lg:items-start lg:flex-row gap-8"
}
  , yB = {
    class: "h-48 w-48 bg-zinc-500 rounded-full relative"
}
  , bB = {
    key: 0,
    class: "absolute h-8 w-8 rounded-full bg-zinc-700 shadow bottom-2.5 right-2.5"
}
  , SB = {
    class: "h-full w-full relative flex items-center justify-center"
}
  , EB = {
    class: "flex flex-col"
}
  , wB = {
    class: "text-5xl font-bold"
}
  , TB = {
    class: "text-zinc-400 mt-3 text-lg"
}
  , AB = {
    class: "font-medium text-white"
}
  , CB = {
    class: "font-medium text-white"
}
  , MB = {
    class: "font-medium text-white"
}
  , RB = {
    class: "flex gap-3"
}
  , LB = {
    key: 0,
    class: "text-zinc-100 w-full text-left mt-4 rounded-md"
}
  , IB = ut({
    __name: "User",
    async setup(i) {
        let e, t;
        const {isProduction: n} = it();
        d_( () => {
            Tt.setOptions({
                gfm: !0,
                breaks: !0
            })
        }
        );
        const s = ei({
            loading: !1,
            editing: !1,
            fields: {
                bio: "",
                support_url: ""
            }
        })
          , r = xe();
        r.value = ([e,t] = As( () => ct.users.getUser(Ki().params.username)),
        e = await e,
        t(),
        e);
        const o = it();
        Ln(async () => {
            s.fields.bio = r.value.bio,
            s.fields.support_url = r.value.profile.support_url ? r.value.profile.support_url : ""
        }
        );
        const a = Vt( () => r && o.user && r.value.id === o.user.id)
          , l = async u => {
            const d = u.target;
            if (!d.files || d.files.length === 0)
                return;
            const f = new FormData;
            f.append("file", d.files[0]),
            r.value.avatar_url = await ct.user.updateAvatar(f)
        }
          , c = async () => {
            s.loading = !0;
            try {
                await ct.user.updateBio(s.fields.bio),
                r.value.bio = s.fields.bio,
                await ct.user.updateProfile({
                    support_url: s.fields.support_url
                }),
                r.value.profile.support_url = s.fields.support_url,
                s.editing = !1
            } catch (u) {
                window.alert(u)
            } finally {
                s.loading = !1
            }
        }
        ;
        return Ti( () => {
            var u;
            return ci(n ? `${(u = r.value) == null ? void 0 : u.username} FapTap` : "Demo")
        }
        ),
        (u, d) => (w(),
        R(Ge, null, [x("div", _B, [x("div", xB, [x("div", yB, [O(Bo, {
            icon: "account",
            image: r.value.avatar_url,
            class: "h-full w-full"
        }, null, 8, ["image"]), a.value ? (w(),
        R("div", bB, [x("div", SB, [x("input", {
            onChange: Vn(l, ["prevent"]),
            type: "file",
            class: "opacity-0 absolute inset-0 w-full h-full"
        }, null, 32), O(ze, {
            name: "pencil",
            class: "h-4 w-4 text-white"
        })])])) : le("", !0)]), x("div", EB, [d[9] || (d[9] = x("p", {
            class: "uppercase text-sm text-zinc-300"
        }, "User", -1)), x("h1", wB, ee(r.value.username), 1), x("p", TB, [x("span", AB, ee(E(vr)(r.value.subscribers)), 1), d[4] || (d[4] = J(" subscribers ")), x("span", CB, ee(E(vr)(r.value.views)), 1), d[5] || (d[5] = J(" views ")), x("span", MB, ee(E(vr)(r.value.videos)), 1), d[6] || (d[6] = J(" videos "))]), d[10] || (d[10] = x("div", {
            class: "flex-1"
        }, null, -1)), x("div", RB, [a.value && (E(o).isCreator || E(o).isAdmin) ? (w(),
        Re(je, {
            key: 0,
            onClick: d[0] || (d[0] = f => s.editing = !0),
            class: "w-full"
        }, {
            default: Y( () => d[7] || (d[7] = [J(" Edit Profile ")])),
            _: 1
        })) : le("", !0), O(wm, {
            class: "w-full",
            user: r.value
        }, null, 8, ["user"]), r.value.profile.support_url && r.value.profile.support_url.length ? (w(),
        Re(je, {
            key: 1,
            href: r.value.profile.support_url,
            class: "w-full",
            theme: "green"
        }, {
            default: Y( () => d[8] || (d[8] = [J(" Support ")])),
            _: 1
        }, 8, ["href"])) : le("", !0)])])]), r.value && r.value.bio && r.value.bio.length ? (w(),
        R("div", LB, [O(Y_, {
            class: "lg:!text-sm",
            text: r.value.bio
        }, null, 8, ["text"])])) : le("", !0)]), d[12] || (d[12] = x("hr", {
            class: "border-zinc-800 my-2"
        }, null, -1)), r.value ? (w(),
        Re($l, {
            key: 0,
            user: r.value.id
        }, null, 8, ["user"])) : le("", !0), O(mr, {
            modelValue: s.editing,
            "onUpdate:modelValue": d[3] || (d[3] = f => s.editing = f),
            title: "Edit"
        }, {
            default: Y( () => [x("form", {
                onSubmit: Vn(c, ["prevent"]),
                class: "mt-4 flex flex-col gap-y-3"
            }, [O(vn, {
                modelValue: s.fields.bio,
                "onUpdate:modelValue": d[1] || (d[1] = f => s.fields.bio = f),
                rows: "8",
                placeholder: "Bio...",
                textarea: !0,
                required: "",
                min: "3",
                max: "250"
            }, null, 8, ["modelValue"]), O(vn, {
                modelValue: s.fields.support_url,
                "onUpdate:modelValue": d[2] || (d[2] = f => s.fields.support_url = f),
                placeholder: "Link to Patreon, Gumroad, Boosty, ...",
                max: "250"
            }, null, 8, ["modelValue"]), O(je, {
                theme: "blue"
            }, {
                default: Y( () => d[11] || (d[11] = [J("Edit")])),
                _: 1
            })], 32)]),
            _: 1
        }, 8, ["modelValue"])], 64))
    }
})
  , kB = {
    class: "flex gap-8 text-white flex flex-col items-center lg:items-start lg:flex-row text-center lg:text-left"
}
  , PB = {
    class: "flex flex-col"
}
  , DB = {
    class: "text-5xl font-bold"
}
  , FB = {
    class: "text-zinc-400 mt-3 text-lg"
}
  , OB = {
    class: "font-medium text-white"
}
  , UB = {
    class: "font-medium text-white"
}
  , NB = ut({
    __name: "Performer",
    async setup(i) {
        let e, t;
        const {isProduction: n} = it()
          , s = ([e,t] = As( () => ct.performers.getPerformer(Ki().params.slug)),
        e = await e,
        t(),
        e);
        return Ti( () => ci(n ? `${s.name} Interactive Porn Videos FapTap` : "Demo")),
        (r, o) => (w(),
        R(Ge, null, [x("div", kB, [O(Bo, {
            icon: "woman-face-shimmer",
            image: E(s).avatar_url,
            class: "h-48 w-48"
        }, null, 8, ["image"]), x("div", PB, [o[2] || (o[2] = x("p", {
            class: "uppercase text-sm text-zinc-300"
        }, "Performer", -1)), x("h1", DB, ee(E(s).name), 1), x("p", FB, [x("span", OB, ee(E(vr)(E(s).videos)), 1), o[0] || (o[0] = J(" videos ")), x("span", UB, ee(E(vr)(E(s).views)), 1), o[1] || (o[1] = J(" views "))]), o[3] || (o[3] = x("div", {
            class: "flex-1"
        }, null, -1))])]), E(s) ? (w(),
        Re($l, {
            key: 0,
            class: "mt-4",
            performer: E(s).id
        }, null, 8, ["performer"])) : le("", !0)], 64))
    }
})
  , BB = {
    class: "grid grid-cols-2 md:grid-cols-4 lg:grid-cols-10 gap-2 px-2 lg:px-0"
}
  , VB = {
    class: "p-2 text-center"
}
  , $B = {
    class: "line-clamp-1 font-medium text-xl md:text-base"
}
  , HB = {
    class: "md:text-sm text-zinc-500"
}
  , zB = {
    class: "md:text-sm text-zinc-500"
}
  , GB = ut({
    __name: "Creators",
    async setup(i) {
        let e, t;
        const {isProduction: n} = it()
          , s = ([e,t] = As( () => ct.users.getUsers()),
        e = await e,
        t(),
        e);
        return Ti( () => ci(n ? "Creators FapTap" : "Demo")),
        (r, o) => {
            const a = li("router-link");
            return w(),
            R(Ge, null, [o[0] || (o[0] = x("a", {
                href: "mailto:contact@faptap.net?subject=Creator%20Access&body=Hi%2C%0D%0AI%20would%20like%20to%20become%20a%20creator%20on%20FapTap.%20My%20username%20is%3A%20%3Cusername%3E",
                class: "bg-blue-500 text-white py-2.5 px-5 rounded-md mb-4 lg:mb-8 mx-2 lg:mx-0 text-center lg:text-left block"
            }, [x("span", {
                class: "text-blue-100"
            }, "Are you a creator and want to share your script with others?"), x("span", {
                class: "font-medium"
            }, " Get Access Now")], -1)), x("div", BB, [(w(!0),
            R(Ge, null, Ht(E(s), l => (w(),
            Re(a, {
                to: `/u/${l.username}`,
                class: "p-2 rounded hover:bg-zinc-800"
            }, {
                default: Y( () => [O(Bo, {
                    icon: "account",
                    image: l.avatar_url,
                    class: "w-full aspect-square"
                }, null, 8, ["image"]), x("div", VB, [x("p", $B, ee(l.username), 1), x("div", HB, ee(l.subscribers) + " subscribers", 1), x("div", zB, ee(l.videos) + " videos", 1)])]),
                _: 2
            }, 1032, ["to"]))), 256))])], 64)
        }
    }
})
  , WB = {
    class: "px-2 container"
}
  , qB = {
    class: "text-center"
}
  , jB = {
    key: 0,
    class: "text-zinc-300"
}
  , KB = {
    key: 1,
    class: "text-zinc-300"
}
  , XB = {
    class: "flex justify-center"
}
  , YB = {
    class: "grid grid-cols-1 lg:grid-cols-3 gap-6 items-center p-3 mt-4"
}
  , ZB = {
    key: 0,
    class: "text-red-500 text-sm -mt-1.5"
}
  , JB = {
    key: 1,
    class: "text-red-500 text-sm -mt-1.5"
}
  , QB = {
    key: 2,
    class: "text-sm text-center text-red-500"
}
  , eV = {
    key: 3,
    class: "text-sm text-center text-green-400"
}
  , tV = {
    key: 0,
    class: "text-red-500 text-sm -mt-1.5"
}
  , nV = {
    key: 1,
    class: "text-red-500 text-sm -mt-1.5"
}
  , iV = {
    key: 2,
    class: "text-sm text-center text-red-500"
}
  , sV = {
    key: 3,
    class: "text-sm text-center text-green-400"
}
  , rV = {
    key: 0,
    class: "text-red-500 text-sm -mt-1.5"
}
  , oV = {
    key: 1,
    class: "text-sm text-center text-red-500"
}
  , aV = {
    key: 2,
    class: "text-sm text-center text-green-500"
}
  , lV = ut({
    __name: "Preferences",
    setup(i) {
        const {isProduction: e} = it()
          , t = it()
          , n = xe(!1)
          , s = xe(!1)
          , r = xe(!1)
          , o = ti()
          , a = async () => {
            o.push("/"),
            t.setUser(null),
            window.location.reload(),
            u.value = {}
        }
          , l = ei({
            fields: {
                newPassword: "",
                username: "",
                password: ""
            },
            loadingupdateusername: !1,
            loadingpassword: !1,
            loadingdeleteaccount: !1
        })
          , c = async () => {
            l.loadingpassword = !0;
            try {
                await h()
            } catch {
                l.loadingpassword = !1;
                return
            }
            try {
                await ct.user.updatePassword(l.fields.password, l.fields.newPassword),
                l.loadingpassword = !1,
                l.fields.newPassword = "",
                l.fields.password = "",
                u.value.generalpasswordsuccess = "Password updated successfully.",
                u.value.generalpassword = "",
                setTimeout( () => {
                    u.value.generalpasswordsuccess = ""
                }
                , 2e3)
            } catch (m) {
                u.value.generalpassword = m
            } finally {
                l.loadingpassword = !1
            }
        }
          , u = xe({})
          , d = ef().shape({
            username: Us().required().min(3, "username must be at least 3 characters long").max(20, "Username can be at most 20 characters long").matches(/^[a-zA-Z0-9]+$/, "Only alphanumeric characters are allowed."),
            password: Us().required().min(6).max(60),
            newPassword: Us().required().min(6).max(60)
        })
          , f = async m => {
            try {
                await d.validateAt(m, l.fields),
                delete u.value[m]
            } catch (v) {
                u.value[m] = v.errors[0]
            }
        }
          , h = async () => {
            try {
                await d.validate(l.fields, {
                    abortEarly: !1
                }),
                u.value = {}
            } catch (m) {
                u.value = m.inner.reduce( (v, _) => (v[_.path] = _.message,
                v), {})
            }
        }
          , p = async () => {
            l.loadingupdateusername = !0;
            try {
                await h()
            } catch {
                l.loadingupdateusername = !1;
                return
            }
            try {
                const m = await ct.user.updateUsername(l.fields.username, l.fields.password);
                l.loadingupdateusername = !1,
                l.fields.username = "",
                l.fields.password = "",
                t.setUser(m),
                u.value.generalusernamesuccess = "Username updated successfully.",
                u.value.generalusername = "",
                setTimeout( () => {
                    u.value.generalusernamesuccess = ""
                }
                , 2e3)
            } catch (m) {
                u.value.generalusername = m
            } finally {
                l.loadingupdateusername = !1
            }
        }
          , g = async () => {
            l.loadingdeleteaccount = !0;
            try {
                await f("password")
            } catch {
                l.loadingdeleteaccount = !1;
                return
            }
            try {
                await ct.user.deleteSelf(l.fields.password),
                l.loadingdeleteaccount = !1,
                l.fields.password = "",
                u.value.generaldeleteaccountsuccess = "User deleted successfully",
                u.value.generaldeleteaccount = "",
                setTimeout( () => {
                    a()
                }
                , 2e3)
            } catch (m) {
                u.value.generaldeleteaccount = m
            } finally {
                l.loadingdeleteaccount = !1
            }
        }
        ;
        return Ti( () => ci(e ? "Preferences FapTap" : "Demo")),
        (m, v) => (w(),
        R(Ge, null, [x("div", WB, [x("div", qB, [v[21] || (v[21] = x("h2", {
            class: "font-medium text-2xl font-medium text-white"
        }, "Security", -1)), E(it)().isProduction ? (w(),
        R("p", jB, "Manage access to your FapTap account")) : (w(),
        R("p", KB, "Manage access to your account"))]), x("div", XB, [x("div", YB, [O(je, {
            onClick: v[0] || (v[0] = _ => {
                u.value = {},
                s.value = !0
            }
            ),
            class: "bg-zinc-800 rounded-md p-3 mt-3 flex items-center gap-3 w-full hover:bg-zinc-700/50 transition-all"
        }, {
            default: Y( () => [O(ze, {
                name: "user-reset",
                class: "h-8 w-8 text-zinc-400"
            }), v[22] || (v[22] = x("p", {
                class: "font-medium text-white"
            }, "Change Username", -1)), v[23] || (v[23] = x("div", {
                class: "flex-1"
            }, null, -1)), O(ze, {
                name: "chevron-right",
                class: "h-6 w-6 text-zinc-400"
            })]),
            _: 1
        }), O(je, {
            onClick: v[1] || (v[1] = _ => {
                u.value = {},
                n.value = !0
            }
            ),
            class: "bg-zinc-800 rounded-md p-3 mt-3 flex items-center gap-3 w-full hover:bg-zinc-700/50 transition-all"
        }, {
            default: Y( () => [O(ze, {
                name: "lock-reset",
                class: "h-8 w-8 text-zinc-400"
            }), v[24] || (v[24] = x("p", {
                class: "font-medium text-white"
            }, "Update Password", -1)), v[25] || (v[25] = x("div", {
                class: "flex-1"
            }, null, -1)), O(ze, {
                name: "chevron-right",
                class: "h-6 w-6 text-zinc-400"
            })]),
            _: 1
        }), O(je, {
            onClick: v[2] || (v[2] = _ => {
                u.value = {},
                r.value = !0
            }
            ),
            class: "bg-zinc-800 rounded-md p-3 mt-3 flex items-center gap-3 w-full hover:bg-zinc-700/50 transition-all"
        }, {
            default: Y( () => [O(ze, {
                name: "user-delete",
                class: "h-8 w-8 text-zinc-400"
            }), v[26] || (v[26] = x("p", {
                class: "font-medium text-white"
            }, "Delete Account", -1)), v[27] || (v[27] = x("div", {
                class: "flex-1"
            }, null, -1)), O(ze, {
                name: "chevron-right",
                class: "h-6 w-6 text-zinc-400"
            })]),
            _: 1
        })])])]), O(mr, {
            title: "Update Username",
            modelValue: s.value,
            "onUpdate:modelValue": v[9] || (v[9] = _ => s.value = _)
        }, {
            default: Y( () => [x("form", {
                onSubmit: Vn(p, ["prevent"]),
                class: "mt-3"
            }, [O(vn, {
                required: "",
                modelValue: l.fields.username,
                "onUpdate:modelValue": v[3] || (v[3] = _ => l.fields.username = _),
                light: !0,
                placeholder: "New Username",
                type: "text",
                class: "w-full",
                onBlur: v[4] || (v[4] = _ => f("username")),
                onInput: v[5] || (v[5] = _ => u.value.username && f("username"))
            }, null, 8, ["modelValue"]), u.value.username ? (w(),
            R("span", ZB, ee(u.value.username), 1)) : le("", !0), O(vn, {
                required: "",
                modelValue: l.fields.password,
                "onUpdate:modelValue": v[6] || (v[6] = _ => l.fields.password = _),
                light: !0,
                placeholder: "Verify password",
                type: "password",
                class: "w-full mt-2",
                onBlur: v[7] || (v[7] = _ => f("password")),
                onInput: v[8] || (v[8] = _ => u.value.password && f("password"))
            }, null, 8, ["modelValue"]), u.value.password ? (w(),
            R("span", JB, ee(u.value.password), 1)) : le("", !0), O(je, {
                loading: l.loadingupdateusername,
                theme: "blue",
                class: "mt-4 w-full"
            }, {
                default: Y( () => v[28] || (v[28] = [J("Update")])),
                _: 1
            }, 8, ["loading"]), u.value.generalusername ? (w(),
            R("span", QB, ee(u.value.generalusername), 1)) : le("", !0), u.value.generalusernamesuccess ? (w(),
            R("span", eV, ee(u.value.generalusernamesuccess), 1)) : le("", !0)], 32)]),
            _: 1
        }, 8, ["modelValue"]), O(mr, {
            title: "Update Password",
            modelValue: n.value,
            "onUpdate:modelValue": v[16] || (v[16] = _ => n.value = _)
        }, {
            default: Y( () => [x("form", {
                onSubmit: Vn(c, ["prevent"]),
                class: "mt-3"
            }, [O(vn, {
                required: "",
                modelValue: l.fields.password,
                "onUpdate:modelValue": v[10] || (v[10] = _ => l.fields.password = _),
                light: !0,
                placeholder: "Current password",
                type: "password",
                class: "w-full",
                onBlur: v[11] || (v[11] = _ => f("password")),
                onInput: v[12] || (v[12] = _ => u.value.password && f("password"))
            }, null, 8, ["modelValue"]), u.value.password ? (w(),
            R("span", tV, ee(u.value.password), 1)) : le("", !0), O(vn, {
                required: "",
                modelValue: l.fields.newPassword,
                "onUpdate:modelValue": v[13] || (v[13] = _ => l.fields.newPassword = _),
                light: !0,
                placeholder: "New password",
                type: "password",
                class: "w-full mt-2",
                onBlur: v[14] || (v[14] = _ => f("newPassword")),
                onInput: v[15] || (v[15] = _ => u.value.newPassword && f("newPassword"))
            }, null, 8, ["modelValue"]), u.value.newPassword ? (w(),
            R("span", nV, ee(u.value.newPassword), 1)) : le("", !0), O(je, {
                loading: l.loadingpassword,
                theme: "blue",
                class: "mt-4 w-full"
            }, {
                default: Y( () => v[29] || (v[29] = [J("Update")])),
                _: 1
            }, 8, ["loading"]), u.value.generalpassword ? (w(),
            R("span", iV, ee(u.value.generalpassword), 1)) : le("", !0), u.value.generalpasswordsuccess ? (w(),
            R("span", sV, ee(u.value.generalpasswordsuccess), 1)) : le("", !0)], 32)]),
            _: 1
        }, 8, ["modelValue"]), O(mr, {
            title: "Delete Account",
            modelValue: r.value,
            "onUpdate:modelValue": v[20] || (v[20] = _ => r.value = _)
        }, {
            default: Y( () => [x("form", {
                onSubmit: Vn(g, ["prevent"]),
                class: "mt-3"
            }, [v[31] || (v[31] = x("p", null, [J(" Are you sure you want to delete your account? This action is permanent, and all your data will be lost. "), x("br"), J(" Please confirm to proceed. ")], -1)), O(vn, {
                required: "",
                modelValue: l.fields.password,
                "onUpdate:modelValue": v[17] || (v[17] = _ => l.fields.password = _),
                light: !0,
                placeholder: "Verify password",
                type: "password",
                class: "w-full mt-4",
                onBlur: v[18] || (v[18] = _ => f("password")),
                onInput: v[19] || (v[19] = _ => u.value.password && f("password"))
            }, null, 8, ["modelValue"]), u.value.password ? (w(),
            R("span", rV, ee(u.value.password), 1)) : le("", !0), O(je, {
                loading: l.loadingdeleteaccount,
                theme: "blue",
                class: "mt-4 w-full"
            }, {
                default: Y( () => v[30] || (v[30] = [J("Update")])),
                _: 1
            }, 8, ["loading"]), u.value.generaldeleteaccount ? (w(),
            R("span", oV, ee(u.value.generaldeleteaccount), 1)) : le("", !0), u.value.generaldeleteaccountsuccess ? (w(),
            R("span", aV, ee(u.value.generaldeleteaccountsuccess), 1)) : le("", !0)], 32)]),
            _: 1
        }, 8, ["modelValue"])], 64))
    }
})
  , cV = {
    class: "font-medium text-xl flex items-center gap-2"
}
  , uV = {
    class: "px-2 md:px-0"
}
  , dV = {
    class: "mb-3"
}
  , fV = {
    class: "font-medium text-xl"
}
  , hV = {
    class: "grid grid-cols-1 md:grid-cols-4 lg:grid-cols-6 xl:grid-cols-8 gap-1.5 mt-1.5"
}
  , pV = {
    class: "-m-1.5 py-1.5 px-3 font-medium bg-zinc-700"
}
  , mV = ut({
    __name: "Tags",
    async setup(i) {
        let e, t;
        const {isProduction: n} = it()
          , s = Ki()
          , r = ([e,t] = As(async () => new Promise(async o => {
            let a;
            return s.params.slug ? a = await ct.tags.getTagSlug(s.params.slug) : a = await ct.tags.getTags({
                orderBy: "videos"
            }),
            o(a.reduce( (l, c) => {
                let u = c.name.charAt(0).toUpperCase();
                return u === u.toLowerCase() && (u = "#"),
                l[u] = l[u] || [],
                l[u].push(c),
                l
            }
            , {}))
        }
        )),
        e = await e,
        t(),
        e);
        return Ti( () => ci(n ? "Categories for Interactive Porn Videos FapTap" : "Demo")),
        (o, a) => {
            const l = li("router-link");
            return w(),
            R(Ge, null, [E(s).params.slug ? (w(),
            Re(l, {
                key: 0,
                to: "/tags",
                class: "block w-full mb-2"
            }, {
                default: Y( () => [x("h2", cV, [O(ze, {
                    name: "back-arrow",
                    class: "h-4 w-4 text-white mb-1"
                }), a[0] || (a[0] = J(" All Tags"))])]),
                _: 1
            })) : le("", !0), x("div", uV, [(w(!0),
            R(Ge, null, Ht(E(r), (c, u) => (w(),
            R("div", dV, [O(l, {
                to: `/tags/${u}`,
                class: "p-2 shadow"
            }, {
                default: Y( () => [x("strong", fV, ee(u), 1)]),
                _: 2
            }, 1032, ["to"]), x("div", hV, [(w(!0),
            R(Ge, null, Ht(c, d => (w(),
            Re(l, {
                to: `/t/${d.slug}`,
                class: "flex bg-zinc-800 rounded-md hover:bg-zinc-700 p-1.5 justify-between overflow-hidden"
            }, {
                default: Y( () => [x("span", null, ee(d.name), 1), x("div", pV, ee(d.videos), 1)]),
                _: 2
            }, 1032, ["to"]))), 256))])]))), 256))])], 64)
        }
    }
})
  , gV = {
    class: "flex flex-wrap gap-1.5 mt-1.5 mb-8 max-height-2tabs overflow-hidden"
}
  , vV = ["onClick"]
  , _V = {
    class: "drop-shadow truncate relative px-4 py-2"
}
  , xV = {
    class: "text-xl lg:text-2xl !leading-none text-white mb-4 px-2 lg:px-0"
}
  , yV = ut({
    __name: "Tag",
    async setup(i) {
        let e, t;
        const {isProduction: n} = it()
          , s = m => Array.isArray(m) && m.length === 1 && (m[0].includes("%2F") || m[0].includes("/"))
          , r = m => {
            switch (typeof m) {
            case "string":
                return m.split("/").filter(Boolean);
            case "object":
                if (s(m))
                    return decodeURI(m[0]).split("/").filter(Boolean);
                if (Array.isArray(m))
                    return m;
            default:
                return []
            }
        }
          , o = Ki().params.slug
          , a = r(o)
          , l = ti()
          , c = ([e,t] = As( () => Promise.all(a.map(m => ct.tags.getTag(m)))),
        e = await e,
        t(),
        e)
          , u = ([e,t] = As( () => ct.tags.getTopTags()),
        e = await e,
        t(),
        e)
          , d = c.map(m => m.id).join(",")
          , f = c.map(m => m.name).join(", ")
          , h = m => r(Ki().params.slug).includes(m.slug)
          , p = m => {
            const v = l.currentRoute.value
              , _ = a.indexOf(m);
            _ > -1 ? a.splice(_, 1) : a.push(m);
            const y = a.join("/");
            v.name && l.push({
                name: v.name,
                params: {
                    slug: y
                }
            })
        }
          , g = [...u].sort( (m, v) => {
            const _ = h(m)
              , y = h(v);
            return _ && !y ? -1 : !_ && y ? 1 : 0
        }
        );
        return Ti( () => {
            const m = n ? `Interactive ${f} Porn Videos FapTap` : "Demo";
            ci(m)
        }
        ),
        (m, v) => (w(),
        R(Ge, null, [x("div", gV, [(w(!0),
        R(Ge, null, Ht(E(g), _ => (w(),
        R("div", {
            key: _.id,
            class: Pt(["rounded-lg overflow-hidden group flex items-center justify-center font-bold text-1xl relative z-10 bg-zinc-800 cursor-pointer", {
                "selected-tag-white-bg": h(_)
            }]),
            onClick: y => p(_.slug)
        }, [x("span", _V, ee(E(MC)(_.name)), 1)], 10, vV))), 128))]), x("h2", xV, ee(E(f)), 1), E(d) ? (w(),
        Re($l, {
            key: 0,
            class: "mt-2",
            tag: E(d)
        }, null, 8, ["tag"])) : le("", !0)], 64))
    }
})
  , bV = {
    key: 0,
    class: "grid grid-cols-1 md:grid-cols-6 gap-3"
}
  , SV = {
    class: "col-span-1 flex flex-col gap-3"
}
  , EV = {
    class: "flex items-center"
}
  , wV = {
    class: "line-clamp-1"
}
  , TV = {
    class: "col-span-5"
}
  , AV = {
    key: 1,
    class: "flex flex-col gap-3 items-center justify-center h-80"
}
  , CV = {
    key: 1,
    class: "flex justify-center items-center flex-col h-80 text-center"
}
  , MV = ut({
    __name: "Feed",
    setup(i) {
        const e = ti()
          , {isAuthorized: t, user: n, subscriptions: s} = Pn(it())
          , {authDialog: r} = Pn(Xi())
          , {isProduction: o} = it();
        return Ti( () => ci(o ? "My Feed :FapTap" : "Demo")),
        (a, l) => {
            const c = li("router-link");
            return E(t) ? (w(),
            R(Ge, {
                key: 0
            }, [l[4] || (l[4] = x("h2", {
                class: "text-xl lg:text-2xl !leading-none text-white mb-4 px-2 md:px-0"
            }, "Subscriptions", -1)), E(s).length ? (w(),
            R("div", bV, [x("div", SV, [(w(!0),
            R(Ge, null, Ht(E(s), u => (w(),
            R("div", EV, [O(c, {
                to: `/u/${u.username}`,
                class: "flex items-center gap-2 text-white font-medium flex-1"
            }, {
                default: Y( () => [O(Bo, {
                    image: u.avatar_url,
                    icon: "account",
                    class: "h-7 w-7"
                }, null, 8, ["image"]), x("span", wV, ee(u.username), 1)]),
                _: 2
            }, 1032, ["to"]), O(wm, {
                user: u
            }, null, 8, ["user"])]))), 256))]), x("div", TV, [E(s).length ? (w(),
            Re($l, {
                key: 0,
                subscriptions: !0,
                "with-tags": !1,
                "with-menu": !1,
                removeExcludedTags: !0
            })) : le("", !0)])])) : (w(),
            R("div", AV, [l[3] || (l[3] = x("h2", {
                class: "text-white font-medium text-2xl"
            }, "You are not subscribed to any creators yet", -1)), O(je, {
                theme: "blue",
                onClick: l[0] || (l[0] = u => E(e).push("/creators"))
            }, {
                default: Y( () => l[2] || (l[2] = [J("Find Creators")])),
                _: 1
            })]))], 64)) : (w(),
            R("div", CV, [l[6] || (l[6] = x("h2", {
                class: "text-white font-medium text-2xl"
            }, "Log In to get your personalized feed", -1)), O(je, {
                onClick: l[1] || (l[1] = u => r.value = !0),
                class: "mt-3"
            }, {
                default: Y( () => l[5] || (l[5] = [J("Log In")])),
                _: 1
            })]))
        }
    }
})
  , RV = ut({
    __name: "Likes",
    setup(i) {
        const {isProduction: e} = it();
        return Pn(it()),
        Ti( () => ci(e ? "My Likes - FapTap" : "Demo")),
        (t, n) => (w(),
        R(Ge, null, [n[0] || (n[0] = x("h2", {
            class: "text-xl lg:text-2xl !leading-none text-white mb-4 px-2 md:px-0"
        }, "My Liked Videos", -1)), O($l, {
            likes: !0
        })], 64))
    }
})
  , LV = {
    class: "grid grid grid-cols-2 md:grid-cols-4 lg:grid-cols-10 gap-2"
}
  , IV = {
    class: "p-2 text-center"
}
  , kV = {
    class: "line-clamp-1 font-medium text-xl md:text-base"
}
  , PV = {
    class: "md:text-sm text-zinc-500"
}
  , DV = ut({
    __name: "Performers",
    async setup(i) {
        let e, t;
        const {isProduction: n} = it()
          , s = ([e,t] = As( () => ct.performers.getPerformers({})),
        e = await e,
        t(),
        e);
        return Ti( () => ci(n ? "Top Pornstars for Interactive Porn Videos FapTap" : "Demo")),
        (r, o) => {
            const a = li("router-link");
            return w(),
            R("div", LV, [(w(!0),
            R(Ge, null, Ht(E(s), l => (w(),
            Re(a, {
                to: `/p/${l.slug}`,
                class: "p-2 group hover:bg-zinc-800 rounded"
            }, {
                default: Y( () => [O(Bo, {
                    icon: "woman-face-shimmer",
                    image: l.avatar_url,
                    class: "w-full aspect-square"
                }, null, 8, ["image"]), x("div", IV, [x("p", kV, ee(l.name), 1), x("div", PV, ee(l.videos) + " videos", 1)])]),
                _: 2
            }, 1032, ["to"]))), 256))])
        }
    }
})
  , FV = {
    class: "text-xl lg:text-2xl !leading-none text-white mb-4 px-2 lg:px-0"
}
  , OV = ut({
    __name: "Videos",
    setup(i) {
        const {isProduction: e} = it()
          , t = Ki()
          , n = Vt( () => {
            const s = t.query.q;
            return s ? `${s} Videos` : "All Videos"
        }
        );
        return Bt( () => n.value, () => ci(e ? `${n.value} FapTap` : "Demo"), {
            immediate: !0
        }),
        Ti( () => ci(e ? `${n.value} FapTap` : "Demo")),
        (s, r) => (w(),
        R(Ge, null, [x("h2", FV, ee(n.value), 1), O($l, {
            query: E(t).query.q,
            removeExcludedTags: !0
        }, null, 8, ["query"])], 64))
    }
})
  , OC = ut({
    __name: "Rating",
    props: {
        thingId: {},
        thingType: {},
        liked: {
            type: Boolean
        },
        likes: {}
    },
    setup(i) {
        const {authDialog: e} = Pn(Xi())
          , t = it()
          , n = i
          , s = xe(!1)
          , r = xe(!1)
          , o = xe(!1)
          , a = xe(0);
        Ln( () => {
            o.value = n.liked,
            a.value = n.likes
        }
        );
        const l = async () => {
            if (!r.value) {
                if (!t.isAuthorized) {
                    e.value = !0;
                    return
                }
                s.value = !0,
                await ct.rating.setRating(n.thingId, n.thingType),
                s.value = !1,
                a.value += o.value ? -1 : 1,
                o.value = !o.value,
                r.value = !0,
                setTimeout( () => {
                    r.value = !1
                }
                , 1e3)
            }
        }
        ;
        return (c, u) => (w(),
        Re(je, {
            disabled: s.value,
            onClick: l,
            theme: o.value ? "blue" : void 0,
            class: "flex gap-2 items-center"
        }, {
            default: Y( () => [O(ze, {
                name: o.value ? "heart" : "heart-outline",
                class: Pt([{
                    "!text-white": o.value
                }, "h-5 w-5 text-zinc-400 group-hover:text-white"])
            }, null, 8, ["name", "class"]), x("span", null, ee(a.value), 1)]),
            _: 1
        }, 8, ["disabled", "theme"]))
    }
})
  , UV = {
    key: 0,
    class: "flex gap-3 items-start"
}
  , NV = ["disabled"]
  , BV = {
    class: "flex flex-wrap gap-1.5 p-2"
}
  , VV = ["onClick"]
  , $V = {
    key: 1
}
  , HV = {
    class: "text-center text-white"
}
  , O1 = ut({
    __name: "CommentsForm",
    props: {
        thingId: {},
        thingType: {},
        parentId: {}
    },
    emits: ["add-comment"],
    setup(i, {emit: e}) {
        const t = i
          , n = e
          , {user: s, isAuthorized: r} = Pn(it())
          , {authDialog: o} = Pn(Xi())
          , a = xe(!1)
          , l = xe("")
          , c = xe(!1)
          , u = f => {
            const h = f.target;
            h.style.height = "0",
            h.style.height = h.scrollHeight + "px"
        }
          , d = async () => {
            c.value = !0;
            try {
                const f = await ct.comments.createComment(t.thingId, t.thingType, l.value, t.parentId);
                n("add-comment", f),
                l.value = ""
            } catch (f) {
                alert(f)
            }
        }
        ;
        return (f, h) => E(r) ? (w(),
        R("div", UV, [O(Bo, {
            image: E(s).avatar_url,
            icon: "account",
            class: "h-9 w-9 grow-0 shrink-0"
        }, null, 8, ["image"]), O(vn, {
            textarea: !0,
            rows: 1,
            onInput: u,
            modelValue: l.value,
            "onUpdate:modelValue": h[0] || (h[0] = p => l.value = p),
            placeholder: "Your comment",
            ref: "input",
            class: "flex-1 !resize-none"
        }, null, 8, ["modelValue"]), x("button", {
            onClick: h[1] || (h[1] = Vn(p => a.value = !0, ["stop"])),
            ref: "el"
        }, [O(ze, {
            name: "smiley",
            class: "h-6 w-6 text-zinc-300 mt-1.5"
        })], 512), x("button", {
            onClick: Vn(d, ["stop"]),
            disabled: l.value.length < 3,
            class: "disabled:opacity-25"
        }, [O(ze, {
            name: "send",
            class: "h-6 w-6 text-zinc-300 mt-1.5"
        })], 8, NV), O(ji, {
            target: f.$refs.el,
            modelValue: a.value,
            "onUpdate:modelValue": h[2] || (h[2] = p => a.value = p),
            placement: "top-end",
            offset: 8
        }, {
            default: Y( () => [x("div", BV, [(w(),
            R(Ge, null, Ht(["\u2764\uFE0F", "\u{1F60A}", "\u{1F975}", "\u{1F924}", "\u{1F44D}", "\u{1F351}", "\u{1F346}", "\u{1F4A6}"], p => x("button", {
                onClick: g => {
                    var m;
                    return l.value += p,
                    a.value = !1,
                    (m = f.$refs.input) == null ? void 0 : m.$el.focus()
                }
                ,
                class: "p-1.5 rounded-md hover:bg-zinc-600"
            }, ee(p), 9, VV)), 64))])]),
            _: 1
        }, 8, ["target", "modelValue"])])) : (w(),
        R("div", $V, [x("p", HV, [x("span", {
            class: "text-blue-400 font-medium cursor-pointer",
            onClick: h[3] || (h[3] = p => o.value = !0)
        }, "Sign In"), h[4] || (h[4] = J(" to write your comment "))])]))
    }
})
  , zV = {
    class: "flex gap-x-3"
}
  , GV = {
    class: "flex-1"
}
  , WV = {
    class: "text-sm"
}
  , qV = {
    class: "text-zinc-400 ml-2 text-xs"
}
  , jV = {
    class: "whitespace-pre-line text-zinc-300 mt-0.5 font-normal select-text"
}
  , KV = {
    class: "flex gap-1.5 mt-1"
}
  , Cb = ut({
    __name: "Comment",
    props: {
        comment: {},
        thingId: {},
        thingType: {}
    },
    setup(i) {
        const e = s => {
            n.value = !1,
            t.comment.comments || (t.comment.comments = []),
            t.comment.comments.push(s)
        }
          , t = i
          , n = xe(!1);
        return (s, r) => {
            const o = li("router-link")
              , a = li("Comment", !0);
            return w(),
            R("div", zV, [O(o, {
                to: `/u/${s.comment.user.username}`,
                class: "grow-0 shrink-0"
            }, {
                default: Y( () => [O(Bo, {
                    image: s.comment.user.avatar_url,
                    icon: "account",
                    class: "h-9 w-9"
                }, null, 8, ["image"])]),
                _: 1
            }, 8, ["to"]), x("div", GV, [x("div", WV, [O(o, {
                to: `/u/${s.comment.user.username}`,
                class: "text-zinc-100 font-medium"
            }, {
                default: Y( () => [J(ee(s.comment.user.username), 1)]),
                _: 1
            }, 8, ["to"]), x("span", qV, ee(E(j_)(new Date(s.comment.created_at))) + " ago", 1)]), x("p", jV, ee(s.comment.comment), 1), x("div", KV, [O(OC, {
                liked: s.comment.liked,
                likes: s.comment.likes,
                "thing-id": s.comment.id,
                "thing-type": E(gp).Comment
            }, null, 8, ["liked", "likes", "thing-id", "thing-type"]), O(je, {
                onClick: r[0] || (r[0] = l => n.value = !n.value),
                dense: !0,
                class: "!text-xs"
            }, {
                default: Y( () => [J(ee(n.value ? "Cancel" : "Reply"), 1)]),
                _: 1
            })]), n.value ? (w(),
            Re(O1, {
                key: 0,
                "parent-id": s.comment.id,
                "thing-id": t.thingId,
                "thing-type": t.thingType,
                class: "mt-2",
                onAddComment: e
            }, null, 8, ["parent-id", "thing-id", "thing-type"])) : le("", !0), x("div", null, [(w(!0),
            R(Ge, null, Ht(s.comment.comments, l => (w(),
            Re(a, {
                class: "mt-2",
                comment: l,
                "thing-type": t.thingType,
                "thing-id": t.thingId
            }, null, 8, ["comment", "thing-type", "thing-id"]))), 256))])])])
        }
    }
})
  , XV = {
    key: 0
}
  , YV = {
    class: "font-medium"
}
  , ZV = {
    key: 1
}
  , JV = ut({
    __name: "Comments",
    props: {
        thingId: {},
        thingType: {}
    },
    async setup(i) {
        let e, t;
        const {isMobile: n} = Ks()
          , s = i
          , r = xe(!1)
          , o = xe([])
          , a = async l => {
            o.value.unshift(l)
        }
        ;
        return o.value = ([e,t] = As( () => ct.comments.getComments(s.thingId)),
        e = await e,
        t(),
        e),
        (l, c) => E(n) ? (w(),
        R("div", XV, [x("div", {
            class: "border-t border-b py-3 border-zinc-800 flex items-center justify-between px-2",
            onClick: c[0] || (c[0] = u => r.value = !0)
        }, [x("span", YV, ee(o.value.length) + " comments", 1), O(ze, {
            name: "unfold",
            class: "h-6 w-6"
        })]), O(dr, {
            modelValue: r.value,
            "onUpdate:modelValue": c[1] || (c[1] = u => r.value = u)
        }, {
            default: Y( () => [O(O1, {
                "thing-id": s.thingId,
                "thing-type": s.thingType,
                class: "mb-6 px-2",
                onAddComment: a
            }, null, 8, ["thing-id", "thing-type"]), (w(!0),
            R(Ge, null, Ht(o.value, u => (w(),
            Re(Cb, {
                class: "my-4 px-2",
                "thing-type": s.thingType,
                "thing-id": s.thingId,
                comment: u
            }, null, 8, ["thing-type", "thing-id", "comment"]))), 256))]),
            _: 1
        }, 8, ["modelValue"])])) : (w(),
        R("div", ZV, [O(O1, {
            "thing-id": s.thingId,
            "thing-type": s.thingType,
            class: "mb-3",
            onAddComment: a
        }, null, 8, ["thing-id", "thing-type"]), (w(!0),
        R(Ge, null, Ht(o.value, u => (w(),
        Re(Cb, {
            class: "my-2",
            comment: u,
            "thing-type": s.thingType,
            "thing-id": s.thingId
        }, null, 8, ["comment", "thing-type", "thing-id"]))), 256))]))
    }
})
  , QV = {
    class: "bg-zinc-700 rounded text-sm px-2.5 py-0.5 flex items-center gap-x-1 grow-0 shrink-0"
}
  , e$ = ["placeholder"]
  , wp = ut({
    __name: "SelectInput",
    props: {
        max: {
            default: -1
        },
        create: {
            type: Boolean,
            default: !1
        },
        options: {},
        modelValue: {},
        placeholder: {}
    },
    emits: ["update:modelValue", "search"],
    setup(i, {emit: e}) {
        const t = e
          , n = i
          , s = xe(!1)
          , r = xe("")
          , o = xe()
          , a = xe()
          , l = xe(!1)
          , c = p => {
            n.modelValue.splice(p, 1),
            t("update:modelValue", n.modelValue)
        }
          , u = p => {
            p === "" || !n.create || n.modelValue.findIndex(g => g.toLowerCase() === p.toLowerCase()) === -1 && (n.max !== -1 && n.modelValue.length == n.max || (n.modelValue.push(p),
            t("update:modelValue", n.modelValue),
            r.value = "",
            o.value.focus()))
        }
          , d = p => {
            switch (p.code) {
            case "Enter":
                p.preventDefault(),
                u(r.value);
                break;
            case "Backspace":
                if (r.value !== "")
                    return;
                p.preventDefault(),
                n.modelValue.length > 0 && n.modelValue.splice(n.modelValue.length - 1, 1);
                break
            }
        }
          , f = Vt( () => {
            let p = n.options.filter(g => !n.modelValue.includes(g));
            return p = p.filter(g => g.toLowerCase().includes(r.value.toLowerCase())),
            p
        }
        );
        let h = -1;
        return Bt( () => r.value, p => {
            clearTimeout(h),
            s.value = p.length > 0,
            h = setTimeout( () => t("search", p), 200)
        }
        ),
        (p, g) => (w(),
        R("div", {
            ref_key: "referenceElement",
            ref: a,
            onClick: g[5] || (g[5] = m => p.$refs.inputElement.focus()),
            class: Pt(["w-full py-1.5 px-2 focus-visible:outline-none bg-zinc-800 focus:ring-2 ring-blue-500 disabled:opacity-70 rounded flex gap-1.5 flex-wrap", {
                "ring-2 ring-blue-500": l.value
            }])
        }, [(w(!0),
        R(Ge, null, Ht(n.modelValue, (m, v) => (w(),
        R("div", QV, [x("span", null, ee(m), 1), O(ze, {
            onClick: _ => {
                var y;
                return c(v),
                (y = o.value) == null ? void 0 : y.focus()
            }
            ,
            name: "close",
            class: "text-zinc-400 h-4 w-4 -mr-1.5 hover:text-white cursor-pointer"
        }, null, 8, ["onClick"])]))), 256)), zt(x("input", {
            ref_key: "inputElement",
            ref: o,
            placeholder: n.modelValue.length ? void 0 : n.placeholder,
            "onUpdate:modelValue": g[0] || (g[0] = m => r.value = m),
            onFocus: g[1] || (g[1] = m => l.value = !0),
            onFocusout: g[2] || (g[2] = m => l.value = !1),
            onKeydown: d,
            class: "bg-transparent focus-visible:outline-none text-white",
            type: "text"
        }, null, 40, e$), [[b_, r.value]]), O(ji, {
            modelValue: s.value,
            "onUpdate:modelValue": g[4] || (g[4] = m => s.value = m),
            target: p.$refs.referenceElement,
            placement: "bottom",
            offset: 8,
            class: "py-1.5 text-white"
        }, {
            default: Y( () => [O(Ot, {
                onClick: g[3] || (g[3] = m => u(r.value))
            }, {
                default: Y( () => [J(' Press Enter to add "' + ee(r.value) + '" ', 1)]),
                _: 1
            }), (w(!0),
            R(Ge, null, Ht(f.value, m => (w(),
            Re(Ot, {
                onClick: v => u(m)
            }, {
                default: Y( () => [J(ee(m), 1)]),
                _: 2
            }, 1032, ["onClick"]))), 256))]),
            _: 1
        }, 8, ["modelValue", "target"])], 2))
    }
})
  , t$ = {
    key: 0,
    class: "bg-red-600 rounded-md p-2 text-sm"
}
  , n$ = {
    class: "flex flex-col gap-y-1"
}
  , i$ = {
    class: "flex flex-col gap-y-1"
}
  , s$ = {
    class: "flex flex-col gap-y-1"
}
  , r$ = {
    class: "flex"
}
  , o$ = {
    ref: "el",
    class: "flex items-center"
}
  , a$ = {
    class: "w-64 p-3"
}
  , l$ = {
    class: "text-zinc-300 mt-3 text-sm"
}
  , c$ = ["href"]
  , u$ = {
    class: "mt-1"
}
  , d$ = {
    class: "flex gap-3"
}
  , f$ = {
    class: "mt-1"
}
  , h$ = ["value"]
  , p$ = {
    class: "flex flex-col gap-y-1"
}
  , m$ = {
    class: "flex justify-center items-center"
}
  , g$ = {
    key: 0,
    class: "flex items-center gap-1.5 text-zinc-300"
}
  , v$ = {
    key: 1
}
  , _$ = ["required"]
  , x$ = {
    class: "flex gap-3"
}
  , y$ = {
    class: "flex gap-3"
}
  , b$ = ut({
    __name: "VideoForm",
    props: {
        video: {}
    },
    emits: ["submit-video"],
    setup(i, {emit: e}) {
        const t = i
          , n = e
          , s = xe(!1)
          , r = ei({
            loading: !1,
            performers: [],
            tags: [],
            providers: [],
            projections: ["MONO_FLAT", "MONO_360", "STEREO_FLAT_LR", "STEREO_FLAT_LR_SQUARE", "STEREO_FLAT_TB", "STEREO_FLAT_TB_SQUARE", "STEREO_180_LR", "STEREO_180_LR_SPHERICAL", "STEREO_180_TB", "STEREO_180_TB_SPHERICAL", "STEREO_360_LR", "STEREO_360_TB", "STEREO_FISHEYE_200_LR"],
            fields: {
                name: "",
                description: "",
                stream_url: "",
                downloadable: !0,
                performers: [],
                tags: [],
                orientation: 0,
                vr: !1,
                projection: "MONO_FLAT"
            }
        });
        Ln( () => {
            t.video && (r.fields.id = t.video.id,
            r.fields.name = t.video.name,
            r.fields.downloadable = t.video.downloadable,
            r.fields.description = t.video.description,
            r.fields.stream_url = t.video.stream_url,
            r.fields.orientation = t.video.orientation,
            r.fields.vr = t.video.vr,
            r.fields.projection = t.video.projection,
            t.video.tags && (r.fields.tags = t.video.tags.map(d => d.name)),
            t.video.performers && (r.fields.performers = t.video.performers.map(d => d.name))),
            ct.providers.getProviders().then(d => r.providers = d)
        }
        );
        const o = async () => {
            try {
                r.loading = !0,
                r.error = void 0;
                let d;
                r.fields.id ? (d = await ct.videos.updateVideo(r.fields),
                r.fields.script && await ct.videos.updateScript(r.fields.id, r.fields.script)) : d = await ct.videos.createVideo(r.fields),
                n("submit-video", d)
            } catch (d) {
                r.error = d
            } finally {
                r.loading = !1
            }
        }
          , a = d => {
            const f = d.target.files;
            if (!f.length) {
                r.fields.script = void 0;
                return
            }
            const h = new FileReader;
            h.onload = () => {
                r.fields.script = JSON.parse(h.result).actions.map(p => [p.at, p.pos]),
                r.filename = f[0].name
            }
            ,
            h.readAsText(f[0])
        }
          , l = async d => {
            if (d.length < 2) {
                r.tags = [];
                return
            }
            const f = await ct.tags.getTags({
                query: d,
                orderBy: "videos"
            });
            r.tags = f.map(h => h.name)
        }
          , c = async d => {
            if (d.length < 2) {
                r.tags = [];
                return
            }
            const f = await ct.performers.getPerformers({
                page: 1,
                limit: 10,
                query: d
            });
            r.performers = f.map(h => h.name)
        }
          , u = async () => {
            if (!!r.fields.id) {
                r.loading = !0;
                try {
                    await ct.videos.deleteVideo(r.fields.id),
                    window.location.href = "/videos"
                } catch (d) {
                    r.error = d
                } finally {
                    r.loading = !1
                }
            }
        }
        ;
        return (d, f) => (w(),
        R("form", {
            onSubmit: Vn(o, ["prevent"]),
            class: "flex flex-col gap-y-3 mt-4"
        }, [r.error ? (w(),
        R("div", t$, ee(r.error), 1)) : le("", !0), x("div", n$, [O(vn, {
            required: "",
            modelValue: r.fields.name,
            "onUpdate:modelValue": f[0] || (f[0] = h => r.fields.name = h),
            placeholder: "Title"
        }, null, 8, ["modelValue"])]), x("div", i$, [O(vn, {
            rows: "3",
            textarea: !0,
            modelValue: r.fields.description,
            "onUpdate:modelValue": f[1] || (f[1] = h => r.fields.description = h),
            placeholder: "Description"
        }, null, 8, ["modelValue"])]), x("div", s$, [x("div", r$, [O(vn, {
            class: "flex-1",
            required: "",
            modelValue: r.fields.stream_url,
            "onUpdate:modelValue": f[2] || (f[2] = h => r.fields.stream_url = h),
            placeholder: "Stream URL"
        }, null, 8, ["modelValue"]), x("div", o$, [O(je, {
            onClick: f[3] || (f[3] = h => s.value = !0),
            type: "button",
            theme: "transparent",
            class: "!pr-0"
        }, {
            default: Y( () => [O(ze, {
                name: "help-outline",
                class: "h-6 w-6 text-zinc-400"
            })]),
            _: 1
        })], 512), O(ji, {
            modelValue: s.value,
            "onUpdate:modelValue": f[4] || (f[4] = h => s.value = h),
            target: d.$refs.el,
            placement: "right",
            offset: 8
        }, {
            default: Y( () => [x("div", a$, [f[11] || (f[11] = x("p", {
                class: "text-white font-medium"
            }, "Supported sites", -1)), x("ul", l$, [(w(!0),
            R(Ge, null, Ht(r.providers, h => (w(),
            R("li", null, [x("a", {
                href: `https://${h}`,
                target: "_blank",
                class: "hover:text-white"
            }, "https://" + ee(h), 9, c$)]))), 256))])])]),
            _: 1
        }, 8, ["modelValue", "target"])])]), x("div", null, [O(wp, {
            class: "mt-1",
            onSearch: l,
            modelValue: r.fields.tags,
            "onUpdate:modelValue": f[5] || (f[5] = h => r.fields.tags = h),
            options: r.tags,
            max: 20,
            placeholder: "Tags",
            create: !0
        }, null, 8, ["modelValue", "options"])]), x("div", null, [O(wp, {
            class: "mt-1",
            onSearch: c,
            modelValue: r.fields.performers,
            "onUpdate:modelValue": f[6] || (f[6] = h => r.fields.performers = h),
            options: r.performers,
            max: 10,
            placeholder: "Performers",
            create: !0
        }, null, 8, ["modelValue", "options"])]), x("div", u$, [zt(x("select", {
            "onUpdate:modelValue": f[7] || (f[7] = h => r.fields.orientation = h),
            class: "w-full bg-zinc-800 rounded px-2 py-2 focus-visible:outline-none focus:ring-2 ring-blue-500"
        }, f[12] || (f[12] = [x("option", {
            value: 0
        }, "Straight", -1), x("option", {
            value: 1
        }, "Transgender", -1), x("option", {
            value: 2
        }, "Gay", -1)]), 512), [[wd, r.fields.orientation]])]), x("div", d$, [f[13] || (f[13] = x("span", {
            class: "font-medium text-sm text-zinc-400"
        }, "VR", -1)), zt(x("input", {
            type: "checkbox",
            "onUpdate:modelValue": f[8] || (f[8] = h => r.fields.vr = h)
        }, null, 512), [[Fc, r.fields.vr]])]), zt(x("div", f$, [zt(x("select", {
            "onUpdate:modelValue": f[9] || (f[9] = h => r.fields.projection = h),
            class: "w-full bg-zinc-800 rounded px-2 py-2 focus-visible:outline-none focus:ring-2 ring-blue-500"
        }, [(w(!0),
        R(Ge, null, Ht(r.projections, h => (w(),
        R("option", {
            value: h
        }, ee(h), 9, h$))), 256))], 512), [[wd, r.fields.projection]])], 512), [[$n, r.fields.vr]]), x("div", p$, [O(je, {
            type: "button",
            class: "mt-1"
        }, {
            default: Y( () => [x("label", m$, [r.fields.script ? (w(),
            R("div", v$, [x("p", null, ee(r.filename) + " - " + ee(r.fields.script.length) + " actions", 1)])) : (w(),
            R("div", g$, [f[14] || (f[14] = x("p", null, "Select Funscript", -1)), O(ze, {
                name: "upload",
                class: "h-6 w-6"
            })])), x("input", {
                class: "hidden",
                required: !r.fields.id,
                onChange: a,
                type: "file"
            }, null, 40, _$)])]),
            _: 1
        })]), x("div", x$, [f[15] || (f[15] = x("span", {
            class: "font-medium text-sm text-zinc-400"
        }, "Script Download", -1)), zt(x("input", {
            type: "checkbox",
            "onUpdate:modelValue": f[10] || (f[10] = h => r.fields.downloadable = h)
        }, null, 512), [[Fc, r.fields.downloadable]])]), x("div", y$, [r.fields.id ? (w(),
        Re(je, {
            key: 0,
            loading: r.loading,
            theme: "red",
            onClick: u,
            class: "shrink-0"
        }, {
            default: Y( () => f[16] || (f[16] = [J("Delete")])),
            _: 1
        }, 8, ["loading"])) : le("", !0), O(je, {
            loading: r.loading,
            theme: "blue",
            class: "flex-1"
        }, {
            default: Y( () => [J(ee(r.fields.id ? "Edit" : "Create"), 1)]),
            _: 1
        }, 8, ["loading"])])], 32))
    }
});
var S$ = "M11,15H13V17H11V15M11,7H13V13H11V7M12,2C6.47,2 2,6.5 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4A8,8 0 0,1 20,12A8,8 0 0,1 12,20Z"
  , E$ = "M12,15.5A3.5,3.5 0 0,1 8.5,12A3.5,3.5 0 0,1 12,8.5A3.5,3.5 0 0,1 15.5,12A3.5,3.5 0 0,1 12,15.5M19.43,12.97C19.47,12.65 19.5,12.33 19.5,12C19.5,11.67 19.47,11.34 19.43,11L21.54,9.37C21.73,9.22 21.78,8.95 21.66,8.73L19.66,5.27C19.54,5.05 19.27,4.96 19.05,5.05L16.56,6.05C16.04,5.66 15.5,5.32 14.87,5.07L14.5,2.42C14.46,2.18 14.25,2 14,2H10C9.75,2 9.54,2.18 9.5,2.42L9.13,5.07C8.5,5.32 7.96,5.66 7.44,6.05L4.95,5.05C4.73,4.96 4.46,5.05 4.34,5.27L2.34,8.73C2.21,8.95 2.27,9.22 2.46,9.37L4.57,11C4.53,11.34 4.5,11.67 4.5,12C4.5,12.33 4.53,12.65 4.57,12.97L2.46,14.63C2.27,14.78 2.21,15.05 2.34,15.27L4.34,18.73C4.46,18.95 4.73,19.03 4.95,18.95L7.44,17.94C7.96,18.34 8.5,18.68 9.13,18.93L9.5,21.58C9.54,21.82 9.75,22 10,22H14C14.25,22 14.46,21.82 14.5,21.58L14.87,18.93C15.5,18.67 16.04,18.34 16.56,17.94L19.05,18.95C19.27,19.03 19.54,18.95 19.66,18.73L21.66,15.27C21.78,15.05 21.73,14.78 21.54,14.63L19.43,12.97Z"
  , w$ = "M10,12V22H8V14H6V12H10M18,14V20C18,21.11 17.11,22 16,22H14A2,2 0 0,1 12,20V14A2,2 0 0,1 14,12H16C17.11,12 18,12.9 18,14M14,14V20H16V14H14M11.5,3C14.15,3 16.55,4 18.4,5.6L21,3V10H14L16.62,7.38C15.23,6.22 13.46,5.5 11.5,5.5C7.96,5.5 4.95,7.81 3.9,11L1.53,10.22C2.92,6.03 6.85,3 11.5,3Z"
  , Mb = "M5,5H10V7H7V10H5V5M14,5H19V10H17V7H14V5M17,14H19V19H14V17H17V14M10,17V19H5V14H7V17H10Z"
  , Rb = "M14,14H19V16H16V19H14V14M5,14H10V19H8V16H5V14M8,5H10V10H5V8H8V5M19,8V10H14V5H16V8H19Z"
  , Lb = "M14,19H18V5H14M6,19H10V5H6V19Z"
  , Ib = "M8,5.14V19.14L19,12.14L8,5.14Z"
  , T$ = "M14.5,13.5H16.5V10.5H14.5M18,14A1,1 0 0,1 17,15H16.25V16.5H14.75V15H14A1,1 0 0,1 13,14V10A1,1 0 0,1 14,9H17A1,1 0 0,1 18,10M11,15H9.5V13H7.5V15H6V9H7.5V11.5H9.5V9H11M19,4H5C3.89,4 3,4.89 3,6V18A2,2 0 0,0 5,20H19A2,2 0 0,0 21,18V6C21,4.89 20.1,4 19,4Z"
  , A$ = "M12.5,3C17.15,3 21.08,6.03 22.47,10.22L20.1,11C19.05,7.81 16.04,5.5 12.5,5.5C10.54,5.5 8.77,6.22 7.38,7.38L10,10H3V3L5.6,5.6C7.45,4 9.85,3 12.5,3M10,12V22H8V14H6V12H10M18,14V20C18,21.11 17.11,22 16,22H14A2,2 0 0,1 12,20V14A2,2 0 0,1 14,12H16C17.11,12 18,12.9 18,14M14,14V20H16V14H14Z"
  , C$ = "M14,3.23V5.29C16.89,6.15 19,8.83 19,12C19,15.17 16.89,17.84 14,18.7V20.77C18,19.86 21,16.28 21,12C21,7.72 18,4.14 14,3.23M16.5,12C16.5,10.23 15.5,8.71 14,7.97V16C15.5,15.29 16.5,13.76 16.5,12M3,9V15H7L12,20V4L7,9H3Z"
  , M$ = "M12,4L9.91,6.09L12,8.18M4.27,3L3,4.27L7.73,9H3V15H7L12,20V13.27L16.25,17.53C15.58,18.04 14.83,18.46 14,18.7V20.77C15.38,20.45 16.63,19.82 17.68,18.96L19.73,21L21,19.73L12,10.73M19,12C19,12.94 18.8,13.82 18.46,14.64L19.97,16.15C20.62,14.91 21,13.5 21,12C21,7.72 18,4.14 14,3.23V5.29C16.89,6.15 19,8.83 19,12M16.5,12C16.5,10.23 15.5,8.71 14,7.97V10.18L16.45,12.63C16.5,12.43 16.5,12.21 16.5,12Z";
function R$(i) {
    return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i
}
var UC = {
    exports: {}
};
(function(i, e) {
    (function(t) {
        var n = /^(?=((?:[a-zA-Z0-9+\-.]+:)?))\1(?=((?:\/\/[^\/?#]*)?))\2(?=((?:(?:[^?#\/]*\/)*[^;?#\/]*)?))\3((?:;[^?#]*)?)(\?[^#]*)?(#[^]*)?$/
          , s = /^(?=([^\/?#]*))\1([^]*)$/
          , r = /(?:\/|^)\.(?=\/)/g
          , o = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g
          , a = {
            buildAbsoluteURL: function(l, c, u) {
                if (u = u || {},
                l = l.trim(),
                c = c.trim(),
                !c) {
                    if (!u.alwaysNormalize)
                        return l;
                    var d = a.parseURL(l);
                    if (!d)
                        throw new Error("Error trying to parse base URL.");
                    return d.path = a.normalizePath(d.path),
                    a.buildURLFromParts(d)
                }
                var f = a.parseURL(c);
                if (!f)
                    throw new Error("Error trying to parse relative URL.");
                if (f.scheme)
                    return u.alwaysNormalize ? (f.path = a.normalizePath(f.path),
                    a.buildURLFromParts(f)) : c;
                var h = a.parseURL(l);
                if (!h)
                    throw new Error("Error trying to parse base URL.");
                if (!h.netLoc && h.path && h.path[0] !== "/") {
                    var p = s.exec(h.path);
                    h.netLoc = p[1],
                    h.path = p[2]
                }
                h.netLoc && !h.path && (h.path = "/");
                var g = {
                    scheme: h.scheme,
                    netLoc: f.netLoc,
                    path: null,
                    params: f.params,
                    query: f.query,
                    fragment: f.fragment
                };
                if (!f.netLoc && (g.netLoc = h.netLoc,
                f.path[0] !== "/"))
                    if (!f.path)
                        g.path = h.path,
                        f.params || (g.params = h.params,
                        f.query || (g.query = h.query));
                    else {
                        var m = h.path
                          , v = m.substring(0, m.lastIndexOf("/") + 1) + f.path;
                        g.path = a.normalizePath(v)
                    }
                return g.path === null && (g.path = u.alwaysNormalize ? a.normalizePath(f.path) : f.path),
                a.buildURLFromParts(g)
            },
            parseURL: function(l) {
                var c = n.exec(l);
                return c ? {
                    scheme: c[1] || "",
                    netLoc: c[2] || "",
                    path: c[3] || "",
                    params: c[4] || "",
                    query: c[5] || "",
                    fragment: c[6] || ""
                } : null
            },
            normalizePath: function(l) {
                for (l = l.split("").reverse().join("").replace(r, ""); l.length !== (l = l.replace(o, "")).length; )
                    ;
                return l.split("").reverse().join("")
            },
            buildURLFromParts: function(l) {
                return l.scheme + l.netLoc + l.path + l.params + l.query + l.fragment
            }
        };
        i.exports = a
    }
    )()
}
)(UC);
var Z_ = UC.exports;
function kb(i, e) {
    var t = Object.keys(i);
    if (Object.getOwnPropertySymbols) {
        var n = Object.getOwnPropertySymbols(i);
        e && (n = n.filter(function(s) {
            return Object.getOwnPropertyDescriptor(i, s).enumerable
        })),
        t.push.apply(t, n)
    }
    return t
}
function yi(i) {
    for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e] != null ? arguments[e] : {};
        e % 2 ? kb(Object(t), !0).forEach(function(n) {
            k$(i, n, t[n])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(i, Object.getOwnPropertyDescriptors(t)) : kb(Object(t)).forEach(function(n) {
            Object.defineProperty(i, n, Object.getOwnPropertyDescriptor(t, n))
        })
    }
    return i
}
function L$(i, e) {
    if (typeof i != "object" || !i)
        return i;
    var t = i[Symbol.toPrimitive];
    if (t !== void 0) {
        var n = t.call(i, e || "default");
        if (typeof n != "object")
            return n;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (e === "string" ? String : Number)(i)
}
function I$(i) {
    var e = L$(i, "string");
    return typeof e == "symbol" ? e : String(e)
}
function k$(i, e, t) {
    return e = I$(e),
    e in i ? Object.defineProperty(i, e, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : i[e] = t,
    i
}
function Qn() {
    return Qn = Object.assign ? Object.assign.bind() : function(i) {
        for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var n in t)
                Object.prototype.hasOwnProperty.call(t, n) && (i[n] = t[n])
        }
        return i
    }
    ,
    Qn.apply(this, arguments)
}
const pt = Number.isFinite || function(i) {
    return typeof i == "number" && isFinite(i)
}
  , P$ = Number.isSafeInteger || function(i) {
    return typeof i == "number" && Math.abs(i) <= D$
}
  , D$ = Number.MAX_SAFE_INTEGER || 9007199254740991;
let P = function(i) {
    return i.MEDIA_ATTACHING = "hlsMediaAttaching",
    i.MEDIA_ATTACHED = "hlsMediaAttached",
    i.MEDIA_DETACHING = "hlsMediaDetaching",
    i.MEDIA_DETACHED = "hlsMediaDetached",
    i.BUFFER_RESET = "hlsBufferReset",
    i.BUFFER_CODECS = "hlsBufferCodecs",
    i.BUFFER_CREATED = "hlsBufferCreated",
    i.BUFFER_APPENDING = "hlsBufferAppending",
    i.BUFFER_APPENDED = "hlsBufferAppended",
    i.BUFFER_EOS = "hlsBufferEos",
    i.BUFFER_FLUSHING = "hlsBufferFlushing",
    i.BUFFER_FLUSHED = "hlsBufferFlushed",
    i.MANIFEST_LOADING = "hlsManifestLoading",
    i.MANIFEST_LOADED = "hlsManifestLoaded",
    i.MANIFEST_PARSED = "hlsManifestParsed",
    i.LEVEL_SWITCHING = "hlsLevelSwitching",
    i.LEVEL_SWITCHED = "hlsLevelSwitched",
    i.LEVEL_LOADING = "hlsLevelLoading",
    i.LEVEL_LOADED = "hlsLevelLoaded",
    i.LEVEL_UPDATED = "hlsLevelUpdated",
    i.LEVEL_PTS_UPDATED = "hlsLevelPtsUpdated",
    i.LEVELS_UPDATED = "hlsLevelsUpdated",
    i.AUDIO_TRACKS_UPDATED = "hlsAudioTracksUpdated",
    i.AUDIO_TRACK_SWITCHING = "hlsAudioTrackSwitching",
    i.AUDIO_TRACK_SWITCHED = "hlsAudioTrackSwitched",
    i.AUDIO_TRACK_LOADING = "hlsAudioTrackLoading",
    i.AUDIO_TRACK_LOADED = "hlsAudioTrackLoaded",
    i.SUBTITLE_TRACKS_UPDATED = "hlsSubtitleTracksUpdated",
    i.SUBTITLE_TRACKS_CLEARED = "hlsSubtitleTracksCleared",
    i.SUBTITLE_TRACK_SWITCH = "hlsSubtitleTrackSwitch",
    i.SUBTITLE_TRACK_LOADING = "hlsSubtitleTrackLoading",
    i.SUBTITLE_TRACK_LOADED = "hlsSubtitleTrackLoaded",
    i.SUBTITLE_FRAG_PROCESSED = "hlsSubtitleFragProcessed",
    i.CUES_PARSED = "hlsCuesParsed",
    i.NON_NATIVE_TEXT_TRACKS_FOUND = "hlsNonNativeTextTracksFound",
    i.INIT_PTS_FOUND = "hlsInitPtsFound",
    i.FRAG_LOADING = "hlsFragLoading",
    i.FRAG_LOAD_EMERGENCY_ABORTED = "hlsFragLoadEmergencyAborted",
    i.FRAG_LOADED = "hlsFragLoaded",
    i.FRAG_DECRYPTED = "hlsFragDecrypted",
    i.FRAG_PARSING_INIT_SEGMENT = "hlsFragParsingInitSegment",
    i.FRAG_PARSING_USERDATA = "hlsFragParsingUserdata",
    i.FRAG_PARSING_METADATA = "hlsFragParsingMetadata",
    i.FRAG_PARSED = "hlsFragParsed",
    i.FRAG_BUFFERED = "hlsFragBuffered",
    i.FRAG_CHANGED = "hlsFragChanged",
    i.FPS_DROP = "hlsFpsDrop",
    i.FPS_DROP_LEVEL_CAPPING = "hlsFpsDropLevelCapping",
    i.MAX_AUTO_LEVEL_UPDATED = "hlsMaxAutoLevelUpdated",
    i.ERROR = "hlsError",
    i.DESTROYING = "hlsDestroying",
    i.KEY_LOADING = "hlsKeyLoading",
    i.KEY_LOADED = "hlsKeyLoaded",
    i.LIVE_BACK_BUFFER_REACHED = "hlsLiveBackBufferReached",
    i.BACK_BUFFER_REACHED = "hlsBackBufferReached",
    i.STEERING_MANIFEST_LOADED = "hlsSteeringManifestLoaded",
    i
}({})
  , Ut = function(i) {
    return i.NETWORK_ERROR = "networkError",
    i.MEDIA_ERROR = "mediaError",
    i.KEY_SYSTEM_ERROR = "keySystemError",
    i.MUX_ERROR = "muxError",
    i.OTHER_ERROR = "otherError",
    i
}({})
  , Ae = function(i) {
    return i.KEY_SYSTEM_NO_KEYS = "keySystemNoKeys",
    i.KEY_SYSTEM_NO_ACCESS = "keySystemNoAccess",
    i.KEY_SYSTEM_NO_SESSION = "keySystemNoSession",
    i.KEY_SYSTEM_NO_CONFIGURED_LICENSE = "keySystemNoConfiguredLicense",
    i.KEY_SYSTEM_LICENSE_REQUEST_FAILED = "keySystemLicenseRequestFailed",
    i.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED = "keySystemServerCertificateRequestFailed",
    i.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED = "keySystemServerCertificateUpdateFailed",
    i.KEY_SYSTEM_SESSION_UPDATE_FAILED = "keySystemSessionUpdateFailed",
    i.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED = "keySystemStatusOutputRestricted",
    i.KEY_SYSTEM_STATUS_INTERNAL_ERROR = "keySystemStatusInternalError",
    i.MANIFEST_LOAD_ERROR = "manifestLoadError",
    i.MANIFEST_LOAD_TIMEOUT = "manifestLoadTimeOut",
    i.MANIFEST_PARSING_ERROR = "manifestParsingError",
    i.MANIFEST_INCOMPATIBLE_CODECS_ERROR = "manifestIncompatibleCodecsError",
    i.LEVEL_EMPTY_ERROR = "levelEmptyError",
    i.LEVEL_LOAD_ERROR = "levelLoadError",
    i.LEVEL_LOAD_TIMEOUT = "levelLoadTimeOut",
    i.LEVEL_PARSING_ERROR = "levelParsingError",
    i.LEVEL_SWITCH_ERROR = "levelSwitchError",
    i.AUDIO_TRACK_LOAD_ERROR = "audioTrackLoadError",
    i.AUDIO_TRACK_LOAD_TIMEOUT = "audioTrackLoadTimeOut",
    i.SUBTITLE_LOAD_ERROR = "subtitleTrackLoadError",
    i.SUBTITLE_TRACK_LOAD_TIMEOUT = "subtitleTrackLoadTimeOut",
    i.FRAG_LOAD_ERROR = "fragLoadError",
    i.FRAG_LOAD_TIMEOUT = "fragLoadTimeOut",
    i.FRAG_DECRYPT_ERROR = "fragDecryptError",
    i.FRAG_PARSING_ERROR = "fragParsingError",
    i.FRAG_GAP = "fragGap",
    i.REMUX_ALLOC_ERROR = "remuxAllocError",
    i.KEY_LOAD_ERROR = "keyLoadError",
    i.KEY_LOAD_TIMEOUT = "keyLoadTimeOut",
    i.BUFFER_ADD_CODEC_ERROR = "bufferAddCodecError",
    i.BUFFER_INCOMPATIBLE_CODECS_ERROR = "bufferIncompatibleCodecsError",
    i.BUFFER_APPEND_ERROR = "bufferAppendError",
    i.BUFFER_APPENDING_ERROR = "bufferAppendingError",
    i.BUFFER_STALLED_ERROR = "bufferStalledError",
    i.BUFFER_FULL_ERROR = "bufferFullError",
    i.BUFFER_SEEK_OVER_HOLE = "bufferSeekOverHole",
    i.BUFFER_NUDGE_ON_STALL = "bufferNudgeOnStall",
    i.INTERNAL_EXCEPTION = "internalException",
    i.INTERNAL_ABORTED = "aborted",
    i.UNKNOWN = "unknown",
    i
}({});
const tl = function() {}
  , U1 = {
    trace: tl,
    debug: tl,
    log: tl,
    warn: tl,
    info: tl,
    error: tl
};
let fd = U1;
function F$(i) {
    const e = self.console[i];
    return e ? e.bind(self.console, `[${i}] >`) : tl
}
function O$(i, ...e) {
    e.forEach(function(t) {
        fd[t] = i[t] ? i[t].bind(i) : F$(t)
    })
}
function U$(i, e) {
    if (typeof console == "object" && i === !0 || typeof i == "object") {
        O$(i, "debug", "log", "info", "warn", "error");
        try {
            fd.log(`Debug logs enabled for "${e}" in hls.js version 1.5.17`)
        } catch {
            fd = U1
        }
    } else
        fd = U1
}
const de = fd
  , N$ = /^(\d+)x(\d+)$/
  , Pb = /(.+?)=(".*?"|.*?)(?:,|$)/g;
class Un {
    constructor(e) {
        typeof e == "string" && (e = Un.parseAttrList(e)),
        Qn(this, e)
    }
    get clientAttrs() {
        return Object.keys(this).filter(e => e.substring(0, 2) === "X-")
    }
    decimalInteger(e) {
        const t = parseInt(this[e], 10);
        return t > Number.MAX_SAFE_INTEGER ? 1 / 0 : t
    }
    hexadecimalInteger(e) {
        if (this[e]) {
            let t = (this[e] || "0x").slice(2);
            t = (t.length & 1 ? "0" : "") + t;
            const n = new Uint8Array(t.length / 2);
            for (let s = 0; s < t.length / 2; s++)
                n[s] = parseInt(t.slice(s * 2, s * 2 + 2), 16);
            return n
        } else
            return null
    }
    hexadecimalIntegerAsNumber(e) {
        const t = parseInt(this[e], 16);
        return t > Number.MAX_SAFE_INTEGER ? 1 / 0 : t
    }
    decimalFloatingPoint(e) {
        return parseFloat(this[e])
    }
    optionalFloat(e, t) {
        const n = this[e];
        return n ? parseFloat(n) : t
    }
    enumeratedString(e) {
        return this[e]
    }
    bool(e) {
        return this[e] === "YES"
    }
    decimalResolution(e) {
        const t = N$.exec(this[e]);
        if (t !== null)
            return {
                width: parseInt(t[1], 10),
                height: parseInt(t[2], 10)
            }
    }
    static parseAttrList(e) {
        let t;
        const n = {}
          , s = '"';
        for (Pb.lastIndex = 0; (t = Pb.exec(e)) !== null; ) {
            let r = t[2];
            r.indexOf(s) === 0 && r.lastIndexOf(s) === r.length - 1 && (r = r.slice(1, -1));
            const o = t[1].trim();
            n[o] = r
        }
        return n
    }
}
function B$(i) {
    return i !== "ID" && i !== "CLASS" && i !== "START-DATE" && i !== "DURATION" && i !== "END-DATE" && i !== "END-ON-NEXT"
}
function V$(i) {
    return i === "SCTE35-OUT" || i === "SCTE35-IN"
}
class NC {
    constructor(e, t) {
        if (this.attr = void 0,
        this._startDate = void 0,
        this._endDate = void 0,
        this._badValueForSameId = void 0,
        t) {
            const n = t.attr;
            for (const s in n)
                if (Object.prototype.hasOwnProperty.call(e, s) && e[s] !== n[s]) {
                    de.warn(`DATERANGE tag attribute: "${s}" does not match for tags with ID: "${e.ID}"`),
                    this._badValueForSameId = s;
                    break
                }
            e = Qn(new Un({}), n, e)
        }
        if (this.attr = e,
        this._startDate = new Date(e["START-DATE"]),
        "END-DATE"in this.attr) {
            const n = new Date(this.attr["END-DATE"]);
            pt(n.getTime()) && (this._endDate = n)
        }
    }
    get id() {
        return this.attr.ID
    }
    get class() {
        return this.attr.CLASS
    }
    get startDate() {
        return this._startDate
    }
    get endDate() {
        if (this._endDate)
            return this._endDate;
        const e = this.duration;
        return e !== null ? new Date(this._startDate.getTime() + e * 1e3) : null
    }
    get duration() {
        if ("DURATION"in this.attr) {
            const e = this.attr.decimalFloatingPoint("DURATION");
            if (pt(e))
                return e
        } else if (this._endDate)
            return (this._endDate.getTime() - this._startDate.getTime()) / 1e3;
        return null
    }
    get plannedDuration() {
        return "PLANNED-DURATION"in this.attr ? this.attr.decimalFloatingPoint("PLANNED-DURATION") : null
    }
    get endOnNext() {
        return this.attr.bool("END-ON-NEXT")
    }
    get isValid() {
        return !!this.id && !this._badValueForSameId && pt(this.startDate.getTime()) && (this.duration === null || this.duration >= 0) && (!this.endOnNext || !!this.class)
    }
}
class Tm {
    constructor() {
        this.aborted = !1,
        this.loaded = 0,
        this.retry = 0,
        this.total = 0,
        this.chunkCount = 0,
        this.bwEstimate = 0,
        this.loading = {
            start: 0,
            first: 0,
            end: 0
        },
        this.parsing = {
            start: 0,
            end: 0
        },
        this.buffering = {
            start: 0,
            first: 0,
            end: 0
        }
    }
}
var gn = {
    AUDIO: "audio",
    VIDEO: "video",
    AUDIOVIDEO: "audiovideo"
};
class BC {
    constructor(e) {
        this._byteRange = null,
        this._url = null,
        this.baseurl = void 0,
        this.relurl = void 0,
        this.elementaryStreams = {
            [gn.AUDIO]: null,
            [gn.VIDEO]: null,
            [gn.AUDIOVIDEO]: null
        },
        this.baseurl = e
    }
    setByteRange(e, t) {
        const n = e.split("@", 2);
        let s;
        n.length === 1 ? s = (t == null ? void 0 : t.byteRangeEndOffset) || 0 : s = parseInt(n[1]),
        this._byteRange = [s, parseInt(n[0]) + s]
    }
    get byteRange() {
        return this._byteRange ? this._byteRange : []
    }
    get byteRangeStartOffset() {
        return this.byteRange[0]
    }
    get byteRangeEndOffset() {
        return this.byteRange[1]
    }
    get url() {
        return !this._url && this.baseurl && this.relurl && (this._url = Z_.buildAbsoluteURL(this.baseurl, this.relurl, {
            alwaysNormalize: !0
        })),
        this._url || ""
    }
    set url(e) {
        this._url = e
    }
}
class y0 extends BC {
    constructor(e, t) {
        super(t),
        this._decryptdata = null,
        this.rawProgramDateTime = null,
        this.programDateTime = null,
        this.tagList = [],
        this.duration = 0,
        this.sn = 0,
        this.levelkeys = void 0,
        this.type = void 0,
        this.loader = null,
        this.keyLoader = null,
        this.level = -1,
        this.cc = 0,
        this.startPTS = void 0,
        this.endPTS = void 0,
        this.startDTS = void 0,
        this.endDTS = void 0,
        this.start = 0,
        this.deltaPTS = void 0,
        this.maxStartPTS = void 0,
        this.minEndPTS = void 0,
        this.stats = new Tm,
        this.data = void 0,
        this.bitrateTest = !1,
        this.title = null,
        this.initSegment = null,
        this.endList = void 0,
        this.gap = void 0,
        this.urlId = 0,
        this.type = e
    }
    get decryptdata() {
        const {levelkeys: e} = this;
        if (!e && !this._decryptdata)
            return null;
        if (!this._decryptdata && this.levelkeys && !this.levelkeys.NONE) {
            const t = this.levelkeys.identity;
            if (t)
                this._decryptdata = t.getDecryptData(this.sn);
            else {
                const n = Object.keys(this.levelkeys);
                if (n.length === 1)
                    return this._decryptdata = this.levelkeys[n[0]].getDecryptData(this.sn)
            }
        }
        return this._decryptdata
    }
    get end() {
        return this.start + this.duration
    }
    get endProgramDateTime() {
        if (this.programDateTime === null || !pt(this.programDateTime))
            return null;
        const e = pt(this.duration) ? this.duration : 0;
        return this.programDateTime + e * 1e3
    }
    get encrypted() {
        var e;
        if ((e = this._decryptdata) != null && e.encrypted)
            return !0;
        if (this.levelkeys) {
            const t = Object.keys(this.levelkeys)
              , n = t.length;
            if (n > 1 || n === 1 && this.levelkeys[t[0]].encrypted)
                return !0
        }
        return !1
    }
    setKeyFormat(e) {
        if (this.levelkeys) {
            const t = this.levelkeys[e];
            t && !this._decryptdata && (this._decryptdata = t.getDecryptData(this.sn))
        }
    }
    abortRequests() {
        var e, t;
        (e = this.loader) == null || e.abort(),
        (t = this.keyLoader) == null || t.abort()
    }
    setElementaryStreamInfo(e, t, n, s, r, o=!1) {
        const {elementaryStreams: a} = this
          , l = a[e];
        if (!l) {
            a[e] = {
                startPTS: t,
                endPTS: n,
                startDTS: s,
                endDTS: r,
                partial: o
            };
            return
        }
        l.startPTS = Math.min(l.startPTS, t),
        l.endPTS = Math.max(l.endPTS, n),
        l.startDTS = Math.min(l.startDTS, s),
        l.endDTS = Math.max(l.endDTS, r)
    }
    clearElementaryStreamInfo() {
        const {elementaryStreams: e} = this;
        e[gn.AUDIO] = null,
        e[gn.VIDEO] = null,
        e[gn.AUDIOVIDEO] = null
    }
}
class $$ extends BC {
    constructor(e, t, n, s, r) {
        super(n),
        this.fragOffset = 0,
        this.duration = 0,
        this.gap = !1,
        this.independent = !1,
        this.relurl = void 0,
        this.fragment = void 0,
        this.index = void 0,
        this.stats = new Tm,
        this.duration = e.decimalFloatingPoint("DURATION"),
        this.gap = e.bool("GAP"),
        this.independent = e.bool("INDEPENDENT"),
        this.relurl = e.enumeratedString("URI"),
        this.fragment = t,
        this.index = s;
        const o = e.enumeratedString("BYTERANGE");
        o && this.setByteRange(o, r),
        r && (this.fragOffset = r.fragOffset + r.duration)
    }
    get start() {
        return this.fragment.start + this.fragOffset
    }
    get end() {
        return this.start + this.duration
    }
    get loaded() {
        const {elementaryStreams: e} = this;
        return !!(e.audio || e.video || e.audiovideo)
    }
}
const H$ = 10;
class z$ {
    constructor(e) {
        this.PTSKnown = !1,
        this.alignedSliding = !1,
        this.averagetargetduration = void 0,
        this.endCC = 0,
        this.endSN = 0,
        this.fragments = void 0,
        this.fragmentHint = void 0,
        this.partList = null,
        this.dateRanges = void 0,
        this.live = !0,
        this.ageHeader = 0,
        this.advancedDateTime = void 0,
        this.updated = !0,
        this.advanced = !0,
        this.availabilityDelay = void 0,
        this.misses = 0,
        this.startCC = 0,
        this.startSN = 0,
        this.startTimeOffset = null,
        this.targetduration = 0,
        this.totalduration = 0,
        this.type = null,
        this.url = void 0,
        this.m3u8 = "",
        this.version = null,
        this.canBlockReload = !1,
        this.canSkipUntil = 0,
        this.canSkipDateRanges = !1,
        this.skippedSegments = 0,
        this.recentlyRemovedDateranges = void 0,
        this.partHoldBack = 0,
        this.holdBack = 0,
        this.partTarget = 0,
        this.preloadHint = void 0,
        this.renditionReports = void 0,
        this.tuneInGoal = 0,
        this.deltaUpdateFailed = void 0,
        this.driftStartTime = 0,
        this.driftEndTime = 0,
        this.driftStart = 0,
        this.driftEnd = 0,
        this.encryptedFragments = void 0,
        this.playlistParsingError = null,
        this.variableList = null,
        this.hasVariableRefs = !1,
        this.fragments = [],
        this.encryptedFragments = [],
        this.dateRanges = {},
        this.url = e
    }
    reloaded(e) {
        if (!e) {
            this.advanced = !0,
            this.updated = !0;
            return
        }
        const t = this.lastPartSn - e.lastPartSn
          , n = this.lastPartIndex - e.lastPartIndex;
        this.updated = this.endSN !== e.endSN || !!n || !!t || !this.live,
        this.advanced = this.endSN > e.endSN || t > 0 || t === 0 && n > 0,
        this.updated || this.advanced ? this.misses = Math.floor(e.misses * .6) : this.misses = e.misses + 1,
        this.availabilityDelay = e.availabilityDelay
    }
    get hasProgramDateTime() {
        return this.fragments.length ? pt(this.fragments[this.fragments.length - 1].programDateTime) : !1
    }
    get levelTargetDuration() {
        return this.averagetargetduration || this.targetduration || H$
    }
    get drift() {
        const e = this.driftEndTime - this.driftStartTime;
        return e > 0 ? (this.driftEnd - this.driftStart) * 1e3 / e : 1
    }
    get edge() {
        return this.partEnd || this.fragmentEnd
    }
    get partEnd() {
        var e;
        return (e = this.partList) != null && e.length ? this.partList[this.partList.length - 1].end : this.fragmentEnd
    }
    get fragmentEnd() {
        var e;
        return (e = this.fragments) != null && e.length ? this.fragments[this.fragments.length - 1].end : 0
    }
    get age() {
        return this.advancedDateTime ? Math.max(Date.now() - this.advancedDateTime, 0) / 1e3 : 0
    }
    get lastPartIndex() {
        var e;
        return (e = this.partList) != null && e.length ? this.partList[this.partList.length - 1].index : -1
    }
    get lastPartSn() {
        var e;
        return (e = this.partList) != null && e.length ? this.partList[this.partList.length - 1].fragment.sn : this.endSN
    }
}
function J_(i) {
    return Uint8Array.from(atob(i), e => e.charCodeAt(0))
}
function G$(i) {
    const e = N1(i).subarray(0, 16)
      , t = new Uint8Array(16);
    return t.set(e, 16 - e.length),
    t
}
function W$(i) {
    const e = function(n, s, r) {
        const o = n[s];
        n[s] = n[r],
        n[r] = o
    };
    e(i, 0, 3),
    e(i, 1, 2),
    e(i, 4, 5),
    e(i, 6, 7)
}
function q$(i) {
    const e = i.split(":");
    let t = null;
    if (e[0] === "data" && e.length === 2) {
        const n = e[1].split(";")
          , s = n[n.length - 1].split(",");
        if (s.length === 2) {
            const r = s[0] === "base64"
              , o = s[1];
            r ? (n.splice(-1, 1),
            t = J_(o)) : t = G$(o)
        }
    }
    return t
}
function N1(i) {
    return Uint8Array.from(unescape(encodeURIComponent(i)), e => e.charCodeAt(0))
}
const lu = typeof self < "u" ? self : void 0;
var Rn = {
    CLEARKEY: "org.w3.clearkey",
    FAIRPLAY: "com.apple.fps",
    PLAYREADY: "com.microsoft.playready",
    WIDEVINE: "com.widevine.alpha"
}
  , ns = {
    CLEARKEY: "org.w3.clearkey",
    FAIRPLAY: "com.apple.streamingkeydelivery",
    PLAYREADY: "com.microsoft.playready",
    WIDEVINE: "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed"
};
function Db(i) {
    switch (i) {
    case ns.FAIRPLAY:
        return Rn.FAIRPLAY;
    case ns.PLAYREADY:
        return Rn.PLAYREADY;
    case ns.WIDEVINE:
        return Rn.WIDEVINE;
    case ns.CLEARKEY:
        return Rn.CLEARKEY
    }
}
var Yu = {
    CENC: "1077efecc0b24d02ace33c1e52e2fb4b",
    CLEARKEY: "e2719d58a985b3c9781ab030af78d30e",
    FAIRPLAY: "94ce86fb07ff4f43adb893d2fa968ca2",
    PLAYREADY: "9a04f07998404286ab92e65be0885f95",
    WIDEVINE: "edef8ba979d64acea3c827dcd51d21ed"
};
function Fb(i) {
    if (i === Yu.WIDEVINE)
        return Rn.WIDEVINE;
    if (i === Yu.PLAYREADY)
        return Rn.PLAYREADY;
    if (i === Yu.CENC || i === Yu.CLEARKEY)
        return Rn.CLEARKEY
}
function Ob(i) {
    switch (i) {
    case Rn.FAIRPLAY:
        return ns.FAIRPLAY;
    case Rn.PLAYREADY:
        return ns.PLAYREADY;
    case Rn.WIDEVINE:
        return ns.WIDEVINE;
    case Rn.CLEARKEY:
        return ns.CLEARKEY
    }
}
function b0(i) {
    const {drmSystems: e, widevineLicenseUrl: t} = i
      , n = e ? [Rn.FAIRPLAY, Rn.WIDEVINE, Rn.PLAYREADY, Rn.CLEARKEY].filter(s => !!e[s]) : [];
    return !n[Rn.WIDEVINE] && t && n.push(Rn.WIDEVINE),
    n
}
const VC = function(i) {
    return lu != null && (i = lu.navigator) != null && i.requestMediaKeySystemAccess ? self.navigator.requestMediaKeySystemAccess.bind(self.navigator) : null
}();
function j$(i, e, t, n) {
    let s;
    switch (i) {
    case Rn.FAIRPLAY:
        s = ["cenc", "sinf"];
        break;
    case Rn.WIDEVINE:
    case Rn.PLAYREADY:
        s = ["cenc"];
        break;
    case Rn.CLEARKEY:
        s = ["cenc", "keyids"];
        break;
    default:
        throw new Error(`Unknown key-system: ${i}`)
    }
    return K$(s, e, t, n)
}
function K$(i, e, t, n) {
    return [{
        initDataTypes: i,
        persistentState: n.persistentState || "optional",
        distinctiveIdentifier: n.distinctiveIdentifier || "optional",
        sessionTypes: n.sessionTypes || [n.sessionType || "temporary"],
        audioCapabilities: e.map(r => ({
            contentType: `audio/mp4; codecs="${r}"`,
            robustness: n.audioRobustness || "",
            encryptionScheme: n.audioEncryptionScheme || null
        })),
        videoCapabilities: t.map(r => ({
            contentType: `video/mp4; codecs="${r}"`,
            robustness: n.videoRobustness || "",
            encryptionScheme: n.videoEncryptionScheme || null
        }))
    }]
}
function Sl(i, e, t) {
    return Uint8Array.prototype.slice ? i.slice(e, t) : new Uint8Array(Array.prototype.slice.call(i, e, t))
}
const Q_ = (i, e) => e + 10 <= i.length && i[e] === 73 && i[e + 1] === 68 && i[e + 2] === 51 && i[e + 3] < 255 && i[e + 4] < 255 && i[e + 6] < 128 && i[e + 7] < 128 && i[e + 8] < 128 && i[e + 9] < 128
  , $C = (i, e) => e + 10 <= i.length && i[e] === 51 && i[e + 1] === 68 && i[e + 2] === 73 && i[e + 3] < 255 && i[e + 4] < 255 && i[e + 6] < 128 && i[e + 7] < 128 && i[e + 8] < 128 && i[e + 9] < 128
  , Fd = (i, e) => {
    const t = e;
    let n = 0;
    for (; Q_(i, e); ) {
        n += 10;
        const s = Am(i, e + 6);
        n += s,
        $C(i, e + 10) && (n += 10),
        e += n
    }
    if (n > 0)
        return i.subarray(t, t + n)
}
  , Am = (i, e) => {
    let t = 0;
    return t = (i[e] & 127) << 21,
    t |= (i[e + 1] & 127) << 14,
    t |= (i[e + 2] & 127) << 7,
    t |= i[e + 3] & 127,
    t
}
  , X$ = (i, e) => Q_(i, e) && Am(i, e + 6) + 10 <= i.length - e
  , ex = i => {
    const e = zC(i);
    for (let t = 0; t < e.length; t++) {
        const n = e[t];
        if (HC(n))
            return tH(n)
    }
}
  , HC = i => i && i.key === "PRIV" && i.info === "com.apple.streaming.transportStreamTimestamp"
  , Y$ = i => {
    const e = String.fromCharCode(i[0], i[1], i[2], i[3])
      , t = Am(i, 4)
      , n = 10;
    return {
        type: e,
        size: t,
        data: i.subarray(n, n + t)
    }
}
  , zC = i => {
    let e = 0;
    const t = [];
    for (; Q_(i, e); ) {
        const n = Am(i, e + 6);
        e += 10;
        const s = e + n;
        for (; e + 8 < s; ) {
            const r = Y$(i.subarray(e))
              , o = Z$(r);
            o && t.push(o),
            e += r.size + 10
        }
        $C(i, e) && (e += 10)
    }
    return t
}
  , Z$ = i => i.type === "PRIV" ? J$(i) : i.type[0] === "W" ? eH(i) : Q$(i)
  , J$ = i => {
    if (i.size < 2)
        return;
    const e = Hr(i.data, !0)
      , t = new Uint8Array(i.data.subarray(e.length + 1));
    return {
        key: i.type,
        info: e,
        data: t.buffer
    }
}
  , Q$ = i => {
    if (i.size < 2)
        return;
    if (i.type === "TXXX") {
        let t = 1;
        const n = Hr(i.data.subarray(t), !0);
        t += n.length + 1;
        const s = Hr(i.data.subarray(t));
        return {
            key: i.type,
            info: n,
            data: s
        }
    }
    const e = Hr(i.data.subarray(1));
    return {
        key: i.type,
        data: e
    }
}
  , eH = i => {
    if (i.type === "WXXX") {
        if (i.size < 2)
            return;
        let t = 1;
        const n = Hr(i.data.subarray(t), !0);
        t += n.length + 1;
        const s = Hr(i.data.subarray(t));
        return {
            key: i.type,
            info: n,
            data: s
        }
    }
    const e = Hr(i.data);
    return {
        key: i.type,
        data: e
    }
}
  , tH = i => {
    if (i.data.byteLength === 8) {
        const e = new Uint8Array(i.data)
          , t = e[3] & 1;
        let n = (e[4] << 23) + (e[5] << 15) + (e[6] << 7) + e[7];
        return n /= 45,
        t && (n += 4772185884e-2),
        Math.round(n)
    }
}
  , Hr = (i, e=!1) => {
    const t = nH();
    if (t) {
        const c = t.decode(i);
        if (e) {
            const u = c.indexOf("\0");
            return u !== -1 ? c.substring(0, u) : c
        }
        return c.replace(/\0/g, "")
    }
    const n = i.length;
    let s, r, o, a = "", l = 0;
    for (; l < n; ) {
        if (s = i[l++],
        s === 0 && e)
            return a;
        if (s === 0 || s === 3)
            continue;
        switch (s >> 4) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
            a += String.fromCharCode(s);
            break;
        case 12:
        case 13:
            r = i[l++],
            a += String.fromCharCode((s & 31) << 6 | r & 63);
            break;
        case 14:
            r = i[l++],
            o = i[l++],
            a += String.fromCharCode((s & 15) << 12 | (r & 63) << 6 | (o & 63) << 0);
            break
        }
    }
    return a
}
;
let S0;
function nH() {
    if (!navigator.userAgent.includes("PlayStation 4"))
        return !S0 && typeof self.TextDecoder < "u" && (S0 = new self.TextDecoder("utf-8")),
        S0
}
const Rr = {
    hexDump: function(i) {
        let e = "";
        for (let t = 0; t < i.length; t++) {
            let n = i[t].toString(16);
            n.length < 2 && (n = "0" + n),
            e += n
        }
        return e
    }
}
  , Tp = Math.pow(2, 32) - 1
  , iH = [].push
  , GC = {
    video: 1,
    audio: 2,
    id3: 3,
    text: 4
};
function ii(i) {
    return String.fromCharCode.apply(null, i)
}
function WC(i, e) {
    const t = i[e] << 8 | i[e + 1];
    return t < 0 ? 65536 + t : t
}
function At(i, e) {
    const t = qC(i, e);
    return t < 0 ? 4294967296 + t : t
}
function Ub(i, e) {
    let t = At(i, e);
    return t *= Math.pow(2, 32),
    t += At(i, e + 4),
    t
}
function qC(i, e) {
    return i[e] << 24 | i[e + 1] << 16 | i[e + 2] << 8 | i[e + 3]
}
function E0(i, e, t) {
    i[e] = t >> 24,
    i[e + 1] = t >> 16 & 255,
    i[e + 2] = t >> 8 & 255,
    i[e + 3] = t & 255
}
function sH(i) {
    const e = i.byteLength;
    for (let t = 0; t < e; ) {
        const n = At(i, t);
        if (n > 8 && i[t + 4] === 109 && i[t + 5] === 111 && i[t + 6] === 111 && i[t + 7] === 102)
            return !0;
        t = n > 1 ? t + n : e
    }
    return !1
}
function $t(i, e) {
    const t = [];
    if (!e.length)
        return t;
    const n = i.byteLength;
    for (let s = 0; s < n; ) {
        const r = At(i, s)
          , o = ii(i.subarray(s + 4, s + 8))
          , a = r > 1 ? s + r : n;
        if (o === e[0])
            if (e.length === 1)
                t.push(i.subarray(s + 8, a));
            else {
                const l = $t(i.subarray(s + 8, a), e.slice(1));
                l.length && iH.apply(t, l)
            }
        s = a
    }
    return t
}
function rH(i) {
    const e = []
      , t = i[0];
    let n = 8;
    const s = At(i, n);
    n += 4;
    let r = 0
      , o = 0;
    t === 0 ? (r = At(i, n),
    o = At(i, n + 4),
    n += 8) : (r = Ub(i, n),
    o = Ub(i, n + 8),
    n += 16),
    n += 2;
    let a = i.length + o;
    const l = WC(i, n);
    n += 2;
    for (let c = 0; c < l; c++) {
        let u = n;
        const d = At(i, u);
        u += 4;
        const f = d & 2147483647;
        if ((d & 2147483648) >>> 31 === 1)
            return de.warn("SIDX has hierarchical references (not supported)"),
            null;
        const p = At(i, u);
        u += 4,
        e.push({
            referenceSize: f,
            subsegmentDuration: p,
            info: {
                duration: p / s,
                start: a,
                end: a + f - 1
            }
        }),
        a += f,
        u += 4,
        n = u
    }
    return {
        earliestPresentationTime: r,
        timescale: s,
        version: t,
        referencesCount: l,
        references: e
    }
}
function jC(i) {
    const e = []
      , t = $t(i, ["moov", "trak"]);
    for (let s = 0; s < t.length; s++) {
        const r = t[s]
          , o = $t(r, ["tkhd"])[0];
        if (o) {
            let a = o[0];
            const l = At(o, a === 0 ? 12 : 20)
              , c = $t(r, ["mdia", "mdhd"])[0];
            if (c) {
                a = c[0];
                const u = At(c, a === 0 ? 12 : 20)
                  , d = $t(r, ["mdia", "hdlr"])[0];
                if (d) {
                    const f = ii(d.subarray(8, 12))
                      , h = {
                        soun: gn.AUDIO,
                        vide: gn.VIDEO
                    }[f];
                    if (h) {
                        const p = $t(r, ["mdia", "minf", "stbl", "stsd"])[0]
                          , g = oH(p);
                        e[l] = {
                            timescale: u,
                            type: h
                        },
                        e[h] = yi({
                            timescale: u,
                            id: l
                        }, g)
                    }
                }
            }
        }
    }
    return $t(i, ["moov", "mvex", "trex"]).forEach(s => {
        const r = At(s, 4)
          , o = e[r];
        o && (o.default = {
            duration: At(s, 12),
            flags: At(s, 20)
        })
    }
    ),
    e
}
function oH(i) {
    const e = i.subarray(8)
      , t = e.subarray(8 + 78)
      , n = ii(e.subarray(4, 8));
    let s = n;
    const r = n === "enca" || n === "encv";
    if (r) {
        const a = $t(e, [n])[0].subarray(n === "enca" ? 28 : 78);
        $t(a, ["sinf"]).forEach(c => {
            const u = $t(c, ["schm"])[0];
            if (u) {
                const d = ii(u.subarray(4, 8));
                if (d === "cbcs" || d === "cenc") {
                    const f = $t(c, ["frma"])[0];
                    f && (s = ii(f))
                }
            }
        }
        )
    }
    switch (s) {
    case "avc1":
    case "avc2":
    case "avc3":
    case "avc4":
        {
            const o = $t(t, ["avcC"])[0];
            s += "." + kf(o[1]) + kf(o[2]) + kf(o[3]);
            break
        }
    case "mp4a":
        {
            const o = $t(e, [n])[0]
              , a = $t(o.subarray(28), ["esds"])[0];
            if (a && a.length > 12) {
                let l = 4;
                if (a[l++] !== 3)
                    break;
                l = w0(a, l),
                l += 2;
                const c = a[l++];
                if (c & 128 && (l += 2),
                c & 64 && (l += a[l++]),
                a[l++] !== 4)
                    break;
                l = w0(a, l);
                const u = a[l++];
                if (u === 64)
                    s += "." + kf(u);
                else
                    break;
                if (l += 12,
                a[l++] !== 5)
                    break;
                l = w0(a, l);
                const d = a[l++];
                let f = (d & 248) >> 3;
                f === 31 && (f += 1 + ((d & 7) << 3) + ((a[l] & 224) >> 5)),
                s += "." + f
            }
            break
        }
    case "hvc1":
    case "hev1":
        {
            const o = $t(t, ["hvcC"])[0]
              , a = o[1]
              , l = ["", "A", "B", "C"][a >> 6]
              , c = a & 31
              , u = At(o, 2)
              , d = (a & 32) >> 5 ? "H" : "L"
              , f = o[12]
              , h = o.subarray(6, 12);
            s += "." + l + c,
            s += "." + u.toString(16).toUpperCase(),
            s += "." + d + f;
            let p = "";
            for (let g = h.length; g--; ) {
                const m = h[g];
                (m || p) && (p = "." + m.toString(16).toUpperCase() + p)
            }
            s += p;
            break
        }
    case "dvh1":
    case "dvhe":
        {
            const o = $t(t, ["dvcC"])[0]
              , a = o[2] >> 1 & 127
              , l = o[2] << 5 & 32 | o[3] >> 3 & 31;
            s += "." + Tr(a) + "." + Tr(l);
            break
        }
    case "vp09":
        {
            const o = $t(t, ["vpcC"])[0]
              , a = o[4]
              , l = o[5]
              , c = o[6] >> 4 & 15;
            s += "." + Tr(a) + "." + Tr(l) + "." + Tr(c);
            break
        }
    case "av01":
        {
            const o = $t(t, ["av1C"])[0]
              , a = o[1] >>> 5
              , l = o[1] & 31
              , c = o[2] >>> 7 ? "H" : "M"
              , u = (o[2] & 64) >> 6
              , d = (o[2] & 32) >> 5
              , f = a === 2 && u ? d ? 12 : 10 : u ? 10 : 8
              , h = (o[2] & 16) >> 4
              , p = (o[2] & 8) >> 3
              , g = (o[2] & 4) >> 2
              , m = o[2] & 3
              , v = 1
              , _ = 1
              , y = 1
              , b = 0;
            s += "." + a + "." + Tr(l) + c + "." + Tr(f) + "." + h + "." + p + g + m + "." + Tr(v) + "." + Tr(_) + "." + Tr(y) + "." + b;
            break
        }
    }
    return {
        codec: s,
        encrypted: r
    }
}
function w0(i, e) {
    const t = e + 5;
    for (; i[e++] & 128 && e < t; )
        ;
    return e
}
function kf(i) {
    return ("0" + i.toString(16).toUpperCase()).slice(-2)
}
function Tr(i) {
    return (i < 10 ? "0" : "") + i
}
function aH(i, e) {
    if (!i || !e)
        return i;
    const t = e.keyId;
    return t && e.isCommonEncryption && $t(i, ["moov", "trak"]).forEach(s => {
        const o = $t(s, ["mdia", "minf", "stbl", "stsd"])[0].subarray(8);
        let a = $t(o, ["enca"]);
        const l = a.length > 0;
        l || (a = $t(o, ["encv"])),
        a.forEach(c => {
            const u = l ? c.subarray(28) : c.subarray(78);
            $t(u, ["sinf"]).forEach(f => {
                const h = KC(f);
                if (h) {
                    const p = h.subarray(8, 24);
                    p.some(g => g !== 0) || (de.log(`[eme] Patching keyId in 'enc${l ? "a" : "v"}>sinf>>tenc' box: ${Rr.hexDump(p)} -> ${Rr.hexDump(t)}`),
                    h.set(t, 8))
                }
            }
            )
        }
        )
    }
    ),
    i
}
function KC(i) {
    const e = $t(i, ["schm"])[0];
    if (e) {
        const t = ii(e.subarray(4, 8));
        if (t === "cbcs" || t === "cenc")
            return $t(i, ["schi", "tenc"])[0]
    }
    return null
}
function lH(i, e) {
    return $t(e, ["moof", "traf"]).reduce( (t, n) => {
        const s = $t(n, ["tfdt"])[0]
          , r = s[0]
          , o = $t(n, ["tfhd"]).reduce( (a, l) => {
            const c = At(l, 4)
              , u = i[c];
            if (u) {
                let d = At(s, 4);
                if (r === 1) {
                    if (d === Tp)
                        return de.warn("[mp4-demuxer]: Ignoring assumed invalid signed 64-bit track fragment decode time"),
                        a;
                    d *= Tp + 1,
                    d += At(s, 8)
                }
                const f = u.timescale || 9e4
                  , h = d / f;
                if (pt(h) && (a === null || h < a))
                    return h
            }
            return a
        }
        , null);
        return o !== null && pt(o) && (t === null || o < t) ? o : t
    }
    , null)
}
function cH(i, e) {
    let t = 0
      , n = 0
      , s = 0;
    const r = $t(i, ["moof", "traf"]);
    for (let o = 0; o < r.length; o++) {
        const a = r[o]
          , l = $t(a, ["tfhd"])[0]
          , c = At(l, 4)
          , u = e[c];
        if (!u)
            continue;
        const d = u.default
          , f = At(l, 0) | (d == null ? void 0 : d.flags);
        let h = d == null ? void 0 : d.duration;
        f & 8 && (f & 2 ? h = At(l, 12) : h = At(l, 8));
        const p = u.timescale || 9e4
          , g = $t(a, ["trun"]);
        for (let m = 0; m < g.length; m++) {
            if (t = uH(g[m]),
            !t && h) {
                const v = At(g[m], 4);
                t = h * v
            }
            u.type === gn.VIDEO ? n += t / p : u.type === gn.AUDIO && (s += t / p)
        }
    }
    if (n === 0 && s === 0) {
        let o = 1 / 0
          , a = 0
          , l = 0;
        const c = $t(i, ["sidx"]);
        for (let u = 0; u < c.length; u++) {
            const d = rH(c[u]);
            if (d != null && d.references) {
                o = Math.min(o, d.earliestPresentationTime / d.timescale);
                const f = d.references.reduce( (h, p) => h + p.info.duration || 0, 0);
                a = Math.max(a, f + d.earliestPresentationTime / d.timescale),
                l = a - o
            }
        }
        if (l && pt(l))
            return l
    }
    return n || s
}
function uH(i) {
    const e = At(i, 0);
    let t = 8;
    e & 1 && (t += 4),
    e & 4 && (t += 4);
    let n = 0;
    const s = At(i, 4);
    for (let r = 0; r < s; r++) {
        if (e & 256) {
            const o = At(i, t);
            n += o,
            t += 4
        }
        e & 512 && (t += 4),
        e & 1024 && (t += 4),
        e & 2048 && (t += 4)
    }
    return n
}
function dH(i, e, t) {
    $t(e, ["moof", "traf"]).forEach(n => {
        $t(n, ["tfhd"]).forEach(s => {
            const r = At(s, 4)
              , o = i[r];
            if (!o)
                return;
            const a = o.timescale || 9e4;
            $t(n, ["tfdt"]).forEach(l => {
                const c = l[0]
                  , u = t * a;
                if (u) {
                    let d = At(l, 4);
                    if (c === 0)
                        d -= u,
                        d = Math.max(d, 0),
                        E0(l, 4, d);
                    else {
                        d *= Math.pow(2, 32),
                        d += At(l, 8),
                        d -= u,
                        d = Math.max(d, 0);
                        const f = Math.floor(d / (Tp + 1))
                          , h = Math.floor(d % (Tp + 1));
                        E0(l, 4, f),
                        E0(l, 8, h)
                    }
                }
            }
            )
        }
        )
    }
    )
}
function fH(i) {
    const e = {
        valid: null,
        remainder: null
    }
      , t = $t(i, ["moof"]);
    if (t.length < 2)
        return e.remainder = i,
        e;
    const n = t[t.length - 1];
    return e.valid = Sl(i, 0, n.byteOffset - 8),
    e.remainder = Sl(i, n.byteOffset - 8),
    e
}
function qs(i, e) {
    const t = new Uint8Array(i.length + e.length);
    return t.set(i),
    t.set(e, i.length),
    t
}
function Nb(i, e) {
    const t = []
      , n = e.samples
      , s = e.timescale
      , r = e.id;
    let o = !1;
    return $t(n, ["moof"]).map(l => {
        const c = l.byteOffset - 8;
        $t(l, ["traf"]).map(d => {
            const f = $t(d, ["tfdt"]).map(h => {
                const p = h[0];
                let g = At(h, 4);
                return p === 1 && (g *= Math.pow(2, 32),
                g += At(h, 8)),
                g / s
            }
            )[0];
            return f !== void 0 && (i = f),
            $t(d, ["tfhd"]).map(h => {
                const p = At(h, 4)
                  , g = At(h, 0) & 16777215
                  , m = (g & 1) !== 0
                  , v = (g & 2) !== 0
                  , _ = (g & 8) !== 0;
                let y = 0;
                const b = (g & 16) !== 0;
                let S = 0;
                const C = (g & 32) !== 0;
                let M = 8;
                p === r && (m && (M += 8),
                v && (M += 4),
                _ && (y = At(h, M),
                M += 4),
                b && (S = At(h, M),
                M += 4),
                C && (M += 4),
                e.type === "video" && (o = hH(e.codec)),
                $t(d, ["trun"]).map(L => {
                    const T = L[0]
                      , A = At(L, 0) & 16777215
                      , k = (A & 1) !== 0;
                    let D = 0;
                    const F = (A & 4) !== 0
                      , z = (A & 256) !== 0;
                    let G = 0;
                    const H = (A & 512) !== 0;
                    let X = 0;
                    const K = (A & 1024) !== 0
                      , ce = (A & 2048) !== 0;
                    let ue = 0;
                    const Ie = At(L, 4);
                    let ke = 8;
                    k && (D = At(L, ke),
                    ke += 4),
                    F && (ke += 4);
                    let We = D + c;
                    for (let se = 0; se < Ie; se++) {
                        if (z ? (G = At(L, ke),
                        ke += 4) : G = y,
                        H ? (X = At(L, ke),
                        ke += 4) : X = S,
                        K && (ke += 4),
                        ce && (T === 0 ? ue = At(L, ke) : ue = qC(L, ke),
                        ke += 4),
                        e.type === gn.VIDEO) {
                            let Se = 0;
                            for (; Se < X; ) {
                                const be = At(n, We);
                                if (We += 4,
                                pH(o, n[We])) {
                                    const q = n.subarray(We, We + be);
                                    XC(q, o ? 2 : 1, i + ue / s, t)
                                }
                                We += be,
                                Se += be + 4
                            }
                        }
                        i += G / s
                    }
                }
                ))
            }
            )
        }
        )
    }
    ),
    t
}
function hH(i) {
    if (!i)
        return !1;
    const e = i.indexOf(".")
      , t = e < 0 ? i : i.substring(0, e);
    return t === "hvc1" || t === "hev1" || t === "dvh1" || t === "dvhe"
}
function pH(i, e) {
    if (i) {
        const t = e >> 1 & 63;
        return t === 39 || t === 40
    } else
        return (e & 31) === 6
}
function XC(i, e, t, n) {
    const s = YC(i);
    let r = 0;
    r += e;
    let o = 0
      , a = 0
      , l = 0;
    for (; r < s.length; ) {
        o = 0;
        do {
            if (r >= s.length)
                break;
            l = s[r++],
            o += l
        } while (l === 255);
        a = 0;
        do {
            if (r >= s.length)
                break;
            l = s[r++],
            a += l
        } while (l === 255);
        const c = s.length - r;
        let u = r;
        if (a < c)
            r += a;
        else if (a > c) {
            de.error(`Malformed SEI payload. ${a} is too small, only ${c} bytes left to parse.`);
            break
        }
        if (o === 4) {
            if (s[u++] === 181) {
                const f = WC(s, u);
                if (u += 2,
                f === 49) {
                    const h = At(s, u);
                    if (u += 4,
                    h === 1195456820) {
                        const p = s[u++];
                        if (p === 3) {
                            const g = s[u++]
                              , m = 31 & g
                              , v = 64 & g
                              , _ = v ? 2 + m * 3 : 0
                              , y = new Uint8Array(_);
                            if (v) {
                                y[0] = g;
                                for (let b = 1; b < _; b++)
                                    y[b] = s[u++]
                            }
                            n.push({
                                type: p,
                                payloadType: o,
                                pts: t,
                                bytes: y
                            })
                        }
                    }
                }
            }
        } else if (o === 5 && a > 16) {
            const d = [];
            for (let p = 0; p < 16; p++) {
                const g = s[u++].toString(16);
                d.push(g.length == 1 ? "0" + g : g),
                (p === 3 || p === 5 || p === 7 || p === 9) && d.push("-")
            }
            const f = a - 16
              , h = new Uint8Array(f);
            for (let p = 0; p < f; p++)
                h[p] = s[u++];
            n.push({
                payloadType: o,
                pts: t,
                uuid: d.join(""),
                userData: Hr(h),
                userDataBytes: h
            })
        }
    }
}
function YC(i) {
    const e = i.byteLength
      , t = [];
    let n = 1;
    for (; n < e - 2; )
        i[n] === 0 && i[n + 1] === 0 && i[n + 2] === 3 ? (t.push(n + 2),
        n += 2) : n++;
    if (t.length === 0)
        return i;
    const s = e - t.length
      , r = new Uint8Array(s);
    let o = 0;
    for (n = 0; n < s; o++,
    n++)
        o === t[0] && (o++,
        t.shift()),
        r[n] = i[o];
    return r
}
function mH(i) {
    const e = i[0];
    let t = ""
      , n = ""
      , s = 0
      , r = 0
      , o = 0
      , a = 0
      , l = 0
      , c = 0;
    if (e === 0) {
        for (; ii(i.subarray(c, c + 1)) !== "\0"; )
            t += ii(i.subarray(c, c + 1)),
            c += 1;
        for (t += ii(i.subarray(c, c + 1)),
        c += 1; ii(i.subarray(c, c + 1)) !== "\0"; )
            n += ii(i.subarray(c, c + 1)),
            c += 1;
        n += ii(i.subarray(c, c + 1)),
        c += 1,
        s = At(i, 12),
        r = At(i, 16),
        a = At(i, 20),
        l = At(i, 24),
        c = 28
    } else if (e === 1) {
        c += 4,
        s = At(i, c),
        c += 4;
        const d = At(i, c);
        c += 4;
        const f = At(i, c);
        for (c += 4,
        o = 2 ** 32 * d + f,
        P$(o) || (o = Number.MAX_SAFE_INTEGER,
        de.warn("Presentation time exceeds safe integer limit and wrapped to max safe integer in parsing emsg box")),
        a = At(i, c),
        c += 4,
        l = At(i, c),
        c += 4; ii(i.subarray(c, c + 1)) !== "\0"; )
            t += ii(i.subarray(c, c + 1)),
            c += 1;
        for (t += ii(i.subarray(c, c + 1)),
        c += 1; ii(i.subarray(c, c + 1)) !== "\0"; )
            n += ii(i.subarray(c, c + 1)),
            c += 1;
        n += ii(i.subarray(c, c + 1)),
        c += 1
    }
    const u = i.subarray(c, i.byteLength);
    return {
        schemeIdUri: t,
        value: n,
        timeScale: s,
        presentationTime: o,
        presentationTimeDelta: r,
        eventDuration: a,
        id: l,
        payload: u
    }
}
function gH(i, ...e) {
    const t = e.length;
    let n = 8
      , s = t;
    for (; s--; )
        n += e[s].byteLength;
    const r = new Uint8Array(n);
    for (r[0] = n >> 24 & 255,
    r[1] = n >> 16 & 255,
    r[2] = n >> 8 & 255,
    r[3] = n & 255,
    r.set(i, 4),
    s = 0,
    n = 8; s < t; s++)
        r.set(e[s], n),
        n += e[s].byteLength;
    return r
}
function vH(i, e, t) {
    if (i.byteLength !== 16)
        throw new RangeError("Invalid system id");
    let n, s;
    if (e) {
        n = 1,
        s = new Uint8Array(e.length * 16);
        for (let a = 0; a < e.length; a++) {
            const l = e[a];
            if (l.byteLength !== 16)
                throw new RangeError("Invalid key");
            s.set(l, a * 16)
        }
    } else
        n = 0,
        s = new Uint8Array;
    let r;
    n > 0 ? (r = new Uint8Array(4),
    e.length > 0 && new DataView(r.buffer).setUint32(0, e.length, !1)) : r = new Uint8Array;
    const o = new Uint8Array(4);
    return t && t.byteLength > 0 && new DataView(o.buffer).setUint32(0, t.byteLength, !1),
    gH([112, 115, 115, 104], new Uint8Array([n, 0, 0, 0]), i, r, s, o, t || new Uint8Array)
}
function _H(i) {
    const e = [];
    if (i instanceof ArrayBuffer) {
        const t = i.byteLength;
        let n = 0;
        for (; n + 32 < t; ) {
            const s = new DataView(i,n)
              , r = xH(s);
            e.push(r),
            n += r.size
        }
    }
    return e
}
function xH(i) {
    const e = i.getUint32(0)
      , t = i.byteOffset
      , n = i.byteLength;
    if (n < e)
        return {
            offset: t,
            size: n
        };
    if (i.getUint32(4) !== 1886614376)
        return {
            offset: t,
            size: e
        };
    const r = i.getUint32(8) >>> 24;
    if (r !== 0 && r !== 1)
        return {
            offset: t,
            size: e
        };
    const o = i.buffer
      , a = Rr.hexDump(new Uint8Array(o,t + 12,16))
      , l = i.getUint32(28);
    let c = null
      , u = null;
    if (r === 0) {
        if (e - 32 < l || l < 22)
            return {
                offset: t,
                size: e
            };
        u = new Uint8Array(o,t + 32,l)
    } else if (r === 1) {
        if (!l || n < t + 32 + l * 16 + 16)
            return {
                offset: t,
                size: e
            };
        c = [];
        for (let d = 0; d < l; d++)
            c.push(new Uint8Array(o,t + 32 + d * 16,16))
    }
    return {
        version: r,
        systemId: a,
        kids: c,
        data: u,
        offset: t,
        size: e
    }
}
let Pf = {};
class Od {
    static clearKeyUriToKeyIdMap() {
        Pf = {}
    }
    constructor(e, t, n, s=[1], r=null) {
        this.uri = void 0,
        this.method = void 0,
        this.keyFormat = void 0,
        this.keyFormatVersions = void 0,
        this.encrypted = void 0,
        this.isCommonEncryption = void 0,
        this.iv = null,
        this.key = null,
        this.keyId = null,
        this.pssh = null,
        this.method = e,
        this.uri = t,
        this.keyFormat = n,
        this.keyFormatVersions = s,
        this.iv = r,
        this.encrypted = e ? e !== "NONE" : !1,
        this.isCommonEncryption = this.encrypted && e !== "AES-128"
    }
    isSupported() {
        if (this.method) {
            if (this.method === "AES-128" || this.method === "NONE")
                return !0;
            if (this.keyFormat === "identity")
                return this.method === "SAMPLE-AES";
            switch (this.keyFormat) {
            case ns.FAIRPLAY:
            case ns.WIDEVINE:
            case ns.PLAYREADY:
            case ns.CLEARKEY:
                return ["ISO-23001-7", "SAMPLE-AES", "SAMPLE-AES-CENC", "SAMPLE-AES-CTR"].indexOf(this.method) !== -1
            }
        }
        return !1
    }
    getDecryptData(e) {
        if (!this.encrypted || !this.uri)
            return null;
        if (this.method === "AES-128" && this.uri && !this.iv) {
            typeof e != "number" && (this.method === "AES-128" && !this.iv && de.warn(`missing IV for initialization segment with method="${this.method}" - compliance issue`),
            e = 0);
            const n = yH(e);
            return new Od(this.method,this.uri,"identity",this.keyFormatVersions,n)
        }
        const t = q$(this.uri);
        if (t)
            switch (this.keyFormat) {
            case ns.WIDEVINE:
                this.pssh = t,
                t.length >= 22 && (this.keyId = t.subarray(t.length - 22, t.length - 6));
                break;
            case ns.PLAYREADY:
                {
                    const n = new Uint8Array([154, 4, 240, 121, 152, 64, 66, 134, 171, 146, 230, 91, 224, 136, 95, 149]);
                    this.pssh = vH(n, null, t);
                    const s = new Uint16Array(t.buffer,t.byteOffset,t.byteLength / 2)
                      , r = String.fromCharCode.apply(null, Array.from(s))
                      , o = r.substring(r.indexOf("<"), r.length)
                      , c = new DOMParser().parseFromString(o, "text/xml").getElementsByTagName("KID")[0];
                    if (c) {
                        const u = c.childNodes[0] ? c.childNodes[0].nodeValue : c.getAttribute("VALUE");
                        if (u) {
                            const d = J_(u).subarray(0, 16);
                            W$(d),
                            this.keyId = d
                        }
                    }
                    break
                }
            default:
                {
                    let n = t.subarray(0, 16);
                    if (n.length !== 16) {
                        const s = new Uint8Array(16);
                        s.set(n, 16 - n.length),
                        n = s
                    }
                    this.keyId = n;
                    break
                }
            }
        if (!this.keyId || this.keyId.byteLength !== 16) {
            let n = Pf[this.uri];
            if (!n) {
                const s = Object.keys(Pf).length % Number.MAX_SAFE_INTEGER;
                n = new Uint8Array(16),
                new DataView(n.buffer,12,4).setUint32(0, s),
                Pf[this.uri] = n
            }
            this.keyId = n
        }
        return this
    }
}
function yH(i) {
    const e = new Uint8Array(16);
    for (let t = 12; t < 16; t++)
        e[t] = i >> 8 * (15 - t) & 255;
    return e
}
const ZC = /\{\$([a-zA-Z0-9-_]+)\}/g;
function Bb(i) {
    return ZC.test(i)
}
function Qi(i, e, t) {
    if (i.variableList !== null || i.hasVariableRefs)
        for (let n = t.length; n--; ) {
            const s = t[n]
              , r = e[s];
            r && (e[s] = B1(i, r))
        }
}
function B1(i, e) {
    if (i.variableList !== null || i.hasVariableRefs) {
        const t = i.variableList;
        return e.replace(ZC, n => {
            const s = n.substring(2, n.length - 1)
              , r = t == null ? void 0 : t[s];
            return r === void 0 ? (i.playlistParsingError || (i.playlistParsingError = new Error(`Missing preceding EXT-X-DEFINE tag for Variable Reference: "${s}"`)),
            n) : r
        }
        )
    }
    return e
}
function Vb(i, e, t) {
    let n = i.variableList;
    n || (i.variableList = n = {});
    let s, r;
    if ("QUERYPARAM"in e) {
        s = e.QUERYPARAM;
        try {
            const o = new self.URL(t).searchParams;
            if (o.has(s))
                r = o.get(s);
            else
                throw new Error(`"${s}" does not match any query parameter in URI: "${t}"`)
        } catch (o) {
            i.playlistParsingError || (i.playlistParsingError = new Error(`EXT-X-DEFINE QUERYPARAM: ${o.message}`))
        }
    } else
        s = e.NAME,
        r = e.VALUE;
    s in n ? i.playlistParsingError || (i.playlistParsingError = new Error(`EXT-X-DEFINE duplicate Variable Name declarations: "${s}"`)) : n[s] = r || ""
}
function bH(i, e, t) {
    const n = e.IMPORT;
    if (t && n in t) {
        let s = i.variableList;
        s || (i.variableList = s = {}),
        s[n] = t[n]
    } else
        i.playlistParsingError || (i.playlistParsingError = new Error(`EXT-X-DEFINE IMPORT attribute not found in Multivariant Playlist: "${n}"`))
}
function kl(i=!0) {
    return typeof self > "u" ? void 0 : (i || !self.MediaSource) && self.ManagedMediaSource || self.MediaSource || self.WebKitMediaSource
}
function SH(i) {
    return typeof self < "u" && i === self.ManagedMediaSource
}
const Ap = {
    audio: {
        a3ds: 1,
        "ac-3": .95,
        "ac-4": 1,
        alac: .9,
        alaw: 1,
        dra1: 1,
        "dts+": 1,
        "dts-": 1,
        dtsc: 1,
        dtse: 1,
        dtsh: 1,
        "ec-3": .9,
        enca: 1,
        fLaC: .9,
        flac: .9,
        FLAC: .9,
        g719: 1,
        g726: 1,
        m4ae: 1,
        mha1: 1,
        mha2: 1,
        mhm1: 1,
        mhm2: 1,
        mlpa: 1,
        mp4a: 1,
        "raw ": 1,
        Opus: 1,
        opus: 1,
        samr: 1,
        sawb: 1,
        sawp: 1,
        sevc: 1,
        sqcp: 1,
        ssmv: 1,
        twos: 1,
        ulaw: 1
    },
    video: {
        avc1: 1,
        avc2: 1,
        avc3: 1,
        avc4: 1,
        avcp: 1,
        av01: .8,
        drac: 1,
        dva1: 1,
        dvav: 1,
        dvh1: .7,
        dvhe: .7,
        encv: 1,
        hev1: .75,
        hvc1: .75,
        mjp2: 1,
        mp4v: 1,
        mvc1: 1,
        mvc2: 1,
        mvc3: 1,
        mvc4: 1,
        resv: 1,
        rv60: 1,
        s263: 1,
        svc1: 1,
        svc2: 1,
        "vc-1": 1,
        vp08: 1,
        vp09: .9
    },
    text: {
        stpp: 1,
        wvtt: 1
    }
};
function EH(i, e) {
    const t = Ap[e];
    return !!t && !!t[i.slice(0, 4)]
}
function T0(i, e, t=!0) {
    return !i.split(",").some(n => !JC(n, e, t))
}
function JC(i, e, t=!0) {
    var n;
    const s = kl(t);
    return (n = s == null ? void 0 : s.isTypeSupported(Ud(i, e))) != null ? n : !1
}
function Ud(i, e) {
    return `${e}/mp4;codecs="${i}"`
}
function $b(i) {
    if (i) {
        const e = i.substring(0, 4);
        return Ap.video[e]
    }
    return 2
}
function Cp(i) {
    return i.split(",").reduce( (e, t) => {
        const n = Ap.video[t];
        return n ? (n * 2 + e) / (e ? 3 : 2) : (Ap.audio[t] + e) / (e ? 2 : 1)
    }
    , 0)
}
const A0 = {};
function wH(i, e=!0) {
    if (A0[i])
        return A0[i];
    const t = {
        flac: ["flac", "fLaC", "FLAC"],
        opus: ["opus", "Opus"]
    }[i];
    for (let n = 0; n < t.length; n++)
        if (JC(t[n], "audio", e))
            return A0[i] = t[n],
            t[n];
    return i
}
const TH = /flac|opus/i;
function Mp(i, e=!0) {
    return i.replace(TH, t => wH(t.toLowerCase(), e))
}
function Hb(i, e) {
    return i && i !== "mp4a" ? i : e && e.split(",")[0]
}
function AH(i) {
    const e = i.split(",");
    for (let t = 0; t < e.length; t++) {
        const n = e[t].split(".");
        if (n.length > 2) {
            let s = n.shift() + ".";
            s += parseInt(n.shift()).toString(16),
            s += ("000" + parseInt(n.shift()).toString(16)).slice(-4),
            e[t] = s
        }
    }
    return e.join(",")
}
const zb = /#EXT-X-STREAM-INF:([^\r\n]*)(?:[\r\n](?:#[^\r\n]*)?)*([^\r\n]+)|#EXT-X-(SESSION-DATA|SESSION-KEY|DEFINE|CONTENT-STEERING|START):([^\r\n]*)[\r\n]+/g
  , Gb = /#EXT-X-MEDIA:(.*)/g
  , CH = /^#EXT(?:INF|-X-TARGETDURATION):/m
  , Wb = new RegExp([/#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source, /(?!#) *(\S[^\r\n]*)/.source, /#EXT-X-BYTERANGE:*(.+)/.source, /#EXT-X-PROGRAM-DATE-TIME:(.+)/.source, /#.*/.source].join("|"),"g")
  , MH = new RegExp([/#(EXTM3U)/.source, /#EXT-X-(DATERANGE|DEFINE|KEY|MAP|PART|PART-INF|PLAYLIST-TYPE|PRELOAD-HINT|RENDITION-REPORT|SERVER-CONTROL|SKIP|START):(.+)/.source, /#EXT-X-(BITRATE|DISCONTINUITY-SEQUENCE|MEDIA-SEQUENCE|TARGETDURATION|VERSION): *(\d+)/.source, /#EXT-X-(DISCONTINUITY|ENDLIST|GAP|INDEPENDENT-SEGMENTS)/.source, /(#)([^:]*):(.*)/.source, /(#)(.*)(?:.*)\r?\n?/.source].join("|"));
class Ur {
    static findGroup(e, t) {
        for (let n = 0; n < e.length; n++) {
            const s = e[n];
            if (s.id === t)
                return s
        }
    }
    static resolve(e, t) {
        return Z_.buildAbsoluteURL(t, e, {
            alwaysNormalize: !0
        })
    }
    static isMediaPlaylist(e) {
        return CH.test(e)
    }
    static parseMasterPlaylist(e, t) {
        const n = Bb(e)
          , s = {
            contentSteering: null,
            levels: [],
            playlistParsingError: null,
            sessionData: null,
            sessionKeys: null,
            startTimeOffset: null,
            variableList: null,
            hasVariableRefs: n
        }
          , r = [];
        zb.lastIndex = 0;
        let o;
        for (; (o = zb.exec(e)) != null; )
            if (o[1]) {
                var a;
                const c = new Un(o[1]);
                Qi(s, c, ["CODECS", "SUPPLEMENTAL-CODECS", "ALLOWED-CPC", "PATHWAY-ID", "STABLE-VARIANT-ID", "AUDIO", "VIDEO", "SUBTITLES", "CLOSED-CAPTIONS", "NAME"]);
                const u = B1(s, o[2])
                  , d = {
                    attrs: c,
                    bitrate: c.decimalInteger("BANDWIDTH") || c.decimalInteger("AVERAGE-BANDWIDTH"),
                    name: c.NAME,
                    url: Ur.resolve(u, t)
                }
                  , f = c.decimalResolution("RESOLUTION");
                f && (d.width = f.width,
                d.height = f.height),
                RH(c.CODECS, d),
                (a = d.unknownCodecs) != null && a.length || r.push(d),
                s.levels.push(d)
            } else if (o[3]) {
                const c = o[3]
                  , u = o[4];
                switch (c) {
                case "SESSION-DATA":
                    {
                        const d = new Un(u);
                        Qi(s, d, ["DATA-ID", "LANGUAGE", "VALUE", "URI"]);
                        const f = d["DATA-ID"];
                        f && (s.sessionData === null && (s.sessionData = {}),
                        s.sessionData[f] = d);
                        break
                    }
                case "SESSION-KEY":
                    {
                        const d = qb(u, t, s);
                        d.encrypted && d.isSupported() ? (s.sessionKeys === null && (s.sessionKeys = []),
                        s.sessionKeys.push(d)) : de.warn(`[Keys] Ignoring invalid EXT-X-SESSION-KEY tag: "${u}"`);
                        break
                    }
                case "DEFINE":
                    {
                        {
                            const d = new Un(u);
                            Qi(s, d, ["NAME", "VALUE", "QUERYPARAM"]),
                            Vb(s, d, t)
                        }
                        break
                    }
                case "CONTENT-STEERING":
                    {
                        const d = new Un(u);
                        Qi(s, d, ["SERVER-URI", "PATHWAY-ID"]),
                        s.contentSteering = {
                            uri: Ur.resolve(d["SERVER-URI"], t),
                            pathwayId: d["PATHWAY-ID"] || "."
                        };
                        break
                    }
                case "START":
                    {
                        s.startTimeOffset = jb(u);
                        break
                    }
                }
            }
        const l = r.length > 0 && r.length < s.levels.length;
        return s.levels = l ? r : s.levels,
        s.levels.length === 0 && (s.playlistParsingError = new Error("no levels found in manifest")),
        s
    }
    static parseMasterPlaylistMedia(e, t, n) {
        let s;
        const r = {}
          , o = n.levels
          , a = {
            AUDIO: o.map(c => ({
                id: c.attrs.AUDIO,
                audioCodec: c.audioCodec
            })),
            SUBTITLES: o.map(c => ({
                id: c.attrs.SUBTITLES,
                textCodec: c.textCodec
            })),
            "CLOSED-CAPTIONS": []
        };
        let l = 0;
        for (Gb.lastIndex = 0; (s = Gb.exec(e)) !== null; ) {
            const c = new Un(s[1])
              , u = c.TYPE;
            if (u) {
                const d = a[u]
                  , f = r[u] || [];
                r[u] = f,
                Qi(n, c, ["URI", "GROUP-ID", "LANGUAGE", "ASSOC-LANGUAGE", "STABLE-RENDITION-ID", "NAME", "INSTREAM-ID", "CHARACTERISTICS", "CHANNELS"]);
                const h = c.LANGUAGE
                  , p = c["ASSOC-LANGUAGE"]
                  , g = c.CHANNELS
                  , m = c.CHARACTERISTICS
                  , v = c["INSTREAM-ID"]
                  , _ = {
                    attrs: c,
                    bitrate: 0,
                    id: l++,
                    groupId: c["GROUP-ID"] || "",
                    name: c.NAME || h || "",
                    type: u,
                    default: c.bool("DEFAULT"),
                    autoselect: c.bool("AUTOSELECT"),
                    forced: c.bool("FORCED"),
                    lang: h,
                    url: c.URI ? Ur.resolve(c.URI, t) : ""
                };
                if (p && (_.assocLang = p),
                g && (_.channels = g),
                m && (_.characteristics = m),
                v && (_.instreamId = v),
                d != null && d.length) {
                    const y = Ur.findGroup(d, _.groupId) || d[0];
                    Kb(_, y, "audioCodec"),
                    Kb(_, y, "textCodec")
                }
                f.push(_)
            }
        }
        return r
    }
    static parseLevelPlaylist(e, t, n, s, r, o) {
        const a = new z$(t)
          , l = a.fragments;
        let c = null, u = 0, d = 0, f = 0, h = 0, p = null, g = new y0(s,t), m, v, _, y = -1, b = !1, S = null;
        for (Wb.lastIndex = 0,
        a.m3u8 = e,
        a.hasVariableRefs = Bb(e); (m = Wb.exec(e)) !== null; ) {
            b && (b = !1,
            g = new y0(s,t),
            g.start = f,
            g.sn = u,
            g.cc = h,
            g.level = n,
            c && (g.initSegment = c,
            g.rawProgramDateTime = c.rawProgramDateTime,
            c.rawProgramDateTime = null,
            S && (g.setByteRange(S),
            S = null)));
            const T = m[1];
            if (T) {
                g.duration = parseFloat(T);
                const A = (" " + m[2]).slice(1);
                g.title = A || null,
                g.tagList.push(A ? ["INF", T, A] : ["INF", T])
            } else if (m[3]) {
                if (pt(g.duration)) {
                    g.start = f,
                    _ && Zb(g, _, a),
                    g.sn = u,
                    g.level = n,
                    g.cc = h,
                    l.push(g);
                    const A = (" " + m[3]).slice(1);
                    g.relurl = B1(a, A),
                    Xb(g, p),
                    p = g,
                    f += g.duration,
                    u++,
                    d = 0,
                    b = !0
                }
            } else if (m[4]) {
                const A = (" " + m[4]).slice(1);
                p ? g.setByteRange(A, p) : g.setByteRange(A)
            } else if (m[5])
                g.rawProgramDateTime = (" " + m[5]).slice(1),
                g.tagList.push(["PROGRAM-DATE-TIME", g.rawProgramDateTime]),
                y === -1 && (y = l.length);
            else {
                if (m = m[0].match(MH),
                !m) {
                    de.warn("No matches on slow regex match for level playlist!");
                    continue
                }
                for (v = 1; v < m.length && !(typeof m[v] < "u"); v++)
                    ;
                const A = (" " + m[v]).slice(1)
                  , k = (" " + m[v + 1]).slice(1)
                  , D = m[v + 2] ? (" " + m[v + 2]).slice(1) : "";
                switch (A) {
                case "PLAYLIST-TYPE":
                    a.type = k.toUpperCase();
                    break;
                case "MEDIA-SEQUENCE":
                    u = a.startSN = parseInt(k);
                    break;
                case "SKIP":
                    {
                        const F = new Un(k);
                        Qi(a, F, ["RECENTLY-REMOVED-DATERANGES"]);
                        const z = F.decimalInteger("SKIPPED-SEGMENTS");
                        if (pt(z)) {
                            a.skippedSegments = z;
                            for (let H = z; H--; )
                                l.unshift(null);
                            u += z
                        }
                        const G = F.enumeratedString("RECENTLY-REMOVED-DATERANGES");
                        G && (a.recentlyRemovedDateranges = G.split("	"));
                        break
                    }
                case "TARGETDURATION":
                    a.targetduration = Math.max(parseInt(k), 1);
                    break;
                case "VERSION":
                    a.version = parseInt(k);
                    break;
                case "INDEPENDENT-SEGMENTS":
                case "EXTM3U":
                    break;
                case "ENDLIST":
                    a.live = !1;
                    break;
                case "#":
                    (k || D) && g.tagList.push(D ? [k, D] : [k]);
                    break;
                case "DISCONTINUITY":
                    h++,
                    g.tagList.push(["DIS"]);
                    break;
                case "GAP":
                    g.gap = !0,
                    g.tagList.push([A]);
                    break;
                case "BITRATE":
                    g.tagList.push([A, k]);
                    break;
                case "DATERANGE":
                    {
                        const F = new Un(k);
                        Qi(a, F, ["ID", "CLASS", "START-DATE", "END-DATE", "SCTE35-CMD", "SCTE35-OUT", "SCTE35-IN"]),
                        Qi(a, F, F.clientAttrs);
                        const z = new NC(F,a.dateRanges[F.ID]);
                        z.isValid || a.skippedSegments ? a.dateRanges[z.id] = z : de.warn(`Ignoring invalid DATERANGE tag: "${k}"`),
                        g.tagList.push(["EXT-X-DATERANGE", k]);
                        break
                    }
                case "DEFINE":
                    {
                        {
                            const F = new Un(k);
                            Qi(a, F, ["NAME", "VALUE", "IMPORT", "QUERYPARAM"]),
                            "IMPORT"in F ? bH(a, F, o) : Vb(a, F, t)
                        }
                        break
                    }
                case "DISCONTINUITY-SEQUENCE":
                    h = parseInt(k);
                    break;
                case "KEY":
                    {
                        const F = qb(k, t, a);
                        if (F.isSupported()) {
                            if (F.method === "NONE") {
                                _ = void 0;
                                break
                            }
                            _ || (_ = {}),
                            _[F.keyFormat] && (_ = Qn({}, _)),
                            _[F.keyFormat] = F
                        } else
                            de.warn(`[Keys] Ignoring invalid EXT-X-KEY tag: "${k}"`);
                        break
                    }
                case "START":
                    a.startTimeOffset = jb(k);
                    break;
                case "MAP":
                    {
                        const F = new Un(k);
                        if (Qi(a, F, ["BYTERANGE", "URI"]),
                        g.duration) {
                            const z = new y0(s,t);
                            Yb(z, F, n, _),
                            c = z,
                            g.initSegment = c,
                            c.rawProgramDateTime && !g.rawProgramDateTime && (g.rawProgramDateTime = c.rawProgramDateTime)
                        } else {
                            const z = g.byteRangeEndOffset;
                            if (z) {
                                const G = g.byteRangeStartOffset;
                                S = `${z - G}@${G}`
                            } else
                                S = null;
                            Yb(g, F, n, _),
                            c = g,
                            b = !0
                        }
                        break
                    }
                case "SERVER-CONTROL":
                    {
                        const F = new Un(k);
                        a.canBlockReload = F.bool("CAN-BLOCK-RELOAD"),
                        a.canSkipUntil = F.optionalFloat("CAN-SKIP-UNTIL", 0),
                        a.canSkipDateRanges = a.canSkipUntil > 0 && F.bool("CAN-SKIP-DATERANGES"),
                        a.partHoldBack = F.optionalFloat("PART-HOLD-BACK", 0),
                        a.holdBack = F.optionalFloat("HOLD-BACK", 0);
                        break
                    }
                case "PART-INF":
                    {
                        const F = new Un(k);
                        a.partTarget = F.decimalFloatingPoint("PART-TARGET");
                        break
                    }
                case "PART":
                    {
                        let F = a.partList;
                        F || (F = a.partList = []);
                        const z = d > 0 ? F[F.length - 1] : void 0
                          , G = d++
                          , H = new Un(k);
                        Qi(a, H, ["BYTERANGE", "URI"]);
                        const X = new $$(H,g,t,G,z);
                        F.push(X),
                        g.duration += X.duration;
                        break
                    }
                case "PRELOAD-HINT":
                    {
                        const F = new Un(k);
                        Qi(a, F, ["URI"]),
                        a.preloadHint = F;
                        break
                    }
                case "RENDITION-REPORT":
                    {
                        const F = new Un(k);
                        Qi(a, F, ["URI"]),
                        a.renditionReports = a.renditionReports || [],
                        a.renditionReports.push(F);
                        break
                    }
                default:
                    de.warn(`line parsed but not handled: ${m}`);
                    break
                }
            }
        }
        p && !p.relurl ? (l.pop(),
        f -= p.duration,
        a.partList && (a.fragmentHint = p)) : a.partList && (Xb(g, p),
        g.cc = h,
        a.fragmentHint = g,
        _ && Zb(g, _, a));
        const C = l.length
          , M = l[0]
          , L = l[C - 1];
        if (f += a.skippedSegments * a.targetduration,
        f > 0 && C && L) {
            a.averagetargetduration = f / C;
            const T = L.sn;
            a.endSN = T !== "initSegment" ? T : 0,
            a.live || (L.endList = !0),
            M && (a.startCC = M.cc)
        } else
            a.endSN = 0,
            a.startCC = 0;
        return a.fragmentHint && (f += a.fragmentHint.duration),
        a.totalduration = f,
        a.endCC = h,
        y > 0 && LH(l, y),
        a
    }
}
function qb(i, e, t) {
    var n, s;
    const r = new Un(i);
    Qi(t, r, ["KEYFORMAT", "KEYFORMATVERSIONS", "URI", "IV", "URI"]);
    const o = (n = r.METHOD) != null ? n : ""
      , a = r.URI
      , l = r.hexadecimalInteger("IV")
      , c = r.KEYFORMATVERSIONS
      , u = (s = r.KEYFORMAT) != null ? s : "identity";
    a && r.IV && !l && de.error(`Invalid IV: ${r.IV}`);
    const d = a ? Ur.resolve(a, e) : ""
      , f = (c || "1").split("/").map(Number).filter(Number.isFinite);
    return new Od(o,d,u,f,l)
}
function jb(i) {
    const t = new Un(i).decimalFloatingPoint("TIME-OFFSET");
    return pt(t) ? t : null
}
function RH(i, e) {
    let t = (i || "").split(/[ ,]+/).filter(n => n);
    ["video", "audio", "text"].forEach(n => {
        const s = t.filter(r => EH(r, n));
        s.length && (e[`${n}Codec`] = s.join(","),
        t = t.filter(r => s.indexOf(r) === -1))
    }
    ),
    e.unknownCodecs = t
}
function Kb(i, e, t) {
    const n = e[t];
    n && (i[t] = n)
}
function LH(i, e) {
    let t = i[e];
    for (let n = e; n--; ) {
        const s = i[n];
        if (!s)
            return;
        s.programDateTime = t.programDateTime - s.duration * 1e3,
        t = s
    }
}
function Xb(i, e) {
    i.rawProgramDateTime ? i.programDateTime = Date.parse(i.rawProgramDateTime) : e != null && e.programDateTime && (i.programDateTime = e.endProgramDateTime),
    pt(i.programDateTime) || (i.programDateTime = null,
    i.rawProgramDateTime = null)
}
function Yb(i, e, t, n) {
    i.relurl = e.URI,
    e.BYTERANGE && i.setByteRange(e.BYTERANGE),
    i.level = t,
    i.sn = "initSegment",
    n && (i.levelkeys = n),
    i.initSegment = null
}
function Zb(i, e, t) {
    i.levelkeys = e;
    const {encryptedFragments: n} = t;
    (!n.length || n[n.length - 1].levelkeys !== e) && Object.keys(e).some(s => e[s].isCommonEncryption) && n.push(i)
}
var en = {
    MANIFEST: "manifest",
    LEVEL: "level",
    AUDIO_TRACK: "audioTrack",
    SUBTITLE_TRACK: "subtitleTrack"
}
  , Ct = {
    MAIN: "main",
    AUDIO: "audio",
    SUBTITLE: "subtitle"
};
function Jb(i) {
    const {type: e} = i;
    switch (e) {
    case en.AUDIO_TRACK:
        return Ct.AUDIO;
    case en.SUBTITLE_TRACK:
        return Ct.SUBTITLE;
    default:
        return Ct.MAIN
    }
}
function C0(i, e) {
    let t = i.url;
    return (t === void 0 || t.indexOf("data:") === 0) && (t = e.url),
    t
}
class IH {
    constructor(e) {
        this.hls = void 0,
        this.loaders = Object.create(null),
        this.variableList = null,
        this.hls = e,
        this.registerListeners()
    }
    startLoad(e) {}
    stopLoad() {
        this.destroyInternalLoaders()
    }
    registerListeners() {
        const {hls: e} = this;
        e.on(P.MANIFEST_LOADING, this.onManifestLoading, this),
        e.on(P.LEVEL_LOADING, this.onLevelLoading, this),
        e.on(P.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this),
        e.on(P.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this)
    }
    unregisterListeners() {
        const {hls: e} = this;
        e.off(P.MANIFEST_LOADING, this.onManifestLoading, this),
        e.off(P.LEVEL_LOADING, this.onLevelLoading, this),
        e.off(P.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this),
        e.off(P.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this)
    }
    createInternalLoader(e) {
        const t = this.hls.config
          , n = t.pLoader
          , s = t.loader
          , r = n || s
          , o = new r(t);
        return this.loaders[e.type] = o,
        o
    }
    getInternalLoader(e) {
        return this.loaders[e.type]
    }
    resetInternalLoader(e) {
        this.loaders[e] && delete this.loaders[e]
    }
    destroyInternalLoaders() {
        for (const e in this.loaders) {
            const t = this.loaders[e];
            t && t.destroy(),
            this.resetInternalLoader(e)
        }
    }
    destroy() {
        this.variableList = null,
        this.unregisterListeners(),
        this.destroyInternalLoaders()
    }
    onManifestLoading(e, t) {
        const {url: n} = t;
        this.variableList = null,
        this.load({
            id: null,
            level: 0,
            responseType: "text",
            type: en.MANIFEST,
            url: n,
            deliveryDirectives: null
        })
    }
    onLevelLoading(e, t) {
        const {id: n, level: s, pathwayId: r, url: o, deliveryDirectives: a} = t;
        this.load({
            id: n,
            level: s,
            pathwayId: r,
            responseType: "text",
            type: en.LEVEL,
            url: o,
            deliveryDirectives: a
        })
    }
    onAudioTrackLoading(e, t) {
        const {id: n, groupId: s, url: r, deliveryDirectives: o} = t;
        this.load({
            id: n,
            groupId: s,
            level: null,
            responseType: "text",
            type: en.AUDIO_TRACK,
            url: r,
            deliveryDirectives: o
        })
    }
    onSubtitleTrackLoading(e, t) {
        const {id: n, groupId: s, url: r, deliveryDirectives: o} = t;
        this.load({
            id: n,
            groupId: s,
            level: null,
            responseType: "text",
            type: en.SUBTITLE_TRACK,
            url: r,
            deliveryDirectives: o
        })
    }
    load(e) {
        var t;
        const n = this.hls.config;
        let s = this.getInternalLoader(e);
        if (s) {
            const c = s.context;
            if (c && c.url === e.url && c.level === e.level) {
                de.trace("[playlist-loader]: playlist request ongoing");
                return
            }
            de.log(`[playlist-loader]: aborting previous loader for type: ${e.type}`),
            s.abort()
        }
        let r;
        if (e.type === en.MANIFEST ? r = n.manifestLoadPolicy.default : r = Qn({}, n.playlistLoadPolicy.default, {
            timeoutRetry: null,
            errorRetry: null
        }),
        s = this.createInternalLoader(e),
        pt((t = e.deliveryDirectives) == null ? void 0 : t.part)) {
            let c;
            if (e.type === en.LEVEL && e.level !== null ? c = this.hls.levels[e.level].details : e.type === en.AUDIO_TRACK && e.id !== null ? c = this.hls.audioTracks[e.id].details : e.type === en.SUBTITLE_TRACK && e.id !== null && (c = this.hls.subtitleTracks[e.id].details),
            c) {
                const u = c.partTarget
                  , d = c.targetduration;
                if (u && d) {
                    const f = Math.max(u * 3, d * .8) * 1e3;
                    r = Qn({}, r, {
                        maxTimeToFirstByteMs: Math.min(f, r.maxTimeToFirstByteMs),
                        maxLoadTimeMs: Math.min(f, r.maxTimeToFirstByteMs)
                    })
                }
            }
        }
        const o = r.errorRetry || r.timeoutRetry || {}
          , a = {
            loadPolicy: r,
            timeout: r.maxLoadTimeMs,
            maxRetry: o.maxNumRetry || 0,
            retryDelay: o.retryDelayMs || 0,
            maxRetryDelay: o.maxRetryDelayMs || 0
        }
          , l = {
            onSuccess: (c, u, d, f) => {
                const h = this.getInternalLoader(d);
                this.resetInternalLoader(d.type);
                const p = c.data;
                if (p.indexOf("#EXTM3U") !== 0) {
                    this.handleManifestParsingError(c, d, new Error("no EXTM3U delimiter"), f || null, u);
                    return
                }
                u.parsing.start = performance.now(),
                Ur.isMediaPlaylist(p) ? this.handleTrackOrLevelPlaylist(c, u, d, f || null, h) : this.handleMasterPlaylist(c, u, d, f)
            }
            ,
            onError: (c, u, d, f) => {
                this.handleNetworkError(u, d, !1, c, f)
            }
            ,
            onTimeout: (c, u, d) => {
                this.handleNetworkError(u, d, !0, void 0, c)
            }
        };
        s.load(e, a, l)
    }
    handleMasterPlaylist(e, t, n, s) {
        const r = this.hls
          , o = e.data
          , a = C0(e, n)
          , l = Ur.parseMasterPlaylist(o, a);
        if (l.playlistParsingError) {
            this.handleManifestParsingError(e, n, l.playlistParsingError, s, t);
            return
        }
        const {contentSteering: c, levels: u, sessionData: d, sessionKeys: f, startTimeOffset: h, variableList: p} = l;
        this.variableList = p;
        const {AUDIO: g=[], SUBTITLES: m, "CLOSED-CAPTIONS": v} = Ur.parseMasterPlaylistMedia(o, a, l);
        g.length && !g.some(y => !y.url) && u[0].audioCodec && !u[0].attrs.AUDIO && (de.log("[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one"),
        g.unshift({
            type: "main",
            name: "main",
            groupId: "main",
            default: !1,
            autoselect: !1,
            forced: !1,
            id: -1,
            attrs: new Un({}),
            bitrate: 0,
            url: ""
        })),
        r.trigger(P.MANIFEST_LOADED, {
            levels: u,
            audioTracks: g,
            subtitles: m,
            captions: v,
            contentSteering: c,
            url: a,
            stats: t,
            networkDetails: s,
            sessionData: d,
            sessionKeys: f,
            startTimeOffset: h,
            variableList: p
        })
    }
    handleTrackOrLevelPlaylist(e, t, n, s, r) {
        const o = this.hls
          , {id: a, level: l, type: c} = n
          , u = C0(e, n)
          , d = 0
          , f = pt(l) ? l : pt(a) ? a : 0
          , h = Jb(n)
          , p = Ur.parseLevelPlaylist(e.data, u, f, h, d, this.variableList);
        if (c === en.MANIFEST) {
            const g = {
                attrs: new Un({}),
                bitrate: 0,
                details: p,
                name: "",
                url: u
            };
            o.trigger(P.MANIFEST_LOADED, {
                levels: [g],
                audioTracks: [],
                url: u,
                stats: t,
                networkDetails: s,
                sessionData: null,
                sessionKeys: null,
                contentSteering: null,
                startTimeOffset: null,
                variableList: null
            })
        }
        t.parsing.end = performance.now(),
        n.levelDetails = p,
        this.handlePlaylistLoaded(p, e, t, n, s, r)
    }
    handleManifestParsingError(e, t, n, s, r) {
        this.hls.trigger(P.ERROR, {
            type: Ut.NETWORK_ERROR,
            details: Ae.MANIFEST_PARSING_ERROR,
            fatal: t.type === en.MANIFEST,
            url: e.url,
            err: n,
            error: n,
            reason: n.message,
            response: e,
            context: t,
            networkDetails: s,
            stats: r
        })
    }
    handleNetworkError(e, t, n=!1, s, r) {
        let o = `A network ${n ? "timeout" : "error" + (s ? " (status " + s.code + ")" : "")} occurred while loading ${e.type}`;
        e.type === en.LEVEL ? o += `: ${e.level} id: ${e.id}` : (e.type === en.AUDIO_TRACK || e.type === en.SUBTITLE_TRACK) && (o += ` id: ${e.id} group-id: "${e.groupId}"`);
        const a = new Error(o);
        de.warn(`[playlist-loader]: ${o}`);
        let l = Ae.UNKNOWN
          , c = !1;
        const u = this.getInternalLoader(e);
        switch (e.type) {
        case en.MANIFEST:
            l = n ? Ae.MANIFEST_LOAD_TIMEOUT : Ae.MANIFEST_LOAD_ERROR,
            c = !0;
            break;
        case en.LEVEL:
            l = n ? Ae.LEVEL_LOAD_TIMEOUT : Ae.LEVEL_LOAD_ERROR,
            c = !1;
            break;
        case en.AUDIO_TRACK:
            l = n ? Ae.AUDIO_TRACK_LOAD_TIMEOUT : Ae.AUDIO_TRACK_LOAD_ERROR,
            c = !1;
            break;
        case en.SUBTITLE_TRACK:
            l = n ? Ae.SUBTITLE_TRACK_LOAD_TIMEOUT : Ae.SUBTITLE_LOAD_ERROR,
            c = !1;
            break
        }
        u && this.resetInternalLoader(e.type);
        const d = {
            type: Ut.NETWORK_ERROR,
            details: l,
            fatal: c,
            url: e.url,
            loader: u,
            context: e,
            error: a,
            networkDetails: t,
            stats: r
        };
        if (s) {
            const f = (t == null ? void 0 : t.url) || e.url;
            d.response = yi({
                url: f,
                data: void 0
            }, s)
        }
        this.hls.trigger(P.ERROR, d)
    }
    handlePlaylistLoaded(e, t, n, s, r, o) {
        const a = this.hls
          , {type: l, level: c, id: u, groupId: d, deliveryDirectives: f} = s
          , h = C0(t, s)
          , p = Jb(s)
          , g = typeof s.level == "number" && p === Ct.MAIN ? c : void 0;
        if (!e.fragments.length) {
            const v = new Error("No Segments found in Playlist");
            a.trigger(P.ERROR, {
                type: Ut.NETWORK_ERROR,
                details: Ae.LEVEL_EMPTY_ERROR,
                fatal: !1,
                url: h,
                error: v,
                reason: v.message,
                response: t,
                context: s,
                level: g,
                parent: p,
                networkDetails: r,
                stats: n
            });
            return
        }
        e.targetduration || (e.playlistParsingError = new Error("Missing Target Duration"));
        const m = e.playlistParsingError;
        if (m) {
            a.trigger(P.ERROR, {
                type: Ut.NETWORK_ERROR,
                details: Ae.LEVEL_PARSING_ERROR,
                fatal: !1,
                url: h,
                error: m,
                reason: m.message,
                response: t,
                context: s,
                level: g,
                parent: p,
                networkDetails: r,
                stats: n
            });
            return
        }
        switch (e.live && o && (o.getCacheAge && (e.ageHeader = o.getCacheAge() || 0),
        (!o.getCacheAge || isNaN(e.ageHeader)) && (e.ageHeader = 0)),
        l) {
        case en.MANIFEST:
        case en.LEVEL:
            a.trigger(P.LEVEL_LOADED, {
                details: e,
                level: g || 0,
                id: u || 0,
                stats: n,
                networkDetails: r,
                deliveryDirectives: f
            });
            break;
        case en.AUDIO_TRACK:
            a.trigger(P.AUDIO_TRACK_LOADED, {
                details: e,
                id: u || 0,
                groupId: d || "",
                stats: n,
                networkDetails: r,
                deliveryDirectives: f
            });
            break;
        case en.SUBTITLE_TRACK:
            a.trigger(P.SUBTITLE_TRACK_LOADED, {
                details: e,
                id: u || 0,
                groupId: d || "",
                stats: n,
                networkDetails: r,
                deliveryDirectives: f
            });
            break
        }
    }
}
function QC(i, e) {
    let t;
    try {
        t = new Event("addtrack")
    } catch {
        t = document.createEvent("Event"),
        t.initEvent("addtrack", !1, !1)
    }
    t.track = i,
    e.dispatchEvent(t)
}
function eM(i, e) {
    const t = i.mode;
    if (t === "disabled" && (i.mode = "hidden"),
    i.cues && !i.cues.getCueById(e.id))
        try {
            if (i.addCue(e),
            !i.cues.getCueById(e.id))
                throw new Error(`addCue is failed for: ${e}`)
        } catch (n) {
            de.debug(`[texttrack-utils]: ${n}`);
            try {
                const s = new self.TextTrackCue(e.startTime,e.endTime,e.text);
                s.id = e.id,
                i.addCue(s)
            } catch (s) {
                de.debug(`[texttrack-utils]: Legacy TextTrackCue fallback failed: ${s}`)
            }
        }
    t === "disabled" && (i.mode = t)
}
function Ac(i) {
    const e = i.mode;
    if (e === "disabled" && (i.mode = "hidden"),
    i.cues)
        for (let t = i.cues.length; t--; )
            i.removeCue(i.cues[t]);
    e === "disabled" && (i.mode = e)
}
function V1(i, e, t, n) {
    const s = i.mode;
    if (s === "disabled" && (i.mode = "hidden"),
    i.cues && i.cues.length > 0) {
        const r = PH(i.cues, e, t);
        for (let o = 0; o < r.length; o++)
            (!n || n(r[o])) && i.removeCue(r[o])
    }
    s === "disabled" && (i.mode = s)
}
function kH(i, e) {
    if (e < i[0].startTime)
        return 0;
    const t = i.length - 1;
    if (e > i[t].endTime)
        return -1;
    let n = 0
      , s = t;
    for (; n <= s; ) {
        const r = Math.floor((s + n) / 2);
        if (e < i[r].startTime)
            s = r - 1;
        else if (e > i[r].startTime && n < t)
            n = r + 1;
        else
            return r
    }
    return i[n].startTime - e < e - i[s].startTime ? n : s
}
function PH(i, e, t) {
    const n = []
      , s = kH(i, e);
    if (s > -1)
        for (let r = s, o = i.length; r < o; r++) {
            const a = i[r];
            if (a.startTime >= e && a.endTime <= t)
                n.push(a);
            else if (a.startTime > t)
                return n
        }
    return n
}
function Ch(i) {
    const e = [];
    for (let t = 0; t < i.length; t++) {
        const n = i[t];
        (n.kind === "subtitles" || n.kind === "captions") && n.label && e.push(i[t])
    }
    return e
}
var or = {
    audioId3: "org.id3",
    dateRange: "com.apple.quicktime.HLS",
    emsg: "https://aomedia.org/emsg/ID3"
};
const DH = .25;
function $1() {
    if (!(typeof self > "u"))
        return self.VTTCue || self.TextTrackCue
}
function Qb(i, e, t, n, s) {
    let r = new i(e,t,"");
    try {
        r.value = n,
        s && (r.type = s)
    } catch {
        r = new i(e,t,JSON.stringify(s ? yi({
            type: s
        }, n) : n))
    }
    return r
}
const Df = ( () => {
    const i = $1();
    try {
        i && new i(0,Number.POSITIVE_INFINITY,"")
    } catch {
        return Number.MAX_VALUE
    }
    return Number.POSITIVE_INFINITY
}
)();
function M0(i, e) {
    return i.getTime() / 1e3 - e
}
function FH(i) {
    return Uint8Array.from(i.replace(/^0x/, "").replace(/([\da-fA-F]{2}) ?/g, "0x$1 ").replace(/ +$/, "").split(" ")).buffer
}
class OH {
    constructor(e) {
        this.hls = void 0,
        this.id3Track = null,
        this.media = null,
        this.dateRangeCuesAppended = {},
        this.hls = e,
        this._registerListeners()
    }
    destroy() {
        this._unregisterListeners(),
        this.id3Track = null,
        this.media = null,
        this.dateRangeCuesAppended = {},
        this.hls = null
    }
    _registerListeners() {
        const {hls: e} = this;
        e.on(P.MEDIA_ATTACHED, this.onMediaAttached, this),
        e.on(P.MEDIA_DETACHING, this.onMediaDetaching, this),
        e.on(P.MANIFEST_LOADING, this.onManifestLoading, this),
        e.on(P.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this),
        e.on(P.BUFFER_FLUSHING, this.onBufferFlushing, this),
        e.on(P.LEVEL_UPDATED, this.onLevelUpdated, this)
    }
    _unregisterListeners() {
        const {hls: e} = this;
        e.off(P.MEDIA_ATTACHED, this.onMediaAttached, this),
        e.off(P.MEDIA_DETACHING, this.onMediaDetaching, this),
        e.off(P.MANIFEST_LOADING, this.onManifestLoading, this),
        e.off(P.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this),
        e.off(P.BUFFER_FLUSHING, this.onBufferFlushing, this),
        e.off(P.LEVEL_UPDATED, this.onLevelUpdated, this)
    }
    onMediaAttached(e, t) {
        this.media = t.media
    }
    onMediaDetaching() {
        !this.id3Track || (Ac(this.id3Track),
        this.id3Track = null,
        this.media = null,
        this.dateRangeCuesAppended = {})
    }
    onManifestLoading() {
        this.dateRangeCuesAppended = {}
    }
    createTrack(e) {
        const t = this.getID3Track(e.textTracks);
        return t.mode = "hidden",
        t
    }
    getID3Track(e) {
        if (!!this.media) {
            for (let t = 0; t < e.length; t++) {
                const n = e[t];
                if (n.kind === "metadata" && n.label === "id3")
                    return QC(n, this.media),
                    n
            }
            return this.media.addTextTrack("metadata", "id3")
        }
    }
    onFragParsingMetadata(e, t) {
        if (!this.media)
            return;
        const {hls: {config: {enableEmsgMetadataCues: n, enableID3MetadataCues: s}}} = this;
        if (!n && !s)
            return;
        const {samples: r} = t;
        this.id3Track || (this.id3Track = this.createTrack(this.media));
        const o = $1();
        if (!!o)
            for (let a = 0; a < r.length; a++) {
                const l = r[a].type;
                if (l === or.emsg && !n || !s)
                    continue;
                const c = zC(r[a].data);
                if (c) {
                    const u = r[a].pts;
                    let d = u + r[a].duration;
                    d > Df && (d = Df),
                    d - u <= 0 && (d = u + DH);
                    for (let h = 0; h < c.length; h++) {
                        const p = c[h];
                        if (!HC(p)) {
                            this.updateId3CueEnds(u, l);
                            const g = Qb(o, u, d, p, l);
                            g && this.id3Track.addCue(g)
                        }
                    }
                }
            }
    }
    updateId3CueEnds(e, t) {
        var n;
        const s = (n = this.id3Track) == null ? void 0 : n.cues;
        if (s)
            for (let r = s.length; r--; ) {
                const o = s[r];
                o.type === t && o.startTime < e && o.endTime === Df && (o.endTime = e)
            }
    }
    onBufferFlushing(e, {startOffset: t, endOffset: n, type: s}) {
        const {id3Track: r, hls: o} = this;
        if (!o)
            return;
        const {config: {enableEmsgMetadataCues: a, enableID3MetadataCues: l}} = o;
        if (r && (a || l)) {
            let c;
            s === "audio" ? c = u => u.type === or.audioId3 && l : s === "video" ? c = u => u.type === or.emsg && a : c = u => u.type === or.audioId3 && l || u.type === or.emsg && a,
            V1(r, t, n, c)
        }
    }
    onLevelUpdated(e, {details: t}) {
        if (!this.media || !t.hasProgramDateTime || !this.hls.config.enableDateRangeMetadataCues)
            return;
        const {dateRangeCuesAppended: n, id3Track: s} = this
          , {dateRanges: r} = t
          , o = Object.keys(r);
        if (s) {
            const u = Object.keys(n).filter(d => !o.includes(d));
            for (let d = u.length; d--; ) {
                const f = u[d];
                Object.keys(n[f].cues).forEach(h => {
                    s.removeCue(n[f].cues[h])
                }
                ),
                delete n[f]
            }
        }
        const a = t.fragments[t.fragments.length - 1];
        if (o.length === 0 || !pt(a == null ? void 0 : a.programDateTime))
            return;
        this.id3Track || (this.id3Track = this.createTrack(this.media));
        const l = a.programDateTime / 1e3 - a.start
          , c = $1();
        for (let u = 0; u < o.length; u++) {
            const d = o[u]
              , f = r[d]
              , h = M0(f.startDate, l)
              , p = n[d]
              , g = (p == null ? void 0 : p.cues) || {};
            let m = (p == null ? void 0 : p.durationKnown) || !1
              , v = Df;
            const _ = f.endDate;
            if (_)
                v = M0(_, l),
                m = !0;
            else if (f.endOnNext && !m) {
                const b = o.reduce( (S, C) => {
                    if (C !== f.id) {
                        const M = r[C];
                        if (M.class === f.class && M.startDate > f.startDate && (!S || f.startDate < S.startDate))
                            return M
                    }
                    return S
                }
                , null);
                b && (v = M0(b.startDate, l),
                m = !0)
            }
            const y = Object.keys(f.attr);
            for (let b = 0; b < y.length; b++) {
                const S = y[b];
                if (!B$(S))
                    continue;
                const C = g[S];
                if (C)
                    m && !p.durationKnown && (C.endTime = v);
                else if (c) {
                    let M = f.attr[S];
                    V$(S) && (M = FH(M));
                    const L = Qb(c, h, v, {
                        key: S,
                        data: M
                    }, or.dateRange);
                    L && (L.id = d,
                    this.id3Track.addCue(L),
                    g[S] = L)
                }
            }
            n[d] = {
                cues: g,
                dateRange: f,
                durationKnown: m
            }
        }
    }
}
class UH {
    constructor(e) {
        this.hls = void 0,
        this.config = void 0,
        this.media = null,
        this.levelDetails = null,
        this.currentTime = 0,
        this.stallCount = 0,
        this._latency = null,
        this.timeupdateHandler = () => this.timeupdate(),
        this.hls = e,
        this.config = e.config,
        this.registerListeners()
    }
    get latency() {
        return this._latency || 0
    }
    get maxLatency() {
        const {config: e, levelDetails: t} = this;
        return e.liveMaxLatencyDuration !== void 0 ? e.liveMaxLatencyDuration : t ? e.liveMaxLatencyDurationCount * t.targetduration : 0
    }
    get targetLatency() {
        const {levelDetails: e} = this;
        if (e === null)
            return null;
        const {holdBack: t, partHoldBack: n, targetduration: s} = e
          , {liveSyncDuration: r, liveSyncDurationCount: o, lowLatencyMode: a} = this.config
          , l = this.hls.userConfig;
        let c = a && n || t;
        (l.liveSyncDuration || l.liveSyncDurationCount || c === 0) && (c = r !== void 0 ? r : o * s);
        const u = s
          , d = 1;
        return c + Math.min(this.stallCount * d, u)
    }
    get liveSyncPosition() {
        const e = this.estimateLiveEdge()
          , t = this.targetLatency
          , n = this.levelDetails;
        if (e === null || t === null || n === null)
            return null;
        const s = n.edge
          , r = e - t - this.edgeStalled
          , o = s - n.totalduration
          , a = s - (this.config.lowLatencyMode && n.partTarget || n.targetduration);
        return Math.min(Math.max(o, r), a)
    }
    get drift() {
        const {levelDetails: e} = this;
        return e === null ? 1 : e.drift
    }
    get edgeStalled() {
        const {levelDetails: e} = this;
        if (e === null)
            return 0;
        const t = (this.config.lowLatencyMode && e.partTarget || e.targetduration) * 3;
        return Math.max(e.age - t, 0)
    }
    get forwardBufferLength() {
        const {media: e, levelDetails: t} = this;
        if (!e || !t)
            return 0;
        const n = e.buffered.length;
        return (n ? e.buffered.end(n - 1) : t.edge) - this.currentTime
    }
    destroy() {
        this.unregisterListeners(),
        this.onMediaDetaching(),
        this.levelDetails = null,
        this.hls = this.timeupdateHandler = null
    }
    registerListeners() {
        this.hls.on(P.MEDIA_ATTACHED, this.onMediaAttached, this),
        this.hls.on(P.MEDIA_DETACHING, this.onMediaDetaching, this),
        this.hls.on(P.MANIFEST_LOADING, this.onManifestLoading, this),
        this.hls.on(P.LEVEL_UPDATED, this.onLevelUpdated, this),
        this.hls.on(P.ERROR, this.onError, this)
    }
    unregisterListeners() {
        this.hls.off(P.MEDIA_ATTACHED, this.onMediaAttached, this),
        this.hls.off(P.MEDIA_DETACHING, this.onMediaDetaching, this),
        this.hls.off(P.MANIFEST_LOADING, this.onManifestLoading, this),
        this.hls.off(P.LEVEL_UPDATED, this.onLevelUpdated, this),
        this.hls.off(P.ERROR, this.onError, this)
    }
    onMediaAttached(e, t) {
        this.media = t.media,
        this.media.addEventListener("timeupdate", this.timeupdateHandler)
    }
    onMediaDetaching() {
        this.media && (this.media.removeEventListener("timeupdate", this.timeupdateHandler),
        this.media = null)
    }
    onManifestLoading() {
        this.levelDetails = null,
        this._latency = null,
        this.stallCount = 0
    }
    onLevelUpdated(e, {details: t}) {
        this.levelDetails = t,
        t.advanced && this.timeupdate(),
        !t.live && this.media && this.media.removeEventListener("timeupdate", this.timeupdateHandler)
    }
    onError(e, t) {
        var n;
        t.details === Ae.BUFFER_STALLED_ERROR && (this.stallCount++,
        (n = this.levelDetails) != null && n.live && de.warn("[playback-rate-controller]: Stall detected, adjusting target latency"))
    }
    timeupdate() {
        const {media: e, levelDetails: t} = this;
        if (!e || !t)
            return;
        this.currentTime = e.currentTime;
        const n = this.computeLatency();
        if (n === null)
            return;
        this._latency = n;
        const {lowLatencyMode: s, maxLiveSyncPlaybackRate: r} = this.config;
        if (!s || r === 1 || !t.live)
            return;
        const o = this.targetLatency;
        if (o === null)
            return;
        const a = n - o
          , l = Math.min(this.maxLatency, o + t.targetduration);
        if (a < l && a > .05 && this.forwardBufferLength > 1) {
            const u = Math.min(2, Math.max(1, r))
              , d = Math.round(2 / (1 + Math.exp(-.75 * a - this.edgeStalled)) * 20) / 20;
            e.playbackRate = Math.min(u, Math.max(1, d))
        } else
            e.playbackRate !== 1 && e.playbackRate !== 0 && (e.playbackRate = 1)
    }
    estimateLiveEdge() {
        const {levelDetails: e} = this;
        return e === null ? null : e.edge + e.age
    }
    computeLatency() {
        const e = this.estimateLiveEdge();
        return e === null ? null : e - this.currentTime
    }
}
const H1 = ["NONE", "TYPE-0", "TYPE-1", null];
function NH(i) {
    return H1.indexOf(i) > -1
}
const Rp = ["SDR", "PQ", "HLG"];
function BH(i) {
    return !!i && Rp.indexOf(i) > -1
}
var Mh = {
    No: "",
    Yes: "YES",
    v2: "v2"
};
function eS(i) {
    const {canSkipUntil: e, canSkipDateRanges: t, age: n} = i
      , s = n < e / 2;
    return e && s ? t ? Mh.v2 : Mh.Yes : Mh.No
}
class tS {
    constructor(e, t, n) {
        this.msn = void 0,
        this.part = void 0,
        this.skip = void 0,
        this.msn = e,
        this.part = t,
        this.skip = n
    }
    addDirectives(e) {
        const t = new self.URL(e);
        return this.msn !== void 0 && t.searchParams.set("_HLS_msn", this.msn.toString()),
        this.part !== void 0 && t.searchParams.set("_HLS_part", this.part.toString()),
        this.skip && t.searchParams.set("_HLS_skip", this.skip),
        t.href
    }
}
class cu {
    constructor(e) {
        this._attrs = void 0,
        this.audioCodec = void 0,
        this.bitrate = void 0,
        this.codecSet = void 0,
        this.url = void 0,
        this.frameRate = void 0,
        this.height = void 0,
        this.id = void 0,
        this.name = void 0,
        this.videoCodec = void 0,
        this.width = void 0,
        this.details = void 0,
        this.fragmentError = 0,
        this.loadError = 0,
        this.loaded = void 0,
        this.realBitrate = 0,
        this.supportedPromise = void 0,
        this.supportedResult = void 0,
        this._avgBitrate = 0,
        this._audioGroups = void 0,
        this._subtitleGroups = void 0,
        this._urlId = 0,
        this.url = [e.url],
        this._attrs = [e.attrs],
        this.bitrate = e.bitrate,
        e.details && (this.details = e.details),
        this.id = e.id || 0,
        this.name = e.name,
        this.width = e.width || 0,
        this.height = e.height || 0,
        this.frameRate = e.attrs.optionalFloat("FRAME-RATE", 0),
        this._avgBitrate = e.attrs.decimalInteger("AVERAGE-BANDWIDTH"),
        this.audioCodec = e.audioCodec,
        this.videoCodec = e.videoCodec,
        this.codecSet = [e.videoCodec, e.audioCodec].filter(t => !!t).map(t => t.substring(0, 4)).join(","),
        this.addGroupId("audio", e.attrs.AUDIO),
        this.addGroupId("text", e.attrs.SUBTITLES)
    }
    get maxBitrate() {
        return Math.max(this.realBitrate, this.bitrate)
    }
    get averageBitrate() {
        return this._avgBitrate || this.realBitrate || this.bitrate
    }
    get attrs() {
        return this._attrs[0]
    }
    get codecs() {
        return this.attrs.CODECS || ""
    }
    get pathwayId() {
        return this.attrs["PATHWAY-ID"] || "."
    }
    get videoRange() {
        return this.attrs["VIDEO-RANGE"] || "SDR"
    }
    get score() {
        return this.attrs.optionalFloat("SCORE", 0)
    }
    get uri() {
        return this.url[0] || ""
    }
    hasAudioGroup(e) {
        return nS(this._audioGroups, e)
    }
    hasSubtitleGroup(e) {
        return nS(this._subtitleGroups, e)
    }
    get audioGroups() {
        return this._audioGroups
    }
    get subtitleGroups() {
        return this._subtitleGroups
    }
    addGroupId(e, t) {
        if (!!t) {
            if (e === "audio") {
                let n = this._audioGroups;
                n || (n = this._audioGroups = []),
                n.indexOf(t) === -1 && n.push(t)
            } else if (e === "text") {
                let n = this._subtitleGroups;
                n || (n = this._subtitleGroups = []),
                n.indexOf(t) === -1 && n.push(t)
            }
        }
    }
    get urlId() {
        return 0
    }
    set urlId(e) {}
    get audioGroupIds() {
        return this.audioGroups ? [this.audioGroupId] : void 0
    }
    get textGroupIds() {
        return this.subtitleGroups ? [this.textGroupId] : void 0
    }
    get audioGroupId() {
        var e;
        return (e = this.audioGroups) == null ? void 0 : e[0]
    }
    get textGroupId() {
        var e;
        return (e = this.subtitleGroups) == null ? void 0 : e[0]
    }
    addFallback() {}
}
function nS(i, e) {
    return !e || !i ? !1 : i.indexOf(e) !== -1
}
function R0(i, e) {
    const t = e.startPTS;
    if (pt(t)) {
        let n = 0, s;
        e.sn > i.sn ? (n = t - i.start,
        s = i) : (n = i.start - t,
        s = e),
        s.duration !== n && (s.duration = n)
    } else
        e.sn > i.sn ? i.cc === e.cc && i.minEndPTS ? e.start = i.start + (i.minEndPTS - i.start) : e.start = i.start + i.duration : e.start = Math.max(i.start - e.duration, 0)
}
function tM(i, e, t, n, s, r) {
    n - t <= 0 && (de.warn("Fragment should have a positive duration", e),
    n = t + e.duration,
    r = s + e.duration);
    let a = t
      , l = n;
    const c = e.startPTS
      , u = e.endPTS;
    if (pt(c)) {
        const m = Math.abs(c - t);
        pt(e.deltaPTS) ? e.deltaPTS = Math.max(m, e.deltaPTS) : e.deltaPTS = m,
        a = Math.max(t, c),
        t = Math.min(t, c),
        s = Math.min(s, e.startDTS),
        l = Math.min(n, u),
        n = Math.max(n, u),
        r = Math.max(r, e.endDTS)
    }
    const d = t - e.start;
    e.start !== 0 && (e.start = t),
    e.duration = n - e.start,
    e.startPTS = t,
    e.maxStartPTS = a,
    e.startDTS = s,
    e.endPTS = n,
    e.minEndPTS = l,
    e.endDTS = r;
    const f = e.sn;
    if (!i || f < i.startSN || f > i.endSN)
        return 0;
    let h;
    const p = f - i.startSN
      , g = i.fragments;
    for (g[p] = e,
    h = p; h > 0; h--)
        R0(g[h], g[h - 1]);
    for (h = p; h < g.length - 1; h++)
        R0(g[h], g[h + 1]);
    return i.fragmentHint && R0(g[g.length - 1], i.fragmentHint),
    i.PTSKnown = i.alignedSliding = !0,
    d
}
function VH(i, e) {
    let t = null;
    const n = i.fragments;
    for (let l = n.length - 1; l >= 0; l--) {
        const c = n[l].initSegment;
        if (c) {
            t = c;
            break
        }
    }
    i.fragmentHint && delete i.fragmentHint.endPTS;
    let s = 0, r;
    if (zH(i, e, (l, c) => {
        l.relurl && (s = l.cc - c.cc),
        pt(l.startPTS) && pt(l.endPTS) && (c.start = c.startPTS = l.startPTS,
        c.startDTS = l.startDTS,
        c.maxStartPTS = l.maxStartPTS,
        c.endPTS = l.endPTS,
        c.endDTS = l.endDTS,
        c.minEndPTS = l.minEndPTS,
        c.duration = l.endPTS - l.startPTS,
        c.duration && (r = c),
        e.PTSKnown = e.alignedSliding = !0),
        c.elementaryStreams = l.elementaryStreams,
        c.loader = l.loader,
        c.stats = l.stats,
        l.initSegment && (c.initSegment = l.initSegment,
        t = l.initSegment)
    }
    ),
    t && (e.fragmentHint ? e.fragments.concat(e.fragmentHint) : e.fragments).forEach(c => {
        var u;
        c && (!c.initSegment || c.initSegment.relurl === ((u = t) == null ? void 0 : u.relurl)) && (c.initSegment = t)
    }
    ),
    e.skippedSegments)
        if (e.deltaUpdateFailed = e.fragments.some(l => !l),
        e.deltaUpdateFailed) {
            de.warn("[level-helper] Previous playlist missing segments skipped in delta playlist");
            for (let l = e.skippedSegments; l--; )
                e.fragments.shift();
            e.startSN = e.fragments[0].sn,
            e.startCC = e.fragments[0].cc
        } else
            e.canSkipDateRanges && (e.dateRanges = $H(i.dateRanges, e.dateRanges, e.recentlyRemovedDateranges));
    const o = e.fragments;
    if (s) {
        de.warn("discontinuity sliding from playlist, take drift into account");
        for (let l = 0; l < o.length; l++)
            o[l].cc += s
    }
    e.skippedSegments && (e.startCC = e.fragments[0].cc),
    HH(i.partList, e.partList, (l, c) => {
        c.elementaryStreams = l.elementaryStreams,
        c.stats = l.stats
    }
    ),
    r ? tM(e, r, r.startPTS, r.endPTS, r.startDTS, r.endDTS) : nM(i, e),
    o.length && (e.totalduration = e.edge - o[0].start),
    e.driftStartTime = i.driftStartTime,
    e.driftStart = i.driftStart;
    const a = e.advancedDateTime;
    if (e.advanced && a) {
        const l = e.edge;
        e.driftStart || (e.driftStartTime = a,
        e.driftStart = l),
        e.driftEndTime = a,
        e.driftEnd = l
    } else
        e.driftEndTime = i.driftEndTime,
        e.driftEnd = i.driftEnd,
        e.advancedDateTime = i.advancedDateTime
}
function $H(i, e, t) {
    const n = Qn({}, i);
    return t && t.forEach(s => {
        delete n[s]
    }
    ),
    Object.keys(e).forEach(s => {
        const r = new NC(e[s].attr,n[s]);
        r.isValid ? n[s] = r : de.warn(`Ignoring invalid Playlist Delta Update DATERANGE tag: "${JSON.stringify(e[s].attr)}"`)
    }
    ),
    n
}
function HH(i, e, t) {
    if (i && e) {
        let n = 0;
        for (let s = 0, r = i.length; s <= r; s++) {
            const o = i[s]
              , a = e[s + n];
            o && a && o.index === a.index && o.fragment.sn === a.fragment.sn ? t(o, a) : n--
        }
    }
}
function zH(i, e, t) {
    const n = e.skippedSegments
      , s = Math.max(i.startSN, e.startSN) - e.startSN
      , r = (i.fragmentHint ? 1 : 0) + (n ? e.endSN : Math.min(i.endSN, e.endSN)) - e.startSN
      , o = e.startSN - i.startSN
      , a = e.fragmentHint ? e.fragments.concat(e.fragmentHint) : e.fragments
      , l = i.fragmentHint ? i.fragments.concat(i.fragmentHint) : i.fragments;
    for (let c = s; c <= r; c++) {
        const u = l[o + c];
        let d = a[c];
        n && !d && c < n && (d = e.fragments[c] = u),
        u && d && t(u, d)
    }
}
function nM(i, e) {
    const t = e.startSN + e.skippedSegments - i.startSN
      , n = i.fragments;
    t < 0 || t >= n.length || z1(e, n[t].start)
}
function z1(i, e) {
    if (e) {
        const t = i.fragments;
        for (let n = i.skippedSegments; n < t.length; n++)
            t[n].start += e;
        i.fragmentHint && (i.fragmentHint.start += e)
    }
}
function GH(i, e=1 / 0) {
    let t = 1e3 * i.targetduration;
    if (i.updated) {
        const n = i.fragments
          , s = 4;
        if (n.length && t * s > e) {
            const r = n[n.length - 1].duration * 1e3;
            r < t && (t = r)
        }
    } else
        t /= 2;
    return Math.round(t)
}
function WH(i, e, t) {
    if (!(i != null && i.details))
        return null;
    const n = i.details;
    let s = n.fragments[e - n.startSN];
    return s || (s = n.fragmentHint,
    s && s.sn === e) ? s : e < n.startSN && t && t.sn === e ? t : null
}
function iS(i, e, t) {
    var n;
    return i != null && i.details ? iM((n = i.details) == null ? void 0 : n.partList, e, t) : null
}
function iM(i, e, t) {
    if (i)
        for (let n = i.length; n--; ) {
            const s = i[n];
            if (s.index === t && s.fragment.sn === e)
                return s
        }
    return null
}
function sM(i) {
    i.forEach( (e, t) => {
        const {details: n} = e;
        n != null && n.fragments && n.fragments.forEach(s => {
            s.level = t
        }
        )
    }
    )
}
function Lp(i) {
    switch (i.details) {
    case Ae.FRAG_LOAD_TIMEOUT:
    case Ae.KEY_LOAD_TIMEOUT:
    case Ae.LEVEL_LOAD_TIMEOUT:
    case Ae.MANIFEST_LOAD_TIMEOUT:
        return !0
    }
    return !1
}
function sS(i, e) {
    const t = Lp(e);
    return i.default[`${t ? "timeout" : "error"}Retry`]
}
function tx(i, e) {
    const t = i.backoff === "linear" ? 1 : Math.pow(2, e);
    return Math.min(t * i.retryDelayMs, i.maxRetryDelayMs)
}
function rS(i) {
    return yi(yi({}, i), {
        errorRetry: null,
        timeoutRetry: null
    })
}
function Ip(i, e, t, n) {
    if (!i)
        return !1;
    const s = n == null ? void 0 : n.code
      , r = e < i.maxNumRetry && (qH(s) || !!t);
    return i.shouldRetry ? i.shouldRetry(i, e, t, n, r) : r
}
function qH(i) {
    return i === 0 && navigator.onLine === !1 || !!i && (i < 400 || i > 499)
}
const rM = {
    search: function(i, e) {
        let t = 0
          , n = i.length - 1
          , s = null
          , r = null;
        for (; t <= n; ) {
            s = (t + n) / 2 | 0,
            r = i[s];
            const o = e(r);
            if (o > 0)
                t = s + 1;
            else if (o < 0)
                n = s - 1;
            else
                return r
        }
        return null
    }
};
function jH(i, e, t) {
    if (e === null || !Array.isArray(i) || !i.length || !pt(e))
        return null;
    const n = i[0].programDateTime;
    if (e < (n || 0))
        return null;
    const s = i[i.length - 1].endProgramDateTime;
    if (e >= (s || 0))
        return null;
    t = t || 0;
    for (let r = 0; r < i.length; ++r) {
        const o = i[r];
        if (XH(e, t, o))
            return o
    }
    return null
}
function kp(i, e, t=0, n=0, s=.005) {
    let r = null;
    if (i) {
        r = e[i.sn - e[0].sn + 1] || null;
        const a = i.endDTS - t;
        a > 0 && a < 15e-7 && (t += 15e-7)
    } else
        t === 0 && e[0].start === 0 && (r = e[0]);
    if (r && ((!i || i.level === r.level) && G1(t, n, r) === 0 || KH(r, i, Math.min(s, n))))
        return r;
    const o = rM.search(e, G1.bind(null, t, n));
    return o && (o !== i || !r) ? o : r
}
function KH(i, e, t) {
    if (e && e.start === 0 && e.level < i.level && (e.endPTS || 0) > 0) {
        const n = e.tagList.reduce( (s, r) => (r[0] === "INF" && (s += parseFloat(r[1])),
        s), t);
        return i.start <= n
    }
    return !1
}
function G1(i=0, e=0, t) {
    if (t.start <= i && t.start + t.duration > i)
        return 0;
    const n = Math.min(e, t.duration + (t.deltaPTS ? t.deltaPTS : 0));
    return t.start + t.duration - n <= i ? 1 : t.start - n > i && t.start ? -1 : 0
}
function XH(i, e, t) {
    const n = Math.min(e, t.duration + (t.deltaPTS ? t.deltaPTS : 0)) * 1e3;
    return (t.endProgramDateTime || 0) - n > i
}
function YH(i, e) {
    return rM.search(i, t => t.cc < e ? 1 : t.cc > e ? -1 : 0)
}
var Ei = {
    DoNothing: 0,
    SendEndCallback: 1,
    SendAlternateToPenaltyBox: 2,
    RemoveAlternatePermanently: 3,
    InsertDiscontinuity: 4,
    RetryRequest: 5
}
  , tr = {
    None: 0,
    MoveAllAlternatesMatchingHost: 1,
    MoveAllAlternatesMatchingHDCP: 2,
    SwitchToSDR: 4
};
class ZH {
    constructor(e) {
        this.hls = void 0,
        this.playlistError = 0,
        this.penalizedRenditions = {},
        this.log = void 0,
        this.warn = void 0,
        this.error = void 0,
        this.hls = e,
        this.log = de.log.bind(de, "[info]:"),
        this.warn = de.warn.bind(de, "[warning]:"),
        this.error = de.error.bind(de, "[error]:"),
        this.registerListeners()
    }
    registerListeners() {
        const e = this.hls;
        e.on(P.ERROR, this.onError, this),
        e.on(P.MANIFEST_LOADING, this.onManifestLoading, this),
        e.on(P.LEVEL_UPDATED, this.onLevelUpdated, this)
    }
    unregisterListeners() {
        const e = this.hls;
        !e || (e.off(P.ERROR, this.onError, this),
        e.off(P.ERROR, this.onErrorOut, this),
        e.off(P.MANIFEST_LOADING, this.onManifestLoading, this),
        e.off(P.LEVEL_UPDATED, this.onLevelUpdated, this))
    }
    destroy() {
        this.unregisterListeners(),
        this.hls = null,
        this.penalizedRenditions = {}
    }
    startLoad(e) {}
    stopLoad() {
        this.playlistError = 0
    }
    getVariantLevelIndex(e) {
        return (e == null ? void 0 : e.type) === Ct.MAIN ? e.level : this.hls.loadLevel
    }
    onManifestLoading() {
        this.playlistError = 0,
        this.penalizedRenditions = {}
    }
    onLevelUpdated() {
        this.playlistError = 0
    }
    onError(e, t) {
        var n, s;
        if (t.fatal)
            return;
        const r = this.hls
          , o = t.context;
        switch (t.details) {
        case Ae.FRAG_LOAD_ERROR:
        case Ae.FRAG_LOAD_TIMEOUT:
        case Ae.KEY_LOAD_ERROR:
        case Ae.KEY_LOAD_TIMEOUT:
            t.errorAction = this.getFragRetryOrSwitchAction(t);
            return;
        case Ae.FRAG_PARSING_ERROR:
            if ((n = t.frag) != null && n.gap) {
                t.errorAction = {
                    action: Ei.DoNothing,
                    flags: tr.None
                };
                return
            }
        case Ae.FRAG_GAP:
        case Ae.FRAG_DECRYPT_ERROR:
            {
                t.errorAction = this.getFragRetryOrSwitchAction(t),
                t.errorAction.action = Ei.SendAlternateToPenaltyBox;
                return
            }
        case Ae.LEVEL_EMPTY_ERROR:
        case Ae.LEVEL_PARSING_ERROR:
            {
                var a, l;
                const c = t.parent === Ct.MAIN ? t.level : r.loadLevel;
                t.details === Ae.LEVEL_EMPTY_ERROR && !!((a = t.context) != null && (l = a.levelDetails) != null && l.live) ? t.errorAction = this.getPlaylistRetryOrSwitchAction(t, c) : (t.levelRetry = !1,
                t.errorAction = this.getLevelSwitchAction(t, c))
            }
            return;
        case Ae.LEVEL_LOAD_ERROR:
        case Ae.LEVEL_LOAD_TIMEOUT:
            typeof (o == null ? void 0 : o.level) == "number" && (t.errorAction = this.getPlaylistRetryOrSwitchAction(t, o.level));
            return;
        case Ae.AUDIO_TRACK_LOAD_ERROR:
        case Ae.AUDIO_TRACK_LOAD_TIMEOUT:
        case Ae.SUBTITLE_LOAD_ERROR:
        case Ae.SUBTITLE_TRACK_LOAD_TIMEOUT:
            if (o) {
                const c = r.levels[r.loadLevel];
                if (c && (o.type === en.AUDIO_TRACK && c.hasAudioGroup(o.groupId) || o.type === en.SUBTITLE_TRACK && c.hasSubtitleGroup(o.groupId))) {
                    t.errorAction = this.getPlaylistRetryOrSwitchAction(t, r.loadLevel),
                    t.errorAction.action = Ei.SendAlternateToPenaltyBox,
                    t.errorAction.flags = tr.MoveAllAlternatesMatchingHost;
                    return
                }
            }
            return;
        case Ae.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED:
            {
                const c = r.levels[r.loadLevel]
                  , u = c == null ? void 0 : c.attrs["HDCP-LEVEL"];
                u ? t.errorAction = {
                    action: Ei.SendAlternateToPenaltyBox,
                    flags: tr.MoveAllAlternatesMatchingHDCP,
                    hdcpLevel: u
                } : this.keySystemError(t)
            }
            return;
        case Ae.BUFFER_ADD_CODEC_ERROR:
        case Ae.REMUX_ALLOC_ERROR:
        case Ae.BUFFER_APPEND_ERROR:
            t.errorAction = this.getLevelSwitchAction(t, (s = t.level) != null ? s : r.loadLevel);
            return;
        case Ae.INTERNAL_EXCEPTION:
        case Ae.BUFFER_APPENDING_ERROR:
        case Ae.BUFFER_FULL_ERROR:
        case Ae.LEVEL_SWITCH_ERROR:
        case Ae.BUFFER_STALLED_ERROR:
        case Ae.BUFFER_SEEK_OVER_HOLE:
        case Ae.BUFFER_NUDGE_ON_STALL:
            t.errorAction = {
                action: Ei.DoNothing,
                flags: tr.None
            };
            return
        }
        t.type === Ut.KEY_SYSTEM_ERROR && this.keySystemError(t)
    }
    keySystemError(e) {
        const t = this.getVariantLevelIndex(e.frag);
        e.levelRetry = !1,
        e.errorAction = this.getLevelSwitchAction(e, t)
    }
    getPlaylistRetryOrSwitchAction(e, t) {
        const n = this.hls
          , s = sS(n.config.playlistLoadPolicy, e)
          , r = this.playlistError++;
        if (Ip(s, r, Lp(e), e.response))
            return {
                action: Ei.RetryRequest,
                flags: tr.None,
                retryConfig: s,
                retryCount: r
            };
        const a = this.getLevelSwitchAction(e, t);
        return s && (a.retryConfig = s,
        a.retryCount = r),
        a
    }
    getFragRetryOrSwitchAction(e) {
        const t = this.hls
          , n = this.getVariantLevelIndex(e.frag)
          , s = t.levels[n]
          , {fragLoadPolicy: r, keyLoadPolicy: o} = t.config
          , a = sS(e.details.startsWith("key") ? o : r, e)
          , l = t.levels.reduce( (u, d) => u + d.fragmentError, 0);
        if (s && (e.details !== Ae.FRAG_GAP && s.fragmentError++,
        Ip(a, l, Lp(e), e.response)))
            return {
                action: Ei.RetryRequest,
                flags: tr.None,
                retryConfig: a,
                retryCount: l
            };
        const c = this.getLevelSwitchAction(e, n);
        return a && (c.retryConfig = a,
        c.retryCount = l),
        c
    }
    getLevelSwitchAction(e, t) {
        const n = this.hls;
        t == null && (t = n.loadLevel);
        const s = this.hls.levels[t];
        if (s) {
            var r, o;
            const c = e.details;
            s.loadError++,
            c === Ae.BUFFER_APPEND_ERROR && s.fragmentError++;
            let u = -1;
            const {levels: d, loadLevel: f, minAutoLevel: h, maxAutoLevel: p} = n;
            n.autoLevelEnabled || (n.loadLevel = -1);
            const g = (r = e.frag) == null ? void 0 : r.type
              , v = (g === Ct.AUDIO && c === Ae.FRAG_PARSING_ERROR || e.sourceBufferName === "audio" && (c === Ae.BUFFER_ADD_CODEC_ERROR || c === Ae.BUFFER_APPEND_ERROR)) && d.some( ({audioCodec: C}) => s.audioCodec !== C)
              , y = e.sourceBufferName === "video" && (c === Ae.BUFFER_ADD_CODEC_ERROR || c === Ae.BUFFER_APPEND_ERROR) && d.some( ({codecSet: C, audioCodec: M}) => s.codecSet !== C && s.audioCodec === M)
              , {type: b, groupId: S} = (o = e.context) != null ? o : {};
            for (let C = d.length; C--; ) {
                const M = (C + f) % d.length;
                if (M !== f && M >= h && M <= p && d[M].loadError === 0) {
                    var a, l;
                    const L = d[M];
                    if (c === Ae.FRAG_GAP && g === Ct.MAIN && e.frag) {
                        const T = d[M].details;
                        if (T) {
                            const A = kp(e.frag, T.fragments, e.frag.start);
                            if (A != null && A.gap)
                                continue
                        }
                    } else {
                        if (b === en.AUDIO_TRACK && L.hasAudioGroup(S) || b === en.SUBTITLE_TRACK && L.hasSubtitleGroup(S))
                            continue;
                        if (g === Ct.AUDIO && (a = s.audioGroups) != null && a.some(T => L.hasAudioGroup(T)) || g === Ct.SUBTITLE && (l = s.subtitleGroups) != null && l.some(T => L.hasSubtitleGroup(T)) || v && s.audioCodec === L.audioCodec || !v && s.audioCodec !== L.audioCodec || y && s.codecSet === L.codecSet)
                            continue
                    }
                    u = M;
                    break
                }
            }
            if (u > -1 && n.loadLevel !== u)
                return e.levelRetry = !0,
                this.playlistError = 0,
                {
                    action: Ei.SendAlternateToPenaltyBox,
                    flags: tr.None,
                    nextAutoLevel: u
                }
        }
        return {
            action: Ei.SendAlternateToPenaltyBox,
            flags: tr.MoveAllAlternatesMatchingHost
        }
    }
    onErrorOut(e, t) {
        var n;
        switch ((n = t.errorAction) == null ? void 0 : n.action) {
        case Ei.DoNothing:
            break;
        case Ei.SendAlternateToPenaltyBox:
            this.sendAlternateToPenaltyBox(t),
            !t.errorAction.resolved && t.details !== Ae.FRAG_GAP ? t.fatal = !0 : /MediaSource readyState: ended/.test(t.error.message) && (this.warn(`MediaSource ended after "${t.sourceBufferName}" sourceBuffer append error. Attempting to recover from media error.`),
            this.hls.recoverMediaError());
            break
        }
        if (t.fatal) {
            this.hls.stopLoad();
            return
        }
    }
    sendAlternateToPenaltyBox(e) {
        const t = this.hls
          , n = e.errorAction;
        if (!n)
            return;
        const {flags: s, hdcpLevel: r, nextAutoLevel: o} = n;
        switch (s) {
        case tr.None:
            this.switchLevel(e, o);
            break;
        case tr.MoveAllAlternatesMatchingHDCP:
            r && (t.maxHdcpLevel = H1[H1.indexOf(r) - 1],
            n.resolved = !0),
            this.warn(`Restricting playback to HDCP-LEVEL of "${t.maxHdcpLevel}" or lower`);
            break
        }
        n.resolved || this.switchLevel(e, o)
    }
    switchLevel(e, t) {
        t !== void 0 && e.errorAction && (this.warn(`switching to level ${t} after ${e.details}`),
        this.hls.nextAutoLevel = t,
        e.errorAction.resolved = !0,
        this.hls.nextLoadLevel = this.hls.nextAutoLevel)
    }
}
class nx {
    constructor(e, t) {
        this.hls = void 0,
        this.timer = -1,
        this.requestScheduled = -1,
        this.canLoad = !1,
        this.log = void 0,
        this.warn = void 0,
        this.log = de.log.bind(de, `${t}:`),
        this.warn = de.warn.bind(de, `${t}:`),
        this.hls = e
    }
    destroy() {
        this.clearTimer(),
        this.hls = this.log = this.warn = null
    }
    clearTimer() {
        this.timer !== -1 && (self.clearTimeout(this.timer),
        this.timer = -1)
    }
    startLoad() {
        this.canLoad = !0,
        this.requestScheduled = -1,
        this.loadPlaylist()
    }
    stopLoad() {
        this.canLoad = !1,
        this.clearTimer()
    }
    switchParams(e, t, n) {
        const s = t == null ? void 0 : t.renditionReports;
        if (s) {
            let r = -1;
            for (let o = 0; o < s.length; o++) {
                const a = s[o];
                let l;
                try {
                    l = new self.URL(a.URI,t.url).href
                } catch (c) {
                    de.warn(`Could not construct new URL for Rendition Report: ${c}`),
                    l = a.URI || ""
                }
                if (l === e) {
                    r = o;
                    break
                } else
                    l === e.substring(0, l.length) && (r = o)
            }
            if (r !== -1) {
                const o = s[r]
                  , a = parseInt(o["LAST-MSN"]) || (t == null ? void 0 : t.lastPartSn);
                let l = parseInt(o["LAST-PART"]) || (t == null ? void 0 : t.lastPartIndex);
                if (this.hls.config.lowLatencyMode) {
                    const u = Math.min(t.age - t.partTarget, t.targetduration);
                    l >= 0 && u > t.partTarget && (l += 1)
                }
                const c = n && eS(n);
                return new tS(a,l >= 0 ? l : void 0,c)
            }
        }
    }
    loadPlaylist(e) {
        this.requestScheduled === -1 && (this.requestScheduled = self.performance.now())
    }
    shouldLoadPlaylist(e) {
        return this.canLoad && !!e && !!e.url && (!e.details || e.details.live)
    }
    shouldReloadPlaylist(e) {
        return this.timer === -1 && this.requestScheduled === -1 && this.shouldLoadPlaylist(e)
    }
    playlistLoaded(e, t, n) {
        const {details: s, stats: r} = t
          , o = self.performance.now()
          , a = r.loading.first ? Math.max(0, o - r.loading.first) : 0;
        if (s.advancedDateTime = Date.now() - a,
        s.live || n != null && n.live) {
            if (s.reloaded(n),
            n && this.log(`live playlist ${e} ${s.advanced ? "REFRESHED " + s.lastPartSn + "-" + s.lastPartIndex : s.updated ? "UPDATED" : "MISSED"}`),
            n && s.fragments.length > 0 && VH(n, s),
            !this.canLoad || !s.live)
                return;
            let l, c, u;
            if (s.canBlockReload && s.endSN && s.advanced) {
                const m = this.hls.config.lowLatencyMode
                  , v = s.lastPartSn
                  , _ = s.endSN
                  , y = s.lastPartIndex
                  , b = y !== -1
                  , S = v === _
                  , C = m ? 0 : y;
                b ? (c = S ? _ + 1 : v,
                u = S ? C : y + 1) : c = _ + 1;
                const M = s.age
                  , L = M + s.ageHeader;
                let T = Math.min(L - s.partTarget, s.targetduration * 1.5);
                if (T > 0) {
                    if (n && T > n.tuneInGoal)
                        this.warn(`CDN Tune-in goal increased from: ${n.tuneInGoal} to: ${T} with playlist age: ${s.age}`),
                        T = 0;
                    else {
                        const A = Math.floor(T / s.targetduration);
                        if (c += A,
                        u !== void 0) {
                            const k = Math.round(T % s.targetduration / s.partTarget);
                            u += k
                        }
                        this.log(`CDN Tune-in age: ${s.ageHeader}s last advanced ${M.toFixed(2)}s goal: ${T} skip sn ${A} to part ${u}`)
                    }
                    s.tuneInGoal = T
                }
                if (l = this.getDeliveryDirectives(s, t.deliveryDirectives, c, u),
                m || !S) {
                    this.loadPlaylist(l);
                    return
                }
            } else
                (s.canBlockReload || s.canSkipUntil) && (l = this.getDeliveryDirectives(s, t.deliveryDirectives, c, u));
            const d = this.hls.mainForwardBufferInfo
              , f = d ? d.end - d.len : 0
              , h = (s.edge - f) * 1e3
              , p = GH(s, h);
            s.updated && o > this.requestScheduled + p && (this.requestScheduled = r.loading.start),
            c !== void 0 && s.canBlockReload ? this.requestScheduled = r.loading.first + p - (s.partTarget * 1e3 || 1e3) : this.requestScheduled === -1 || this.requestScheduled + p < o ? this.requestScheduled = o : this.requestScheduled - o <= 0 && (this.requestScheduled += p);
            let g = this.requestScheduled - o;
            g = Math.max(0, g),
            this.log(`reload live playlist ${e} in ${Math.round(g)} ms`),
            this.timer = self.setTimeout( () => this.loadPlaylist(l), g)
        } else
            this.clearTimer()
    }
    getDeliveryDirectives(e, t, n, s) {
        let r = eS(e);
        return t != null && t.skip && e.deltaUpdateFailed && (n = t.msn,
        s = t.part,
        r = Mh.No),
        new tS(n,s,r)
    }
    checkRetry(e) {
        const t = e.details
          , n = Lp(e)
          , s = e.errorAction
          , {action: r, retryCount: o=0, retryConfig: a} = s || {}
          , l = !!s && !!a && (r === Ei.RetryRequest || !s.resolved && r === Ei.SendAlternateToPenaltyBox);
        if (l) {
            var c;
            if (this.requestScheduled = -1,
            o >= a.maxNumRetry)
                return !1;
            if (n && (c = e.context) != null && c.deliveryDirectives)
                this.warn(`Retrying playlist loading ${o + 1}/${a.maxNumRetry} after "${t}" without delivery-directives`),
                this.loadPlaylist();
            else {
                const u = tx(a, o);
                this.timer = self.setTimeout( () => this.loadPlaylist(), u),
                this.warn(`Retrying playlist loading ${o + 1}/${a.maxNumRetry} after "${t}" in ${u}ms`)
            }
            e.levelRetry = !0,
            s.resolved = !0
        }
        return l
    }
}
class Kl {
    constructor(e, t=0, n=0) {
        this.halfLife = void 0,
        this.alpha_ = void 0,
        this.estimate_ = void 0,
        this.totalWeight_ = void 0,
        this.halfLife = e,
        this.alpha_ = e ? Math.exp(Math.log(.5) / e) : 0,
        this.estimate_ = t,
        this.totalWeight_ = n
    }
    sample(e, t) {
        const n = Math.pow(this.alpha_, e);
        this.estimate_ = t * (1 - n) + n * this.estimate_,
        this.totalWeight_ += e
    }
    getTotalWeight() {
        return this.totalWeight_
    }
    getEstimate() {
        if (this.alpha_) {
            const e = 1 - Math.pow(this.alpha_, this.totalWeight_);
            if (e)
                return this.estimate_ / e
        }
        return this.estimate_
    }
}
class JH {
    constructor(e, t, n, s=100) {
        this.defaultEstimate_ = void 0,
        this.minWeight_ = void 0,
        this.minDelayMs_ = void 0,
        this.slow_ = void 0,
        this.fast_ = void 0,
        this.defaultTTFB_ = void 0,
        this.ttfb_ = void 0,
        this.defaultEstimate_ = n,
        this.minWeight_ = .001,
        this.minDelayMs_ = 50,
        this.slow_ = new Kl(e),
        this.fast_ = new Kl(t),
        this.defaultTTFB_ = s,
        this.ttfb_ = new Kl(e)
    }
    update(e, t) {
        const {slow_: n, fast_: s, ttfb_: r} = this;
        n.halfLife !== e && (this.slow_ = new Kl(e,n.getEstimate(),n.getTotalWeight())),
        s.halfLife !== t && (this.fast_ = new Kl(t,s.getEstimate(),s.getTotalWeight())),
        r.halfLife !== e && (this.ttfb_ = new Kl(e,r.getEstimate(),r.getTotalWeight()))
    }
    sample(e, t) {
        e = Math.max(e, this.minDelayMs_);
        const n = 8 * t
          , s = e / 1e3
          , r = n / s;
        this.fast_.sample(s, r),
        this.slow_.sample(s, r)
    }
    sampleTTFB(e) {
        const t = e / 1e3
          , n = Math.sqrt(2) * Math.exp(-Math.pow(t, 2) / 2);
        this.ttfb_.sample(n, Math.max(e, 5))
    }
    canEstimate() {
        return this.fast_.getTotalWeight() >= this.minWeight_
    }
    getEstimate() {
        return this.canEstimate() ? Math.min(this.fast_.getEstimate(), this.slow_.getEstimate()) : this.defaultEstimate_
    }
    getEstimateTTFB() {
        return this.ttfb_.getTotalWeight() >= this.minWeight_ ? this.ttfb_.getEstimate() : this.defaultTTFB_
    }
    destroy() {}
}
const oM = {
    supported: !0,
    configurations: [],
    decodingInfoResults: [{
        supported: !0,
        powerEfficient: !0,
        smooth: !0
    }]
}
  , oS = {};
function QH(i, e, t, n, s, r) {
    const o = i.audioCodec ? i.audioGroups : null
      , a = r == null ? void 0 : r.audioCodec
      , l = r == null ? void 0 : r.channels
      , c = l ? parseInt(l) : a ? 1 / 0 : 2;
    let u = null;
    if (o != null && o.length)
        try {
            o.length === 1 && o[0] ? u = e.groups[o[0]].channels : u = o.reduce( (d, f) => {
                if (f) {
                    const h = e.groups[f];
                    if (!h)
                        throw new Error(`Audio track group ${f} not found`);
                    Object.keys(h.channels).forEach(p => {
                        d[p] = (d[p] || 0) + h.channels[p]
                    }
                    )
                }
                return d
            }
            , {
                2: 0
            })
        } catch {
            return !0
        }
    return i.videoCodec !== void 0 && (i.width > 1920 && i.height > 1088 || i.height > 1920 && i.width > 1088 || i.frameRate > Math.max(n, 30) || i.videoRange !== "SDR" && i.videoRange !== t || i.bitrate > Math.max(s, 8e6)) || !!u && pt(c) && Object.keys(u).some(d => parseInt(d) > c)
}
function ez(i, e, t) {
    const n = i.videoCodec
      , s = i.audioCodec;
    if (!n || !s || !t)
        return Promise.resolve(oM);
    const r = {
        width: i.width,
        height: i.height,
        bitrate: Math.ceil(Math.max(i.bitrate * .9, i.averageBitrate)),
        framerate: i.frameRate || 30
    }
      , o = i.videoRange;
    o !== "SDR" && (r.transferFunction = o.toLowerCase());
    const a = n.split(",").map(l => ({
        type: "media-source",
        video: yi(yi({}, r), {}, {
            contentType: Ud(l, "video")
        })
    }));
    return s && i.audioGroups && i.audioGroups.forEach(l => {
        var c;
        !l || (c = e.groups[l]) == null || c.tracks.forEach(u => {
            if (u.groupId === l) {
                const d = u.channels || ""
                  , f = parseFloat(d);
                pt(f) && f > 2 && a.push.apply(a, s.split(",").map(h => ({
                    type: "media-source",
                    audio: {
                        contentType: Ud(h, "audio"),
                        channels: "" + f
                    }
                })))
            }
        }
        )
    }
    ),
    Promise.all(a.map(l => {
        const c = tz(l);
        return oS[c] || (oS[c] = t.decodingInfo(l))
    }
    )).then(l => ({
        supported: !l.some(c => !c.supported),
        configurations: a,
        decodingInfoResults: l
    })).catch(l => ({
        supported: !1,
        configurations: a,
        decodingInfoResults: [],
        error: l
    }))
}
function tz(i) {
    const {audio: e, video: t} = i
      , n = t || e;
    if (n) {
        const s = n.contentType.split('"')[1];
        if (t)
            return `r${t.height}x${t.width}f${Math.ceil(t.framerate)}${t.transferFunction || "sd"}_${s}_${Math.ceil(t.bitrate / 1e5)}`;
        if (e)
            return `c${e.channels}${e.spatialRendering ? "s" : "n"}_${s}`
    }
    return ""
}
function nz() {
    if (typeof matchMedia == "function") {
        const i = matchMedia("(dynamic-range: high)")
          , e = matchMedia("bad query");
        if (i.media !== e.media)
            return i.matches === !0
    }
    return !1
}
function iz(i, e) {
    let t = !1
      , n = [];
    return i && (t = i !== "SDR",
    n = [i]),
    e && (n = e.allowedVideoRanges || Rp.slice(0),
    t = e.preferHDR !== void 0 ? e.preferHDR : nz(),
    t ? n = n.filter(s => s !== "SDR") : n = ["SDR"]),
    {
        preferHDR: t,
        allowedVideoRanges: n
    }
}
function sz(i, e, t, n, s) {
    const r = Object.keys(i)
      , o = n == null ? void 0 : n.channels
      , a = n == null ? void 0 : n.audioCodec
      , l = o && parseInt(o) === 2;
    let c = !0
      , u = !1
      , d = 1 / 0
      , f = 1 / 0
      , h = 1 / 0
      , p = 0
      , g = [];
    const {preferHDR: m, allowedVideoRanges: v} = iz(e, s);
    for (let S = r.length; S--; ) {
        const C = i[r[S]];
        c = C.channels[2] > 0,
        d = Math.min(d, C.minHeight),
        f = Math.min(f, C.minFramerate),
        h = Math.min(h, C.minBitrate);
        const M = v.filter(L => C.videoRanges[L] > 0);
        M.length > 0 && (u = !0,
        g = M)
    }
    d = pt(d) ? d : 0,
    f = pt(f) ? f : 0;
    const _ = Math.max(1080, d)
      , y = Math.max(30, f);
    return h = pt(h) ? h : t,
    t = Math.max(h, t),
    u || (e = void 0,
    g = []),
    {
        codecSet: r.reduce( (S, C) => {
            const M = i[C];
            if (C === S)
                return S;
            if (M.minBitrate > t)
                return so(C, `min bitrate of ${M.minBitrate} > current estimate of ${t}`),
                S;
            if (!M.hasDefaultAudio)
                return so(C, "no renditions with default or auto-select sound found"),
                S;
            if (a && C.indexOf(a.substring(0, 4)) % 5 !== 0)
                return so(C, `audio codec preference "${a}" not found`),
                S;
            if (o && !l) {
                if (!M.channels[o])
                    return so(C, `no renditions with ${o} channel sound found (channels options: ${Object.keys(M.channels)})`),
                    S
            } else if ((!a || l) && c && M.channels[2] === 0)
                return so(C, "no renditions with stereo sound found"),
                S;
            return M.minHeight > _ ? (so(C, `min resolution of ${M.minHeight} > maximum of ${_}`),
            S) : M.minFramerate > y ? (so(C, `min framerate of ${M.minFramerate} > maximum of ${y}`),
            S) : g.some(L => M.videoRanges[L] > 0) ? M.maxScore < p ? (so(C, `max score of ${M.maxScore} < selected max of ${p}`),
            S) : S && (Cp(C) >= Cp(S) || M.fragmentError > i[S].fragmentError) ? S : (p = M.maxScore,
            C) : (so(C, `no variants with VIDEO-RANGE of ${JSON.stringify(g)} found`),
            S)
        }
        , void 0),
        videoRanges: g,
        preferHDR: m,
        minFramerate: f,
        minBitrate: h
    }
}
function so(i, e) {
    de.log(`[abr] start candidates with "${i}" ignored because ${e}`)
}
function rz(i) {
    return i.reduce( (e, t) => {
        let n = e.groups[t.groupId];
        n || (n = e.groups[t.groupId] = {
            tracks: [],
            channels: {
                2: 0
            },
            hasDefault: !1,
            hasAutoSelect: !1
        }),
        n.tracks.push(t);
        const s = t.channels || "2";
        return n.channels[s] = (n.channels[s] || 0) + 1,
        n.hasDefault = n.hasDefault || t.default,
        n.hasAutoSelect = n.hasAutoSelect || t.autoselect,
        n.hasDefault && (e.hasDefaultAudio = !0),
        n.hasAutoSelect && (e.hasAutoSelectAudio = !0),
        e
    }
    , {
        hasDefaultAudio: !1,
        hasAutoSelectAudio: !1,
        groups: {}
    })
}
function oz(i, e, t, n) {
    return i.slice(t, n + 1).reduce( (s, r) => {
        if (!r.codecSet)
            return s;
        const o = r.audioGroups;
        let a = s[r.codecSet];
        a || (s[r.codecSet] = a = {
            minBitrate: 1 / 0,
            minHeight: 1 / 0,
            minFramerate: 1 / 0,
            maxScore: 0,
            videoRanges: {
                SDR: 0
            },
            channels: {
                2: 0
            },
            hasDefaultAudio: !o,
            fragmentError: 0
        }),
        a.minBitrate = Math.min(a.minBitrate, r.bitrate);
        const l = Math.min(r.height, r.width);
        return a.minHeight = Math.min(a.minHeight, l),
        a.minFramerate = Math.min(a.minFramerate, r.frameRate),
        a.maxScore = Math.max(a.maxScore, r.score),
        a.fragmentError += r.fragmentError,
        a.videoRanges[r.videoRange] = (a.videoRanges[r.videoRange] || 0) + 1,
        o && o.forEach(c => {
            if (!c)
                return;
            const u = e.groups[c];
            !u || (a.hasDefaultAudio = a.hasDefaultAudio || e.hasDefaultAudio ? u.hasDefault : u.hasAutoSelect || !e.hasDefaultAudio && !e.hasAutoSelectAudio,
            Object.keys(u.channels).forEach(d => {
                a.channels[d] = (a.channels[d] || 0) + u.channels[d]
            }
            ))
        }
        ),
        s
    }
    , {})
}
function Nr(i, e, t) {
    if ("attrs"in i) {
        const n = e.indexOf(i);
        if (n !== -1)
            return n
    }
    for (let n = 0; n < e.length; n++) {
        const s = e[n];
        if (Hc(i, s, t))
            return n
    }
    return -1
}
function Hc(i, e, t) {
    const {groupId: n, name: s, lang: r, assocLang: o, characteristics: a, default: l} = i
      , c = i.forced;
    return (n === void 0 || e.groupId === n) && (s === void 0 || e.name === s) && (r === void 0 || e.lang === r) && (r === void 0 || e.assocLang === o) && (l === void 0 || e.default === l) && (c === void 0 || e.forced === c) && (a === void 0 || az(a, e.characteristics)) && (t === void 0 || t(i, e))
}
function az(i, e="") {
    const t = i.split(",")
      , n = e.split(",");
    return t.length === n.length && !t.some(s => n.indexOf(s) === -1)
}
function Xl(i, e) {
    const {audioCodec: t, channels: n} = i;
    return (t === void 0 || (e.audioCodec || "").substring(0, 4) === t.substring(0, 4)) && (n === void 0 || n === (e.channels || "2"))
}
function lz(i, e, t, n, s) {
    const r = e[n]
      , a = e.reduce( (f, h, p) => {
        const g = h.uri;
        return (f[g] || (f[g] = [])).push(p),
        f
    }
    , {})[r.uri];
    a.length > 1 && (n = Math.max.apply(Math, a));
    const l = r.videoRange
      , c = r.frameRate
      , u = r.codecSet.substring(0, 4)
      , d = aS(e, n, f => {
        if (f.videoRange !== l || f.frameRate !== c || f.codecSet.substring(0, 4) !== u)
            return !1;
        const h = f.audioGroups
          , p = t.filter(g => !h || h.indexOf(g.groupId) !== -1);
        return Nr(i, p, s) > -1
    }
    );
    return d > -1 ? d : aS(e, n, f => {
        const h = f.audioGroups
          , p = t.filter(g => !h || h.indexOf(g.groupId) !== -1);
        return Nr(i, p, s) > -1
    }
    )
}
function aS(i, e, t) {
    for (let n = e; n > -1; n--)
        if (t(i[n]))
            return n;
    for (let n = e + 1; n < i.length; n++)
        if (t(i[n]))
            return n;
    return -1
}
class cz {
    constructor(e) {
        this.hls = void 0,
        this.lastLevelLoadSec = 0,
        this.lastLoadedFragLevel = -1,
        this.firstSelection = -1,
        this._nextAutoLevel = -1,
        this.nextAutoLevelKey = "",
        this.audioTracksByGroup = null,
        this.codecTiers = null,
        this.timer = -1,
        this.fragCurrent = null,
        this.partCurrent = null,
        this.bitrateTestDelay = 0,
        this.bwEstimator = void 0,
        this._abandonRulesCheck = () => {
            const {fragCurrent: t, partCurrent: n, hls: s} = this
              , {autoLevelEnabled: r, media: o} = s;
            if (!t || !o)
                return;
            const a = performance.now()
              , l = n ? n.stats : t.stats
              , c = n ? n.duration : t.duration
              , u = a - l.loading.start
              , d = s.minAutoLevel;
            if (l.aborted || l.loaded && l.loaded === l.total || t.level <= d) {
                this.clearTimer(),
                this._nextAutoLevel = -1;
                return
            }
            if (!r || o.paused || !o.playbackRate || !o.readyState)
                return;
            const f = s.mainForwardBufferInfo;
            if (f === null)
                return;
            const h = this.bwEstimator.getEstimateTTFB()
              , p = Math.abs(o.playbackRate);
            if (u <= Math.max(h, 1e3 * (c / (p * 2))))
                return;
            const g = f.len / p
              , m = l.loading.first ? l.loading.first - l.loading.start : -1
              , v = l.loaded && m > -1
              , _ = this.getBwEstimate()
              , y = s.levels
              , b = y[t.level]
              , S = l.total || Math.max(l.loaded, Math.round(c * b.averageBitrate / 8));
            let C = v ? u - m : u;
            C < 1 && v && (C = Math.min(u, l.loaded * 8 / _));
            const M = v ? l.loaded * 1e3 / C : 0
              , L = M ? (S - l.loaded) / M : S * 8 / _ + h / 1e3;
            if (L <= g)
                return;
            const T = M ? M * 8 : _;
            let A = Number.POSITIVE_INFINITY, k;
            for (k = t.level - 1; k > d; k--) {
                const F = y[k].maxBitrate;
                if (A = this.getTimeToLoadFrag(h / 1e3, T, c * F, !y[k].details),
                A < g)
                    break
            }
            if (A >= L || A > c * 10)
                return;
            s.nextLoadLevel = s.nextAutoLevel = k,
            v ? this.bwEstimator.sample(u - Math.min(h, m), l.loaded) : this.bwEstimator.sampleTTFB(u);
            const D = y[k].maxBitrate;
            this.getBwEstimate() * this.hls.config.abrBandWidthUpFactor > D && this.resetEstimator(D),
            this.clearTimer(),
            de.warn(`[abr] Fragment ${t.sn}${n ? " part " + n.index : ""} of level ${t.level} is loading too slowly;
      Time to underbuffer: ${g.toFixed(3)} s
      Estimated load time for current fragment: ${L.toFixed(3)} s
      Estimated load time for down switch fragment: ${A.toFixed(3)} s
      TTFB estimate: ${m | 0} ms
      Current BW estimate: ${pt(_) ? _ | 0 : "Unknown"} bps
      New BW estimate: ${this.getBwEstimate() | 0} bps
      Switching to level ${k} @ ${D | 0} bps`),
            s.trigger(P.FRAG_LOAD_EMERGENCY_ABORTED, {
                frag: t,
                part: n,
                stats: l
            })
        }
        ,
        this.hls = e,
        this.bwEstimator = this.initEstimator(),
        this.registerListeners()
    }
    resetEstimator(e) {
        e && (de.log(`setting initial bwe to ${e}`),
        this.hls.config.abrEwmaDefaultEstimate = e),
        this.firstSelection = -1,
        this.bwEstimator = this.initEstimator()
    }
    initEstimator() {
        const e = this.hls.config;
        return new JH(e.abrEwmaSlowVoD,e.abrEwmaFastVoD,e.abrEwmaDefaultEstimate)
    }
    registerListeners() {
        const {hls: e} = this;
        e.on(P.MANIFEST_LOADING, this.onManifestLoading, this),
        e.on(P.FRAG_LOADING, this.onFragLoading, this),
        e.on(P.FRAG_LOADED, this.onFragLoaded, this),
        e.on(P.FRAG_BUFFERED, this.onFragBuffered, this),
        e.on(P.LEVEL_SWITCHING, this.onLevelSwitching, this),
        e.on(P.LEVEL_LOADED, this.onLevelLoaded, this),
        e.on(P.LEVELS_UPDATED, this.onLevelsUpdated, this),
        e.on(P.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this),
        e.on(P.ERROR, this.onError, this)
    }
    unregisterListeners() {
        const {hls: e} = this;
        !e || (e.off(P.MANIFEST_LOADING, this.onManifestLoading, this),
        e.off(P.FRAG_LOADING, this.onFragLoading, this),
        e.off(P.FRAG_LOADED, this.onFragLoaded, this),
        e.off(P.FRAG_BUFFERED, this.onFragBuffered, this),
        e.off(P.LEVEL_SWITCHING, this.onLevelSwitching, this),
        e.off(P.LEVEL_LOADED, this.onLevelLoaded, this),
        e.off(P.LEVELS_UPDATED, this.onLevelsUpdated, this),
        e.off(P.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this),
        e.off(P.ERROR, this.onError, this))
    }
    destroy() {
        this.unregisterListeners(),
        this.clearTimer(),
        this.hls = this._abandonRulesCheck = null,
        this.fragCurrent = this.partCurrent = null
    }
    onManifestLoading(e, t) {
        this.lastLoadedFragLevel = -1,
        this.firstSelection = -1,
        this.lastLevelLoadSec = 0,
        this.fragCurrent = this.partCurrent = null,
        this.onLevelsUpdated(),
        this.clearTimer()
    }
    onLevelsUpdated() {
        this.lastLoadedFragLevel > -1 && this.fragCurrent && (this.lastLoadedFragLevel = this.fragCurrent.level),
        this._nextAutoLevel = -1,
        this.onMaxAutoLevelUpdated(),
        this.codecTiers = null,
        this.audioTracksByGroup = null
    }
    onMaxAutoLevelUpdated() {
        this.firstSelection = -1,
        this.nextAutoLevelKey = ""
    }
    onFragLoading(e, t) {
        const n = t.frag;
        if (!this.ignoreFragment(n)) {
            if (!n.bitrateTest) {
                var s;
                this.fragCurrent = n,
                this.partCurrent = (s = t.part) != null ? s : null
            }
            this.clearTimer(),
            this.timer = self.setInterval(this._abandonRulesCheck, 100)
        }
    }
    onLevelSwitching(e, t) {
        this.clearTimer()
    }
    onError(e, t) {
        if (!t.fatal)
            switch (t.details) {
            case Ae.BUFFER_ADD_CODEC_ERROR:
            case Ae.BUFFER_APPEND_ERROR:
                this.lastLoadedFragLevel = -1,
                this.firstSelection = -1;
                break;
            case Ae.FRAG_LOAD_TIMEOUT:
                {
                    const n = t.frag
                      , {fragCurrent: s, partCurrent: r} = this;
                    if (n && s && n.sn === s.sn && n.level === s.level) {
                        const o = performance.now()
                          , a = r ? r.stats : n.stats
                          , l = o - a.loading.start
                          , c = a.loading.first ? a.loading.first - a.loading.start : -1;
                        if (a.loaded && c > -1) {
                            const d = this.bwEstimator.getEstimateTTFB();
                            this.bwEstimator.sample(l - Math.min(d, c), a.loaded)
                        } else
                            this.bwEstimator.sampleTTFB(l)
                    }
                    break
                }
            }
    }
    getTimeToLoadFrag(e, t, n, s) {
        const r = e + n / t
          , o = s ? this.lastLevelLoadSec : 0;
        return r + o
    }
    onLevelLoaded(e, t) {
        const n = this.hls.config
          , {loading: s} = t.stats
          , r = s.end - s.start;
        pt(r) && (this.lastLevelLoadSec = r / 1e3),
        t.details.live ? this.bwEstimator.update(n.abrEwmaSlowLive, n.abrEwmaFastLive) : this.bwEstimator.update(n.abrEwmaSlowVoD, n.abrEwmaFastVoD)
    }
    onFragLoaded(e, {frag: t, part: n}) {
        const s = n ? n.stats : t.stats;
        if (t.type === Ct.MAIN && this.bwEstimator.sampleTTFB(s.loading.first - s.loading.start),
        !this.ignoreFragment(t)) {
            if (this.clearTimer(),
            t.level === this._nextAutoLevel && (this._nextAutoLevel = -1),
            this.firstSelection = -1,
            this.hls.config.abrMaxWithRealBitrate) {
                const r = n ? n.duration : t.duration
                  , o = this.hls.levels[t.level]
                  , a = (o.loaded ? o.loaded.bytes : 0) + s.loaded
                  , l = (o.loaded ? o.loaded.duration : 0) + r;
                o.loaded = {
                    bytes: a,
                    duration: l
                },
                o.realBitrate = Math.round(8 * a / l)
            }
            if (t.bitrateTest) {
                const r = {
                    stats: s,
                    frag: t,
                    part: n,
                    id: t.type
                };
                this.onFragBuffered(P.FRAG_BUFFERED, r),
                t.bitrateTest = !1
            } else
                this.lastLoadedFragLevel = t.level
        }
    }
    onFragBuffered(e, t) {
        const {frag: n, part: s} = t
          , r = s != null && s.stats.loaded ? s.stats : n.stats;
        if (r.aborted || this.ignoreFragment(n))
            return;
        const o = r.parsing.end - r.loading.start - Math.min(r.loading.first - r.loading.start, this.bwEstimator.getEstimateTTFB());
        this.bwEstimator.sample(o, r.loaded),
        r.bwEstimate = this.getBwEstimate(),
        n.bitrateTest ? this.bitrateTestDelay = o / 1e3 : this.bitrateTestDelay = 0
    }
    ignoreFragment(e) {
        return e.type !== Ct.MAIN || e.sn === "initSegment"
    }
    clearTimer() {
        this.timer > -1 && (self.clearInterval(this.timer),
        this.timer = -1)
    }
    get firstAutoLevel() {
        const {maxAutoLevel: e, minAutoLevel: t} = this.hls
          , n = this.getBwEstimate()
          , s = this.hls.config.maxStarvationDelay
          , r = this.findBestLevel(n, t, e, 0, s, 1, 1);
        if (r > -1)
            return r;
        const o = this.hls.firstLevel
          , a = Math.min(Math.max(o, t), e);
        return de.warn(`[abr] Could not find best starting auto level. Defaulting to first in playlist ${o} clamped to ${a}`),
        a
    }
    get forcedAutoLevel() {
        return this.nextAutoLevelKey ? -1 : this._nextAutoLevel
    }
    get nextAutoLevel() {
        const e = this.forcedAutoLevel
          , n = this.bwEstimator.canEstimate()
          , s = this.lastLoadedFragLevel > -1;
        if (e !== -1 && (!n || !s || this.nextAutoLevelKey === this.getAutoLevelKey()))
            return e;
        const r = n && s ? this.getNextABRAutoLevel() : this.firstAutoLevel;
        if (e !== -1) {
            const o = this.hls.levels;
            if (o.length > Math.max(e, r) && o[e].loadError <= o[r].loadError)
                return e
        }
        return this._nextAutoLevel = r,
        this.nextAutoLevelKey = this.getAutoLevelKey(),
        r
    }
    getAutoLevelKey() {
        return `${this.getBwEstimate()}_${this.getStarvationDelay().toFixed(2)}`
    }
    getNextABRAutoLevel() {
        const {fragCurrent: e, partCurrent: t, hls: n} = this
          , {maxAutoLevel: s, config: r, minAutoLevel: o} = n
          , a = t ? t.duration : e ? e.duration : 0
          , l = this.getBwEstimate()
          , c = this.getStarvationDelay();
        let u = r.abrBandWidthFactor
          , d = r.abrBandWidthUpFactor;
        if (c) {
            const m = this.findBestLevel(l, o, s, c, 0, u, d);
            if (m >= 0)
                return m
        }
        let f = a ? Math.min(a, r.maxStarvationDelay) : r.maxStarvationDelay;
        if (!c) {
            const m = this.bitrateTestDelay;
            m && (f = (a ? Math.min(a, r.maxLoadingDelay) : r.maxLoadingDelay) - m,
            de.info(`[abr] bitrate test took ${Math.round(1e3 * m)}ms, set first fragment max fetchDuration to ${Math.round(1e3 * f)} ms`),
            u = d = 1)
        }
        const h = this.findBestLevel(l, o, s, c, f, u, d);
        if (de.info(`[abr] ${c ? "rebuffering expected" : "buffer is empty"}, optimal quality level ${h}`),
        h > -1)
            return h;
        const p = n.levels[o]
          , g = n.levels[n.loadLevel];
        return (p == null ? void 0 : p.bitrate) < (g == null ? void 0 : g.bitrate) ? o : n.loadLevel
    }
    getStarvationDelay() {
        const e = this.hls
          , t = e.media;
        if (!t)
            return 1 / 0;
        const n = t && t.playbackRate !== 0 ? Math.abs(t.playbackRate) : 1
          , s = e.mainForwardBufferInfo;
        return (s ? s.len : 0) / n
    }
    getBwEstimate() {
        return this.bwEstimator.canEstimate() ? this.bwEstimator.getEstimate() : this.hls.config.abrEwmaDefaultEstimate
    }
    findBestLevel(e, t, n, s, r, o, a) {
        var l;
        const c = s + r
          , u = this.lastLoadedFragLevel
          , d = u === -1 ? this.hls.firstLevel : u
          , {fragCurrent: f, partCurrent: h} = this
          , {levels: p, allAudioTracks: g, loadLevel: m, config: v} = this.hls;
        if (p.length === 1)
            return 0;
        const _ = p[d]
          , y = !!(_ != null && (l = _.details) != null && l.live)
          , b = m === -1 || u === -1;
        let S, C = "SDR", M = (_ == null ? void 0 : _.frameRate) || 0;
        const {audioPreference: L, videoPreference: T} = v
          , A = this.audioTracksByGroup || (this.audioTracksByGroup = rz(g));
        if (b) {
            if (this.firstSelection !== -1)
                return this.firstSelection;
            const G = this.codecTiers || (this.codecTiers = oz(p, A, t, n))
              , H = sz(G, C, e, L, T)
              , {codecSet: X, videoRanges: K, minFramerate: ce, minBitrate: ue, preferHDR: Ie} = H;
            S = X,
            C = Ie ? K[K.length - 1] : K[0],
            M = ce,
            e = Math.max(e, ue),
            de.log(`[abr] picked start tier ${JSON.stringify(H)}`)
        } else
            S = _ == null ? void 0 : _.codecSet,
            C = _ == null ? void 0 : _.videoRange;
        const k = h ? h.duration : f ? f.duration : 0
          , D = this.bwEstimator.getEstimateTTFB() / 1e3
          , F = [];
        for (let G = n; G >= t; G--) {
            var z;
            const H = p[G]
              , X = G > d;
            if (!H)
                continue;
            if (v.useMediaCapabilities && !H.supportedResult && !H.supportedPromise) {
                const se = navigator.mediaCapabilities;
                typeof (se == null ? void 0 : se.decodingInfo) == "function" && QH(H, A, C, M, e, L) ? (H.supportedPromise = ez(H, A, se),
                H.supportedPromise.then(Se => {
                    if (!this.hls)
                        return;
                    H.supportedResult = Se;
                    const be = this.hls.levels
                      , q = be.indexOf(H);
                    Se.error ? de.warn(`[abr] MediaCapabilities decodingInfo error: "${Se.error}" for level ${q} ${JSON.stringify(Se)}`) : Se.supported || (de.warn(`[abr] Unsupported MediaCapabilities decodingInfo result for level ${q} ${JSON.stringify(Se)}`),
                    q > -1 && be.length > 1 && (de.log(`[abr] Removing unsupported level ${q}`),
                    this.hls.removeLevel(q)))
                }
                )) : H.supportedResult = oM
            }
            if (S && H.codecSet !== S || C && H.videoRange !== C || X && M > H.frameRate || !X && M > 0 && M < H.frameRate || H.supportedResult && !((z = H.supportedResult.decodingInfoResults) != null && z[0].smooth)) {
                F.push(G);
                continue
            }
            const K = H.details
              , ce = (h ? K == null ? void 0 : K.partTarget : K == null ? void 0 : K.averagetargetduration) || k;
            let ue;
            X ? ue = a * e : ue = o * e;
            const Ie = k && s >= k * 2 && r === 0 ? p[G].averageBitrate : p[G].maxBitrate
              , ke = this.getTimeToLoadFrag(D, ue, Ie * ce, K === void 0);
            if (ue >= Ie && (G === u || H.loadError === 0 && H.fragmentError === 0) && (ke <= D || !pt(ke) || y && !this.bitrateTestDelay || ke < c)) {
                const se = this.forcedAutoLevel;
                return G !== m && (se === -1 || se !== m) && (F.length && de.trace(`[abr] Skipped level(s) ${F.join(",")} of ${n} max with CODECS and VIDEO-RANGE:"${p[F[0]].codecs}" ${p[F[0]].videoRange}; not compatible with "${_.codecs}" ${C}`),
                de.info(`[abr] switch candidate:${d}->${G} adjustedbw(${Math.round(ue)})-bitrate=${Math.round(ue - Ie)} ttfb:${D.toFixed(1)} avgDuration:${ce.toFixed(1)} maxFetchDuration:${c.toFixed(1)} fetchDuration:${ke.toFixed(1)} firstSelection:${b} codecSet:${S} videoRange:${C} hls.loadLevel:${m}`)),
                b && (this.firstSelection = G),
                G
            }
        }
        return -1
    }
    set nextAutoLevel(e) {
        const {maxAutoLevel: t, minAutoLevel: n} = this.hls
          , s = Math.min(Math.max(e, n), t);
        this._nextAutoLevel !== s && (this.nextAutoLevelKey = "",
        this._nextAutoLevel = s)
    }
}
class uz {
    constructor() {
        this._boundTick = void 0,
        this._tickTimer = null,
        this._tickInterval = null,
        this._tickCallCount = 0,
        this._boundTick = this.tick.bind(this)
    }
    destroy() {
        this.onHandlerDestroying(),
        this.onHandlerDestroyed()
    }
    onHandlerDestroying() {
        this.clearNextTick(),
        this.clearInterval()
    }
    onHandlerDestroyed() {}
    hasInterval() {
        return !!this._tickInterval
    }
    hasNextTick() {
        return !!this._tickTimer
    }
    setInterval(e) {
        return this._tickInterval ? !1 : (this._tickCallCount = 0,
        this._tickInterval = self.setInterval(this._boundTick, e),
        !0)
    }
    clearInterval() {
        return this._tickInterval ? (self.clearInterval(this._tickInterval),
        this._tickInterval = null,
        !0) : !1
    }
    clearNextTick() {
        return this._tickTimer ? (self.clearTimeout(this._tickTimer),
        this._tickTimer = null,
        !0) : !1
    }
    tick() {
        this._tickCallCount++,
        this._tickCallCount === 1 && (this.doTick(),
        this._tickCallCount > 1 && this.tickImmediate(),
        this._tickCallCount = 0)
    }
    tickImmediate() {
        this.clearNextTick(),
        this._tickTimer = self.setTimeout(this._boundTick, 0)
    }
    doTick() {}
}
var gi = {
    NOT_LOADED: "NOT_LOADED",
    APPENDING: "APPENDING",
    PARTIAL: "PARTIAL",
    OK: "OK"
};
class dz {
    constructor(e) {
        this.activePartLists = Object.create(null),
        this.endListFragments = Object.create(null),
        this.fragments = Object.create(null),
        this.timeRanges = Object.create(null),
        this.bufferPadding = .2,
        this.hls = void 0,
        this.hasGaps = !1,
        this.hls = e,
        this._registerListeners()
    }
    _registerListeners() {
        const {hls: e} = this;
        e.on(P.BUFFER_APPENDED, this.onBufferAppended, this),
        e.on(P.FRAG_BUFFERED, this.onFragBuffered, this),
        e.on(P.FRAG_LOADED, this.onFragLoaded, this)
    }
    _unregisterListeners() {
        const {hls: e} = this;
        e.off(P.BUFFER_APPENDED, this.onBufferAppended, this),
        e.off(P.FRAG_BUFFERED, this.onFragBuffered, this),
        e.off(P.FRAG_LOADED, this.onFragLoaded, this)
    }
    destroy() {
        this._unregisterListeners(),
        this.fragments = this.activePartLists = this.endListFragments = this.timeRanges = null
    }
    getAppendedFrag(e, t) {
        const n = this.activePartLists[t];
        if (n)
            for (let s = n.length; s--; ) {
                const r = n[s];
                if (!r)
                    break;
                const o = r.end;
                if (r.start <= e && o !== null && e <= o)
                    return r
            }
        return this.getBufferedFrag(e, t)
    }
    getBufferedFrag(e, t) {
        const {fragments: n} = this
          , s = Object.keys(n);
        for (let r = s.length; r--; ) {
            const o = n[s[r]];
            if ((o == null ? void 0 : o.body.type) === t && o.buffered) {
                const a = o.body;
                if (a.start <= e && e <= a.end)
                    return a
            }
        }
        return null
    }
    detectEvictedFragments(e, t, n, s) {
        this.timeRanges && (this.timeRanges[e] = t);
        const r = (s == null ? void 0 : s.fragment.sn) || -1;
        Object.keys(this.fragments).forEach(o => {
            const a = this.fragments[o];
            if (!a || r >= a.body.sn)
                return;
            if (!a.buffered && !a.loaded) {
                a.body.type === n && this.removeFragment(a.body);
                return
            }
            const l = a.range[e];
            !l || l.time.some(c => {
                const u = !this.isTimeBuffered(c.startPTS, c.endPTS, t);
                return u && this.removeFragment(a.body),
                u
            }
            )
        }
        )
    }
    detectPartialFragments(e) {
        const t = this.timeRanges
          , {frag: n, part: s} = e;
        if (!t || n.sn === "initSegment")
            return;
        const r = Yl(n)
          , o = this.fragments[r];
        if (!o || o.buffered && n.gap)
            return;
        const a = !n.relurl;
        Object.keys(t).forEach(l => {
            const c = n.elementaryStreams[l];
            if (!c)
                return;
            const u = t[l]
              , d = a || c.partial === !0;
            o.range[l] = this.getBufferedTimes(n, s, d, u)
        }
        ),
        o.loaded = null,
        Object.keys(o.range).length ? (o.buffered = !0,
        (o.body.endList = n.endList || o.body.endList) && (this.endListFragments[o.body.type] = o),
        Ff(o) || this.removeParts(n.sn - 1, n.type)) : this.removeFragment(o.body)
    }
    removeParts(e, t) {
        const n = this.activePartLists[t];
        !n || (this.activePartLists[t] = n.filter(s => s.fragment.sn >= e))
    }
    fragBuffered(e, t) {
        const n = Yl(e);
        let s = this.fragments[n];
        !s && t && (s = this.fragments[n] = {
            body: e,
            appendedPTS: null,
            loaded: null,
            buffered: !1,
            range: Object.create(null)
        },
        e.gap && (this.hasGaps = !0)),
        s && (s.loaded = null,
        s.buffered = !0)
    }
    getBufferedTimes(e, t, n, s) {
        const r = {
            time: [],
            partial: n
        }
          , o = e.start
          , a = e.end
          , l = e.minEndPTS || a
          , c = e.maxStartPTS || o;
        for (let u = 0; u < s.length; u++) {
            const d = s.start(u) - this.bufferPadding
              , f = s.end(u) + this.bufferPadding;
            if (c >= d && l <= f) {
                r.time.push({
                    startPTS: Math.max(o, s.start(u)),
                    endPTS: Math.min(a, s.end(u))
                });
                break
            } else if (o < f && a > d) {
                const h = Math.max(o, s.start(u))
                  , p = Math.min(a, s.end(u));
                p > h && (r.partial = !0,
                r.time.push({
                    startPTS: h,
                    endPTS: p
                }))
            } else if (a <= d)
                break
        }
        return r
    }
    getPartialFragment(e) {
        let t = null, n, s, r, o = 0;
        const {bufferPadding: a, fragments: l} = this;
        return Object.keys(l).forEach(c => {
            const u = l[c];
            !u || Ff(u) && (s = u.body.start - a,
            r = u.body.end + a,
            e >= s && e <= r && (n = Math.min(e - s, r - e),
            o <= n && (t = u.body,
            o = n)))
        }
        ),
        t
    }
    isEndListAppended(e) {
        const t = this.endListFragments[e];
        return t !== void 0 && (t.buffered || Ff(t))
    }
    getState(e) {
        const t = Yl(e)
          , n = this.fragments[t];
        return n ? n.buffered ? Ff(n) ? gi.PARTIAL : gi.OK : gi.APPENDING : gi.NOT_LOADED
    }
    isTimeBuffered(e, t, n) {
        let s, r;
        for (let o = 0; o < n.length; o++) {
            if (s = n.start(o) - this.bufferPadding,
            r = n.end(o) + this.bufferPadding,
            e >= s && t <= r)
                return !0;
            if (t <= s)
                return !1
        }
        return !1
    }
    onFragLoaded(e, t) {
        const {frag: n, part: s} = t;
        if (n.sn === "initSegment" || n.bitrateTest)
            return;
        const r = s ? null : t
          , o = Yl(n);
        this.fragments[o] = {
            body: n,
            appendedPTS: null,
            loaded: r,
            buffered: !1,
            range: Object.create(null)
        }
    }
    onBufferAppended(e, t) {
        const {frag: n, part: s, timeRanges: r} = t;
        if (n.sn === "initSegment")
            return;
        const o = n.type;
        if (s) {
            let a = this.activePartLists[o];
            a || (this.activePartLists[o] = a = []),
            a.push(s)
        }
        this.timeRanges = r,
        Object.keys(r).forEach(a => {
            const l = r[a];
            this.detectEvictedFragments(a, l, o, s)
        }
        )
    }
    onFragBuffered(e, t) {
        this.detectPartialFragments(t)
    }
    hasFragment(e) {
        const t = Yl(e);
        return !!this.fragments[t]
    }
    hasParts(e) {
        var t;
        return !!((t = this.activePartLists[e]) != null && t.length)
    }
    removeFragmentsInRange(e, t, n, s, r) {
        s && !this.hasGaps || Object.keys(this.fragments).forEach(o => {
            const a = this.fragments[o];
            if (!a)
                return;
            const l = a.body;
            l.type !== n || s && !l.gap || l.start < t && l.end > e && (a.buffered || r) && this.removeFragment(l)
        }
        )
    }
    removeFragment(e) {
        const t = Yl(e);
        e.stats.loaded = 0,
        e.clearElementaryStreamInfo();
        const n = this.activePartLists[e.type];
        if (n) {
            const s = e.sn;
            this.activePartLists[e.type] = n.filter(r => r.fragment.sn !== s)
        }
        delete this.fragments[t],
        e.endList && delete this.endListFragments[e.type]
    }
    removeAllFragments() {
        this.fragments = Object.create(null),
        this.endListFragments = Object.create(null),
        this.activePartLists = Object.create(null),
        this.hasGaps = !1
    }
}
function Ff(i) {
    var e, t, n;
    return i.buffered && (i.body.gap || ((e = i.range.video) == null ? void 0 : e.partial) || ((t = i.range.audio) == null ? void 0 : t.partial) || ((n = i.range.audiovideo) == null ? void 0 : n.partial))
}
function Yl(i) {
    return `${i.type}_${i.level}_${i.sn}`
}
const fz = {
    length: 0,
    start: () => 0,
    end: () => 0
};
class An {
    static isBuffered(e, t) {
        try {
            if (e) {
                const n = An.getBuffered(e);
                for (let s = 0; s < n.length; s++)
                    if (t >= n.start(s) && t <= n.end(s))
                        return !0
            }
        } catch {}
        return !1
    }
    static bufferInfo(e, t, n) {
        try {
            if (e) {
                const s = An.getBuffered(e)
                  , r = [];
                let o;
                for (o = 0; o < s.length; o++)
                    r.push({
                        start: s.start(o),
                        end: s.end(o)
                    });
                return this.bufferedInfo(r, t, n)
            }
        } catch {}
        return {
            len: 0,
            start: t,
            end: t,
            nextStart: void 0
        }
    }
    static bufferedInfo(e, t, n) {
        t = Math.max(0, t),
        e.sort(function(c, u) {
            const d = c.start - u.start;
            return d || u.end - c.end
        });
        let s = [];
        if (n)
            for (let c = 0; c < e.length; c++) {
                const u = s.length;
                if (u) {
                    const d = s[u - 1].end;
                    e[c].start - d < n ? e[c].end > d && (s[u - 1].end = e[c].end) : s.push(e[c])
                } else
                    s.push(e[c])
            }
        else
            s = e;
        let r = 0, o, a = t, l = t;
        for (let c = 0; c < s.length; c++) {
            const u = s[c].start
              , d = s[c].end;
            if (t + n >= u && t < d)
                a = u,
                l = d,
                r = l - t;
            else if (t + n < u) {
                o = u;
                break
            }
        }
        return {
            len: r,
            start: a || 0,
            end: l || 0,
            nextStart: o
        }
    }
    static getBuffered(e) {
        try {
            return e.buffered
        } catch (t) {
            return de.log("failed to get media.buffered", t),
            fz
        }
    }
}
class ix {
    constructor(e, t, n, s=0, r=-1, o=!1) {
        this.level = void 0,
        this.sn = void 0,
        this.part = void 0,
        this.id = void 0,
        this.size = void 0,
        this.partial = void 0,
        this.transmuxing = Of(),
        this.buffering = {
            audio: Of(),
            video: Of(),
            audiovideo: Of()
        },
        this.level = e,
        this.sn = t,
        this.id = n,
        this.size = s,
        this.part = r,
        this.partial = o
    }
}
function Of() {
    return {
        start: 0,
        executeStart: 0,
        executeEnd: 0,
        end: 0
    }
}
function Rh(i, e) {
    for (let n = 0, s = i.length; n < s; n++) {
        var t;
        if (((t = i[n]) == null ? void 0 : t.cc) === e)
            return i[n]
    }
    return null
}
function hz(i, e, t) {
    return !!(e && (t.endCC > t.startCC || i && i.cc < t.startCC))
}
function pz(i, e) {
    const t = i.fragments
      , n = e.fragments;
    if (!n.length || !t.length) {
        de.log("No fragments to align");
        return
    }
    const s = Rh(t, n[0].cc);
    if (!s || s && !s.startPTS) {
        de.log("No frag in previous level to align on");
        return
    }
    return s
}
function lS(i, e) {
    if (i) {
        const t = i.start + e;
        i.start = i.startPTS = t,
        i.endPTS = t + i.duration
    }
}
function aM(i, e) {
    const t = e.fragments;
    for (let n = 0, s = t.length; n < s; n++)
        lS(t[n], i);
    e.fragmentHint && lS(e.fragmentHint, i),
    e.alignedSliding = !0
}
function mz(i, e, t) {
    !e || (gz(i, t, e),
    !t.alignedSliding && e && Pp(t, e),
    !t.alignedSliding && e && !t.skippedSegments && nM(e, t))
}
function gz(i, e, t) {
    if (hz(i, t, e)) {
        const n = pz(t, e);
        n && pt(n.start) && (de.log(`Adjusting PTS using last level due to CC increase within current level ${e.url}`),
        aM(n.start, e))
    }
}
function Pp(i, e) {
    if (!i.hasProgramDateTime || !e.hasProgramDateTime)
        return;
    const t = i.fragments
      , n = e.fragments;
    if (!t.length || !n.length)
        return;
    let s, r;
    const o = Math.min(e.endCC, i.endCC);
    e.startCC < o && i.startCC < o && (s = Rh(n, o),
    r = Rh(t, o)),
    (!s || !r) && (s = n[Math.floor(n.length / 2)],
    r = Rh(t, s.cc) || t[Math.floor(t.length / 2)]);
    const a = s.programDateTime
      , l = r.programDateTime;
    if (!a || !l)
        return;
    const c = (l - a) / 1e3 - (r.start - s.start);
    aM(c, i)
}
const cS = Math.pow(2, 17);
class vz {
    constructor(e) {
        this.config = void 0,
        this.loader = null,
        this.partLoadTimeout = -1,
        this.config = e
    }
    destroy() {
        this.loader && (this.loader.destroy(),
        this.loader = null)
    }
    abort() {
        this.loader && this.loader.abort()
    }
    load(e, t) {
        const n = e.url;
        if (!n)
            return Promise.reject(new _o({
                type: Ut.NETWORK_ERROR,
                details: Ae.FRAG_LOAD_ERROR,
                fatal: !1,
                frag: e,
                error: new Error(`Fragment does not have a ${n ? "part list" : "url"}`),
                networkDetails: null
            }));
        this.abort();
        const s = this.config
          , r = s.fLoader
          , o = s.loader;
        return new Promise( (a, l) => {
            if (this.loader && this.loader.destroy(),
            e.gap)
                if (e.tagList.some(h => h[0] === "GAP")) {
                    l(dS(e));
                    return
                } else
                    e.gap = !1;
            const c = this.loader = e.loader = r ? new r(s) : new o(s)
              , u = uS(e)
              , d = rS(s.fragLoadPolicy.default)
              , f = {
                loadPolicy: d,
                timeout: d.maxLoadTimeMs,
                maxRetry: 0,
                retryDelay: 0,
                maxRetryDelay: 0,
                highWaterMark: e.sn === "initSegment" ? 1 / 0 : cS
            };
            e.stats = c.stats,
            c.load(u, f, {
                onSuccess: (h, p, g, m) => {
                    this.resetLoader(e, c);
                    let v = h.data;
                    g.resetIV && e.decryptdata && (e.decryptdata.iv = new Uint8Array(v.slice(0, 16)),
                    v = v.slice(16)),
                    a({
                        frag: e,
                        part: null,
                        payload: v,
                        networkDetails: m
                    })
                }
                ,
                onError: (h, p, g, m) => {
                    this.resetLoader(e, c),
                    l(new _o({
                        type: Ut.NETWORK_ERROR,
                        details: Ae.FRAG_LOAD_ERROR,
                        fatal: !1,
                        frag: e,
                        response: yi({
                            url: n,
                            data: void 0
                        }, h),
                        error: new Error(`HTTP Error ${h.code} ${h.text}`),
                        networkDetails: g,
                        stats: m
                    }))
                }
                ,
                onAbort: (h, p, g) => {
                    this.resetLoader(e, c),
                    l(new _o({
                        type: Ut.NETWORK_ERROR,
                        details: Ae.INTERNAL_ABORTED,
                        fatal: !1,
                        frag: e,
                        error: new Error("Aborted"),
                        networkDetails: g,
                        stats: h
                    }))
                }
                ,
                onTimeout: (h, p, g) => {
                    this.resetLoader(e, c),
                    l(new _o({
                        type: Ut.NETWORK_ERROR,
                        details: Ae.FRAG_LOAD_TIMEOUT,
                        fatal: !1,
                        frag: e,
                        error: new Error(`Timeout after ${f.timeout}ms`),
                        networkDetails: g,
                        stats: h
                    }))
                }
                ,
                onProgress: (h, p, g, m) => {
                    t && t({
                        frag: e,
                        part: null,
                        payload: g,
                        networkDetails: m
                    })
                }
            })
        }
        )
    }
    loadPart(e, t, n) {
        this.abort();
        const s = this.config
          , r = s.fLoader
          , o = s.loader;
        return new Promise( (a, l) => {
            if (this.loader && this.loader.destroy(),
            e.gap || t.gap) {
                l(dS(e, t));
                return
            }
            const c = this.loader = e.loader = r ? new r(s) : new o(s)
              , u = uS(e, t)
              , d = rS(s.fragLoadPolicy.default)
              , f = {
                loadPolicy: d,
                timeout: d.maxLoadTimeMs,
                maxRetry: 0,
                retryDelay: 0,
                maxRetryDelay: 0,
                highWaterMark: cS
            };
            t.stats = c.stats,
            c.load(u, f, {
                onSuccess: (h, p, g, m) => {
                    this.resetLoader(e, c),
                    this.updateStatsFromPart(e, t);
                    const v = {
                        frag: e,
                        part: t,
                        payload: h.data,
                        networkDetails: m
                    };
                    n(v),
                    a(v)
                }
                ,
                onError: (h, p, g, m) => {
                    this.resetLoader(e, c),
                    l(new _o({
                        type: Ut.NETWORK_ERROR,
                        details: Ae.FRAG_LOAD_ERROR,
                        fatal: !1,
                        frag: e,
                        part: t,
                        response: yi({
                            url: u.url,
                            data: void 0
                        }, h),
                        error: new Error(`HTTP Error ${h.code} ${h.text}`),
                        networkDetails: g,
                        stats: m
                    }))
                }
                ,
                onAbort: (h, p, g) => {
                    e.stats.aborted = t.stats.aborted,
                    this.resetLoader(e, c),
                    l(new _o({
                        type: Ut.NETWORK_ERROR,
                        details: Ae.INTERNAL_ABORTED,
                        fatal: !1,
                        frag: e,
                        part: t,
                        error: new Error("Aborted"),
                        networkDetails: g,
                        stats: h
                    }))
                }
                ,
                onTimeout: (h, p, g) => {
                    this.resetLoader(e, c),
                    l(new _o({
                        type: Ut.NETWORK_ERROR,
                        details: Ae.FRAG_LOAD_TIMEOUT,
                        fatal: !1,
                        frag: e,
                        part: t,
                        error: new Error(`Timeout after ${f.timeout}ms`),
                        networkDetails: g,
                        stats: h
                    }))
                }
            })
        }
        )
    }
    updateStatsFromPart(e, t) {
        const n = e.stats
          , s = t.stats
          , r = s.total;
        if (n.loaded += s.loaded,
        r) {
            const l = Math.round(e.duration / t.duration)
              , c = Math.min(Math.round(n.loaded / r), l)
              , d = (l - c) * Math.round(n.loaded / c);
            n.total = n.loaded + d
        } else
            n.total = Math.max(n.loaded, n.total);
        const o = n.loading
          , a = s.loading;
        o.start ? o.first += a.first - a.start : (o.start = a.start,
        o.first = a.first),
        o.end = a.end
    }
    resetLoader(e, t) {
        e.loader = null,
        this.loader === t && (self.clearTimeout(this.partLoadTimeout),
        this.loader = null),
        t.destroy()
    }
}
function uS(i, e=null) {
    const t = e || i
      , n = {
        frag: i,
        part: e,
        responseType: "arraybuffer",
        url: t.url,
        headers: {},
        rangeStart: 0,
        rangeEnd: 0
    }
      , s = t.byteRangeStartOffset
      , r = t.byteRangeEndOffset;
    if (pt(s) && pt(r)) {
        var o;
        let a = s
          , l = r;
        if (i.sn === "initSegment" && ((o = i.decryptdata) == null ? void 0 : o.method) === "AES-128") {
            const c = r - s;
            c % 16 && (l = r + (16 - c % 16)),
            s !== 0 && (n.resetIV = !0,
            a = s - 16)
        }
        n.rangeStart = a,
        n.rangeEnd = l
    }
    return n
}
function dS(i, e) {
    const t = new Error(`GAP ${i.gap ? "tag" : "attribute"} found`)
      , n = {
        type: Ut.MEDIA_ERROR,
        details: Ae.FRAG_GAP,
        fatal: !1,
        frag: i,
        error: t,
        networkDetails: null
    };
    return e && (n.part = e),
    (e || i).stats.aborted = !0,
    new _o(n)
}
class _o extends Error {
    constructor(e) {
        super(e.error.message),
        this.data = void 0,
        this.data = e
    }
}
class _z {
    constructor(e, t) {
        this.subtle = void 0,
        this.aesIV = void 0,
        this.subtle = e,
        this.aesIV = t
    }
    decrypt(e, t) {
        return this.subtle.decrypt({
            name: "AES-CBC",
            iv: this.aesIV
        }, t, e)
    }
}
class xz {
    constructor(e, t) {
        this.subtle = void 0,
        this.key = void 0,
        this.subtle = e,
        this.key = t
    }
    expandKey() {
        return this.subtle.importKey("raw", this.key, {
            name: "AES-CBC"
        }, !1, ["encrypt", "decrypt"])
    }
}
function yz(i) {
    const e = i.byteLength
      , t = e && new DataView(i.buffer).getUint8(e - 1);
    return t ? Sl(i, 0, e - t) : i
}
class bz {
    constructor() {
        this.rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54],
        this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)],
        this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)],
        this.sBox = new Uint32Array(256),
        this.invSBox = new Uint32Array(256),
        this.key = new Uint32Array(0),
        this.ksRows = 0,
        this.keySize = 0,
        this.keySchedule = void 0,
        this.invKeySchedule = void 0,
        this.initTable()
    }
    uint8ArrayToUint32Array_(e) {
        const t = new DataView(e)
          , n = new Uint32Array(4);
        for (let s = 0; s < 4; s++)
            n[s] = t.getUint32(s * 4);
        return n
    }
    initTable() {
        const e = this.sBox
          , t = this.invSBox
          , n = this.subMix
          , s = n[0]
          , r = n[1]
          , o = n[2]
          , a = n[3]
          , l = this.invSubMix
          , c = l[0]
          , u = l[1]
          , d = l[2]
          , f = l[3]
          , h = new Uint32Array(256);
        let p = 0
          , g = 0
          , m = 0;
        for (m = 0; m < 256; m++)
            m < 128 ? h[m] = m << 1 : h[m] = m << 1 ^ 283;
        for (m = 0; m < 256; m++) {
            let v = g ^ g << 1 ^ g << 2 ^ g << 3 ^ g << 4;
            v = v >>> 8 ^ v & 255 ^ 99,
            e[p] = v,
            t[v] = p;
            const _ = h[p]
              , y = h[_]
              , b = h[y];
            let S = h[v] * 257 ^ v * 16843008;
            s[p] = S << 24 | S >>> 8,
            r[p] = S << 16 | S >>> 16,
            o[p] = S << 8 | S >>> 24,
            a[p] = S,
            S = b * 16843009 ^ y * 65537 ^ _ * 257 ^ p * 16843008,
            c[v] = S << 24 | S >>> 8,
            u[v] = S << 16 | S >>> 16,
            d[v] = S << 8 | S >>> 24,
            f[v] = S,
            p ? (p = _ ^ h[h[h[b ^ _]]],
            g ^= h[h[g]]) : p = g = 1
        }
    }
    expandKey(e) {
        const t = this.uint8ArrayToUint32Array_(e);
        let n = !0
          , s = 0;
        for (; s < t.length && n; )
            n = t[s] === this.key[s],
            s++;
        if (n)
            return;
        this.key = t;
        const r = this.keySize = t.length;
        if (r !== 4 && r !== 6 && r !== 8)
            throw new Error("Invalid aes key size=" + r);
        const o = this.ksRows = (r + 6 + 1) * 4;
        let a, l;
        const c = this.keySchedule = new Uint32Array(o)
          , u = this.invKeySchedule = new Uint32Array(o)
          , d = this.sBox
          , f = this.rcon
          , h = this.invSubMix
          , p = h[0]
          , g = h[1]
          , m = h[2]
          , v = h[3];
        let _, y;
        for (a = 0; a < o; a++) {
            if (a < r) {
                _ = c[a] = t[a];
                continue
            }
            y = _,
            a % r === 0 ? (y = y << 8 | y >>> 24,
            y = d[y >>> 24] << 24 | d[y >>> 16 & 255] << 16 | d[y >>> 8 & 255] << 8 | d[y & 255],
            y ^= f[a / r | 0] << 24) : r > 6 && a % r === 4 && (y = d[y >>> 24] << 24 | d[y >>> 16 & 255] << 16 | d[y >>> 8 & 255] << 8 | d[y & 255]),
            c[a] = _ = (c[a - r] ^ y) >>> 0
        }
        for (l = 0; l < o; l++)
            a = o - l,
            l & 3 ? y = c[a] : y = c[a - 4],
            l < 4 || a <= 4 ? u[l] = y : u[l] = p[d[y >>> 24]] ^ g[d[y >>> 16 & 255]] ^ m[d[y >>> 8 & 255]] ^ v[d[y & 255]],
            u[l] = u[l] >>> 0
    }
    networkToHostOrderSwap(e) {
        return e << 24 | (e & 65280) << 8 | (e & 16711680) >> 8 | e >>> 24
    }
    decrypt(e, t, n) {
        const s = this.keySize + 6
          , r = this.invKeySchedule
          , o = this.invSBox
          , a = this.invSubMix
          , l = a[0]
          , c = a[1]
          , u = a[2]
          , d = a[3]
          , f = this.uint8ArrayToUint32Array_(n);
        let h = f[0]
          , p = f[1]
          , g = f[2]
          , m = f[3];
        const v = new Int32Array(e)
          , _ = new Int32Array(v.length);
        let y, b, S, C, M, L, T, A, k, D, F, z, G, H;
        const X = this.networkToHostOrderSwap;
        for (; t < v.length; ) {
            for (k = X(v[t]),
            D = X(v[t + 1]),
            F = X(v[t + 2]),
            z = X(v[t + 3]),
            M = k ^ r[0],
            L = z ^ r[1],
            T = F ^ r[2],
            A = D ^ r[3],
            G = 4,
            H = 1; H < s; H++)
                y = l[M >>> 24] ^ c[L >> 16 & 255] ^ u[T >> 8 & 255] ^ d[A & 255] ^ r[G],
                b = l[L >>> 24] ^ c[T >> 16 & 255] ^ u[A >> 8 & 255] ^ d[M & 255] ^ r[G + 1],
                S = l[T >>> 24] ^ c[A >> 16 & 255] ^ u[M >> 8 & 255] ^ d[L & 255] ^ r[G + 2],
                C = l[A >>> 24] ^ c[M >> 16 & 255] ^ u[L >> 8 & 255] ^ d[T & 255] ^ r[G + 3],
                M = y,
                L = b,
                T = S,
                A = C,
                G = G + 4;
            y = o[M >>> 24] << 24 ^ o[L >> 16 & 255] << 16 ^ o[T >> 8 & 255] << 8 ^ o[A & 255] ^ r[G],
            b = o[L >>> 24] << 24 ^ o[T >> 16 & 255] << 16 ^ o[A >> 8 & 255] << 8 ^ o[M & 255] ^ r[G + 1],
            S = o[T >>> 24] << 24 ^ o[A >> 16 & 255] << 16 ^ o[M >> 8 & 255] << 8 ^ o[L & 255] ^ r[G + 2],
            C = o[A >>> 24] << 24 ^ o[M >> 16 & 255] << 16 ^ o[L >> 8 & 255] << 8 ^ o[T & 255] ^ r[G + 3],
            _[t] = X(y ^ h),
            _[t + 1] = X(C ^ p),
            _[t + 2] = X(S ^ g),
            _[t + 3] = X(b ^ m),
            h = k,
            p = D,
            g = F,
            m = z,
            t = t + 4
        }
        return _.buffer
    }
}
const Sz = 16;
class sx {
    constructor(e, {removePKCS7Padding: t=!0}={}) {
        if (this.logEnabled = !0,
        this.removePKCS7Padding = void 0,
        this.subtle = null,
        this.softwareDecrypter = null,
        this.key = null,
        this.fastAesKey = null,
        this.remainderData = null,
        this.currentIV = null,
        this.currentResult = null,
        this.useSoftware = void 0,
        this.useSoftware = e.enableSoftwareAES,
        this.removePKCS7Padding = t,
        t)
            try {
                const n = self.crypto;
                n && (this.subtle = n.subtle || n.webkitSubtle)
            } catch {}
        this.useSoftware = !this.subtle
    }
    destroy() {
        this.subtle = null,
        this.softwareDecrypter = null,
        this.key = null,
        this.fastAesKey = null,
        this.remainderData = null,
        this.currentIV = null,
        this.currentResult = null
    }
    isSync() {
        return this.useSoftware
    }
    flush() {
        const {currentResult: e, remainderData: t} = this;
        if (!e || t)
            return this.reset(),
            null;
        const n = new Uint8Array(e);
        return this.reset(),
        this.removePKCS7Padding ? yz(n) : n
    }
    reset() {
        this.currentResult = null,
        this.currentIV = null,
        this.remainderData = null,
        this.softwareDecrypter && (this.softwareDecrypter = null)
    }
    decrypt(e, t, n) {
        return this.useSoftware ? new Promise( (s, r) => {
            this.softwareDecrypt(new Uint8Array(e), t, n);
            const o = this.flush();
            o ? s(o.buffer) : r(new Error("[softwareDecrypt] Failed to decrypt data"))
        }
        ) : this.webCryptoDecrypt(new Uint8Array(e), t, n)
    }
    softwareDecrypt(e, t, n) {
        const {currentIV: s, currentResult: r, remainderData: o} = this;
        this.logOnce("JS AES decrypt"),
        o && (e = qs(o, e),
        this.remainderData = null);
        const a = this.getValidChunk(e);
        if (!a.length)
            return null;
        s && (n = s);
        let l = this.softwareDecrypter;
        l || (l = this.softwareDecrypter = new bz),
        l.expandKey(t);
        const c = r;
        return this.currentResult = l.decrypt(a.buffer, 0, n),
        this.currentIV = Sl(a, -16).buffer,
        c || null
    }
    webCryptoDecrypt(e, t, n) {
        if (this.key !== t || !this.fastAesKey) {
            if (!this.subtle)
                return Promise.resolve(this.onWebCryptoError(e, t, n));
            this.key = t,
            this.fastAesKey = new xz(this.subtle,t)
        }
        return this.fastAesKey.expandKey().then(s => this.subtle ? (this.logOnce("WebCrypto AES decrypt"),
        new _z(this.subtle,new Uint8Array(n)).decrypt(e.buffer, s)) : Promise.reject(new Error("web crypto not initialized"))).catch(s => (de.warn(`[decrypter]: WebCrypto Error, disable WebCrypto API, ${s.name}: ${s.message}`),
        this.onWebCryptoError(e, t, n)))
    }
    onWebCryptoError(e, t, n) {
        this.useSoftware = !0,
        this.logEnabled = !0,
        this.softwareDecrypt(e, t, n);
        const s = this.flush();
        if (s)
            return s.buffer;
        throw new Error("WebCrypto and softwareDecrypt: failed to decrypt data")
    }
    getValidChunk(e) {
        let t = e;
        const n = e.length - e.length % Sz;
        return n !== e.length && (t = Sl(e, 0, n),
        this.remainderData = Sl(e, n)),
        t
    }
    logOnce(e) {
        !this.logEnabled || (de.log(`[decrypter]: ${e}`),
        this.logEnabled = !1)
    }
}
const Ez = {
    toString: function(i) {
        let e = "";
        const t = i.length;
        for (let n = 0; n < t; n++)
            e += `[${i.start(n).toFixed(3)}-${i.end(n).toFixed(3)}]`;
        return e
    }
}
  , Ve = {
    STOPPED: "STOPPED",
    IDLE: "IDLE",
    KEY_LOADING: "KEY_LOADING",
    FRAG_LOADING: "FRAG_LOADING",
    FRAG_LOADING_WAITING_RETRY: "FRAG_LOADING_WAITING_RETRY",
    WAITING_TRACK: "WAITING_TRACK",
    PARSING: "PARSING",
    PARSED: "PARSED",
    ENDED: "ENDED",
    ERROR: "ERROR",
    WAITING_INIT_PTS: "WAITING_INIT_PTS",
    WAITING_LEVEL: "WAITING_LEVEL"
};
class rx extends uz {
    constructor(e, t, n, s, r) {
        super(),
        this.hls = void 0,
        this.fragPrevious = null,
        this.fragCurrent = null,
        this.fragmentTracker = void 0,
        this.transmuxer = null,
        this._state = Ve.STOPPED,
        this.playlistType = void 0,
        this.media = null,
        this.mediaBuffer = null,
        this.config = void 0,
        this.bitrateTest = !1,
        this.lastCurrentTime = 0,
        this.nextLoadPosition = 0,
        this.startPosition = 0,
        this.startTimeOffset = null,
        this.loadedmetadata = !1,
        this.retryDate = 0,
        this.levels = null,
        this.fragmentLoader = void 0,
        this.keyLoader = void 0,
        this.levelLastLoaded = null,
        this.startFragRequested = !1,
        this.decrypter = void 0,
        this.initPTS = [],
        this.onvseeking = null,
        this.onvended = null,
        this.logPrefix = "",
        this.log = void 0,
        this.warn = void 0,
        this.playlistType = r,
        this.logPrefix = s,
        this.log = de.log.bind(de, `${s}:`),
        this.warn = de.warn.bind(de, `${s}:`),
        this.hls = e,
        this.fragmentLoader = new vz(e.config),
        this.keyLoader = n,
        this.fragmentTracker = t,
        this.config = e.config,
        this.decrypter = new sx(e.config),
        e.on(P.MANIFEST_LOADED, this.onManifestLoaded, this)
    }
    doTick() {
        this.onTickEnd()
    }
    onTickEnd() {}
    startLoad(e) {}
    stopLoad() {
        this.fragmentLoader.abort(),
        this.keyLoader.abort(this.playlistType);
        const e = this.fragCurrent;
        e != null && e.loader && (e.abortRequests(),
        this.fragmentTracker.removeFragment(e)),
        this.resetTransmuxer(),
        this.fragCurrent = null,
        this.fragPrevious = null,
        this.clearInterval(),
        this.clearNextTick(),
        this.state = Ve.STOPPED
    }
    _streamEnded(e, t) {
        if (t.live || e.nextStart || !e.end || !this.media)
            return !1;
        const n = t.partList;
        if (n != null && n.length) {
            const r = n[n.length - 1];
            return An.isBuffered(this.media, r.start + r.duration / 2)
        }
        const s = t.fragments[t.fragments.length - 1].type;
        return this.fragmentTracker.isEndListAppended(s)
    }
    getLevelDetails() {
        if (this.levels && this.levelLastLoaded !== null) {
            var e;
            return (e = this.levelLastLoaded) == null ? void 0 : e.details
        }
    }
    onMediaAttached(e, t) {
        const n = this.media = this.mediaBuffer = t.media;
        this.onvseeking = this.onMediaSeeking.bind(this),
        this.onvended = this.onMediaEnded.bind(this),
        n.addEventListener("seeking", this.onvseeking),
        n.addEventListener("ended", this.onvended);
        const s = this.config;
        this.levels && s.autoStartLoad && this.state === Ve.STOPPED && this.startLoad(s.startPosition)
    }
    onMediaDetaching() {
        const e = this.media;
        e != null && e.ended && (this.log("MSE detaching and video ended, reset startPosition"),
        this.startPosition = this.lastCurrentTime = 0),
        e && this.onvseeking && this.onvended && (e.removeEventListener("seeking", this.onvseeking),
        e.removeEventListener("ended", this.onvended),
        this.onvseeking = this.onvended = null),
        this.keyLoader && this.keyLoader.detach(),
        this.media = this.mediaBuffer = null,
        this.loadedmetadata = !1,
        this.fragmentTracker.removeAllFragments(),
        this.stopLoad()
    }
    onMediaSeeking() {
        const {config: e, fragCurrent: t, media: n, mediaBuffer: s, state: r} = this
          , o = n ? n.currentTime : 0
          , a = An.bufferInfo(s || n, o, e.maxBufferHole);
        if (this.log(`media seeking to ${pt(o) ? o.toFixed(3) : o}, state: ${r}`),
        this.state === Ve.ENDED)
            this.resetLoadingState();
        else if (t) {
            const l = e.maxFragLookUpTolerance
              , c = t.start - l
              , u = t.start + t.duration + l;
            if (!a.len || u < a.start || c > a.end) {
                const d = o > u;
                (o < c || d) && (d && t.loader && (this.log("seeking outside of buffer while fragment load in progress, cancel fragment load"),
                t.abortRequests(),
                this.resetLoadingState()),
                this.fragPrevious = null)
            }
        }
        n && (this.fragmentTracker.removeFragmentsInRange(o, 1 / 0, this.playlistType, !0),
        this.lastCurrentTime = o),
        !this.loadedmetadata && !a.len && (this.nextLoadPosition = this.startPosition = o),
        this.tickImmediate()
    }
    onMediaEnded() {
        this.startPosition = this.lastCurrentTime = 0
    }
    onManifestLoaded(e, t) {
        this.startTimeOffset = t.startTimeOffset,
        this.initPTS = []
    }
    onHandlerDestroying() {
        this.hls.off(P.MANIFEST_LOADED, this.onManifestLoaded, this),
        this.stopLoad(),
        super.onHandlerDestroying(),
        this.hls = null
    }
    onHandlerDestroyed() {
        this.state = Ve.STOPPED,
        this.fragmentLoader && this.fragmentLoader.destroy(),
        this.keyLoader && this.keyLoader.destroy(),
        this.decrypter && this.decrypter.destroy(),
        this.hls = this.log = this.warn = this.decrypter = this.keyLoader = this.fragmentLoader = this.fragmentTracker = null,
        super.onHandlerDestroyed()
    }
    loadFragment(e, t, n) {
        this._loadFragForPlayback(e, t, n)
    }
    _loadFragForPlayback(e, t, n) {
        const s = r => {
            if (this.fragContextChanged(e)) {
                this.warn(`Fragment ${e.sn}${r.part ? " p: " + r.part.index : ""} of level ${e.level} was dropped during download.`),
                this.fragmentTracker.removeFragment(e);
                return
            }
            e.stats.chunkCount++,
            this._handleFragmentLoadProgress(r)
        }
        ;
        this._doFragLoad(e, t, n, s).then(r => {
            if (!r)
                return;
            const o = this.state;
            if (this.fragContextChanged(e)) {
                (o === Ve.FRAG_LOADING || !this.fragCurrent && o === Ve.PARSING) && (this.fragmentTracker.removeFragment(e),
                this.state = Ve.IDLE);
                return
            }
            "payload"in r && (this.log(`Loaded fragment ${e.sn} of level ${e.level}`),
            this.hls.trigger(P.FRAG_LOADED, r)),
            this._handleFragmentLoadComplete(r)
        }
        ).catch(r => {
            this.state === Ve.STOPPED || this.state === Ve.ERROR || (this.warn(`Frag error: ${(r == null ? void 0 : r.message) || r}`),
            this.resetFragmentLoading(e))
        }
        )
    }
    clearTrackerIfNeeded(e) {
        var t;
        const {fragmentTracker: n} = this;
        if (n.getState(e) === gi.APPENDING) {
            const r = e.type
              , o = this.getFwdBufferInfo(this.mediaBuffer, r)
              , a = Math.max(e.duration, o ? o.len : this.config.maxBufferLength)
              , l = this.backtrackFragment;
            ((l ? e.sn - l.sn : 0) === 1 || this.reduceMaxBufferLength(a, e.duration)) && n.removeFragment(e)
        } else
            ((t = this.mediaBuffer) == null ? void 0 : t.buffered.length) === 0 ? n.removeAllFragments() : n.hasParts(e.type) && (n.detectPartialFragments({
                frag: e,
                part: null,
                stats: e.stats,
                id: e.type
            }),
            n.getState(e) === gi.PARTIAL && n.removeFragment(e))
    }
    checkLiveUpdate(e) {
        if (e.updated && !e.live) {
            const t = e.fragments[e.fragments.length - 1];
            this.fragmentTracker.detectPartialFragments({
                frag: t,
                part: null,
                stats: t.stats,
                id: t.type
            })
        }
        e.fragments[0] || (e.deltaUpdateFailed = !0)
    }
    flushMainBuffer(e, t, n=null) {
        if (!(e - t))
            return;
        const s = {
            startOffset: e,
            endOffset: t,
            type: n
        };
        this.hls.trigger(P.BUFFER_FLUSHING, s)
    }
    _loadInitSegment(e, t) {
        this._doFragLoad(e, t).then(n => {
            if (!n || this.fragContextChanged(e) || !this.levels)
                throw new Error("init load aborted");
            return n
        }
        ).then(n => {
            const {hls: s} = this
              , {payload: r} = n
              , o = e.decryptdata;
            if (r && r.byteLength > 0 && o != null && o.key && o.iv && o.method === "AES-128") {
                const a = self.performance.now();
                return this.decrypter.decrypt(new Uint8Array(r), o.key.buffer, o.iv.buffer).catch(l => {
                    throw s.trigger(P.ERROR, {
                        type: Ut.MEDIA_ERROR,
                        details: Ae.FRAG_DECRYPT_ERROR,
                        fatal: !1,
                        error: l,
                        reason: l.message,
                        frag: e
                    }),
                    l
                }
                ).then(l => {
                    const c = self.performance.now();
                    return s.trigger(P.FRAG_DECRYPTED, {
                        frag: e,
                        payload: l,
                        stats: {
                            tstart: a,
                            tdecrypt: c
                        }
                    }),
                    n.payload = l,
                    this.completeInitSegmentLoad(n)
                }
                )
            }
            return this.completeInitSegmentLoad(n)
        }
        ).catch(n => {
            this.state === Ve.STOPPED || this.state === Ve.ERROR || (this.warn(n),
            this.resetFragmentLoading(e))
        }
        )
    }
    completeInitSegmentLoad(e) {
        const {levels: t} = this;
        if (!t)
            throw new Error("init load aborted, missing levels");
        const n = e.frag.stats;
        this.state = Ve.IDLE,
        e.frag.data = new Uint8Array(e.payload),
        n.parsing.start = n.buffering.start = self.performance.now(),
        n.parsing.end = n.buffering.end = self.performance.now(),
        this.tick()
    }
    fragContextChanged(e) {
        const {fragCurrent: t} = this;
        return !e || !t || e.sn !== t.sn || e.level !== t.level
    }
    fragBufferedComplete(e, t) {
        var n, s, r, o;
        const a = this.mediaBuffer ? this.mediaBuffer : this.media;
        if (this.log(`Buffered ${e.type} sn: ${e.sn}${t ? " part: " + t.index : ""} of ${this.playlistType === Ct.MAIN ? "level" : "track"} ${e.level} (frag:[${((n = e.startPTS) != null ? n : NaN).toFixed(3)}-${((s = e.endPTS) != null ? s : NaN).toFixed(3)}] > buffer:${a ? Ez.toString(An.getBuffered(a)) : "(detached)"})`),
        e.sn !== "initSegment") {
            var l;
            if (e.type !== Ct.SUBTITLE) {
                const u = e.elementaryStreams;
                if (!Object.keys(u).some(d => !!u[d])) {
                    this.state = Ve.IDLE;
                    return
                }
            }
            const c = (l = this.levels) == null ? void 0 : l[e.level];
            c != null && c.fragmentError && (this.log(`Resetting level fragment error count of ${c.fragmentError} on frag buffered`),
            c.fragmentError = 0)
        }
        this.state = Ve.IDLE,
        a && (!this.loadedmetadata && e.type == Ct.MAIN && a.buffered.length && ((r = this.fragCurrent) == null ? void 0 : r.sn) === ((o = this.fragPrevious) == null ? void 0 : o.sn) && (this.loadedmetadata = !0,
        this.seekToStartPos()),
        this.tick())
    }
    seekToStartPos() {}
    _handleFragmentLoadComplete(e) {
        const {transmuxer: t} = this;
        if (!t)
            return;
        const {frag: n, part: s, partsLoaded: r} = e
          , o = !r || r.length === 0 || r.some(l => !l)
          , a = new ix(n.level,n.sn,n.stats.chunkCount + 1,0,s ? s.index : -1,!o);
        t.flush(a)
    }
    _handleFragmentLoadProgress(e) {}
    _doFragLoad(e, t, n=null, s) {
        var r;
        const o = t == null ? void 0 : t.details;
        if (!this.levels || !o)
            throw new Error(`frag load aborted, missing level${o ? "" : " detail"}s`);
        let a = null;
        if (e.encrypted && !((r = e.decryptdata) != null && r.key) ? (this.log(`Loading key for ${e.sn} of [${o.startSN}-${o.endSN}], ${this.logPrefix === "[stream-controller]" ? "level" : "track"} ${e.level}`),
        this.state = Ve.KEY_LOADING,
        this.fragCurrent = e,
        a = this.keyLoader.load(e).then(u => {
            if (!this.fragContextChanged(u.frag))
                return this.hls.trigger(P.KEY_LOADED, u),
                this.state === Ve.KEY_LOADING && (this.state = Ve.IDLE),
                u
        }
        ),
        this.hls.trigger(P.KEY_LOADING, {
            frag: e
        }),
        this.fragCurrent === null && (a = Promise.reject(new Error("frag load aborted, context changed in KEY_LOADING")))) : !e.encrypted && o.encryptedFragments.length && this.keyLoader.loadClear(e, o.encryptedFragments),
        n = Math.max(e.start, n || 0),
        this.config.lowLatencyMode && e.sn !== "initSegment") {
            const u = o.partList;
            if (u && s) {
                n > e.end && o.fragmentHint && (e = o.fragmentHint);
                const d = this.getNextPart(u, e, n);
                if (d > -1) {
                    const f = u[d];
                    this.log(`Loading part sn: ${e.sn} p: ${f.index} cc: ${e.cc} of playlist [${o.startSN}-${o.endSN}] parts [0-${d}-${u.length - 1}] ${this.logPrefix === "[stream-controller]" ? "level" : "track"}: ${e.level}, target: ${parseFloat(n.toFixed(3))}`),
                    this.nextLoadPosition = f.start + f.duration,
                    this.state = Ve.FRAG_LOADING;
                    let h;
                    return a ? h = a.then(p => !p || this.fragContextChanged(p.frag) ? null : this.doFragPartsLoad(e, f, t, s)).catch(p => this.handleFragLoadError(p)) : h = this.doFragPartsLoad(e, f, t, s).catch(p => this.handleFragLoadError(p)),
                    this.hls.trigger(P.FRAG_LOADING, {
                        frag: e,
                        part: f,
                        targetBufferTime: n
                    }),
                    this.fragCurrent === null ? Promise.reject(new Error("frag load aborted, context changed in FRAG_LOADING parts")) : h
                } else if (!e.url || this.loadedEndOfParts(u, n))
                    return Promise.resolve(null)
            }
        }
        this.log(`Loading fragment ${e.sn} cc: ${e.cc} ${o ? "of [" + o.startSN + "-" + o.endSN + "] " : ""}${this.logPrefix === "[stream-controller]" ? "level" : "track"}: ${e.level}, target: ${parseFloat(n.toFixed(3))}`),
        pt(e.sn) && !this.bitrateTest && (this.nextLoadPosition = e.start + e.duration),
        this.state = Ve.FRAG_LOADING;
        const l = this.config.progressive;
        let c;
        return l && a ? c = a.then(u => !u || this.fragContextChanged(u == null ? void 0 : u.frag) ? null : this.fragmentLoader.load(e, s)).catch(u => this.handleFragLoadError(u)) : c = Promise.all([this.fragmentLoader.load(e, l ? s : void 0), a]).then( ([u]) => (!l && u && s && s(u),
        u)).catch(u => this.handleFragLoadError(u)),
        this.hls.trigger(P.FRAG_LOADING, {
            frag: e,
            targetBufferTime: n
        }),
        this.fragCurrent === null ? Promise.reject(new Error("frag load aborted, context changed in FRAG_LOADING")) : c
    }
    doFragPartsLoad(e, t, n, s) {
        return new Promise( (r, o) => {
            var a;
            const l = []
              , c = (a = n.details) == null ? void 0 : a.partList
              , u = d => {
                this.fragmentLoader.loadPart(e, d, s).then(f => {
                    l[d.index] = f;
                    const h = f.part;
                    this.hls.trigger(P.FRAG_LOADED, f);
                    const p = iS(n, e.sn, d.index + 1) || iM(c, e.sn, d.index + 1);
                    if (p)
                        u(p);
                    else
                        return r({
                            frag: e,
                            part: h,
                            partsLoaded: l
                        })
                }
                ).catch(o)
            }
            ;
            u(t)
        }
        )
    }
    handleFragLoadError(e) {
        if ("data"in e) {
            const t = e.data;
            e.data && t.details === Ae.INTERNAL_ABORTED ? this.handleFragLoadAborted(t.frag, t.part) : this.hls.trigger(P.ERROR, t)
        } else
            this.hls.trigger(P.ERROR, {
                type: Ut.OTHER_ERROR,
                details: Ae.INTERNAL_EXCEPTION,
                err: e,
                error: e,
                fatal: !0
            });
        return null
    }
    _handleTransmuxerFlush(e) {
        const t = this.getCurrentContext(e);
        if (!t || this.state !== Ve.PARSING) {
            !this.fragCurrent && this.state !== Ve.STOPPED && this.state !== Ve.ERROR && (this.state = Ve.IDLE);
            return
        }
        const {frag: n, part: s, level: r} = t
          , o = self.performance.now();
        n.stats.parsing.end = o,
        s && (s.stats.parsing.end = o),
        this.updateLevelTiming(n, s, r, e.partial)
    }
    getCurrentContext(e) {
        const {levels: t, fragCurrent: n} = this
          , {level: s, sn: r, part: o} = e;
        if (!(t != null && t[s]))
            return this.warn(`Levels object was unset while buffering fragment ${r} of level ${s}. The current chunk will not be buffered.`),
            null;
        const a = t[s]
          , l = o > -1 ? iS(a, r, o) : null
          , c = l ? l.fragment : WH(a, r, n);
        return c ? (n && n !== c && (c.stats = n.stats),
        {
            frag: c,
            part: l,
            level: a
        }) : null
    }
    bufferFragmentData(e, t, n, s, r) {
        var o;
        if (!e || this.state !== Ve.PARSING)
            return;
        const {data1: a, data2: l} = e;
        let c = a;
        if (a && l && (c = qs(a, l)),
        !((o = c) != null && o.length))
            return;
        const u = {
            type: e.type,
            frag: t,
            part: n,
            chunkMeta: s,
            parent: t.type,
            data: c
        };
        if (this.hls.trigger(P.BUFFER_APPENDING, u),
        e.dropped && e.independent && !n) {
            if (r)
                return;
            this.flushBufferGap(t)
        }
    }
    flushBufferGap(e) {
        const t = this.media;
        if (!t)
            return;
        if (!An.isBuffered(t, t.currentTime)) {
            this.flushMainBuffer(0, e.start);
            return
        }
        const n = t.currentTime
          , s = An.bufferInfo(t, n, 0)
          , r = e.duration
          , o = Math.min(this.config.maxFragLookUpTolerance * 2, r * .25)
          , a = Math.max(Math.min(e.start - o, s.end - o), n + o);
        e.start - a > o && this.flushMainBuffer(a, e.start)
    }
    getFwdBufferInfo(e, t) {
        const n = this.getLoadPosition();
        return pt(n) ? this.getFwdBufferInfoAtPos(e, n, t) : null
    }
    getFwdBufferInfoAtPos(e, t, n) {
        const {config: {maxBufferHole: s}} = this
          , r = An.bufferInfo(e, t, s);
        if (r.len === 0 && r.nextStart !== void 0) {
            const o = this.fragmentTracker.getBufferedFrag(t, n);
            if (o && r.nextStart < o.end)
                return An.bufferInfo(e, t, Math.max(r.nextStart, s))
        }
        return r
    }
    getMaxBufferLength(e) {
        const {config: t} = this;
        let n;
        return e ? n = Math.max(8 * t.maxBufferSize / e, t.maxBufferLength) : n = t.maxBufferLength,
        Math.min(n, t.maxMaxBufferLength)
    }
    reduceMaxBufferLength(e, t) {
        const n = this.config
          , s = Math.max(Math.min(e - t, n.maxBufferLength), t)
          , r = Math.max(e - t * 3, n.maxMaxBufferLength / 2, s);
        return r >= s ? (n.maxMaxBufferLength = r,
        this.warn(`Reduce max buffer length to ${r}s`),
        !0) : !1
    }
    getAppendedFrag(e, t=Ct.MAIN) {
        const n = this.fragmentTracker.getAppendedFrag(e, Ct.MAIN);
        return n && "fragment"in n ? n.fragment : n
    }
    getNextFragment(e, t) {
        const n = t.fragments
          , s = n.length;
        if (!s)
            return null;
        const {config: r} = this
          , o = n[0].start;
        let a;
        if (t.live) {
            const l = r.initialLiveManifestSize;
            if (s < l)
                return this.warn(`Not enough fragments to start playback (have: ${s}, need: ${l})`),
                null;
            (!t.PTSKnown && !this.startFragRequested && this.startPosition === -1 || e < o) && (a = this.getInitialLiveFragment(t, n),
            this.startPosition = this.nextLoadPosition = a ? this.hls.liveSyncPosition || a.start : e)
        } else
            e <= o && (a = n[0]);
        if (!a) {
            const l = r.lowLatencyMode ? t.partEnd : t.fragmentEnd;
            a = this.getFragmentAtPosition(e, l, t)
        }
        return this.mapToInitFragWhenRequired(a)
    }
    isLoopLoading(e, t) {
        const n = this.fragmentTracker.getState(e);
        return (n === gi.OK || n === gi.PARTIAL && !!e.gap) && this.nextLoadPosition > t
    }
    getNextFragmentLoopLoading(e, t, n, s, r) {
        const o = e.gap
          , a = this.getNextFragment(this.nextLoadPosition, t);
        if (a === null)
            return a;
        if (e = a,
        o && e && !e.gap && n.nextStart) {
            const l = this.getFwdBufferInfoAtPos(this.mediaBuffer ? this.mediaBuffer : this.media, n.nextStart, s);
            if (l !== null && n.len + l.len >= r)
                return this.log(`buffer full after gaps in "${s}" playlist starting at sn: ${e.sn}`),
                null
        }
        return e
    }
    mapToInitFragWhenRequired(e) {
        return e != null && e.initSegment && !(e != null && e.initSegment.data) && !this.bitrateTest ? e.initSegment : e
    }
    getNextPart(e, t, n) {
        let s = -1
          , r = !1
          , o = !0;
        for (let a = 0, l = e.length; a < l; a++) {
            const c = e[a];
            if (o = o && !c.independent,
            s > -1 && n < c.start)
                break;
            const u = c.loaded;
            u ? s = -1 : (r || c.independent || o) && c.fragment === t && (s = a),
            r = u
        }
        return s
    }
    loadedEndOfParts(e, t) {
        const n = e[e.length - 1];
        return n && t > n.start && n.loaded
    }
    getInitialLiveFragment(e, t) {
        const n = this.fragPrevious;
        let s = null;
        if (n) {
            if (e.hasProgramDateTime && (this.log(`Live playlist, switching playlist, load frag with same PDT: ${n.programDateTime}`),
            s = jH(t, n.endProgramDateTime, this.config.maxFragLookUpTolerance)),
            !s) {
                const r = n.sn + 1;
                if (r >= e.startSN && r <= e.endSN) {
                    const o = t[r - e.startSN];
                    n.cc === o.cc && (s = o,
                    this.log(`Live playlist, switching playlist, load frag with next SN: ${s.sn}`))
                }
                s || (s = YH(t, n.cc),
                s && this.log(`Live playlist, switching playlist, load frag with same CC: ${s.sn}`))
            }
        } else {
            const r = this.hls.liveSyncPosition;
            r !== null && (s = this.getFragmentAtPosition(r, this.bitrateTest ? e.fragmentEnd : e.edge, e))
        }
        return s
    }
    getFragmentAtPosition(e, t, n) {
        const {config: s} = this;
        let {fragPrevious: r} = this
          , {fragments: o, endSN: a} = n;
        const {fragmentHint: l} = n
          , {maxFragLookUpTolerance: c} = s
          , u = n.partList
          , d = !!(s.lowLatencyMode && u != null && u.length && l);
        d && l && !this.bitrateTest && (o = o.concat(l),
        a = l.sn);
        let f;
        if (e < t) {
            const h = e > t - c ? 0 : c;
            f = kp(r, o, e, h)
        } else
            f = o[o.length - 1];
        if (f) {
            const h = f.sn - n.startSN
              , p = this.fragmentTracker.getState(f);
            if ((p === gi.OK || p === gi.PARTIAL && f.gap) && (r = f),
            r && f.sn === r.sn && (!d || u[0].fragment.sn > f.sn) && r && f.level === r.level) {
                const m = o[h + 1];
                f.sn < a && this.fragmentTracker.getState(m) !== gi.OK ? f = m : f = null
            }
        }
        return f
    }
    synchronizeToLiveEdge(e) {
        const {config: t, media: n} = this;
        if (!n)
            return;
        const s = this.hls.liveSyncPosition
          , r = n.currentTime
          , o = e.fragments[0].start
          , a = e.edge
          , l = r >= o - t.maxFragLookUpTolerance && r <= a;
        if (s !== null && n.duration > s && (r < s || !l)) {
            const c = t.liveMaxLatencyDuration !== void 0 ? t.liveMaxLatencyDuration : t.liveMaxLatencyDurationCount * e.targetduration;
            (!l && n.readyState < 4 || r < a - c) && (this.loadedmetadata || (this.nextLoadPosition = s),
            n.readyState && (this.warn(`Playback: ${r.toFixed(3)} is located too far from the end of live sliding playlist: ${a}, reset currentTime to : ${s.toFixed(3)}`),
            n.currentTime = s))
        }
    }
    alignPlaylists(e, t, n) {
        const s = e.fragments.length;
        if (!s)
            return this.warn("No fragments in live playlist"),
            0;
        const r = e.fragments[0].start
          , o = !t
          , a = e.alignedSliding && pt(r);
        if (o || !a && !r) {
            const {fragPrevious: l} = this;
            mz(l, n, e);
            const c = e.fragments[0].start;
            return this.log(`Live playlist sliding: ${c.toFixed(2)} start-sn: ${t ? t.startSN : "na"}->${e.startSN} prev-sn: ${l ? l.sn : "na"} fragments: ${s}`),
            c
        }
        return r
    }
    waitForCdnTuneIn(e) {
        return e.live && e.canBlockReload && e.partTarget && e.tuneInGoal > Math.max(e.partHoldBack, e.partTarget * 3)
    }
    setStartPosition(e, t) {
        let n = this.startPosition;
        if (n < t && (n = -1),
        n === -1 || this.lastCurrentTime === -1) {
            const s = this.startTimeOffset !== null
              , r = s ? this.startTimeOffset : e.startTimeOffset;
            r !== null && pt(r) ? (n = t + r,
            r < 0 && (n += e.totalduration),
            n = Math.min(Math.max(t, n), t + e.totalduration),
            this.log(`Start time offset ${r} found in ${s ? "multivariant" : "media"} playlist, adjust startPosition to ${n}`),
            this.startPosition = n) : e.live ? n = this.hls.liveSyncPosition || t : this.startPosition = n = 0,
            this.lastCurrentTime = n
        }
        this.nextLoadPosition = n
    }
    getLoadPosition() {
        const {media: e} = this;
        let t = 0;
        return this.loadedmetadata && e ? t = e.currentTime : this.nextLoadPosition && (t = this.nextLoadPosition),
        t
    }
    handleFragLoadAborted(e, t) {
        this.transmuxer && e.sn !== "initSegment" && e.stats.aborted && (this.warn(`Fragment ${e.sn}${t ? " part " + t.index : ""} of level ${e.level} was aborted`),
        this.resetFragmentLoading(e))
    }
    resetFragmentLoading(e) {
        (!this.fragCurrent || !this.fragContextChanged(e) && this.state !== Ve.FRAG_LOADING_WAITING_RETRY) && (this.state = Ve.IDLE)
    }
    onFragmentOrKeyLoadError(e, t) {
        if (t.chunkMeta && !t.frag) {
            const u = this.getCurrentContext(t.chunkMeta);
            u && (t.frag = u.frag)
        }
        const n = t.frag;
        if (!n || n.type !== e || !this.levels)
            return;
        if (this.fragContextChanged(n)) {
            var s;
            this.warn(`Frag load error must match current frag to retry ${n.url} > ${(s = this.fragCurrent) == null ? void 0 : s.url}`);
            return
        }
        const r = t.details === Ae.FRAG_GAP;
        r && this.fragmentTracker.fragBuffered(n, !0);
        const o = t.errorAction
          , {action: a, retryCount: l=0, retryConfig: c} = o || {};
        if (o && a === Ei.RetryRequest && c) {
            this.resetStartWhenNotLoaded(this.levelLastLoaded);
            const u = tx(c, l);
            this.warn(`Fragment ${n.sn} of ${e} ${n.level} errored with ${t.details}, retrying loading ${l + 1}/${c.maxNumRetry} in ${u}ms`),
            o.resolved = !0,
            this.retryDate = self.performance.now() + u,
            this.state = Ve.FRAG_LOADING_WAITING_RETRY
        } else if (c && o)
            if (this.resetFragmentErrors(e),
            l < c.maxNumRetry)
                !r && a !== Ei.RemoveAlternatePermanently && (o.resolved = !0);
            else {
                de.warn(`${t.details} reached or exceeded max retry (${l})`);
                return
            }
        else
            (o == null ? void 0 : o.action) === Ei.SendAlternateToPenaltyBox ? this.state = Ve.WAITING_LEVEL : this.state = Ve.ERROR;
        this.tickImmediate()
    }
    reduceLengthAndFlushBuffer(e) {
        if (this.state === Ve.PARSING || this.state === Ve.PARSED) {
            const t = e.frag
              , n = e.parent
              , s = this.getFwdBufferInfo(this.mediaBuffer, n)
              , r = s && s.len > .5;
            r && this.reduceMaxBufferLength(s.len, (t == null ? void 0 : t.duration) || 10);
            const o = !r;
            return o && this.warn(`Buffer full error while media.currentTime is not buffered, flush ${n} buffer`),
            t && (this.fragmentTracker.removeFragment(t),
            this.nextLoadPosition = t.start),
            this.resetLoadingState(),
            o
        }
        return !1
    }
    resetFragmentErrors(e) {
        e === Ct.AUDIO && (this.fragCurrent = null),
        this.loadedmetadata || (this.startFragRequested = !1),
        this.state !== Ve.STOPPED && (this.state = Ve.IDLE)
    }
    afterBufferFlushed(e, t, n) {
        if (!e)
            return;
        const s = An.getBuffered(e);
        this.fragmentTracker.detectEvictedFragments(t, s, n),
        this.state === Ve.ENDED && this.resetLoadingState()
    }
    resetLoadingState() {
        this.log("Reset loading state"),
        this.fragCurrent = null,
        this.fragPrevious = null,
        this.state = Ve.IDLE
    }
    resetStartWhenNotLoaded(e) {
        if (!this.loadedmetadata) {
            this.startFragRequested = !1;
            const t = e ? e.details : null;
            t != null && t.live ? (this.startPosition = -1,
            this.setStartPosition(t, 0),
            this.resetLoadingState()) : this.nextLoadPosition = this.startPosition
        }
    }
    resetWhenMissingContext(e) {
        this.warn(`The loading context changed while buffering fragment ${e.sn} of level ${e.level}. This chunk will not be buffered.`),
        this.removeUnbufferedFrags(),
        this.resetStartWhenNotLoaded(this.levelLastLoaded),
        this.resetLoadingState()
    }
    removeUnbufferedFrags(e=0) {
        this.fragmentTracker.removeFragmentsInRange(e, 1 / 0, this.playlistType, !1, !0)
    }
    updateLevelTiming(e, t, n, s) {
        var r;
        const o = n.details;
        if (!o) {
            this.warn("level.details undefined");
            return
        }
        if (!Object.keys(e.elementaryStreams).reduce( (l, c) => {
            const u = e.elementaryStreams[c];
            if (u) {
                const d = u.endPTS - u.startPTS;
                if (d <= 0)
                    return this.warn(`Could not parse fragment ${e.sn} ${c} duration reliably (${d})`),
                    l || !1;
                const f = s ? 0 : tM(o, e, u.startPTS, u.endPTS, u.startDTS, u.endDTS);
                return this.hls.trigger(P.LEVEL_PTS_UPDATED, {
                    details: o,
                    level: n,
                    drift: f,
                    type: c,
                    frag: e,
                    start: u.startPTS,
                    end: u.endPTS
                }),
                !0
            }
            return l
        }
        , !1) && ((r = this.transmuxer) == null ? void 0 : r.error) === null) {
            const l = new Error(`Found no media in fragment ${e.sn} of level ${e.level} resetting transmuxer to fallback to playlist timing`);
            if (n.fragmentError === 0 && (n.fragmentError++,
            e.gap = !0,
            this.fragmentTracker.removeFragment(e),
            this.fragmentTracker.fragBuffered(e, !0)),
            this.warn(l.message),
            this.hls.trigger(P.ERROR, {
                type: Ut.MEDIA_ERROR,
                details: Ae.FRAG_PARSING_ERROR,
                fatal: !1,
                error: l,
                frag: e,
                reason: `Found no media in msn ${e.sn} of level "${n.url}"`
            }),
            !this.hls)
                return;
            this.resetTransmuxer()
        }
        this.state = Ve.PARSED,
        this.hls.trigger(P.FRAG_PARSED, {
            frag: e,
            part: t
        })
    }
    resetTransmuxer() {
        this.transmuxer && (this.transmuxer.destroy(),
        this.transmuxer = null)
    }
    recoverWorkerError(e) {
        e.event === "demuxerWorker" && (this.fragmentTracker.removeAllFragments(),
        this.resetTransmuxer(),
        this.resetStartWhenNotLoaded(this.levelLastLoaded),
        this.resetLoadingState())
    }
    set state(e) {
        const t = this._state;
        t !== e && (this._state = e,
        this.log(`${t}->${e}`))
    }
    get state() {
        return this._state
    }
}
class lM {
    constructor() {
        this.chunks = [],
        this.dataLength = 0
    }
    push(e) {
        this.chunks.push(e),
        this.dataLength += e.length
    }
    flush() {
        const {chunks: e, dataLength: t} = this;
        let n;
        if (e.length)
            e.length === 1 ? n = e[0] : n = wz(e, t);
        else
            return new Uint8Array(0);
        return this.reset(),
        n
    }
    reset() {
        this.chunks.length = 0,
        this.dataLength = 0
    }
}
function wz(i, e) {
    const t = new Uint8Array(e);
    let n = 0;
    for (let s = 0; s < i.length; s++) {
        const r = i[s];
        t.set(r, n),
        n += r.length
    }
    return t
}
function Tz() {
    return typeof __HLS_WORKER_BUNDLE__ == "function"
}
function Az() {
    const i = new self.Blob([`var exports={};var module={exports:exports};function define(f){f()};define.amd=true;(${__HLS_WORKER_BUNDLE__.toString()})(true);`],{
        type: "text/javascript"
    })
      , e = self.URL.createObjectURL(i);
    return {
        worker: new self.Worker(e),
        objectURL: e
    }
}
function Cz(i) {
    const e = new self.URL(i,self.location.href).href;
    return {
        worker: new self.Worker(e),
        scriptURL: e
    }
}
function kr(i="", e=9e4) {
    return {
        type: i,
        id: -1,
        pid: -1,
        inputTimeScale: e,
        sequenceNumber: -1,
        samples: [],
        dropped: 0
    }
}
class ox {
    constructor() {
        this._audioTrack = void 0,
        this._id3Track = void 0,
        this.frameIndex = 0,
        this.cachedData = null,
        this.basePTS = null,
        this.initPTS = null,
        this.lastPTS = null
    }
    resetInitSegment(e, t, n, s) {
        this._id3Track = {
            type: "id3",
            id: 3,
            pid: -1,
            inputTimeScale: 9e4,
            sequenceNumber: 0,
            samples: [],
            dropped: 0
        }
    }
    resetTimeStamp(e) {
        this.initPTS = e,
        this.resetContiguity()
    }
    resetContiguity() {
        this.basePTS = null,
        this.lastPTS = null,
        this.frameIndex = 0
    }
    canParse(e, t) {
        return !1
    }
    appendFrame(e, t, n) {}
    demux(e, t) {
        this.cachedData && (e = qs(this.cachedData, e),
        this.cachedData = null);
        let n = Fd(e, 0), s = n ? n.length : 0, r;
        const o = this._audioTrack
          , a = this._id3Track
          , l = n ? ex(n) : void 0
          , c = e.length;
        for ((this.basePTS === null || this.frameIndex === 0 && pt(l)) && (this.basePTS = Mz(l, t, this.initPTS),
        this.lastPTS = this.basePTS),
        this.lastPTS === null && (this.lastPTS = this.basePTS),
        n && n.length > 0 && a.samples.push({
            pts: this.lastPTS,
            dts: this.lastPTS,
            data: n,
            type: or.audioId3,
            duration: Number.POSITIVE_INFINITY
        }); s < c; ) {
            if (this.canParse(e, s)) {
                const u = this.appendFrame(o, e, s);
                u ? (this.frameIndex++,
                this.lastPTS = u.sample.pts,
                s += u.length,
                r = s) : s = c
            } else
                X$(e, s) ? (n = Fd(e, s),
                a.samples.push({
                    pts: this.lastPTS,
                    dts: this.lastPTS,
                    data: n,
                    type: or.audioId3,
                    duration: Number.POSITIVE_INFINITY
                }),
                s += n.length,
                r = s) : s++;
            if (s === c && r !== c) {
                const u = Sl(e, r);
                this.cachedData ? this.cachedData = qs(this.cachedData, u) : this.cachedData = u
            }
        }
        return {
            audioTrack: o,
            videoTrack: kr(),
            id3Track: a,
            textTrack: kr()
        }
    }
    demuxSampleAes(e, t, n) {
        return Promise.reject(new Error(`[${this}] This demuxer does not support Sample-AES decryption`))
    }
    flush(e) {
        const t = this.cachedData;
        return t && (this.cachedData = null,
        this.demux(t, 0)),
        {
            audioTrack: this._audioTrack,
            videoTrack: kr(),
            id3Track: this._id3Track,
            textTrack: kr()
        }
    }
    destroy() {}
}
const Mz = (i, e, t) => {
    if (pt(i))
        return i * 90;
    const n = t ? t.baseTime * 9e4 / t.timescale : 0;
    return e * 9e4 + n
}
;
function Rz(i, e, t, n) {
    let s, r, o, a;
    const l = navigator.userAgent.toLowerCase()
      , c = n
      , u = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350];
    s = ((e[t + 2] & 192) >>> 6) + 1;
    const d = (e[t + 2] & 60) >>> 2;
    if (d > u.length - 1) {
        const f = new Error(`invalid ADTS sampling index:${d}`);
        i.emit(P.ERROR, P.ERROR, {
            type: Ut.MEDIA_ERROR,
            details: Ae.FRAG_PARSING_ERROR,
            fatal: !0,
            error: f,
            reason: f.message
        });
        return
    }
    return o = (e[t + 2] & 1) << 2,
    o |= (e[t + 3] & 192) >>> 6,
    de.log(`manifest codec:${n}, ADTS type:${s}, samplingIndex:${d}`),
    /firefox/i.test(l) ? d >= 6 ? (s = 5,
    a = new Array(4),
    r = d - 3) : (s = 2,
    a = new Array(2),
    r = d) : l.indexOf("android") !== -1 ? (s = 2,
    a = new Array(2),
    r = d) : (s = 5,
    a = new Array(4),
    n && (n.indexOf("mp4a.40.29") !== -1 || n.indexOf("mp4a.40.5") !== -1) || !n && d >= 6 ? r = d - 3 : ((n && n.indexOf("mp4a.40.2") !== -1 && (d >= 6 && o === 1 || /vivaldi/i.test(l)) || !n && o === 1) && (s = 2,
    a = new Array(2)),
    r = d)),
    a[0] = s << 3,
    a[0] |= (d & 14) >> 1,
    a[1] |= (d & 1) << 7,
    a[1] |= o << 3,
    s === 5 && (a[1] |= (r & 14) >> 1,
    a[2] = (r & 1) << 7,
    a[2] |= 2 << 2,
    a[3] = 0),
    {
        config: a,
        samplerate: u[d],
        channelCount: o,
        codec: "mp4a.40." + s,
        manifestCodec: c
    }
}
function cM(i, e) {
    return i[e] === 255 && (i[e + 1] & 246) === 240
}
function uM(i, e) {
    return i[e + 1] & 1 ? 7 : 9
}
function ax(i, e) {
    return (i[e + 3] & 3) << 11 | i[e + 4] << 3 | (i[e + 5] & 224) >>> 5
}
function Lz(i, e) {
    return e + 5 < i.length
}
function Dp(i, e) {
    return e + 1 < i.length && cM(i, e)
}
function Iz(i, e) {
    return Lz(i, e) && cM(i, e) && ax(i, e) <= i.length - e
}
function kz(i, e) {
    if (Dp(i, e)) {
        const t = uM(i, e);
        if (e + t >= i.length)
            return !1;
        const n = ax(i, e);
        if (n <= t)
            return !1;
        const s = e + n;
        return s === i.length || Dp(i, s)
    }
    return !1
}
function dM(i, e, t, n, s) {
    if (!i.samplerate) {
        const r = Rz(e, t, n, s);
        if (!r)
            return;
        i.config = r.config,
        i.samplerate = r.samplerate,
        i.channelCount = r.channelCount,
        i.codec = r.codec,
        i.manifestCodec = r.manifestCodec,
        de.log(`parsed codec:${i.codec}, rate:${r.samplerate}, channels:${r.channelCount}`)
    }
}
function fM(i) {
    return 1024 * 9e4 / i
}
function Pz(i, e) {
    const t = uM(i, e);
    if (e + t <= i.length) {
        const n = ax(i, e) - t;
        if (n > 0)
            return {
                headerLength: t,
                frameLength: n
            }
    }
}
function hM(i, e, t, n, s) {
    const r = fM(i.samplerate)
      , o = n + s * r
      , a = Pz(e, t);
    let l;
    if (a) {
        const {frameLength: d, headerLength: f} = a
          , h = f + d
          , p = Math.max(0, t + h - e.length);
        p ? (l = new Uint8Array(h - f),
        l.set(e.subarray(t + f, e.length), 0)) : l = e.subarray(t + f, t + h);
        const g = {
            unit: l,
            pts: o
        };
        return p || i.samples.push(g),
        {
            sample: g,
            length: h,
            missing: p
        }
    }
    const c = e.length - t;
    return l = new Uint8Array(c),
    l.set(e.subarray(t, e.length), 0),
    {
        sample: {
            unit: l,
            pts: o
        },
        length: c,
        missing: -1
    }
}
let Uf = null;
const Dz = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160]
  , Fz = [44100, 48e3, 32e3, 22050, 24e3, 16e3, 11025, 12e3, 8e3]
  , Oz = [[0, 72, 144, 12], [0, 0, 0, 0], [0, 72, 144, 12], [0, 144, 144, 12]]
  , Uz = [0, 1, 1, 4];
function pM(i, e, t, n, s) {
    if (t + 24 > e.length)
        return;
    const r = mM(e, t);
    if (r && t + r.frameLength <= e.length) {
        const o = r.samplesPerFrame * 9e4 / r.sampleRate
          , a = n + s * o
          , l = {
            unit: e.subarray(t, t + r.frameLength),
            pts: a,
            dts: a
        };
        return i.config = [],
        i.channelCount = r.channelCount,
        i.samplerate = r.sampleRate,
        i.samples.push(l),
        {
            sample: l,
            length: r.frameLength,
            missing: 0
        }
    }
}
function mM(i, e) {
    const t = i[e + 1] >> 3 & 3
      , n = i[e + 1] >> 1 & 3
      , s = i[e + 2] >> 4 & 15
      , r = i[e + 2] >> 2 & 3;
    if (t !== 1 && s !== 0 && s !== 15 && r !== 3) {
        const o = i[e + 2] >> 1 & 1
          , a = i[e + 3] >> 6
          , l = t === 3 ? 3 - n : n === 3 ? 3 : 4
          , c = Dz[l * 14 + s - 1] * 1e3
          , d = Fz[(t === 3 ? 0 : t === 2 ? 1 : 2) * 3 + r]
          , f = a === 3 ? 1 : 2
          , h = Oz[t][n]
          , p = Uz[n]
          , g = h * 8 * p
          , m = Math.floor(h * c / d + o) * p;
        if (Uf === null) {
            const y = (navigator.userAgent || "").match(/Chrome\/(\d+)/i);
            Uf = y ? parseInt(y[1]) : 0
        }
        return !!Uf && Uf <= 87 && n === 2 && c >= 224e3 && a === 0 && (i[e + 3] = i[e + 3] | 128),
        {
            sampleRate: d,
            channelCount: f,
            frameLength: m,
            samplesPerFrame: g
        }
    }
}
function lx(i, e) {
    return i[e] === 255 && (i[e + 1] & 224) === 224 && (i[e + 1] & 6) !== 0
}
function gM(i, e) {
    return e + 1 < i.length && lx(i, e)
}
function Nz(i, e) {
    return lx(i, e) && 4 <= i.length - e
}
function vM(i, e) {
    if (e + 1 < i.length && lx(i, e)) {
        const n = mM(i, e);
        let s = 4;
        n != null && n.frameLength && (s = n.frameLength);
        const r = e + s;
        return r === i.length || gM(i, r)
    }
    return !1
}
class Bz extends ox {
    constructor(e, t) {
        super(),
        this.observer = void 0,
        this.config = void 0,
        this.observer = e,
        this.config = t
    }
    resetInitSegment(e, t, n, s) {
        super.resetInitSegment(e, t, n, s),
        this._audioTrack = {
            container: "audio/adts",
            type: "audio",
            id: 2,
            pid: -1,
            sequenceNumber: 0,
            segmentCodec: "aac",
            samples: [],
            manifestCodec: t,
            duration: s,
            inputTimeScale: 9e4,
            dropped: 0
        }
    }
    static probe(e) {
        if (!e)
            return !1;
        const t = Fd(e, 0);
        let n = (t == null ? void 0 : t.length) || 0;
        if (vM(e, n))
            return !1;
        for (let s = e.length; n < s; n++)
            if (kz(e, n))
                return de.log("ADTS sync word found !"),
                !0;
        return !1
    }
    canParse(e, t) {
        return Iz(e, t)
    }
    appendFrame(e, t, n) {
        dM(e, this.observer, t, n, e.manifestCodec);
        const s = hM(e, t, n, this.basePTS, this.frameIndex);
        if (s && s.missing === 0)
            return s
    }
}
const Vz = /\/emsg[-/]ID3/i;
class $z {
    constructor(e, t) {
        this.remainderData = null,
        this.timeOffset = 0,
        this.config = void 0,
        this.videoTrack = void 0,
        this.audioTrack = void 0,
        this.id3Track = void 0,
        this.txtTrack = void 0,
        this.config = t
    }
    resetTimeStamp() {}
    resetInitSegment(e, t, n, s) {
        const r = this.videoTrack = kr("video", 1)
          , o = this.audioTrack = kr("audio", 1)
          , a = this.txtTrack = kr("text", 1);
        if (this.id3Track = kr("id3", 1),
        this.timeOffset = 0,
        !(e != null && e.byteLength))
            return;
        const l = jC(e);
        if (l.video) {
            const {id: c, timescale: u, codec: d} = l.video;
            r.id = c,
            r.timescale = a.timescale = u,
            r.codec = d
        }
        if (l.audio) {
            const {id: c, timescale: u, codec: d} = l.audio;
            o.id = c,
            o.timescale = u,
            o.codec = d
        }
        a.id = GC.text,
        r.sampleDuration = 0,
        r.duration = o.duration = s
    }
    resetContiguity() {
        this.remainderData = null
    }
    static probe(e) {
        return sH(e)
    }
    demux(e, t) {
        this.timeOffset = t;
        let n = e;
        const s = this.videoTrack
          , r = this.txtTrack;
        if (this.config.progressive) {
            this.remainderData && (n = qs(this.remainderData, e));
            const a = fH(n);
            this.remainderData = a.remainder,
            s.samples = a.valid || new Uint8Array
        } else
            s.samples = n;
        const o = this.extractID3Track(s, t);
        return r.samples = Nb(t, s),
        {
            videoTrack: s,
            audioTrack: this.audioTrack,
            id3Track: o,
            textTrack: this.txtTrack
        }
    }
    flush() {
        const e = this.timeOffset
          , t = this.videoTrack
          , n = this.txtTrack;
        t.samples = this.remainderData || new Uint8Array,
        this.remainderData = null;
        const s = this.extractID3Track(t, this.timeOffset);
        return n.samples = Nb(e, t),
        {
            videoTrack: t,
            audioTrack: kr(),
            id3Track: s,
            textTrack: kr()
        }
    }
    extractID3Track(e, t) {
        const n = this.id3Track;
        if (e.samples.length) {
            const s = $t(e.samples, ["emsg"]);
            s && s.forEach(r => {
                const o = mH(r);
                if (Vz.test(o.schemeIdUri)) {
                    const a = pt(o.presentationTime) ? o.presentationTime / o.timeScale : t + o.presentationTimeDelta / o.timeScale;
                    let l = o.eventDuration === 4294967295 ? Number.POSITIVE_INFINITY : o.eventDuration / o.timeScale;
                    l <= .001 && (l = Number.POSITIVE_INFINITY);
                    const c = o.payload;
                    n.samples.push({
                        data: c,
                        len: c.byteLength,
                        dts: a,
                        pts: a,
                        type: or.emsg,
                        duration: l
                    })
                }
            }
            )
        }
        return n
    }
    demuxSampleAes(e, t, n) {
        return Promise.reject(new Error("The MP4 demuxer does not support SAMPLE-AES decryption"))
    }
    destroy() {}
}
const _M = (i, e) => {
    let t = 0
      , n = 5;
    e += n;
    const s = new Uint32Array(1)
      , r = new Uint32Array(1)
      , o = new Uint8Array(1);
    for (; n > 0; ) {
        o[0] = i[e];
        const a = Math.min(n, 8)
          , l = 8 - a;
        r[0] = 4278190080 >>> 24 + l << l,
        s[0] = (o[0] & r[0]) >> l,
        t = t ? t << a | s[0] : s[0],
        e += 1,
        n -= a
    }
    return t
}
;
class Hz extends ox {
    constructor(e) {
        super(),
        this.observer = void 0,
        this.observer = e
    }
    resetInitSegment(e, t, n, s) {
        super.resetInitSegment(e, t, n, s),
        this._audioTrack = {
            container: "audio/ac-3",
            type: "audio",
            id: 2,
            pid: -1,
            sequenceNumber: 0,
            segmentCodec: "ac3",
            samples: [],
            manifestCodec: t,
            duration: s,
            inputTimeScale: 9e4,
            dropped: 0
        }
    }
    canParse(e, t) {
        return t + 64 < e.length
    }
    appendFrame(e, t, n) {
        const s = xM(e, t, n, this.basePTS, this.frameIndex);
        if (s !== -1)
            return {
                sample: e.samples[e.samples.length - 1],
                length: s,
                missing: 0
            }
    }
    static probe(e) {
        if (!e)
            return !1;
        const t = Fd(e, 0);
        if (!t)
            return !1;
        const n = t.length;
        return e[n] === 11 && e[n + 1] === 119 && ex(t) !== void 0 && _M(e, n) < 16
    }
}
function xM(i, e, t, n, s) {
    if (t + 8 > e.length || e[t] !== 11 || e[t + 1] !== 119)
        return -1;
    const r = e[t + 4] >> 6;
    if (r >= 3)
        return -1;
    const a = [48e3, 44100, 32e3][r]
      , l = e[t + 4] & 63
      , u = [64, 69, 96, 64, 70, 96, 80, 87, 120, 80, 88, 120, 96, 104, 144, 96, 105, 144, 112, 121, 168, 112, 122, 168, 128, 139, 192, 128, 140, 192, 160, 174, 240, 160, 175, 240, 192, 208, 288, 192, 209, 288, 224, 243, 336, 224, 244, 336, 256, 278, 384, 256, 279, 384, 320, 348, 480, 320, 349, 480, 384, 417, 576, 384, 418, 576, 448, 487, 672, 448, 488, 672, 512, 557, 768, 512, 558, 768, 640, 696, 960, 640, 697, 960, 768, 835, 1152, 768, 836, 1152, 896, 975, 1344, 896, 976, 1344, 1024, 1114, 1536, 1024, 1115, 1536, 1152, 1253, 1728, 1152, 1254, 1728, 1280, 1393, 1920, 1280, 1394, 1920][l * 3 + r] * 2;
    if (t + u > e.length)
        return -1;
    const d = e[t + 6] >> 5;
    let f = 0;
    d === 2 ? f += 2 : (d & 1 && d !== 1 && (f += 2),
    d & 4 && (f += 2));
    const h = (e[t + 6] << 8 | e[t + 7]) >> 12 - f & 1
      , g = [2, 1, 2, 3, 3, 4, 4, 5][d] + h
      , m = e[t + 5] >> 3
      , v = e[t + 5] & 7
      , _ = new Uint8Array([r << 6 | m << 1 | v >> 2, (v & 3) << 6 | d << 3 | h << 2 | l >> 4, l << 4 & 224])
      , y = 1536 / a * 9e4
      , b = n + s * y
      , S = e.subarray(t, t + u);
    return i.config = _,
    i.channelCount = g,
    i.samplerate = a,
    i.samples.push({
        unit: S,
        pts: b
    }),
    u
}
class zz {
    constructor() {
        this.VideoSample = null
    }
    createVideoSample(e, t, n, s) {
        return {
            key: e,
            frame: !1,
            pts: t,
            dts: n,
            units: [],
            debug: s,
            length: 0
        }
    }
    getLastNalUnit(e) {
        var t;
        let n = this.VideoSample, s;
        if ((!n || n.units.length === 0) && (n = e[e.length - 1]),
        (t = n) != null && t.units) {
            const r = n.units;
            s = r[r.length - 1]
        }
        return s
    }
    pushAccessUnit(e, t) {
        if (e.units.length && e.frame) {
            if (e.pts === void 0) {
                const n = t.samples
                  , s = n.length;
                if (s) {
                    const r = n[s - 1];
                    e.pts = r.pts,
                    e.dts = r.dts
                } else {
                    t.dropped++;
                    return
                }
            }
            t.samples.push(e)
        }
        e.debug.length && de.log(e.pts + "/" + e.dts + ":" + e.debug)
    }
}
class fS {
    constructor(e) {
        this.data = void 0,
        this.bytesAvailable = void 0,
        this.word = void 0,
        this.bitsAvailable = void 0,
        this.data = e,
        this.bytesAvailable = e.byteLength,
        this.word = 0,
        this.bitsAvailable = 0
    }
    loadWord() {
        const e = this.data
          , t = this.bytesAvailable
          , n = e.byteLength - t
          , s = new Uint8Array(4)
          , r = Math.min(4, t);
        if (r === 0)
            throw new Error("no bytes available");
        s.set(e.subarray(n, n + r)),
        this.word = new DataView(s.buffer).getUint32(0),
        this.bitsAvailable = r * 8,
        this.bytesAvailable -= r
    }
    skipBits(e) {
        let t;
        e = Math.min(e, this.bytesAvailable * 8 + this.bitsAvailable),
        this.bitsAvailable > e ? (this.word <<= e,
        this.bitsAvailable -= e) : (e -= this.bitsAvailable,
        t = e >> 3,
        e -= t << 3,
        this.bytesAvailable -= t,
        this.loadWord(),
        this.word <<= e,
        this.bitsAvailable -= e)
    }
    readBits(e) {
        let t = Math.min(this.bitsAvailable, e);
        const n = this.word >>> 32 - t;
        if (e > 32 && de.error("Cannot read more than 32 bits at a time"),
        this.bitsAvailable -= t,
        this.bitsAvailable > 0)
            this.word <<= t;
        else if (this.bytesAvailable > 0)
            this.loadWord();
        else
            throw new Error("no bits available");
        return t = e - t,
        t > 0 && this.bitsAvailable ? n << t | this.readBits(t) : n
    }
    skipLZ() {
        let e;
        for (e = 0; e < this.bitsAvailable; ++e)
            if ((this.word & 2147483648 >>> e) !== 0)
                return this.word <<= e,
                this.bitsAvailable -= e,
                e;
        return this.loadWord(),
        e + this.skipLZ()
    }
    skipUEG() {
        this.skipBits(1 + this.skipLZ())
    }
    skipEG() {
        this.skipBits(1 + this.skipLZ())
    }
    readUEG() {
        const e = this.skipLZ();
        return this.readBits(e + 1) - 1
    }
    readEG() {
        const e = this.readUEG();
        return 1 & e ? 1 + e >>> 1 : -1 * (e >>> 1)
    }
    readBoolean() {
        return this.readBits(1) === 1
    }
    readUByte() {
        return this.readBits(8)
    }
    readUShort() {
        return this.readBits(16)
    }
    readUInt() {
        return this.readBits(32)
    }
    skipScalingList(e) {
        let t = 8, n = 8, s;
        for (let r = 0; r < e; r++)
            n !== 0 && (s = this.readEG(),
            n = (t + s + 256) % 256),
            t = n === 0 ? t : n
    }
    readSPS() {
        let e = 0, t = 0, n = 0, s = 0, r, o, a;
        const l = this.readUByte.bind(this)
          , c = this.readBits.bind(this)
          , u = this.readUEG.bind(this)
          , d = this.readBoolean.bind(this)
          , f = this.skipBits.bind(this)
          , h = this.skipEG.bind(this)
          , p = this.skipUEG.bind(this)
          , g = this.skipScalingList.bind(this);
        l();
        const m = l();
        if (c(5),
        f(3),
        l(),
        p(),
        m === 100 || m === 110 || m === 122 || m === 244 || m === 44 || m === 83 || m === 86 || m === 118 || m === 128) {
            const C = u();
            if (C === 3 && f(1),
            p(),
            p(),
            f(1),
            d())
                for (o = C !== 3 ? 8 : 12,
                a = 0; a < o; a++)
                    d() && (a < 6 ? g(16) : g(64))
        }
        p();
        const v = u();
        if (v === 0)
            u();
        else if (v === 1)
            for (f(1),
            h(),
            h(),
            r = u(),
            a = 0; a < r; a++)
                h();
        p(),
        f(1);
        const _ = u()
          , y = u()
          , b = c(1);
        b === 0 && f(1),
        f(1),
        d() && (e = u(),
        t = u(),
        n = u(),
        s = u());
        let S = [1, 1];
        if (d() && d())
            switch (l()) {
            case 1:
                S = [1, 1];
                break;
            case 2:
                S = [12, 11];
                break;
            case 3:
                S = [10, 11];
                break;
            case 4:
                S = [16, 11];
                break;
            case 5:
                S = [40, 33];
                break;
            case 6:
                S = [24, 11];
                break;
            case 7:
                S = [20, 11];
                break;
            case 8:
                S = [32, 11];
                break;
            case 9:
                S = [80, 33];
                break;
            case 10:
                S = [18, 11];
                break;
            case 11:
                S = [15, 11];
                break;
            case 12:
                S = [64, 33];
                break;
            case 13:
                S = [160, 99];
                break;
            case 14:
                S = [4, 3];
                break;
            case 15:
                S = [3, 2];
                break;
            case 16:
                S = [2, 1];
                break;
            case 255:
                {
                    S = [l() << 8 | l(), l() << 8 | l()];
                    break
                }
            }
        return {
            width: Math.ceil((_ + 1) * 16 - e * 2 - t * 2),
            height: (2 - b) * (y + 1) * 16 - (b ? 2 : 4) * (n + s),
            pixelRatio: S
        }
    }
    readSliceType() {
        return this.readUByte(),
        this.readUEG(),
        this.readUEG()
    }
}
class Gz extends zz {
    parseAVCPES(e, t, n, s, r) {
        const o = this.parseAVCNALu(e, n.data);
        let a = this.VideoSample, l, c = !1;
        n.data = null,
        a && o.length && !e.audFound && (this.pushAccessUnit(a, e),
        a = this.VideoSample = this.createVideoSample(!1, n.pts, n.dts, "")),
        o.forEach(u => {
            var d;
            switch (u.type) {
            case 1:
                {
                    let g = !1;
                    l = !0;
                    const m = u.data;
                    if (c && m.length > 4) {
                        const v = new fS(m).readSliceType();
                        (v === 2 || v === 4 || v === 7 || v === 9) && (g = !0)
                    }
                    if (g) {
                        var f;
                        (f = a) != null && f.frame && !a.key && (this.pushAccessUnit(a, e),
                        a = this.VideoSample = null)
                    }
                    a || (a = this.VideoSample = this.createVideoSample(!0, n.pts, n.dts, "")),
                    a.frame = !0,
                    a.key = g;
                    break
                }
            case 5:
                l = !0,
                (d = a) != null && d.frame && !a.key && (this.pushAccessUnit(a, e),
                a = this.VideoSample = null),
                a || (a = this.VideoSample = this.createVideoSample(!0, n.pts, n.dts, "")),
                a.key = !0,
                a.frame = !0;
                break;
            case 6:
                {
                    l = !0,
                    XC(u.data, 1, n.pts, t.samples);
                    break
                }
            case 7:
                {
                    var h, p;
                    l = !0,
                    c = !0;
                    const g = u.data
                      , v = new fS(g).readSPS();
                    if (!e.sps || e.width !== v.width || e.height !== v.height || ((h = e.pixelRatio) == null ? void 0 : h[0]) !== v.pixelRatio[0] || ((p = e.pixelRatio) == null ? void 0 : p[1]) !== v.pixelRatio[1]) {
                        e.width = v.width,
                        e.height = v.height,
                        e.pixelRatio = v.pixelRatio,
                        e.sps = [g],
                        e.duration = r;
                        const _ = g.subarray(1, 4);
                        let y = "avc1.";
                        for (let b = 0; b < 3; b++) {
                            let S = _[b].toString(16);
                            S.length < 2 && (S = "0" + S),
                            y += S
                        }
                        e.codec = y
                    }
                    break
                }
            case 8:
                l = !0,
                e.pps = [u.data];
                break;
            case 9:
                l = !0,
                e.audFound = !0,
                a && this.pushAccessUnit(a, e),
                a = this.VideoSample = this.createVideoSample(!1, n.pts, n.dts, "");
                break;
            case 12:
                l = !0;
                break;
            default:
                l = !1,
                a && (a.debug += "unknown NAL " + u.type + " ");
                break
            }
            a && l && a.units.push(u)
        }
        ),
        s && a && (this.pushAccessUnit(a, e),
        this.VideoSample = null)
    }
    parseAVCNALu(e, t) {
        const n = t.byteLength;
        let s = e.naluState || 0;
        const r = s
          , o = [];
        let a = 0, l, c, u, d = -1, f = 0;
        for (s === -1 && (d = 0,
        f = t[0] & 31,
        s = 0,
        a = 1); a < n; ) {
            if (l = t[a++],
            !s) {
                s = l ? 0 : 1;
                continue
            }
            if (s === 1) {
                s = l ? 0 : 2;
                continue
            }
            if (!l)
                s = 3;
            else if (l === 1) {
                if (c = a - s - 1,
                d >= 0) {
                    const h = {
                        data: t.subarray(d, c),
                        type: f
                    };
                    o.push(h)
                } else {
                    const h = this.getLastNalUnit(e.samples);
                    h && (r && a <= 4 - r && h.state && (h.data = h.data.subarray(0, h.data.byteLength - r)),
                    c > 0 && (h.data = qs(h.data, t.subarray(0, c)),
                    h.state = 0))
                }
                a < n ? (u = t[a] & 31,
                d = a,
                f = u,
                s = 0) : s = -1
            } else
                s = 0
        }
        if (d >= 0 && s >= 0) {
            const h = {
                data: t.subarray(d, n),
                type: f,
                state: s
            };
            o.push(h)
        }
        if (o.length === 0) {
            const h = this.getLastNalUnit(e.samples);
            h && (h.data = qs(h.data, t))
        }
        return e.naluState = s,
        o
    }
}
class Wz {
    constructor(e, t, n) {
        this.keyData = void 0,
        this.decrypter = void 0,
        this.keyData = n,
        this.decrypter = new sx(t,{
            removePKCS7Padding: !1
        })
    }
    decryptBuffer(e) {
        return this.decrypter.decrypt(e, this.keyData.key.buffer, this.keyData.iv.buffer)
    }
    decryptAacSample(e, t, n) {
        const s = e[t].unit;
        if (s.length <= 16)
            return;
        const r = s.subarray(16, s.length - s.length % 16)
          , o = r.buffer.slice(r.byteOffset, r.byteOffset + r.length);
        this.decryptBuffer(o).then(a => {
            const l = new Uint8Array(a);
            s.set(l, 16),
            this.decrypter.isSync() || this.decryptAacSamples(e, t + 1, n)
        }
        )
    }
    decryptAacSamples(e, t, n) {
        for (; ; t++) {
            if (t >= e.length) {
                n();
                return
            }
            if (!(e[t].unit.length < 32) && (this.decryptAacSample(e, t, n),
            !this.decrypter.isSync()))
                return
        }
    }
    getAvcEncryptedData(e) {
        const t = Math.floor((e.length - 48) / 160) * 16 + 16
          , n = new Int8Array(t);
        let s = 0;
        for (let r = 32; r < e.length - 16; r += 160,
        s += 16)
            n.set(e.subarray(r, r + 16), s);
        return n
    }
    getAvcDecryptedUnit(e, t) {
        const n = new Uint8Array(t);
        let s = 0;
        for (let r = 32; r < e.length - 16; r += 160,
        s += 16)
            e.set(n.subarray(s, s + 16), r);
        return e
    }
    decryptAvcSample(e, t, n, s, r) {
        const o = YC(r.data)
          , a = this.getAvcEncryptedData(o);
        this.decryptBuffer(a.buffer).then(l => {
            r.data = this.getAvcDecryptedUnit(o, l),
            this.decrypter.isSync() || this.decryptAvcSamples(e, t, n + 1, s)
        }
        )
    }
    decryptAvcSamples(e, t, n, s) {
        if (e instanceof Uint8Array)
            throw new Error("Cannot decrypt samples of type Uint8Array");
        for (; ; t++,
        n = 0) {
            if (t >= e.length) {
                s();
                return
            }
            const r = e[t].units;
            for (; !(n >= r.length); n++) {
                const o = r[n];
                if (!(o.data.length <= 48 || o.type !== 1 && o.type !== 5) && (this.decryptAvcSample(e, t, n, s, o),
                !this.decrypter.isSync()))
                    return
            }
        }
    }
}
const fi = 188;
class ra {
    constructor(e, t, n) {
        this.observer = void 0,
        this.config = void 0,
        this.typeSupported = void 0,
        this.sampleAes = null,
        this.pmtParsed = !1,
        this.audioCodec = void 0,
        this.videoCodec = void 0,
        this._duration = 0,
        this._pmtId = -1,
        this._videoTrack = void 0,
        this._audioTrack = void 0,
        this._id3Track = void 0,
        this._txtTrack = void 0,
        this.aacOverFlow = null,
        this.remainderData = null,
        this.videoParser = void 0,
        this.observer = e,
        this.config = t,
        this.typeSupported = n,
        this.videoParser = new Gz
    }
    static probe(e) {
        const t = ra.syncOffset(e);
        return t > 0 && de.warn(`MPEG2-TS detected but first sync word found @ offset ${t}`),
        t !== -1
    }
    static syncOffset(e) {
        const t = e.length;
        let n = Math.min(fi * 5, t - fi) + 1
          , s = 0;
        for (; s < n; ) {
            let r = !1
              , o = -1
              , a = 0;
            for (let l = s; l < t; l += fi)
                if (e[l] === 71 && (t - l === fi || e[l + fi] === 71)) {
                    if (a++,
                    o === -1 && (o = l,
                    o !== 0 && (n = Math.min(o + fi * 99, e.length - fi) + 1)),
                    r || (r = W1(e, l) === 0),
                    r && a > 1 && (o === 0 && a > 2 || l + fi > n))
                        return o
                } else {
                    if (a)
                        return -1;
                    break
                }
            s++
        }
        return -1
    }
    static createTrack(e, t) {
        return {
            container: e === "video" || e === "audio" ? "video/mp2t" : void 0,
            type: e,
            id: GC[e],
            pid: -1,
            inputTimeScale: 9e4,
            sequenceNumber: 0,
            samples: [],
            dropped: 0,
            duration: e === "audio" ? t : void 0
        }
    }
    resetInitSegment(e, t, n, s) {
        this.pmtParsed = !1,
        this._pmtId = -1,
        this._videoTrack = ra.createTrack("video"),
        this._audioTrack = ra.createTrack("audio", s),
        this._id3Track = ra.createTrack("id3"),
        this._txtTrack = ra.createTrack("text"),
        this._audioTrack.segmentCodec = "aac",
        this.aacOverFlow = null,
        this.remainderData = null,
        this.audioCodec = t,
        this.videoCodec = n,
        this._duration = s
    }
    resetTimeStamp() {}
    resetContiguity() {
        const {_audioTrack: e, _videoTrack: t, _id3Track: n} = this;
        e && (e.pesData = null),
        t && (t.pesData = null),
        n && (n.pesData = null),
        this.aacOverFlow = null,
        this.remainderData = null
    }
    demux(e, t, n=!1, s=!1) {
        n || (this.sampleAes = null);
        let r;
        const o = this._videoTrack
          , a = this._audioTrack
          , l = this._id3Track
          , c = this._txtTrack;
        let u = o.pid
          , d = o.pesData
          , f = a.pid
          , h = l.pid
          , p = a.pesData
          , g = l.pesData
          , m = null
          , v = this.pmtParsed
          , _ = this._pmtId
          , y = e.length;
        if (this.remainderData && (e = qs(this.remainderData, e),
        y = e.length,
        this.remainderData = null),
        y < fi && !s)
            return this.remainderData = e,
            {
                audioTrack: a,
                videoTrack: o,
                id3Track: l,
                textTrack: c
            };
        const b = Math.max(0, ra.syncOffset(e));
        y -= (y - b) % fi,
        y < e.byteLength && !s && (this.remainderData = new Uint8Array(e.buffer,y,e.buffer.byteLength - y));
        let S = 0;
        for (let M = b; M < y; M += fi)
            if (e[M] === 71) {
                const L = !!(e[M + 1] & 64)
                  , T = W1(e, M)
                  , A = (e[M + 3] & 48) >> 4;
                let k;
                if (A > 1) {
                    if (k = M + 5 + e[M + 4],
                    k === M + fi)
                        continue
                } else
                    k = M + 4;
                switch (T) {
                case u:
                    L && (d && (r = Zl(d)) && this.videoParser.parseAVCPES(o, c, r, !1, this._duration),
                    d = {
                        data: [],
                        size: 0
                    }),
                    d && (d.data.push(e.subarray(k, M + fi)),
                    d.size += M + fi - k);
                    break;
                case f:
                    if (L) {
                        if (p && (r = Zl(p)))
                            switch (a.segmentCodec) {
                            case "aac":
                                this.parseAACPES(a, r);
                                break;
                            case "mp3":
                                this.parseMPEGPES(a, r);
                                break;
                            case "ac3":
                                this.parseAC3PES(a, r);
                                break
                            }
                        p = {
                            data: [],
                            size: 0
                        }
                    }
                    p && (p.data.push(e.subarray(k, M + fi)),
                    p.size += M + fi - k);
                    break;
                case h:
                    L && (g && (r = Zl(g)) && this.parseID3PES(l, r),
                    g = {
                        data: [],
                        size: 0
                    }),
                    g && (g.data.push(e.subarray(k, M + fi)),
                    g.size += M + fi - k);
                    break;
                case 0:
                    L && (k += e[k] + 1),
                    _ = this._pmtId = qz(e, k);
                    break;
                case _:
                    {
                        L && (k += e[k] + 1);
                        const D = jz(e, k, this.typeSupported, n, this.observer);
                        u = D.videoPid,
                        u > 0 && (o.pid = u,
                        o.segmentCodec = D.segmentVideoCodec),
                        f = D.audioPid,
                        f > 0 && (a.pid = f,
                        a.segmentCodec = D.segmentAudioCodec),
                        h = D.id3Pid,
                        h > 0 && (l.pid = h),
                        m !== null && !v && (de.warn(`MPEG-TS PMT found at ${M} after unknown PID '${m}'. Backtracking to sync byte @${b} to parse all TS packets.`),
                        m = null,
                        M = b - 188),
                        v = this.pmtParsed = !0;
                        break
                    }
                case 17:
                case 8191:
                    break;
                default:
                    m = T;
                    break
                }
            } else
                S++;
        S > 0 && Fp(this.observer, new Error(`Found ${S} TS packet/s that do not start with 0x47`)),
        o.pesData = d,
        a.pesData = p,
        l.pesData = g;
        const C = {
            audioTrack: a,
            videoTrack: o,
            id3Track: l,
            textTrack: c
        };
        return s && this.extractRemainingSamples(C),
        C
    }
    flush() {
        const {remainderData: e} = this;
        this.remainderData = null;
        let t;
        return e ? t = this.demux(e, -1, !1, !0) : t = {
            videoTrack: this._videoTrack,
            audioTrack: this._audioTrack,
            id3Track: this._id3Track,
            textTrack: this._txtTrack
        },
        this.extractRemainingSamples(t),
        this.sampleAes ? this.decrypt(t, this.sampleAes) : t
    }
    extractRemainingSamples(e) {
        const {audioTrack: t, videoTrack: n, id3Track: s, textTrack: r} = e
          , o = n.pesData
          , a = t.pesData
          , l = s.pesData;
        let c;
        if (o && (c = Zl(o)) ? (this.videoParser.parseAVCPES(n, r, c, !0, this._duration),
        n.pesData = null) : n.pesData = o,
        a && (c = Zl(a))) {
            switch (t.segmentCodec) {
            case "aac":
                this.parseAACPES(t, c);
                break;
            case "mp3":
                this.parseMPEGPES(t, c);
                break;
            case "ac3":
                this.parseAC3PES(t, c);
                break
            }
            t.pesData = null
        } else
            a != null && a.size && de.log("last AAC PES packet truncated,might overlap between fragments"),
            t.pesData = a;
        l && (c = Zl(l)) ? (this.parseID3PES(s, c),
        s.pesData = null) : s.pesData = l
    }
    demuxSampleAes(e, t, n) {
        const s = this.demux(e, n, !0, !this.config.progressive)
          , r = this.sampleAes = new Wz(this.observer,this.config,t);
        return this.decrypt(s, r)
    }
    decrypt(e, t) {
        return new Promise(n => {
            const {audioTrack: s, videoTrack: r} = e;
            s.samples && s.segmentCodec === "aac" ? t.decryptAacSamples(s.samples, 0, () => {
                r.samples ? t.decryptAvcSamples(r.samples, 0, 0, () => {
                    n(e)
                }
                ) : n(e)
            }
            ) : r.samples && t.decryptAvcSamples(r.samples, 0, 0, () => {
                n(e)
            }
            )
        }
        )
    }
    destroy() {
        this._duration = 0
    }
    parseAACPES(e, t) {
        let n = 0;
        const s = this.aacOverFlow;
        let r = t.data;
        if (s) {
            this.aacOverFlow = null;
            const d = s.missing
              , f = s.sample.unit.byteLength;
            if (d === -1)
                r = qs(s.sample.unit, r);
            else {
                const h = f - d;
                s.sample.unit.set(r.subarray(0, d), h),
                e.samples.push(s.sample),
                n = s.missing
            }
        }
        let o, a;
        for (o = n,
        a = r.length; o < a - 1 && !Dp(r, o); o++)
            ;
        if (o !== n) {
            let d;
            const f = o < a - 1;
            if (f ? d = `AAC PES did not start with ADTS header,offset:${o}` : d = "No ADTS header found in AAC PES",
            Fp(this.observer, new Error(d), f),
            !f)
                return
        }
        dM(e, this.observer, r, o, this.audioCodec);
        let l;
        if (t.pts !== void 0)
            l = t.pts;
        else if (s) {
            const d = fM(e.samplerate);
            l = s.sample.pts + d
        } else {
            de.warn("[tsdemuxer]: AAC PES unknown PTS");
            return
        }
        let c = 0, u;
        for (; o < a; )
            if (u = hM(e, r, o, l, c),
            o += u.length,
            u.missing) {
                this.aacOverFlow = u;
                break
            } else
                for (c++; o < a - 1 && !Dp(r, o); o++)
                    ;
    }
    parseMPEGPES(e, t) {
        const n = t.data
          , s = n.length;
        let r = 0
          , o = 0;
        const a = t.pts;
        if (a === void 0) {
            de.warn("[tsdemuxer]: MPEG PES unknown PTS");
            return
        }
        for (; o < s; )
            if (gM(n, o)) {
                const l = pM(e, n, o, a, r);
                if (l)
                    o += l.length,
                    r++;
                else
                    break
            } else
                o++
    }
    parseAC3PES(e, t) {
        {
            const n = t.data
              , s = t.pts;
            if (s === void 0) {
                de.warn("[tsdemuxer]: AC3 PES unknown PTS");
                return
            }
            const r = n.length;
            let o = 0, a = 0, l;
            for (; a < r && (l = xM(e, n, a, s, o++)) > 0; )
                a += l
        }
    }
    parseID3PES(e, t) {
        if (t.pts === void 0) {
            de.warn("[tsdemuxer]: ID3 PES unknown PTS");
            return
        }
        const n = Qn({}, t, {
            type: this._videoTrack ? or.emsg : or.audioId3,
            duration: Number.POSITIVE_INFINITY
        });
        e.samples.push(n)
    }
}
function W1(i, e) {
    return ((i[e + 1] & 31) << 8) + i[e + 2]
}
function qz(i, e) {
    return (i[e + 10] & 31) << 8 | i[e + 11]
}
function jz(i, e, t, n, s) {
    const r = {
        audioPid: -1,
        videoPid: -1,
        id3Pid: -1,
        segmentVideoCodec: "avc",
        segmentAudioCodec: "aac"
    }
      , o = (i[e + 1] & 15) << 8 | i[e + 2]
      , a = e + 3 + o - 4
      , l = (i[e + 10] & 15) << 8 | i[e + 11];
    for (e += 12 + l; e < a; ) {
        const c = W1(i, e)
          , u = (i[e + 3] & 15) << 8 | i[e + 4];
        switch (i[e]) {
        case 207:
            if (!n) {
                L0("ADTS AAC");
                break
            }
        case 15:
            r.audioPid === -1 && (r.audioPid = c);
            break;
        case 21:
            r.id3Pid === -1 && (r.id3Pid = c);
            break;
        case 219:
            if (!n) {
                L0("H.264");
                break
            }
        case 27:
            r.videoPid === -1 && (r.videoPid = c,
            r.segmentVideoCodec = "avc");
            break;
        case 3:
        case 4:
            !t.mpeg && !t.mp3 ? de.log("MPEG audio found, not supported in this browser") : r.audioPid === -1 && (r.audioPid = c,
            r.segmentAudioCodec = "mp3");
            break;
        case 193:
            if (!n) {
                L0("AC-3");
                break
            }
        case 129:
            t.ac3 ? r.audioPid === -1 && (r.audioPid = c,
            r.segmentAudioCodec = "ac3") : de.log("AC-3 audio found, not supported in this browser");
            break;
        case 6:
            if (r.audioPid === -1 && u > 0) {
                let d = e + 5
                  , f = u;
                for (; f > 2; ) {
                    switch (i[d]) {
                    case 106:
                        t.ac3 !== !0 ? de.log("AC-3 audio found, not supported in this browser for now") : (r.audioPid = c,
                        r.segmentAudioCodec = "ac3");
                        break
                    }
                    const p = i[d + 1] + 2;
                    d += p,
                    f -= p
                }
            }
            break;
        case 194:
        case 135:
            return Fp(s, new Error("Unsupported EC-3 in M2TS found")),
            r;
        case 36:
            return Fp(s, new Error("Unsupported HEVC in M2TS found")),
            r
        }
        e += u + 5
    }
    return r
}
function Fp(i, e, t) {
    de.warn(`parsing error: ${e.message}`),
    i.emit(P.ERROR, P.ERROR, {
        type: Ut.MEDIA_ERROR,
        details: Ae.FRAG_PARSING_ERROR,
        fatal: !1,
        levelRetry: t,
        error: e,
        reason: e.message
    })
}
function L0(i) {
    de.log(`${i} with AES-128-CBC encryption found in unencrypted stream`)
}
function Zl(i) {
    let e = 0, t, n, s, r, o;
    const a = i.data;
    if (!i || i.size === 0)
        return null;
    for (; a[0].length < 19 && a.length > 1; )
        a[0] = qs(a[0], a[1]),
        a.splice(1, 1);
    if (t = a[0],
    (t[0] << 16) + (t[1] << 8) + t[2] === 1) {
        if (n = (t[4] << 8) + t[5],
        n && n > i.size - 6)
            return null;
        const c = t[7];
        c & 192 && (r = (t[9] & 14) * 536870912 + (t[10] & 255) * 4194304 + (t[11] & 254) * 16384 + (t[12] & 255) * 128 + (t[13] & 254) / 2,
        c & 64 ? (o = (t[14] & 14) * 536870912 + (t[15] & 255) * 4194304 + (t[16] & 254) * 16384 + (t[17] & 255) * 128 + (t[18] & 254) / 2,
        r - o > 60 * 9e4 && (de.warn(`${Math.round((r - o) / 9e4)}s delta between PTS and DTS, align them`),
        r = o)) : o = r),
        s = t[8];
        let u = s + 9;
        if (i.size <= u)
            return null;
        i.size -= u;
        const d = new Uint8Array(i.size);
        for (let f = 0, h = a.length; f < h; f++) {
            t = a[f];
            let p = t.byteLength;
            if (u)
                if (u > p) {
                    u -= p;
                    continue
                } else
                    t = t.subarray(u),
                    p -= u,
                    u = 0;
            d.set(t, e),
            e += p
        }
        return n && (n -= s + 3),
        {
            data: d,
            pts: r,
            dts: o,
            len: n
        }
    }
    return null
}
class Kz extends ox {
    resetInitSegment(e, t, n, s) {
        super.resetInitSegment(e, t, n, s),
        this._audioTrack = {
            container: "audio/mpeg",
            type: "audio",
            id: 2,
            pid: -1,
            sequenceNumber: 0,
            segmentCodec: "mp3",
            samples: [],
            manifestCodec: t,
            duration: s,
            inputTimeScale: 9e4,
            dropped: 0
        }
    }
    static probe(e) {
        if (!e)
            return !1;
        const t = Fd(e, 0);
        let n = (t == null ? void 0 : t.length) || 0;
        if (t && e[n] === 11 && e[n + 1] === 119 && ex(t) !== void 0 && _M(e, n) <= 16)
            return !1;
        for (let s = e.length; n < s; n++)
            if (vM(e, n))
                return de.log("MPEG Audio sync word found !"),
                !0;
        return !1
    }
    canParse(e, t) {
        return Nz(e, t)
    }
    appendFrame(e, t, n) {
        if (this.basePTS !== null)
            return pM(e, t, n, this.basePTS, this.frameIndex)
    }
}
class hS {
    static getSilentFrame(e, t) {
        switch (e) {
        case "mp4a.40.2":
            if (t === 1)
                return new Uint8Array([0, 200, 0, 128, 35, 128]);
            if (t === 2)
                return new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]);
            if (t === 3)
                return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142]);
            if (t === 4)
                return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56]);
            if (t === 5)
                return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56]);
            if (t === 6)
                return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224]);
            break;
        default:
            if (t === 1)
                return new Uint8Array([1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0, 28, 6, 241, 193, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
            if (t === 2)
                return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
            if (t === 3)
                return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
            break
        }
    }
}
const Go = Math.pow(2, 32) - 1;
class ve {
    static init() {
        ve.types = {
            avc1: [],
            avcC: [],
            btrt: [],
            dinf: [],
            dref: [],
            esds: [],
            ftyp: [],
            hdlr: [],
            mdat: [],
            mdhd: [],
            mdia: [],
            mfhd: [],
            minf: [],
            moof: [],
            moov: [],
            mp4a: [],
            ".mp3": [],
            dac3: [],
            "ac-3": [],
            mvex: [],
            mvhd: [],
            pasp: [],
            sdtp: [],
            stbl: [],
            stco: [],
            stsc: [],
            stsd: [],
            stsz: [],
            stts: [],
            tfdt: [],
            tfhd: [],
            traf: [],
            trak: [],
            trun: [],
            trex: [],
            tkhd: [],
            vmhd: [],
            smhd: []
        };
        let e;
        for (e in ve.types)
            ve.types.hasOwnProperty(e) && (ve.types[e] = [e.charCodeAt(0), e.charCodeAt(1), e.charCodeAt(2), e.charCodeAt(3)]);
        const t = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 118, 105, 100, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 105, 100, 101, 111, 72, 97, 110, 100, 108, 101, 114, 0])
          , n = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 115, 111, 117, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 111, 117, 110, 100, 72, 97, 110, 100, 108, 101, 114, 0]);
        ve.HDLR_TYPES = {
            video: t,
            audio: n
        };
        const s = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 117, 114, 108, 32, 0, 0, 0, 1])
          , r = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]);
        ve.STTS = ve.STSC = ve.STCO = r,
        ve.STSZ = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
        ve.VMHD = new Uint8Array([0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]),
        ve.SMHD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]),
        ve.STSD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1]);
        const o = new Uint8Array([105, 115, 111, 109])
          , a = new Uint8Array([97, 118, 99, 49])
          , l = new Uint8Array([0, 0, 0, 1]);
        ve.FTYP = ve.box(ve.types.ftyp, o, l, o, a),
        ve.DINF = ve.box(ve.types.dinf, ve.box(ve.types.dref, s))
    }
    static box(e, ...t) {
        let n = 8
          , s = t.length;
        const r = s;
        for (; s--; )
            n += t[s].byteLength;
        const o = new Uint8Array(n);
        for (o[0] = n >> 24 & 255,
        o[1] = n >> 16 & 255,
        o[2] = n >> 8 & 255,
        o[3] = n & 255,
        o.set(e, 4),
        s = 0,
        n = 8; s < r; s++)
            o.set(t[s], n),
            n += t[s].byteLength;
        return o
    }
    static hdlr(e) {
        return ve.box(ve.types.hdlr, ve.HDLR_TYPES[e])
    }
    static mdat(e) {
        return ve.box(ve.types.mdat, e)
    }
    static mdhd(e, t) {
        t *= e;
        const n = Math.floor(t / (Go + 1))
          , s = Math.floor(t % (Go + 1));
        return ve.box(ve.types.mdhd, new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, e & 255, n >> 24, n >> 16 & 255, n >> 8 & 255, n & 255, s >> 24, s >> 16 & 255, s >> 8 & 255, s & 255, 85, 196, 0, 0]))
    }
    static mdia(e) {
        return ve.box(ve.types.mdia, ve.mdhd(e.timescale, e.duration), ve.hdlr(e.type), ve.minf(e))
    }
    static mfhd(e) {
        return ve.box(ve.types.mfhd, new Uint8Array([0, 0, 0, 0, e >> 24, e >> 16 & 255, e >> 8 & 255, e & 255]))
    }
    static minf(e) {
        return e.type === "audio" ? ve.box(ve.types.minf, ve.box(ve.types.smhd, ve.SMHD), ve.DINF, ve.stbl(e)) : ve.box(ve.types.minf, ve.box(ve.types.vmhd, ve.VMHD), ve.DINF, ve.stbl(e))
    }
    static moof(e, t, n) {
        return ve.box(ve.types.moof, ve.mfhd(e), ve.traf(n, t))
    }
    static moov(e) {
        let t = e.length;
        const n = [];
        for (; t--; )
            n[t] = ve.trak(e[t]);
        return ve.box.apply(null, [ve.types.moov, ve.mvhd(e[0].timescale, e[0].duration)].concat(n).concat(ve.mvex(e)))
    }
    static mvex(e) {
        let t = e.length;
        const n = [];
        for (; t--; )
            n[t] = ve.trex(e[t]);
        return ve.box.apply(null, [ve.types.mvex, ...n])
    }
    static mvhd(e, t) {
        t *= e;
        const n = Math.floor(t / (Go + 1))
          , s = Math.floor(t % (Go + 1))
          , r = new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, e & 255, n >> 24, n >> 16 & 255, n >> 8 & 255, n & 255, s >> 24, s >> 16 & 255, s >> 8 & 255, s & 255, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255]);
        return ve.box(ve.types.mvhd, r)
    }
    static sdtp(e) {
        const t = e.samples || []
          , n = new Uint8Array(4 + t.length);
        let s, r;
        for (s = 0; s < t.length; s++)
            r = t[s].flags,
            n[s + 4] = r.dependsOn << 4 | r.isDependedOn << 2 | r.hasRedundancy;
        return ve.box(ve.types.sdtp, n)
    }
    static stbl(e) {
        return ve.box(ve.types.stbl, ve.stsd(e), ve.box(ve.types.stts, ve.STTS), ve.box(ve.types.stsc, ve.STSC), ve.box(ve.types.stsz, ve.STSZ), ve.box(ve.types.stco, ve.STCO))
    }
    static avc1(e) {
        let t = [], n = [], s, r, o;
        for (s = 0; s < e.sps.length; s++)
            r = e.sps[s],
            o = r.byteLength,
            t.push(o >>> 8 & 255),
            t.push(o & 255),
            t = t.concat(Array.prototype.slice.call(r));
        for (s = 0; s < e.pps.length; s++)
            r = e.pps[s],
            o = r.byteLength,
            n.push(o >>> 8 & 255),
            n.push(o & 255),
            n = n.concat(Array.prototype.slice.call(r));
        const a = ve.box(ve.types.avcC, new Uint8Array([1, t[3], t[4], t[5], 255, 224 | e.sps.length].concat(t).concat([e.pps.length]).concat(n)))
          , l = e.width
          , c = e.height
          , u = e.pixelRatio[0]
          , d = e.pixelRatio[1];
        return ve.box(ve.types.avc1, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, l >> 8 & 255, l & 255, c >> 8 & 255, c & 255, 0, 72, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 1, 18, 100, 97, 105, 108, 121, 109, 111, 116, 105, 111, 110, 47, 104, 108, 115, 46, 106, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 17, 17]), a, ve.box(ve.types.btrt, new Uint8Array([0, 28, 156, 128, 0, 45, 198, 192, 0, 45, 198, 192])), ve.box(ve.types.pasp, new Uint8Array([u >> 24, u >> 16 & 255, u >> 8 & 255, u & 255, d >> 24, d >> 16 & 255, d >> 8 & 255, d & 255])))
    }
    static esds(e) {
        const t = e.config.length;
        return new Uint8Array([0, 0, 0, 0, 3, 23 + t, 0, 1, 0, 4, 15 + t, 64, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5].concat([t]).concat(e.config).concat([6, 1, 2]))
    }
    static audioStsd(e) {
        const t = e.samplerate;
        return new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, e.channelCount, 0, 16, 0, 0, 0, 0, t >> 8 & 255, t & 255, 0, 0])
    }
    static mp4a(e) {
        return ve.box(ve.types.mp4a, ve.audioStsd(e), ve.box(ve.types.esds, ve.esds(e)))
    }
    static mp3(e) {
        return ve.box(ve.types[".mp3"], ve.audioStsd(e))
    }
    static ac3(e) {
        return ve.box(ve.types["ac-3"], ve.audioStsd(e), ve.box(ve.types.dac3, e.config))
    }
    static stsd(e) {
        return e.type === "audio" ? e.segmentCodec === "mp3" && e.codec === "mp3" ? ve.box(ve.types.stsd, ve.STSD, ve.mp3(e)) : e.segmentCodec === "ac3" ? ve.box(ve.types.stsd, ve.STSD, ve.ac3(e)) : ve.box(ve.types.stsd, ve.STSD, ve.mp4a(e)) : ve.box(ve.types.stsd, ve.STSD, ve.avc1(e))
    }
    static tkhd(e) {
        const t = e.id
          , n = e.duration * e.timescale
          , s = e.width
          , r = e.height
          , o = Math.floor(n / (Go + 1))
          , a = Math.floor(n % (Go + 1));
        return ve.box(ve.types.tkhd, new Uint8Array([1, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, t & 255, 0, 0, 0, 0, o >> 24, o >> 16 & 255, o >> 8 & 255, o & 255, a >> 24, a >> 16 & 255, a >> 8 & 255, a & 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, s >> 8 & 255, s & 255, 0, 0, r >> 8 & 255, r & 255, 0, 0]))
    }
    static traf(e, t) {
        const n = ve.sdtp(e)
          , s = e.id
          , r = Math.floor(t / (Go + 1))
          , o = Math.floor(t % (Go + 1));
        return ve.box(ve.types.traf, ve.box(ve.types.tfhd, new Uint8Array([0, 0, 0, 0, s >> 24, s >> 16 & 255, s >> 8 & 255, s & 255])), ve.box(ve.types.tfdt, new Uint8Array([1, 0, 0, 0, r >> 24, r >> 16 & 255, r >> 8 & 255, r & 255, o >> 24, o >> 16 & 255, o >> 8 & 255, o & 255])), ve.trun(e, n.length + 16 + 20 + 8 + 16 + 8 + 8), n)
    }
    static trak(e) {
        return e.duration = e.duration || 4294967295,
        ve.box(ve.types.trak, ve.tkhd(e), ve.mdia(e))
    }
    static trex(e) {
        const t = e.id;
        return ve.box(ve.types.trex, new Uint8Array([0, 0, 0, 0, t >> 24, t >> 16 & 255, t >> 8 & 255, t & 255, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1]))
    }
    static trun(e, t) {
        const n = e.samples || []
          , s = n.length
          , r = 12 + 16 * s
          , o = new Uint8Array(r);
        let a, l, c, u, d, f;
        for (t += 8 + r,
        o.set([e.type === "video" ? 1 : 0, 0, 15, 1, s >>> 24 & 255, s >>> 16 & 255, s >>> 8 & 255, s & 255, t >>> 24 & 255, t >>> 16 & 255, t >>> 8 & 255, t & 255], 0),
        a = 0; a < s; a++)
            l = n[a],
            c = l.duration,
            u = l.size,
            d = l.flags,
            f = l.cts,
            o.set([c >>> 24 & 255, c >>> 16 & 255, c >>> 8 & 255, c & 255, u >>> 24 & 255, u >>> 16 & 255, u >>> 8 & 255, u & 255, d.isLeading << 2 | d.dependsOn, d.isDependedOn << 6 | d.hasRedundancy << 4 | d.paddingValue << 1 | d.isNonSync, d.degradPrio & 240 << 8, d.degradPrio & 15, f >>> 24 & 255, f >>> 16 & 255, f >>> 8 & 255, f & 255], 12 + 16 * a);
        return ve.box(ve.types.trun, o)
    }
    static initSegment(e) {
        ve.types || ve.init();
        const t = ve.moov(e);
        return qs(ve.FTYP, t)
    }
}
ve.types = void 0;
ve.HDLR_TYPES = void 0;
ve.STTS = void 0;
ve.STSC = void 0;
ve.STCO = void 0;
ve.STSZ = void 0;
ve.VMHD = void 0;
ve.SMHD = void 0;
ve.STSD = void 0;
ve.FTYP = void 0;
ve.DINF = void 0;
const yM = 9e4;
function cx(i, e, t=1, n=!1) {
    const s = i * e * t;
    return n ? Math.round(s) : s
}
function Xz(i, e, t=1, n=!1) {
    return cx(i, e, 1 / t, n)
}
function Fu(i, e=!1) {
    return cx(i, 1e3, 1 / yM, e)
}
function Yz(i, e=1) {
    return cx(i, yM, 1 / e)
}
const Zz = 10 * 1e3
  , pS = 1024
  , Jz = 1152
  , Qz = 1536;
let Jl = null
  , I0 = null;
class Lh {
    constructor(e, t, n, s="") {
        if (this.observer = void 0,
        this.config = void 0,
        this.typeSupported = void 0,
        this.ISGenerated = !1,
        this._initPTS = null,
        this._initDTS = null,
        this.nextAvcDts = null,
        this.nextAudioPts = null,
        this.videoSampleDuration = null,
        this.isAudioContiguous = !1,
        this.isVideoContiguous = !1,
        this.videoTrackConfig = void 0,
        this.observer = e,
        this.config = t,
        this.typeSupported = n,
        this.ISGenerated = !1,
        Jl === null) {
            const o = (navigator.userAgent || "").match(/Chrome\/(\d+)/i);
            Jl = o ? parseInt(o[1]) : 0
        }
        if (I0 === null) {
            const r = navigator.userAgent.match(/Safari\/(\d+)/i);
            I0 = r ? parseInt(r[1]) : 0
        }
    }
    destroy() {
        this.config = this.videoTrackConfig = this._initPTS = this._initDTS = null
    }
    resetTimeStamp(e) {
        de.log("[mp4-remuxer]: initPTS & initDTS reset"),
        this._initPTS = this._initDTS = e
    }
    resetNextTimestamp() {
        de.log("[mp4-remuxer]: reset next timestamp"),
        this.isVideoContiguous = !1,
        this.isAudioContiguous = !1
    }
    resetInitSegment() {
        de.log("[mp4-remuxer]: ISGenerated flag reset"),
        this.ISGenerated = !1,
        this.videoTrackConfig = void 0
    }
    getVideoStartPts(e) {
        let t = !1;
        const n = e.reduce( (s, r) => {
            const o = r.pts - s;
            return o < -4294967296 ? (t = !0,
            Fs(s, r.pts)) : o > 0 ? s : r.pts
        }
        , e[0].pts);
        return t && de.debug("PTS rollover detected"),
        n
    }
    remux(e, t, n, s, r, o, a, l) {
        let c, u, d, f, h, p, g = r, m = r;
        const v = e.pid > -1
          , _ = t.pid > -1
          , y = t.samples.length
          , b = e.samples.length > 0
          , S = a && y > 0 || y > 1;
        if ((!v || b) && (!_ || S) || this.ISGenerated || a) {
            if (this.ISGenerated) {
                var M, L, T, A;
                const z = this.videoTrackConfig;
                z && (t.width !== z.width || t.height !== z.height || ((M = t.pixelRatio) == null ? void 0 : M[0]) !== ((L = z.pixelRatio) == null ? void 0 : L[0]) || ((T = t.pixelRatio) == null ? void 0 : T[1]) !== ((A = z.pixelRatio) == null ? void 0 : A[1])) && this.resetInitSegment()
            } else
                d = this.generateIS(e, t, r, o);
            const k = this.isVideoContiguous;
            let D = -1, F;
            if (S && (D = eG(t.samples),
            !k && this.config.forceKeyFrameOnDiscontinuity))
                if (p = !0,
                D > 0) {
                    de.warn(`[mp4-remuxer]: Dropped ${D} out of ${y} video samples due to a missing keyframe`);
                    const z = this.getVideoStartPts(t.samples);
                    t.samples = t.samples.slice(D),
                    t.dropped += D,
                    m += (t.samples[0].pts - z) / t.inputTimeScale,
                    F = m
                } else
                    D === -1 && (de.warn(`[mp4-remuxer]: No keyframe found out of ${y} video samples`),
                    p = !1);
            if (this.ISGenerated) {
                if (b && S) {
                    const z = this.getVideoStartPts(t.samples)
                      , H = (Fs(e.samples[0].pts, z) - z) / t.inputTimeScale;
                    g += Math.max(0, H),
                    m += Math.max(0, -H)
                }
                if (b) {
                    if (e.samplerate || (de.warn("[mp4-remuxer]: regenerate InitSegment as audio detected"),
                    d = this.generateIS(e, t, r, o)),
                    u = this.remuxAudio(e, g, this.isAudioContiguous, o, _ || S || l === Ct.AUDIO ? m : void 0),
                    S) {
                        const z = u ? u.endPTS - u.startPTS : 0;
                        t.inputTimeScale || (de.warn("[mp4-remuxer]: regenerate InitSegment as video detected"),
                        d = this.generateIS(e, t, r, o)),
                        c = this.remuxVideo(t, m, k, z)
                    }
                } else
                    S && (c = this.remuxVideo(t, m, k, 0));
                c && (c.firstKeyFrame = D,
                c.independent = D !== -1,
                c.firstKeyFramePTS = F)
            }
        }
        return this.ISGenerated && this._initPTS && this._initDTS && (n.samples.length && (h = bM(n, r, this._initPTS, this._initDTS)),
        s.samples.length && (f = SM(s, r, this._initPTS))),
        {
            audio: u,
            video: c,
            initSegment: d,
            independent: p,
            text: f,
            id3: h
        }
    }
    generateIS(e, t, n, s) {
        const r = e.samples
          , o = t.samples
          , a = this.typeSupported
          , l = {}
          , c = this._initPTS;
        let u = !c || s, d = "audio/mp4", f, h, p;
        if (u && (f = h = 1 / 0),
        e.config && r.length) {
            switch (e.timescale = e.samplerate,
            e.segmentCodec) {
            case "mp3":
                a.mpeg ? (d = "audio/mpeg",
                e.codec = "") : a.mp3 && (e.codec = "mp3");
                break;
            case "ac3":
                e.codec = "ac-3";
                break
            }
            l.audio = {
                id: "audio",
                container: d,
                codec: e.codec,
                initSegment: e.segmentCodec === "mp3" && a.mpeg ? new Uint8Array(0) : ve.initSegment([e]),
                metadata: {
                    channelCount: e.channelCount
                }
            },
            u && (p = e.inputTimeScale,
            !c || p !== c.timescale ? f = h = r[0].pts - Math.round(p * n) : u = !1)
        }
        if (t.sps && t.pps && o.length) {
            if (t.timescale = t.inputTimeScale,
            l.video = {
                id: "main",
                container: "video/mp4",
                codec: t.codec,
                initSegment: ve.initSegment([t]),
                metadata: {
                    width: t.width,
                    height: t.height
                }
            },
            u)
                if (p = t.inputTimeScale,
                !c || p !== c.timescale) {
                    const g = this.getVideoStartPts(o)
                      , m = Math.round(p * n);
                    h = Math.min(h, Fs(o[0].dts, g) - m),
                    f = Math.min(f, g - m)
                } else
                    u = !1;
            this.videoTrackConfig = {
                width: t.width,
                height: t.height,
                pixelRatio: t.pixelRatio
            }
        }
        if (Object.keys(l).length)
            return this.ISGenerated = !0,
            u ? (this._initPTS = {
                baseTime: f,
                timescale: p
            },
            this._initDTS = {
                baseTime: h,
                timescale: p
            }) : f = p = void 0,
            {
                tracks: l,
                initPTS: f,
                timescale: p
            }
    }
    remuxVideo(e, t, n, s) {
        const r = e.inputTimeScale
          , o = e.samples
          , a = []
          , l = o.length
          , c = this._initPTS;
        let u = this.nextAvcDts, d = 8, f = this.videoSampleDuration, h, p, g = Number.POSITIVE_INFINITY, m = Number.NEGATIVE_INFINITY, v = !1;
        if (!n || u === null) {
            const ce = t * r
              , ue = o[0].pts - Fs(o[0].dts, o[0].pts);
            Jl && u !== null && Math.abs(ce - ue - u) < 15e3 ? n = !0 : u = ce - ue
        }
        const _ = c.baseTime * r / c.timescale;
        for (let ce = 0; ce < l; ce++) {
            const ue = o[ce];
            ue.pts = Fs(ue.pts - _, u),
            ue.dts = Fs(ue.dts - _, u),
            ue.dts < o[ce > 0 ? ce - 1 : ce].dts && (v = !0)
        }
        v && o.sort(function(ce, ue) {
            const Ie = ce.dts - ue.dts
              , ke = ce.pts - ue.pts;
            return Ie || ke
        }),
        h = o[0].dts,
        p = o[o.length - 1].dts;
        const y = p - h
          , b = y ? Math.round(y / (l - 1)) : f || e.inputTimeScale / 30;
        if (n) {
            const ce = h - u
              , ue = ce > b
              , Ie = ce < -1;
            if ((ue || Ie) && (ue ? de.warn(`AVC: ${Fu(ce, !0)} ms (${ce}dts) hole between fragments detected at ${t.toFixed(3)}`) : de.warn(`AVC: ${Fu(-ce, !0)} ms (${ce}dts) overlapping between fragments detected at ${t.toFixed(3)}`),
            !Ie || u >= o[0].pts || Jl)) {
                h = u;
                const ke = o[0].pts - ce;
                if (ue)
                    o[0].dts = h,
                    o[0].pts = ke;
                else
                    for (let We = 0; We < o.length && !(o[We].dts > ke); We++)
                        o[We].dts -= ce,
                        o[We].pts -= ce;
                de.log(`Video: Initial PTS/DTS adjusted: ${Fu(ke, !0)}/${Fu(h, !0)}, delta: ${Fu(ce, !0)} ms`)
            }
        }
        h = Math.max(0, h);
        let S = 0
          , C = 0
          , M = h;
        for (let ce = 0; ce < l; ce++) {
            const ue = o[ce]
              , Ie = ue.units
              , ke = Ie.length;
            let We = 0;
            for (let se = 0; se < ke; se++)
                We += Ie[se].data.length;
            C += We,
            S += ke,
            ue.length = We,
            ue.dts < M ? (ue.dts = M,
            M += b / 4 | 0 || 1) : M = ue.dts,
            g = Math.min(ue.pts, g),
            m = Math.max(ue.pts, m)
        }
        p = o[l - 1].dts;
        const L = C + 4 * S + 8;
        let T;
        try {
            T = new Uint8Array(L)
        } catch (ce) {
            this.observer.emit(P.ERROR, P.ERROR, {
                type: Ut.MUX_ERROR,
                details: Ae.REMUX_ALLOC_ERROR,
                fatal: !1,
                error: ce,
                bytes: L,
                reason: `fail allocating video mdat ${L}`
            });
            return
        }
        const A = new DataView(T.buffer);
        A.setUint32(0, L),
        T.set(ve.types.mdat, 4);
        let k = !1
          , D = Number.POSITIVE_INFINITY
          , F = Number.POSITIVE_INFINITY
          , z = Number.NEGATIVE_INFINITY
          , G = Number.NEGATIVE_INFINITY;
        for (let ce = 0; ce < l; ce++) {
            const ue = o[ce]
              , Ie = ue.units;
            let ke = 0;
            for (let Se = 0, be = Ie.length; Se < be; Se++) {
                const q = Ie[Se]
                  , me = q.data
                  , Ce = q.data.byteLength;
                A.setUint32(d, Ce),
                d += 4,
                T.set(me, d),
                d += Ce,
                ke += 4 + Ce
            }
            let We;
            if (ce < l - 1)
                f = o[ce + 1].dts - ue.dts,
                We = o[ce + 1].pts - ue.pts;
            else {
                const Se = this.config
                  , be = ce > 0 ? ue.dts - o[ce - 1].dts : b;
                if (We = ce > 0 ? ue.pts - o[ce - 1].pts : b,
                Se.stretchShortVideoTrack && this.nextAudioPts !== null) {
                    const q = Math.floor(Se.maxBufferHole * r)
                      , me = (s ? g + s * r : this.nextAudioPts) - ue.pts;
                    me > q ? (f = me - be,
                    f < 0 ? f = be : k = !0,
                    de.log(`[mp4-remuxer]: It is approximately ${me / 90} ms to the next segment; using duration ${f / 90} ms for the last video frame.`)) : f = be
                } else
                    f = be
            }
            const se = Math.round(ue.pts - ue.dts);
            D = Math.min(D, f),
            z = Math.max(z, f),
            F = Math.min(F, We),
            G = Math.max(G, We),
            a.push(new mS(ue.key,f,ke,se))
        }
        if (a.length) {
            if (Jl) {
                if (Jl < 70) {
                    const ce = a[0].flags;
                    ce.dependsOn = 2,
                    ce.isNonSync = 0
                }
            } else if (I0 && G - F < z - D && b / z < .025 && a[0].cts === 0) {
                de.warn("Found irregular gaps in sample duration. Using PTS instead of DTS to determine MP4 sample duration.");
                let ce = h;
                for (let ue = 0, Ie = a.length; ue < Ie; ue++) {
                    const ke = ce + a[ue].duration
                      , We = ce + a[ue].cts;
                    if (ue < Ie - 1) {
                        const se = ke + a[ue + 1].cts;
                        a[ue].duration = se - We
                    } else
                        a[ue].duration = ue ? a[ue - 1].duration : b;
                    a[ue].cts = 0,
                    ce = ke
                }
            }
        }
        f = k || !f ? b : f,
        this.nextAvcDts = u = p + f,
        this.videoSampleDuration = f,
        this.isVideoContiguous = !0;
        const H = ve.moof(e.sequenceNumber++, h, Qn({}, e, {
            samples: a
        }))
          , X = "video"
          , K = {
            data1: H,
            data2: T,
            startPTS: g / r,
            endPTS: (m + f) / r,
            startDTS: h / r,
            endDTS: u / r,
            type: X,
            hasAudio: !1,
            hasVideo: !0,
            nb: a.length,
            dropped: e.dropped
        };
        return e.samples = [],
        e.dropped = 0,
        K
    }
    getSamplesPerFrame(e) {
        switch (e.segmentCodec) {
        case "mp3":
            return Jz;
        case "ac3":
            return Qz;
        default:
            return pS
        }
    }
    remuxAudio(e, t, n, s, r) {
        const o = e.inputTimeScale
          , a = e.samplerate ? e.samplerate : o
          , l = o / a
          , c = this.getSamplesPerFrame(e)
          , u = c * l
          , d = this._initPTS
          , f = e.segmentCodec === "mp3" && this.typeSupported.mpeg
          , h = []
          , p = r !== void 0;
        let g = e.samples
          , m = f ? 0 : 8
          , v = this.nextAudioPts || -1;
        const _ = t * o
          , y = d.baseTime * o / d.timescale;
        if (this.isAudioContiguous = n = n || g.length && v > 0 && (s && Math.abs(_ - v) < 9e3 || Math.abs(Fs(g[0].pts - y, _) - v) < 20 * u),
        g.forEach(function(H) {
            H.pts = Fs(H.pts - y, _)
        }),
        !n || v < 0) {
            if (g = g.filter(H => H.pts >= 0),
            !g.length)
                return;
            r === 0 ? v = 0 : s && !p ? v = Math.max(0, _) : v = g[0].pts
        }
        if (e.segmentCodec === "aac") {
            const H = this.config.maxAudioFramesDrift;
            for (let X = 0, K = v; X < g.length; X++) {
                const ce = g[X]
                  , ue = ce.pts
                  , Ie = ue - K
                  , ke = Math.abs(1e3 * Ie / o);
                if (Ie <= -H * u && p)
                    X === 0 && (de.warn(`Audio frame @ ${(ue / o).toFixed(3)}s overlaps nextAudioPts by ${Math.round(1e3 * Ie / o)} ms.`),
                    this.nextAudioPts = v = K = ue);
                else if (Ie >= H * u && ke < Zz && p) {
                    let We = Math.round(Ie / u);
                    K = ue - We * u,
                    K < 0 && (We--,
                    K += u),
                    X === 0 && (this.nextAudioPts = v = K),
                    de.warn(`[mp4-remuxer]: Injecting ${We} audio frame @ ${(K / o).toFixed(3)}s due to ${Math.round(1e3 * Ie / o)} ms gap.`);
                    for (let se = 0; se < We; se++) {
                        const Se = Math.max(K, 0);
                        let be = hS.getSilentFrame(e.manifestCodec || e.codec, e.channelCount);
                        be || (de.log("[mp4-remuxer]: Unable to get silent frame for given audio codec; duplicating last frame instead."),
                        be = ce.unit.subarray()),
                        g.splice(X, 0, {
                            unit: be,
                            pts: Se
                        }),
                        K += u,
                        X++
                    }
                }
                ce.pts = K,
                K += u
            }
        }
        let b = null, S = null, C, M = 0, L = g.length;
        for (; L--; )
            M += g[L].unit.byteLength;
        for (let H = 0, X = g.length; H < X; H++) {
            const K = g[H]
              , ce = K.unit;
            let ue = K.pts;
            if (S !== null) {
                const ke = h[H - 1];
                ke.duration = Math.round((ue - S) / l)
            } else if (n && e.segmentCodec === "aac" && (ue = v),
            b = ue,
            M > 0) {
                M += m;
                try {
                    C = new Uint8Array(M)
                } catch (ke) {
                    this.observer.emit(P.ERROR, P.ERROR, {
                        type: Ut.MUX_ERROR,
                        details: Ae.REMUX_ALLOC_ERROR,
                        fatal: !1,
                        error: ke,
                        bytes: M,
                        reason: `fail allocating audio mdat ${M}`
                    });
                    return
                }
                f || (new DataView(C.buffer).setUint32(0, M),
                C.set(ve.types.mdat, 4))
            } else
                return;
            C.set(ce, m);
            const Ie = ce.byteLength;
            m += Ie,
            h.push(new mS(!0,c,Ie,0)),
            S = ue
        }
        const T = h.length;
        if (!T)
            return;
        const A = h[h.length - 1];
        this.nextAudioPts = v = S + l * A.duration;
        const k = f ? new Uint8Array(0) : ve.moof(e.sequenceNumber++, b / l, Qn({}, e, {
            samples: h
        }));
        e.samples = [];
        const D = b / o
          , F = v / o
          , G = {
            data1: k,
            data2: C,
            startPTS: D,
            endPTS: F,
            startDTS: D,
            endDTS: F,
            type: "audio",
            hasAudio: !0,
            hasVideo: !1,
            nb: T
        };
        return this.isAudioContiguous = !0,
        G
    }
    remuxEmptyAudio(e, t, n, s) {
        const r = e.inputTimeScale
          , o = e.samplerate ? e.samplerate : r
          , a = r / o
          , l = this.nextAudioPts
          , c = this._initDTS
          , u = c.baseTime * 9e4 / c.timescale
          , d = (l !== null ? l : s.startDTS * r) + u
          , f = s.endDTS * r + u
          , h = a * pS
          , p = Math.ceil((f - d) / h)
          , g = hS.getSilentFrame(e.manifestCodec || e.codec, e.channelCount);
        if (de.warn("[mp4-remuxer]: remux empty Audio"),
        !g) {
            de.trace("[mp4-remuxer]: Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec");
            return
        }
        const m = [];
        for (let v = 0; v < p; v++) {
            const _ = d + v * h;
            m.push({
                unit: g,
                pts: _,
                dts: _
            })
        }
        return e.samples = m,
        this.remuxAudio(e, t, n, !1)
    }
}
function Fs(i, e) {
    let t;
    if (e === null)
        return i;
    for (e < i ? t = -8589934592 : t = 8589934592; Math.abs(i - e) > 4294967296; )
        i += t;
    return i
}
function eG(i) {
    for (let e = 0; e < i.length; e++)
        if (i[e].key)
            return e;
    return -1
}
function bM(i, e, t, n) {
    const s = i.samples.length;
    if (!s)
        return;
    const r = i.inputTimeScale;
    for (let a = 0; a < s; a++) {
        const l = i.samples[a];
        l.pts = Fs(l.pts - t.baseTime * r / t.timescale, e * r) / r,
        l.dts = Fs(l.dts - n.baseTime * r / n.timescale, e * r) / r
    }
    const o = i.samples;
    return i.samples = [],
    {
        samples: o
    }
}
function SM(i, e, t) {
    const n = i.samples.length;
    if (!n)
        return;
    const s = i.inputTimeScale;
    for (let o = 0; o < n; o++) {
        const a = i.samples[o];
        a.pts = Fs(a.pts - t.baseTime * s / t.timescale, e * s) / s
    }
    i.samples.sort( (o, a) => o.pts - a.pts);
    const r = i.samples;
    return i.samples = [],
    {
        samples: r
    }
}
class mS {
    constructor(e, t, n, s) {
        this.size = void 0,
        this.duration = void 0,
        this.cts = void 0,
        this.flags = void 0,
        this.duration = t,
        this.size = n,
        this.cts = s,
        this.flags = {
            isLeading: 0,
            isDependedOn: 0,
            hasRedundancy: 0,
            degradPrio: 0,
            dependsOn: e ? 2 : 1,
            isNonSync: e ? 0 : 1
        }
    }
}
class tG {
    constructor() {
        this.emitInitSegment = !1,
        this.audioCodec = void 0,
        this.videoCodec = void 0,
        this.initData = void 0,
        this.initPTS = null,
        this.initTracks = void 0,
        this.lastEndTime = null
    }
    destroy() {}
    resetTimeStamp(e) {
        this.initPTS = e,
        this.lastEndTime = null
    }
    resetNextTimestamp() {
        this.lastEndTime = null
    }
    resetInitSegment(e, t, n, s) {
        this.audioCodec = t,
        this.videoCodec = n,
        this.generateInitSegment(aH(e, s)),
        this.emitInitSegment = !0
    }
    generateInitSegment(e) {
        let {audioCodec: t, videoCodec: n} = this;
        if (!(e != null && e.byteLength)) {
            this.initTracks = void 0,
            this.initData = void 0;
            return
        }
        const s = this.initData = jC(e);
        s.audio && (t = gS(s.audio, gn.AUDIO)),
        s.video && (n = gS(s.video, gn.VIDEO));
        const r = {};
        s.audio && s.video ? r.audiovideo = {
            container: "video/mp4",
            codec: t + "," + n,
            initSegment: e,
            id: "main"
        } : s.audio ? r.audio = {
            container: "audio/mp4",
            codec: t,
            initSegment: e,
            id: "audio"
        } : s.video ? r.video = {
            container: "video/mp4",
            codec: n,
            initSegment: e,
            id: "main"
        } : de.warn("[passthrough-remuxer.ts]: initSegment does not contain moov or trak boxes."),
        this.initTracks = r
    }
    remux(e, t, n, s, r, o) {
        var a, l;
        let {initPTS: c, lastEndTime: u} = this;
        const d = {
            audio: void 0,
            video: void 0,
            text: s,
            id3: n,
            initSegment: void 0
        };
        pt(u) || (u = this.lastEndTime = r || 0);
        const f = t.samples;
        if (!(f != null && f.length))
            return d;
        const h = {
            initPTS: void 0,
            timescale: 1
        };
        let p = this.initData;
        if ((a = p) != null && a.length || (this.generateInitSegment(f),
        p = this.initData),
        !((l = p) != null && l.length))
            return de.warn("[passthrough-remuxer.ts]: Failed to generate initSegment."),
            d;
        this.emitInitSegment && (h.tracks = this.initTracks,
        this.emitInitSegment = !1);
        const g = cH(f, p)
          , m = lH(p, f)
          , v = m === null ? r : m;
        (nG(c, v, r, g) || h.timescale !== c.timescale && o) && (h.initPTS = v - r,
        c && c.timescale === 1 && de.warn(`Adjusting initPTS by ${h.initPTS - c.baseTime}`),
        this.initPTS = c = {
            baseTime: h.initPTS,
            timescale: 1
        });
        const _ = e ? v - c.baseTime / c.timescale : u
          , y = _ + g;
        dH(p, f, c.baseTime / c.timescale),
        g > 0 ? this.lastEndTime = y : (de.warn("Duration parsed from mp4 should be greater than zero"),
        this.resetNextTimestamp());
        const b = !!p.audio
          , S = !!p.video;
        let C = "";
        b && (C += "audio"),
        S && (C += "video");
        const M = {
            data1: f,
            startPTS: _,
            startDTS: _,
            endPTS: y,
            endDTS: y,
            type: C,
            hasAudio: b,
            hasVideo: S,
            nb: 1,
            dropped: 0
        };
        return d.audio = M.type === "audio" ? M : void 0,
        d.video = M.type !== "audio" ? M : void 0,
        d.initSegment = h,
        d.id3 = bM(n, r, c, c),
        s.samples.length && (d.text = SM(s, r, c)),
        d
    }
}
function nG(i, e, t, n) {
    if (i === null)
        return !0;
    const s = Math.max(n, 1)
      , r = e - i.baseTime / i.timescale;
    return Math.abs(r - t) > s
}
function gS(i, e) {
    const t = i == null ? void 0 : i.codec;
    if (t && t.length > 4)
        return t;
    if (e === gn.AUDIO) {
        if (t === "ec-3" || t === "ac-3" || t === "alac")
            return t;
        if (t === "fLaC" || t === "Opus")
            return Mp(t, !1);
        const n = "mp4a.40.5";
        return de.info(`Parsed audio codec "${t}" or audio object type not handled. Using "${n}"`),
        n
    }
    return de.warn(`Unhandled video codec "${t}"`),
    t === "hvc1" || t === "hev1" ? "hvc1.1.6.L120.90" : t === "av01" ? "av01.0.04M.08" : "avc1.42e01e"
}
let xo;
try {
    xo = self.performance.now.bind(self.performance)
} catch {
    de.debug("Unable to use Performance API on this environment"),
    xo = lu == null ? void 0 : lu.Date.now
}
const Ih = [{
    demux: $z,
    remux: tG
}, {
    demux: ra,
    remux: Lh
}, {
    demux: Bz,
    remux: Lh
}, {
    demux: Kz,
    remux: Lh
}];
Ih.splice(2, 0, {
    demux: Hz,
    remux: Lh
});
class vS {
    constructor(e, t, n, s, r) {
        this.async = !1,
        this.observer = void 0,
        this.typeSupported = void 0,
        this.config = void 0,
        this.vendor = void 0,
        this.id = void 0,
        this.demuxer = void 0,
        this.remuxer = void 0,
        this.decrypter = void 0,
        this.probe = void 0,
        this.decryptionPromise = null,
        this.transmuxConfig = void 0,
        this.currentTransmuxState = void 0,
        this.observer = e,
        this.typeSupported = t,
        this.config = n,
        this.vendor = s,
        this.id = r
    }
    configure(e) {
        this.transmuxConfig = e,
        this.decrypter && this.decrypter.reset()
    }
    push(e, t, n, s) {
        const r = n.transmuxing;
        r.executeStart = xo();
        let o = new Uint8Array(e);
        const {currentTransmuxState: a, transmuxConfig: l} = this;
        s && (this.currentTransmuxState = s);
        const {contiguous: c, discontinuity: u, trackSwitch: d, accurateTimeOffset: f, timeOffset: h, initSegmentChange: p} = s || a
          , {audioCodec: g, videoCodec: m, defaultInitPts: v, duration: _, initSegmentData: y} = l
          , b = iG(o, t);
        if (b && b.method === "AES-128") {
            const L = this.getDecrypter();
            if (L.isSync()) {
                let T = L.softwareDecrypt(o, b.key.buffer, b.iv.buffer);
                if (n.part > -1 && (T = L.flush()),
                !T)
                    return r.executeEnd = xo(),
                    k0(n);
                o = new Uint8Array(T)
            } else
                return this.decryptionPromise = L.webCryptoDecrypt(o, b.key.buffer, b.iv.buffer).then(T => {
                    const A = this.push(T, null, n);
                    return this.decryptionPromise = null,
                    A
                }
                ),
                this.decryptionPromise
        }
        const S = this.needsProbing(u, d);
        if (S) {
            const L = this.configureTransmuxer(o);
            if (L)
                return de.warn(`[transmuxer] ${L.message}`),
                this.observer.emit(P.ERROR, P.ERROR, {
                    type: Ut.MEDIA_ERROR,
                    details: Ae.FRAG_PARSING_ERROR,
                    fatal: !1,
                    error: L,
                    reason: L.message
                }),
                r.executeEnd = xo(),
                k0(n)
        }
        (u || d || p || S) && this.resetInitSegment(y, g, m, _, t),
        (u || p || S) && this.resetInitialTimestamp(v),
        c || this.resetContiguity();
        const C = this.transmux(o, b, h, f, n)
          , M = this.currentTransmuxState;
        return M.contiguous = !0,
        M.discontinuity = !1,
        M.trackSwitch = !1,
        r.executeEnd = xo(),
        C
    }
    flush(e) {
        const t = e.transmuxing;
        t.executeStart = xo();
        const {decrypter: n, currentTransmuxState: s, decryptionPromise: r} = this;
        if (r)
            return r.then( () => this.flush(e));
        const o = []
          , {timeOffset: a} = s;
        if (n) {
            const d = n.flush();
            d && o.push(this.push(d, null, e))
        }
        const {demuxer: l, remuxer: c} = this;
        if (!l || !c)
            return t.executeEnd = xo(),
            [k0(e)];
        const u = l.flush(a);
        return kh(u) ? u.then(d => (this.flushRemux(o, d, e),
        o)) : (this.flushRemux(o, u, e),
        o)
    }
    flushRemux(e, t, n) {
        const {audioTrack: s, videoTrack: r, id3Track: o, textTrack: a} = t
          , {accurateTimeOffset: l, timeOffset: c} = this.currentTransmuxState;
        de.log(`[transmuxer.ts]: Flushed fragment ${n.sn}${n.part > -1 ? " p: " + n.part : ""} of level ${n.level}`);
        const u = this.remuxer.remux(s, r, o, a, c, l, !0, this.id);
        e.push({
            remuxResult: u,
            chunkMeta: n
        }),
        n.transmuxing.executeEnd = xo()
    }
    resetInitialTimestamp(e) {
        const {demuxer: t, remuxer: n} = this;
        !t || !n || (t.resetTimeStamp(e),
        n.resetTimeStamp(e))
    }
    resetContiguity() {
        const {demuxer: e, remuxer: t} = this;
        !e || !t || (e.resetContiguity(),
        t.resetNextTimestamp())
    }
    resetInitSegment(e, t, n, s, r) {
        const {demuxer: o, remuxer: a} = this;
        !o || !a || (o.resetInitSegment(e, t, n, s),
        a.resetInitSegment(e, t, n, r))
    }
    destroy() {
        this.demuxer && (this.demuxer.destroy(),
        this.demuxer = void 0),
        this.remuxer && (this.remuxer.destroy(),
        this.remuxer = void 0)
    }
    transmux(e, t, n, s, r) {
        let o;
        return t && t.method === "SAMPLE-AES" ? o = this.transmuxSampleAes(e, t, n, s, r) : o = this.transmuxUnencrypted(e, n, s, r),
        o
    }
    transmuxUnencrypted(e, t, n, s) {
        const {audioTrack: r, videoTrack: o, id3Track: a, textTrack: l} = this.demuxer.demux(e, t, !1, !this.config.progressive);
        return {
            remuxResult: this.remuxer.remux(r, o, a, l, t, n, !1, this.id),
            chunkMeta: s
        }
    }
    transmuxSampleAes(e, t, n, s, r) {
        return this.demuxer.demuxSampleAes(e, t, n).then(o => ({
            remuxResult: this.remuxer.remux(o.audioTrack, o.videoTrack, o.id3Track, o.textTrack, n, s, !1, this.id),
            chunkMeta: r
        }))
    }
    configureTransmuxer(e) {
        const {config: t, observer: n, typeSupported: s, vendor: r} = this;
        let o;
        for (let f = 0, h = Ih.length; f < h; f++) {
            var a;
            if ((a = Ih[f].demux) != null && a.probe(e)) {
                o = Ih[f];
                break
            }
        }
        if (!o)
            return new Error("Failed to find demuxer by probing fragment data");
        const l = this.demuxer
          , c = this.remuxer
          , u = o.remux
          , d = o.demux;
        (!c || !(c instanceof u)) && (this.remuxer = new u(n,t,s,r)),
        (!l || !(l instanceof d)) && (this.demuxer = new d(n,t,s),
        this.probe = d.probe)
    }
    needsProbing(e, t) {
        return !this.demuxer || !this.remuxer || e || t
    }
    getDecrypter() {
        let e = this.decrypter;
        return e || (e = this.decrypter = new sx(this.config)),
        e
    }
}
function iG(i, e) {
    let t = null;
    return i.byteLength > 0 && (e == null ? void 0 : e.key) != null && e.iv !== null && e.method != null && (t = e),
    t
}
const k0 = i => ({
    remuxResult: {},
    chunkMeta: i
});
function kh(i) {
    return "then"in i && i.then instanceof Function
}
class sG {
    constructor(e, t, n, s, r) {
        this.audioCodec = void 0,
        this.videoCodec = void 0,
        this.initSegmentData = void 0,
        this.duration = void 0,
        this.defaultInitPts = void 0,
        this.audioCodec = e,
        this.videoCodec = t,
        this.initSegmentData = n,
        this.duration = s,
        this.defaultInitPts = r || null
    }
}
class rG {
    constructor(e, t, n, s, r, o) {
        this.discontinuity = void 0,
        this.contiguous = void 0,
        this.accurateTimeOffset = void 0,
        this.trackSwitch = void 0,
        this.timeOffset = void 0,
        this.initSegmentChange = void 0,
        this.discontinuity = e,
        this.contiguous = t,
        this.accurateTimeOffset = n,
        this.trackSwitch = s,
        this.timeOffset = r,
        this.initSegmentChange = o
    }
}
var EM = {
    exports: {}
};
(function(i) {
    var e = Object.prototype.hasOwnProperty
      , t = "~";
    function n() {}
    Object.create && (n.prototype = Object.create(null),
    new n().__proto__ || (t = !1));
    function s(l, c, u) {
        this.fn = l,
        this.context = c,
        this.once = u || !1
    }
    function r(l, c, u, d, f) {
        if (typeof u != "function")
            throw new TypeError("The listener must be a function");
        var h = new s(u,d || l,f)
          , p = t ? t + c : c;
        return l._events[p] ? l._events[p].fn ? l._events[p] = [l._events[p], h] : l._events[p].push(h) : (l._events[p] = h,
        l._eventsCount++),
        l
    }
    function o(l, c) {
        --l._eventsCount === 0 ? l._events = new n : delete l._events[c]
    }
    function a() {
        this._events = new n,
        this._eventsCount = 0
    }
    a.prototype.eventNames = function() {
        var c = [], u, d;
        if (this._eventsCount === 0)
            return c;
        for (d in u = this._events)
            e.call(u, d) && c.push(t ? d.slice(1) : d);
        return Object.getOwnPropertySymbols ? c.concat(Object.getOwnPropertySymbols(u)) : c
    }
    ,
    a.prototype.listeners = function(c) {
        var u = t ? t + c : c
          , d = this._events[u];
        if (!d)
            return [];
        if (d.fn)
            return [d.fn];
        for (var f = 0, h = d.length, p = new Array(h); f < h; f++)
            p[f] = d[f].fn;
        return p
    }
    ,
    a.prototype.listenerCount = function(c) {
        var u = t ? t + c : c
          , d = this._events[u];
        return d ? d.fn ? 1 : d.length : 0
    }
    ,
    a.prototype.emit = function(c, u, d, f, h, p) {
        var g = t ? t + c : c;
        if (!this._events[g])
            return !1;
        var m = this._events[g], v = arguments.length, _, y;
        if (m.fn) {
            switch (m.once && this.removeListener(c, m.fn, void 0, !0),
            v) {
            case 1:
                return m.fn.call(m.context),
                !0;
            case 2:
                return m.fn.call(m.context, u),
                !0;
            case 3:
                return m.fn.call(m.context, u, d),
                !0;
            case 4:
                return m.fn.call(m.context, u, d, f),
                !0;
            case 5:
                return m.fn.call(m.context, u, d, f, h),
                !0;
            case 6:
                return m.fn.call(m.context, u, d, f, h, p),
                !0
            }
            for (y = 1,
            _ = new Array(v - 1); y < v; y++)
                _[y - 1] = arguments[y];
            m.fn.apply(m.context, _)
        } else {
            var b = m.length, S;
            for (y = 0; y < b; y++)
                switch (m[y].once && this.removeListener(c, m[y].fn, void 0, !0),
                v) {
                case 1:
                    m[y].fn.call(m[y].context);
                    break;
                case 2:
                    m[y].fn.call(m[y].context, u);
                    break;
                case 3:
                    m[y].fn.call(m[y].context, u, d);
                    break;
                case 4:
                    m[y].fn.call(m[y].context, u, d, f);
                    break;
                default:
                    if (!_)
                        for (S = 1,
                        _ = new Array(v - 1); S < v; S++)
                            _[S - 1] = arguments[S];
                    m[y].fn.apply(m[y].context, _)
                }
        }
        return !0
    }
    ,
    a.prototype.on = function(c, u, d) {
        return r(this, c, u, d, !1)
    }
    ,
    a.prototype.once = function(c, u, d) {
        return r(this, c, u, d, !0)
    }
    ,
    a.prototype.removeListener = function(c, u, d, f) {
        var h = t ? t + c : c;
        if (!this._events[h])
            return this;
        if (!u)
            return o(this, h),
            this;
        var p = this._events[h];
        if (p.fn)
            p.fn === u && (!f || p.once) && (!d || p.context === d) && o(this, h);
        else {
            for (var g = 0, m = [], v = p.length; g < v; g++)
                (p[g].fn !== u || f && !p[g].once || d && p[g].context !== d) && m.push(p[g]);
            m.length ? this._events[h] = m.length === 1 ? m[0] : m : o(this, h)
        }
        return this
    }
    ,
    a.prototype.removeAllListeners = function(c) {
        var u;
        return c ? (u = t ? t + c : c,
        this._events[u] && o(this, u)) : (this._events = new n,
        this._eventsCount = 0),
        this
    }
    ,
    a.prototype.off = a.prototype.removeListener,
    a.prototype.addListener = a.prototype.on,
    a.prefixed = t,
    a.EventEmitter = a,
    i.exports = a
}
)(EM);
var oG = EM.exports
  , ux = R$(oG);
class wM {
    constructor(e, t, n, s) {
        this.error = null,
        this.hls = void 0,
        this.id = void 0,
        this.observer = void 0,
        this.frag = null,
        this.part = null,
        this.useWorker = void 0,
        this.workerContext = null,
        this.onwmsg = void 0,
        this.transmuxer = null,
        this.onTransmuxComplete = void 0,
        this.onFlush = void 0;
        const r = e.config;
        this.hls = e,
        this.id = t,
        this.useWorker = !!r.enableWorker,
        this.onTransmuxComplete = n,
        this.onFlush = s;
        const o = (c, u) => {
            u = u || {},
            u.frag = this.frag,
            u.id = this.id,
            c === P.ERROR && (this.error = u.error),
            this.hls.trigger(c, u)
        }
        ;
        this.observer = new ux,
        this.observer.on(P.FRAG_DECRYPTED, o),
        this.observer.on(P.ERROR, o);
        const a = kl(r.preferManagedMediaSource) || {
            isTypeSupported: () => !1
        }
          , l = {
            mpeg: a.isTypeSupported("audio/mpeg"),
            mp3: a.isTypeSupported('audio/mp4; codecs="mp3"'),
            ac3: a.isTypeSupported('audio/mp4; codecs="ac-3"')
        };
        if (this.useWorker && typeof Worker < "u" && (r.workerPath || Tz())) {
            try {
                r.workerPath ? (de.log(`loading Web Worker ${r.workerPath} for "${t}"`),
                this.workerContext = Cz(r.workerPath)) : (de.log(`injecting Web Worker for "${t}"`),
                this.workerContext = Az()),
                this.onwmsg = d => this.onWorkerMessage(d);
                const {worker: u} = this.workerContext;
                u.addEventListener("message", this.onwmsg),
                u.onerror = d => {
                    const f = new Error(`${d.message}  (${d.filename}:${d.lineno})`);
                    r.enableWorker = !1,
                    de.warn(`Error in "${t}" Web Worker, fallback to inline`),
                    this.hls.trigger(P.ERROR, {
                        type: Ut.OTHER_ERROR,
                        details: Ae.INTERNAL_EXCEPTION,
                        fatal: !1,
                        event: "demuxerWorker",
                        error: f
                    })
                }
                ,
                u.postMessage({
                    cmd: "init",
                    typeSupported: l,
                    vendor: "",
                    id: t,
                    config: JSON.stringify(r)
                })
            } catch (u) {
                de.warn(`Error setting up "${t}" Web Worker, fallback to inline`, u),
                this.resetWorker(),
                this.error = null,
                this.transmuxer = new vS(this.observer,l,r,"",t)
            }
            return
        }
        this.transmuxer = new vS(this.observer,l,r,"",t)
    }
    resetWorker() {
        if (this.workerContext) {
            const {worker: e, objectURL: t} = this.workerContext;
            t && self.URL.revokeObjectURL(t),
            e.removeEventListener("message", this.onwmsg),
            e.onerror = null,
            e.terminate(),
            this.workerContext = null
        }
    }
    destroy() {
        if (this.workerContext)
            this.resetWorker(),
            this.onwmsg = void 0;
        else {
            const t = this.transmuxer;
            t && (t.destroy(),
            this.transmuxer = null)
        }
        const e = this.observer;
        e && e.removeAllListeners(),
        this.frag = null,
        this.observer = null,
        this.hls = null
    }
    push(e, t, n, s, r, o, a, l, c, u) {
        var d, f;
        c.transmuxing.start = self.performance.now();
        const {transmuxer: h} = this
          , p = o ? o.start : r.start
          , g = r.decryptdata
          , m = this.frag
          , v = !(m && r.cc === m.cc)
          , _ = !(m && c.level === m.level)
          , y = m ? c.sn - m.sn : -1
          , b = this.part ? c.part - this.part.index : -1
          , S = y === 0 && c.id > 1 && c.id === (m == null ? void 0 : m.stats.chunkCount)
          , C = !_ && (y === 1 || y === 0 && (b === 1 || S && b <= 0))
          , M = self.performance.now();
        (_ || y || r.stats.parsing.start === 0) && (r.stats.parsing.start = M),
        o && (b || !C) && (o.stats.parsing.start = M);
        const L = !(m && ((d = r.initSegment) == null ? void 0 : d.url) === ((f = m.initSegment) == null ? void 0 : f.url))
          , T = new rG(v,C,l,_,p,L);
        if (!C || v || L) {
            de.log(`[transmuxer-interface, ${r.type}]: Starting new transmux session for sn: ${c.sn} p: ${c.part} level: ${c.level} id: ${c.id}
        discontinuity: ${v}
        trackSwitch: ${_}
        contiguous: ${C}
        accurateTimeOffset: ${l}
        timeOffset: ${p}
        initSegmentChange: ${L}`);
            const A = new sG(n,s,t,a,u);
            this.configureTransmuxer(A)
        }
        if (this.frag = r,
        this.part = o,
        this.workerContext)
            this.workerContext.worker.postMessage({
                cmd: "demux",
                data: e,
                decryptdata: g,
                chunkMeta: c,
                state: T
            }, e instanceof ArrayBuffer ? [e] : []);
        else if (h) {
            const A = h.push(e, g, c, T);
            kh(A) ? (h.async = !0,
            A.then(k => {
                this.handleTransmuxComplete(k)
            }
            ).catch(k => {
                this.transmuxerError(k, c, "transmuxer-interface push error")
            }
            )) : (h.async = !1,
            this.handleTransmuxComplete(A))
        }
    }
    flush(e) {
        e.transmuxing.start = self.performance.now();
        const {transmuxer: t} = this;
        if (this.workerContext)
            this.workerContext.worker.postMessage({
                cmd: "flush",
                chunkMeta: e
            });
        else if (t) {
            let n = t.flush(e);
            kh(n) || t.async ? (kh(n) || (n = Promise.resolve(n)),
            n.then(r => {
                this.handleFlushResult(r, e)
            }
            ).catch(r => {
                this.transmuxerError(r, e, "transmuxer-interface flush error")
            }
            )) : this.handleFlushResult(n, e)
        }
    }
    transmuxerError(e, t, n) {
        !this.hls || (this.error = e,
        this.hls.trigger(P.ERROR, {
            type: Ut.MEDIA_ERROR,
            details: Ae.FRAG_PARSING_ERROR,
            chunkMeta: t,
            frag: this.frag || void 0,
            fatal: !1,
            error: e,
            err: e,
            reason: n
        }))
    }
    handleFlushResult(e, t) {
        e.forEach(n => {
            this.handleTransmuxComplete(n)
        }
        ),
        this.onFlush(t)
    }
    onWorkerMessage(e) {
        const t = e.data;
        if (!(t != null && t.event)) {
            de.warn(`worker message received with no ${t ? "event name" : "data"}`);
            return
        }
        const n = this.hls;
        if (!!this.hls)
            switch (t.event) {
            case "init":
                {
                    var s;
                    const r = (s = this.workerContext) == null ? void 0 : s.objectURL;
                    r && self.URL.revokeObjectURL(r);
                    break
                }
            case "transmuxComplete":
                {
                    this.handleTransmuxComplete(t.data);
                    break
                }
            case "flush":
                {
                    this.onFlush(t.data);
                    break
                }
            case "workerLog":
                de[t.data.logType] && de[t.data.logType](t.data.message);
                break;
            default:
                {
                    t.data = t.data || {},
                    t.data.frag = this.frag,
                    t.data.id = this.id,
                    n.trigger(t.event, t.data);
                    break
                }
            }
    }
    configureTransmuxer(e) {
        const {transmuxer: t} = this;
        this.workerContext ? this.workerContext.worker.postMessage({
            cmd: "configure",
            config: e
        }) : t && t.configure(e)
    }
    handleTransmuxComplete(e) {
        e.chunkMeta.transmuxing.end = self.performance.now(),
        this.onTransmuxComplete(e)
    }
}
function TM(i, e) {
    if (i.length !== e.length)
        return !1;
    for (let t = 0; t < i.length; t++)
        if (!uu(i[t].attrs, e[t].attrs))
            return !1;
    return !0
}
function uu(i, e, t) {
    const n = i["STABLE-RENDITION-ID"];
    return n && !t ? n === e["STABLE-RENDITION-ID"] : !(t || ["LANGUAGE", "NAME", "CHARACTERISTICS", "AUTOSELECT", "DEFAULT", "FORCED", "ASSOC-LANGUAGE"]).some(s => i[s] !== e[s])
}
function q1(i, e) {
    return e.label.toLowerCase() === i.name.toLowerCase() && (!e.language || e.language.toLowerCase() === (i.lang || "").toLowerCase())
}
const _S = 100;
class aG extends rx {
    constructor(e, t, n) {
        super(e, t, n, "[audio-stream-controller]", Ct.AUDIO),
        this.videoBuffer = null,
        this.videoTrackCC = -1,
        this.waitingVideoCC = -1,
        this.bufferedTrack = null,
        this.switchingTrack = null,
        this.trackId = -1,
        this.waitingData = null,
        this.mainDetails = null,
        this.flushing = !1,
        this.bufferFlushed = !1,
        this.cachedTrackLoadedData = null,
        this._registerListeners()
    }
    onHandlerDestroying() {
        this._unregisterListeners(),
        super.onHandlerDestroying(),
        this.mainDetails = null,
        this.bufferedTrack = null,
        this.switchingTrack = null
    }
    _registerListeners() {
        const {hls: e} = this;
        e.on(P.MEDIA_ATTACHED, this.onMediaAttached, this),
        e.on(P.MEDIA_DETACHING, this.onMediaDetaching, this),
        e.on(P.MANIFEST_LOADING, this.onManifestLoading, this),
        e.on(P.LEVEL_LOADED, this.onLevelLoaded, this),
        e.on(P.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this),
        e.on(P.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this),
        e.on(P.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this),
        e.on(P.ERROR, this.onError, this),
        e.on(P.BUFFER_RESET, this.onBufferReset, this),
        e.on(P.BUFFER_CREATED, this.onBufferCreated, this),
        e.on(P.BUFFER_FLUSHING, this.onBufferFlushing, this),
        e.on(P.BUFFER_FLUSHED, this.onBufferFlushed, this),
        e.on(P.INIT_PTS_FOUND, this.onInitPtsFound, this),
        e.on(P.FRAG_BUFFERED, this.onFragBuffered, this)
    }
    _unregisterListeners() {
        const {hls: e} = this;
        e.off(P.MEDIA_ATTACHED, this.onMediaAttached, this),
        e.off(P.MEDIA_DETACHING, this.onMediaDetaching, this),
        e.off(P.MANIFEST_LOADING, this.onManifestLoading, this),
        e.off(P.LEVEL_LOADED, this.onLevelLoaded, this),
        e.off(P.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this),
        e.off(P.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this),
        e.off(P.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this),
        e.off(P.ERROR, this.onError, this),
        e.off(P.BUFFER_RESET, this.onBufferReset, this),
        e.off(P.BUFFER_CREATED, this.onBufferCreated, this),
        e.off(P.BUFFER_FLUSHING, this.onBufferFlushing, this),
        e.off(P.BUFFER_FLUSHED, this.onBufferFlushed, this),
        e.off(P.INIT_PTS_FOUND, this.onInitPtsFound, this),
        e.off(P.FRAG_BUFFERED, this.onFragBuffered, this)
    }
    onInitPtsFound(e, {frag: t, id: n, initPTS: s, timescale: r}) {
        if (n === "main") {
            const o = t.cc;
            this.initPTS[t.cc] = {
                baseTime: s,
                timescale: r
            },
            this.log(`InitPTS for cc: ${o} found from main: ${s}`),
            this.videoTrackCC = o,
            this.state === Ve.WAITING_INIT_PTS && this.tick()
        }
    }
    startLoad(e) {
        if (!this.levels) {
            this.startPosition = e,
            this.state = Ve.STOPPED;
            return
        }
        const t = this.lastCurrentTime;
        this.stopLoad(),
        this.setInterval(_S),
        t > 0 && e === -1 ? (this.log(`Override startPosition with lastCurrentTime @${t.toFixed(3)}`),
        e = t,
        this.state = Ve.IDLE) : (this.loadedmetadata = !1,
        this.state = Ve.WAITING_TRACK),
        this.nextLoadPosition = this.startPosition = this.lastCurrentTime = e,
        this.tick()
    }
    doTick() {
        switch (this.state) {
        case Ve.IDLE:
            this.doTickIdle();
            break;
        case Ve.WAITING_TRACK:
            {
                var e;
                const {levels: n, trackId: s} = this
                  , r = n == null || (e = n[s]) == null ? void 0 : e.details;
                if (r) {
                    if (this.waitForCdnTuneIn(r))
                        break;
                    this.state = Ve.WAITING_INIT_PTS
                }
                break
            }
        case Ve.FRAG_LOADING_WAITING_RETRY:
            {
                var t;
                const n = performance.now()
                  , s = this.retryDate;
                if (!s || n >= s || (t = this.media) != null && t.seeking) {
                    const {levels: r, trackId: o} = this;
                    this.log("RetryDate reached, switch back to IDLE state"),
                    this.resetStartWhenNotLoaded((r == null ? void 0 : r[o]) || null),
                    this.state = Ve.IDLE
                }
                break
            }
        case Ve.WAITING_INIT_PTS:
            {
                const n = this.waitingData;
                if (n) {
                    const {frag: s, part: r, cache: o, complete: a} = n;
                    if (this.initPTS[s.cc] !== void 0) {
                        this.waitingData = null,
                        this.waitingVideoCC = -1,
                        this.state = Ve.FRAG_LOADING;
                        const l = o.flush()
                          , c = {
                            frag: s,
                            part: r,
                            payload: l,
                            networkDetails: null
                        };
                        this._handleFragmentLoadProgress(c),
                        a && super._handleFragmentLoadComplete(c)
                    } else if (this.videoTrackCC !== this.waitingVideoCC)
                        this.log(`Waiting fragment cc (${s.cc}) cancelled because video is at cc ${this.videoTrackCC}`),
                        this.clearWaitingFragment();
                    else {
                        const l = this.getLoadPosition()
                          , c = An.bufferInfo(this.mediaBuffer, l, this.config.maxBufferHole);
                        G1(c.end, this.config.maxFragLookUpTolerance, s) < 0 && (this.log(`Waiting fragment cc (${s.cc}) @ ${s.start} cancelled because another fragment at ${c.end} is needed`),
                        this.clearWaitingFragment())
                    }
                } else
                    this.state = Ve.IDLE
            }
        }
        this.onTickEnd()
    }
    clearWaitingFragment() {
        const e = this.waitingData;
        e && (this.fragmentTracker.removeFragment(e.frag),
        this.waitingData = null,
        this.waitingVideoCC = -1,
        this.state = Ve.IDLE)
    }
    resetLoadingState() {
        this.clearWaitingFragment(),
        super.resetLoadingState()
    }
    onTickEnd() {
        const {media: e} = this;
        !(e != null && e.readyState) || (this.lastCurrentTime = e.currentTime)
    }
    doTickIdle() {
        const {hls: e, levels: t, media: n, trackId: s} = this
          , r = e.config;
        if (!n && (this.startFragRequested || !r.startFragPrefetch) || !(t != null && t[s]))
            return;
        const o = t[s]
          , a = o.details;
        if (!a || a.live && this.levelLastLoaded !== o || this.waitForCdnTuneIn(a)) {
            this.state = Ve.WAITING_TRACK;
            return
        }
        const l = this.mediaBuffer ? this.mediaBuffer : this.media;
        this.bufferFlushed && l && (this.bufferFlushed = !1,
        this.afterBufferFlushed(l, gn.AUDIO, Ct.AUDIO));
        const c = this.getFwdBufferInfo(l, Ct.AUDIO);
        if (c === null)
            return;
        const {bufferedTrack: u, switchingTrack: d} = this;
        if (!d && this._streamEnded(c, a)) {
            e.trigger(P.BUFFER_EOS, {
                type: "audio"
            }),
            this.state = Ve.ENDED;
            return
        }
        const f = this.getFwdBufferInfo(this.videoBuffer ? this.videoBuffer : this.media, Ct.MAIN)
          , h = c.len
          , p = this.getMaxBufferLength(f == null ? void 0 : f.len)
          , g = a.fragments
          , m = g[0].start;
        let v = this.flushing ? this.getLoadPosition() : c.end;
        if (d && n) {
            const S = this.getLoadPosition();
            u && !uu(d.attrs, u.attrs) && (v = S),
            a.PTSKnown && S < m && (c.end > m || c.nextStart) && (this.log("Alt audio track ahead of main track, seek to start of alt audio track"),
            n.currentTime = m + .05)
        }
        if (h >= p && !d && v < g[g.length - 1].start)
            return;
        let _ = this.getNextFragment(v, a)
          , y = !1;
        if (_ && this.isLoopLoading(_, v) && (y = !!_.gap,
        _ = this.getNextFragmentLoopLoading(_, a, c, Ct.MAIN, p)),
        !_) {
            this.bufferFlushed = !0;
            return
        }
        const b = f && _.start > f.end + a.targetduration;
        if (b || !(f != null && f.len) && c.len) {
            const S = this.getAppendedFrag(_.start, Ct.MAIN);
            if (S === null || (y || (y = !!S.gap || !!b && f.len === 0),
            b && !y || y && c.nextStart && c.nextStart < S.end))
                return
        }
        this.loadFragment(_, o, v)
    }
    getMaxBufferLength(e) {
        const t = super.getMaxBufferLength();
        return e ? Math.min(Math.max(t, e), this.config.maxMaxBufferLength) : t
    }
    onMediaDetaching() {
        this.videoBuffer = null,
        this.bufferFlushed = this.flushing = !1,
        super.onMediaDetaching()
    }
    onAudioTracksUpdated(e, {audioTracks: t}) {
        this.resetTransmuxer(),
        this.levels = t.map(n => new cu(n))
    }
    onAudioTrackSwitching(e, t) {
        const n = !!t.url;
        this.trackId = t.id;
        const {fragCurrent: s} = this;
        s && (s.abortRequests(),
        this.removeUnbufferedFrags(s.start)),
        this.resetLoadingState(),
        n ? this.setInterval(_S) : this.resetTransmuxer(),
        n ? (this.switchingTrack = t,
        this.state = Ve.IDLE,
        this.flushAudioIfNeeded(t)) : (this.switchingTrack = null,
        this.bufferedTrack = t,
        this.state = Ve.STOPPED),
        this.tick()
    }
    onManifestLoading() {
        this.fragmentTracker.removeAllFragments(),
        this.startPosition = this.lastCurrentTime = 0,
        this.bufferFlushed = this.flushing = !1,
        this.levels = this.mainDetails = this.waitingData = this.bufferedTrack = this.cachedTrackLoadedData = this.switchingTrack = null,
        this.startFragRequested = !1,
        this.trackId = this.videoTrackCC = this.waitingVideoCC = -1
    }
    onLevelLoaded(e, t) {
        this.mainDetails = t.details,
        this.cachedTrackLoadedData !== null && (this.hls.trigger(P.AUDIO_TRACK_LOADED, this.cachedTrackLoadedData),
        this.cachedTrackLoadedData = null)
    }
    onAudioTrackLoaded(e, t) {
        var n;
        if (this.mainDetails == null) {
            this.cachedTrackLoadedData = t;
            return
        }
        const {levels: s} = this
          , {details: r, id: o} = t;
        if (!s) {
            this.warn(`Audio tracks were reset while loading level ${o}`);
            return
        }
        this.log(`Audio track ${o} loaded [${r.startSN},${r.endSN}]${r.lastPartSn ? `[part-${r.lastPartSn}-${r.lastPartIndex}]` : ""},duration:${r.totalduration}`);
        const a = s[o];
        let l = 0;
        if (r.live || (n = a.details) != null && n.live) {
            this.checkLiveUpdate(r);
            const u = this.mainDetails;
            if (r.deltaUpdateFailed || !u)
                return;
            if (!a.details && r.hasProgramDateTime && u.hasProgramDateTime)
                Pp(r, u),
                l = r.fragments[0].start;
            else {
                var c;
                l = this.alignPlaylists(r, a.details, (c = this.levelLastLoaded) == null ? void 0 : c.details)
            }
        }
        a.details = r,
        this.levelLastLoaded = a,
        !this.startFragRequested && (this.mainDetails || !r.live) && this.setStartPosition(this.mainDetails || r, l),
        this.state === Ve.WAITING_TRACK && !this.waitForCdnTuneIn(r) && (this.state = Ve.IDLE),
        this.tick()
    }
    _handleFragmentLoadProgress(e) {
        var t;
        const {frag: n, part: s, payload: r} = e
          , {config: o, trackId: a, levels: l} = this;
        if (!l) {
            this.warn(`Audio tracks were reset while fragment load was in progress. Fragment ${n.sn} of level ${n.level} will not be buffered`);
            return
        }
        const c = l[a];
        if (!c) {
            this.warn("Audio track is undefined on fragment load progress");
            return
        }
        const u = c.details;
        if (!u) {
            this.warn("Audio track details undefined on fragment load progress"),
            this.removeUnbufferedFrags(n.start);
            return
        }
        const d = o.defaultAudioCodec || c.audioCodec || "mp4a.40.2";
        let f = this.transmuxer;
        f || (f = this.transmuxer = new wM(this.hls,Ct.AUDIO,this._handleTransmuxComplete.bind(this),this._handleTransmuxerFlush.bind(this)));
        const h = this.initPTS[n.cc]
          , p = (t = n.initSegment) == null ? void 0 : t.data;
        if (h !== void 0) {
            const m = s ? s.index : -1
              , v = m !== -1
              , _ = new ix(n.level,n.sn,n.stats.chunkCount,r.byteLength,m,v);
            f.push(r, p, d, "", n, s, u.totalduration, !1, _, h)
        } else {
            this.log(`Unknown video PTS for cc ${n.cc}, waiting for video PTS before demuxing audio frag ${n.sn} of [${u.startSN} ,${u.endSN}],track ${a}`);
            const {cache: g} = this.waitingData = this.waitingData || {
                frag: n,
                part: s,
                cache: new lM,
                complete: !1
            };
            g.push(new Uint8Array(r)),
            this.waitingVideoCC = this.videoTrackCC,
            this.state = Ve.WAITING_INIT_PTS
        }
    }
    _handleFragmentLoadComplete(e) {
        if (this.waitingData) {
            this.waitingData.complete = !0;
            return
        }
        super._handleFragmentLoadComplete(e)
    }
    onBufferReset() {
        this.mediaBuffer = this.videoBuffer = null,
        this.loadedmetadata = !1
    }
    onBufferCreated(e, t) {
        const n = t.tracks.audio;
        n && (this.mediaBuffer = n.buffer || null),
        t.tracks.video && (this.videoBuffer = t.tracks.video.buffer || null)
    }
    onFragBuffered(e, t) {
        const {frag: n, part: s} = t;
        if (n.type !== Ct.AUDIO) {
            if (!this.loadedmetadata && n.type === Ct.MAIN) {
                const r = this.videoBuffer || this.media;
                r && An.getBuffered(r).length && (this.loadedmetadata = !0)
            }
            return
        }
        if (this.fragContextChanged(n)) {
            this.warn(`Fragment ${n.sn}${s ? " p: " + s.index : ""} of level ${n.level} finished buffering, but was aborted. state: ${this.state}, audioSwitch: ${this.switchingTrack ? this.switchingTrack.name : "false"}`);
            return
        }
        if (n.sn !== "initSegment") {
            this.fragPrevious = n;
            const r = this.switchingTrack;
            r && (this.bufferedTrack = r,
            this.switchingTrack = null,
            this.hls.trigger(P.AUDIO_TRACK_SWITCHED, yi({}, r)))
        }
        this.fragBufferedComplete(n, s)
    }
    onError(e, t) {
        var n;
        if (t.fatal) {
            this.state = Ve.ERROR;
            return
        }
        switch (t.details) {
        case Ae.FRAG_GAP:
        case Ae.FRAG_PARSING_ERROR:
        case Ae.FRAG_DECRYPT_ERROR:
        case Ae.FRAG_LOAD_ERROR:
        case Ae.FRAG_LOAD_TIMEOUT:
        case Ae.KEY_LOAD_ERROR:
        case Ae.KEY_LOAD_TIMEOUT:
            this.onFragmentOrKeyLoadError(Ct.AUDIO, t);
            break;
        case Ae.AUDIO_TRACK_LOAD_ERROR:
        case Ae.AUDIO_TRACK_LOAD_TIMEOUT:
        case Ae.LEVEL_PARSING_ERROR:
            !t.levelRetry && this.state === Ve.WAITING_TRACK && ((n = t.context) == null ? void 0 : n.type) === en.AUDIO_TRACK && (this.state = Ve.IDLE);
            break;
        case Ae.BUFFER_APPEND_ERROR:
        case Ae.BUFFER_FULL_ERROR:
            if (!t.parent || t.parent !== "audio")
                return;
            if (t.details === Ae.BUFFER_APPEND_ERROR) {
                this.resetLoadingState();
                return
            }
            this.reduceLengthAndFlushBuffer(t) && (this.bufferedTrack = null,
            super.flushMainBuffer(0, Number.POSITIVE_INFINITY, "audio"));
            break;
        case Ae.INTERNAL_EXCEPTION:
            this.recoverWorkerError(t);
            break
        }
    }
    onBufferFlushing(e, {type: t}) {
        t !== gn.VIDEO && (this.flushing = !0)
    }
    onBufferFlushed(e, {type: t}) {
        if (t !== gn.VIDEO) {
            this.flushing = !1,
            this.bufferFlushed = !0,
            this.state === Ve.ENDED && (this.state = Ve.IDLE);
            const n = this.mediaBuffer || this.media;
            n && (this.afterBufferFlushed(n, t, Ct.AUDIO),
            this.tick())
        }
    }
    _handleTransmuxComplete(e) {
        var t;
        const n = "audio"
          , {hls: s} = this
          , {remuxResult: r, chunkMeta: o} = e
          , a = this.getCurrentContext(o);
        if (!a) {
            this.resetWhenMissingContext(o);
            return
        }
        const {frag: l, part: c, level: u} = a
          , {details: d} = u
          , {audio: f, text: h, id3: p, initSegment: g} = r;
        if (this.fragContextChanged(l) || !d) {
            this.fragmentTracker.removeFragment(l);
            return
        }
        if (this.state = Ve.PARSING,
        this.switchingTrack && f && this.completeAudioSwitch(this.switchingTrack),
        g != null && g.tracks) {
            const m = l.initSegment || l;
            this._bufferInitSegment(u, g.tracks, m, o),
            s.trigger(P.FRAG_PARSING_INIT_SEGMENT, {
                frag: m,
                id: n,
                tracks: g.tracks
            })
        }
        if (f) {
            const {startPTS: m, endPTS: v, startDTS: _, endDTS: y} = f;
            c && (c.elementaryStreams[gn.AUDIO] = {
                startPTS: m,
                endPTS: v,
                startDTS: _,
                endDTS: y
            }),
            l.setElementaryStreamInfo(gn.AUDIO, m, v, _, y),
            this.bufferFragmentData(f, l, c, o)
        }
        if (p != null && (t = p.samples) != null && t.length) {
            const m = Qn({
                id: n,
                frag: l,
                details: d
            }, p);
            s.trigger(P.FRAG_PARSING_METADATA, m)
        }
        if (h) {
            const m = Qn({
                id: n,
                frag: l,
                details: d
            }, h);
            s.trigger(P.FRAG_PARSING_USERDATA, m)
        }
    }
    _bufferInitSegment(e, t, n, s) {
        if (this.state !== Ve.PARSING)
            return;
        t.video && delete t.video;
        const r = t.audio;
        if (!r)
            return;
        r.id = "audio";
        const o = e.audioCodec;
        this.log(`Init audio buffer, container:${r.container}, codecs[level/parsed]=[${o}/${r.codec}]`),
        o && o.split(",").length === 1 && (r.levelCodec = o),
        this.hls.trigger(P.BUFFER_CODECS, t);
        const a = r.initSegment;
        if (a != null && a.byteLength) {
            const l = {
                type: "audio",
                frag: n,
                part: null,
                chunkMeta: s,
                parent: n.type,
                data: a
            };
            this.hls.trigger(P.BUFFER_APPENDING, l)
        }
        this.tickImmediate()
    }
    loadFragment(e, t, n) {
        const s = this.fragmentTracker.getState(e);
        if (this.fragCurrent = e,
        this.switchingTrack || s === gi.NOT_LOADED || s === gi.PARTIAL) {
            var r;
            if (e.sn === "initSegment")
                this._loadInitSegment(e, t);
            else if ((r = t.details) != null && r.live && !this.initPTS[e.cc]) {
                this.log(`Waiting for video PTS in continuity counter ${e.cc} of live stream before loading audio fragment ${e.sn} of level ${this.trackId}`),
                this.state = Ve.WAITING_INIT_PTS;
                const o = this.mainDetails;
                o && o.fragments[0].start !== t.details.fragments[0].start && Pp(t.details, o)
            } else
                this.startFragRequested = !0,
                super.loadFragment(e, t, n)
        } else
            this.clearTrackerIfNeeded(e)
    }
    flushAudioIfNeeded(e) {
        const {media: t, bufferedTrack: n} = this
          , s = n == null ? void 0 : n.attrs
          , r = e.attrs;
        t && s && (s.CHANNELS !== r.CHANNELS || n.name !== e.name || n.lang !== e.lang) && (this.log("Switching audio track : flushing all audio"),
        super.flushMainBuffer(0, Number.POSITIVE_INFINITY, "audio"),
        this.bufferedTrack = null)
    }
    completeAudioSwitch(e) {
        const {hls: t} = this;
        this.flushAudioIfNeeded(e),
        this.bufferedTrack = e,
        this.switchingTrack = null,
        t.trigger(P.AUDIO_TRACK_SWITCHED, yi({}, e))
    }
}
class lG extends nx {
    constructor(e) {
        super(e, "[audio-track-controller]"),
        this.tracks = [],
        this.groupIds = null,
        this.tracksInGroup = [],
        this.trackId = -1,
        this.currentTrack = null,
        this.selectDefaultTrack = !0,
        this.registerListeners()
    }
    registerListeners() {
        const {hls: e} = this;
        e.on(P.MANIFEST_LOADING, this.onManifestLoading, this),
        e.on(P.MANIFEST_PARSED, this.onManifestParsed, this),
        e.on(P.LEVEL_LOADING, this.onLevelLoading, this),
        e.on(P.LEVEL_SWITCHING, this.onLevelSwitching, this),
        e.on(P.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this),
        e.on(P.ERROR, this.onError, this)
    }
    unregisterListeners() {
        const {hls: e} = this;
        e.off(P.MANIFEST_LOADING, this.onManifestLoading, this),
        e.off(P.MANIFEST_PARSED, this.onManifestParsed, this),
        e.off(P.LEVEL_LOADING, this.onLevelLoading, this),
        e.off(P.LEVEL_SWITCHING, this.onLevelSwitching, this),
        e.off(P.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this),
        e.off(P.ERROR, this.onError, this)
    }
    destroy() {
        this.unregisterListeners(),
        this.tracks.length = 0,
        this.tracksInGroup.length = 0,
        this.currentTrack = null,
        super.destroy()
    }
    onManifestLoading() {
        this.tracks = [],
        this.tracksInGroup = [],
        this.groupIds = null,
        this.currentTrack = null,
        this.trackId = -1,
        this.selectDefaultTrack = !0
    }
    onManifestParsed(e, t) {
        this.tracks = t.audioTracks || []
    }
    onAudioTrackLoaded(e, t) {
        const {id: n, groupId: s, details: r} = t
          , o = this.tracksInGroup[n];
        if (!o || o.groupId !== s) {
            this.warn(`Audio track with id:${n} and group:${s} not found in active group ${o == null ? void 0 : o.groupId}`);
            return
        }
        const a = o.details;
        o.details = t.details,
        this.log(`Audio track ${n} "${o.name}" lang:${o.lang} group:${s} loaded [${r.startSN}-${r.endSN}]`),
        n === this.trackId && this.playlistLoaded(n, t, a)
    }
    onLevelLoading(e, t) {
        this.switchLevel(t.level)
    }
    onLevelSwitching(e, t) {
        this.switchLevel(t.level)
    }
    switchLevel(e) {
        const t = this.hls.levels[e];
        if (!t)
            return;
        const n = t.audioGroups || null
          , s = this.groupIds;
        let r = this.currentTrack;
        if (!n || (s == null ? void 0 : s.length) !== (n == null ? void 0 : n.length) || n != null && n.some(a => (s == null ? void 0 : s.indexOf(a)) === -1)) {
            this.groupIds = n,
            this.trackId = -1,
            this.currentTrack = null;
            const a = this.tracks.filter(f => !n || n.indexOf(f.groupId) !== -1);
            if (a.length)
                this.selectDefaultTrack && !a.some(f => f.default) && (this.selectDefaultTrack = !1),
                a.forEach( (f, h) => {
                    f.id = h
                }
                );
            else if (!r && !this.tracksInGroup.length)
                return;
            this.tracksInGroup = a;
            const l = this.hls.config.audioPreference;
            if (!r && l) {
                const f = Nr(l, a, Xl);
                if (f > -1)
                    r = a[f];
                else {
                    const h = Nr(l, this.tracks);
                    r = this.tracks[h]
                }
            }
            let c = this.findTrackId(r);
            c === -1 && r && (c = this.findTrackId(null));
            const u = {
                audioTracks: a
            };
            this.log(`Updating audio tracks, ${a.length} track(s) found in group(s): ${n == null ? void 0 : n.join(",")}`),
            this.hls.trigger(P.AUDIO_TRACKS_UPDATED, u);
            const d = this.trackId;
            if (c !== -1 && d === -1)
                this.setAudioTrack(c);
            else if (a.length && d === -1) {
                var o;
                const f = new Error(`No audio track selected for current audio group-ID(s): ${(o = this.groupIds) == null ? void 0 : o.join(",")} track count: ${a.length}`);
                this.warn(f.message),
                this.hls.trigger(P.ERROR, {
                    type: Ut.MEDIA_ERROR,
                    details: Ae.AUDIO_TRACK_LOAD_ERROR,
                    fatal: !0,
                    error: f
                })
            }
        } else
            this.shouldReloadPlaylist(r) && this.setAudioTrack(this.trackId)
    }
    onError(e, t) {
        t.fatal || !t.context || t.context.type === en.AUDIO_TRACK && t.context.id === this.trackId && (!this.groupIds || this.groupIds.indexOf(t.context.groupId) !== -1) && (this.requestScheduled = -1,
        this.checkRetry(t))
    }
    get allAudioTracks() {
        return this.tracks
    }
    get audioTracks() {
        return this.tracksInGroup
    }
    get audioTrack() {
        return this.trackId
    }
    set audioTrack(e) {
        this.selectDefaultTrack = !1,
        this.setAudioTrack(e)
    }
    setAudioOption(e) {
        const t = this.hls;
        if (t.config.audioPreference = e,
        e) {
            const n = this.allAudioTracks;
            if (this.selectDefaultTrack = !1,
            n.length) {
                const s = this.currentTrack;
                if (s && Hc(e, s, Xl))
                    return s;
                const r = Nr(e, this.tracksInGroup, Xl);
                if (r > -1) {
                    const o = this.tracksInGroup[r];
                    return this.setAudioTrack(r),
                    o
                } else if (s) {
                    let o = t.loadLevel;
                    o === -1 && (o = t.firstAutoLevel);
                    const a = lz(e, t.levels, n, o, Xl);
                    if (a === -1)
                        return null;
                    t.nextLoadLevel = a
                }
                if (e.channels || e.audioCodec) {
                    const o = Nr(e, n);
                    if (o > -1)
                        return n[o]
                }
            }
        }
        return null
    }
    setAudioTrack(e) {
        const t = this.tracksInGroup;
        if (e < 0 || e >= t.length) {
            this.warn(`Invalid audio track id: ${e}`);
            return
        }
        this.clearTimer(),
        this.selectDefaultTrack = !1;
        const n = this.currentTrack
          , s = t[e]
          , r = s.details && !s.details.live;
        if (e === this.trackId && s === n && r || (this.log(`Switching to audio-track ${e} "${s.name}" lang:${s.lang} group:${s.groupId} channels:${s.channels}`),
        this.trackId = e,
        this.currentTrack = s,
        this.hls.trigger(P.AUDIO_TRACK_SWITCHING, yi({}, s)),
        r))
            return;
        const o = this.switchParams(s.url, n == null ? void 0 : n.details, s.details);
        this.loadPlaylist(o)
    }
    findTrackId(e) {
        const t = this.tracksInGroup;
        for (let n = 0; n < t.length; n++) {
            const s = t[n];
            if (!(this.selectDefaultTrack && !s.default) && (!e || Hc(e, s, Xl)))
                return n
        }
        if (e) {
            const {name: n, lang: s, assocLang: r, characteristics: o, audioCodec: a, channels: l} = e;
            for (let c = 0; c < t.length; c++) {
                const u = t[c];
                if (Hc({
                    name: n,
                    lang: s,
                    assocLang: r,
                    characteristics: o,
                    audioCodec: a,
                    channels: l
                }, u, Xl))
                    return c
            }
            for (let c = 0; c < t.length; c++) {
                const u = t[c];
                if (uu(e.attrs, u.attrs, ["LANGUAGE", "ASSOC-LANGUAGE", "CHARACTERISTICS"]))
                    return c
            }
            for (let c = 0; c < t.length; c++) {
                const u = t[c];
                if (uu(e.attrs, u.attrs, ["LANGUAGE"]))
                    return c
            }
        }
        return -1
    }
    loadPlaylist(e) {
        const t = this.currentTrack;
        if (this.shouldLoadPlaylist(t) && t) {
            super.loadPlaylist();
            const n = t.id
              , s = t.groupId;
            let r = t.url;
            if (e)
                try {
                    r = e.addDirectives(r)
                } catch (o) {
                    this.warn(`Could not construct new URL with HLS Delivery Directives: ${o}`)
                }
            this.log(`loading audio-track playlist ${n} "${t.name}" lang:${t.lang} group:${s}`),
            this.clearTimer(),
            this.hls.trigger(P.AUDIO_TRACK_LOADING, {
                url: r,
                id: n,
                groupId: s,
                deliveryDirectives: e || null
            })
        }
    }
}
const xS = 500;
class cG extends rx {
    constructor(e, t, n) {
        super(e, t, n, "[subtitle-stream-controller]", Ct.SUBTITLE),
        this.currentTrackId = -1,
        this.tracksBuffered = [],
        this.mainDetails = null,
        this._registerListeners()
    }
    onHandlerDestroying() {
        this._unregisterListeners(),
        super.onHandlerDestroying(),
        this.mainDetails = null
    }
    _registerListeners() {
        const {hls: e} = this;
        e.on(P.MEDIA_ATTACHED, this.onMediaAttached, this),
        e.on(P.MEDIA_DETACHING, this.onMediaDetaching, this),
        e.on(P.MANIFEST_LOADING, this.onManifestLoading, this),
        e.on(P.LEVEL_LOADED, this.onLevelLoaded, this),
        e.on(P.ERROR, this.onError, this),
        e.on(P.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this),
        e.on(P.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this),
        e.on(P.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this),
        e.on(P.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this),
        e.on(P.BUFFER_FLUSHING, this.onBufferFlushing, this),
        e.on(P.FRAG_BUFFERED, this.onFragBuffered, this)
    }
    _unregisterListeners() {
        const {hls: e} = this;
        e.off(P.MEDIA_ATTACHED, this.onMediaAttached, this),
        e.off(P.MEDIA_DETACHING, this.onMediaDetaching, this),
        e.off(P.MANIFEST_LOADING, this.onManifestLoading, this),
        e.off(P.LEVEL_LOADED, this.onLevelLoaded, this),
        e.off(P.ERROR, this.onError, this),
        e.off(P.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this),
        e.off(P.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this),
        e.off(P.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this),
        e.off(P.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this),
        e.off(P.BUFFER_FLUSHING, this.onBufferFlushing, this),
        e.off(P.FRAG_BUFFERED, this.onFragBuffered, this)
    }
    startLoad(e) {
        this.stopLoad(),
        this.state = Ve.IDLE,
        this.setInterval(xS),
        this.nextLoadPosition = this.startPosition = this.lastCurrentTime = e,
        this.tick()
    }
    onManifestLoading() {
        this.mainDetails = null,
        this.fragmentTracker.removeAllFragments()
    }
    onMediaDetaching() {
        this.tracksBuffered = [],
        super.onMediaDetaching()
    }
    onLevelLoaded(e, t) {
        this.mainDetails = t.details
    }
    onSubtitleFragProcessed(e, t) {
        const {frag: n, success: s} = t;
        if (this.fragPrevious = n,
        this.state = Ve.IDLE,
        !s)
            return;
        const r = this.tracksBuffered[this.currentTrackId];
        if (!r)
            return;
        let o;
        const a = n.start;
        for (let c = 0; c < r.length; c++)
            if (a >= r[c].start && a <= r[c].end) {
                o = r[c];
                break
            }
        const l = n.start + n.duration;
        o ? o.end = l : (o = {
            start: a,
            end: l
        },
        r.push(o)),
        this.fragmentTracker.fragBuffered(n),
        this.fragBufferedComplete(n, null)
    }
    onBufferFlushing(e, t) {
        const {startOffset: n, endOffset: s} = t;
        if (n === 0 && s !== Number.POSITIVE_INFINITY) {
            const r = s - 1;
            if (r <= 0)
                return;
            t.endOffsetSubtitles = Math.max(0, r),
            this.tracksBuffered.forEach(o => {
                for (let a = 0; a < o.length; ) {
                    if (o[a].end <= r) {
                        o.shift();
                        continue
                    } else if (o[a].start < r)
                        o[a].start = r;
                    else
                        break;
                    a++
                }
            }
            ),
            this.fragmentTracker.removeFragmentsInRange(n, r, Ct.SUBTITLE)
        }
    }
    onFragBuffered(e, t) {
        if (!this.loadedmetadata && t.frag.type === Ct.MAIN) {
            var n;
            (n = this.media) != null && n.buffered.length && (this.loadedmetadata = !0)
        }
    }
    onError(e, t) {
        const n = t.frag;
        (n == null ? void 0 : n.type) === Ct.SUBTITLE && (t.details === Ae.FRAG_GAP && this.fragmentTracker.fragBuffered(n, !0),
        this.fragCurrent && this.fragCurrent.abortRequests(),
        this.state !== Ve.STOPPED && (this.state = Ve.IDLE))
    }
    onSubtitleTracksUpdated(e, {subtitleTracks: t}) {
        if (this.levels && TM(this.levels, t)) {
            this.levels = t.map(n => new cu(n));
            return
        }
        this.tracksBuffered = [],
        this.levels = t.map(n => {
            const s = new cu(n);
            return this.tracksBuffered[s.id] = [],
            s
        }
        ),
        this.fragmentTracker.removeFragmentsInRange(0, Number.POSITIVE_INFINITY, Ct.SUBTITLE),
        this.fragPrevious = null,
        this.mediaBuffer = null
    }
    onSubtitleTrackSwitch(e, t) {
        var n;
        if (this.currentTrackId = t.id,
        !((n = this.levels) != null && n.length) || this.currentTrackId === -1) {
            this.clearInterval();
            return
        }
        const s = this.levels[this.currentTrackId];
        s != null && s.details ? this.mediaBuffer = this.mediaBufferTimeRanges : this.mediaBuffer = null,
        s && this.setInterval(xS)
    }
    onSubtitleTrackLoaded(e, t) {
        var n;
        const {currentTrackId: s, levels: r} = this
          , {details: o, id: a} = t;
        if (!r) {
            this.warn(`Subtitle tracks were reset while loading level ${a}`);
            return
        }
        const l = r[a];
        if (a >= r.length || !l)
            return;
        this.log(`Subtitle track ${a} loaded [${o.startSN},${o.endSN}]${o.lastPartSn ? `[part-${o.lastPartSn}-${o.lastPartIndex}]` : ""},duration:${o.totalduration}`),
        this.mediaBuffer = this.mediaBufferTimeRanges;
        let c = 0;
        if (o.live || (n = l.details) != null && n.live) {
            const d = this.mainDetails;
            if (o.deltaUpdateFailed || !d)
                return;
            const f = d.fragments[0];
            if (!l.details)
                o.hasProgramDateTime && d.hasProgramDateTime ? (Pp(o, d),
                c = o.fragments[0].start) : f && (c = f.start,
                z1(o, c));
            else {
                var u;
                c = this.alignPlaylists(o, l.details, (u = this.levelLastLoaded) == null ? void 0 : u.details),
                c === 0 && f && (c = f.start,
                z1(o, c))
            }
        }
        l.details = o,
        this.levelLastLoaded = l,
        a === s && (!this.startFragRequested && (this.mainDetails || !o.live) && this.setStartPosition(this.mainDetails || o, c),
        this.tick(),
        o.live && !this.fragCurrent && this.media && this.state === Ve.IDLE && (kp(null, o.fragments, this.media.currentTime, 0) || (this.warn("Subtitle playlist not aligned with playback"),
        l.details = void 0)))
    }
    _handleFragmentLoadComplete(e) {
        const {frag: t, payload: n} = e
          , s = t.decryptdata
          , r = this.hls;
        if (!this.fragContextChanged(t) && n && n.byteLength > 0 && s != null && s.key && s.iv && s.method === "AES-128") {
            const o = performance.now();
            this.decrypter.decrypt(new Uint8Array(n), s.key.buffer, s.iv.buffer).catch(a => {
                throw r.trigger(P.ERROR, {
                    type: Ut.MEDIA_ERROR,
                    details: Ae.FRAG_DECRYPT_ERROR,
                    fatal: !1,
                    error: a,
                    reason: a.message,
                    frag: t
                }),
                a
            }
            ).then(a => {
                const l = performance.now();
                r.trigger(P.FRAG_DECRYPTED, {
                    frag: t,
                    payload: a,
                    stats: {
                        tstart: o,
                        tdecrypt: l
                    }
                })
            }
            ).catch(a => {
                this.warn(`${a.name}: ${a.message}`),
                this.state = Ve.IDLE
            }
            )
        }
    }
    doTick() {
        if (!this.media) {
            this.state = Ve.IDLE;
            return
        }
        if (this.state === Ve.IDLE) {
            const {currentTrackId: e, levels: t} = this
              , n = t == null ? void 0 : t[e];
            if (!n || !t.length || !n.details)
                return;
            const {config: s} = this
              , r = this.getLoadPosition()
              , o = An.bufferedInfo(this.tracksBuffered[this.currentTrackId] || [], r, s.maxBufferHole)
              , {end: a, len: l} = o
              , c = this.getFwdBufferInfo(this.media, Ct.MAIN)
              , u = n.details
              , d = this.getMaxBufferLength(c == null ? void 0 : c.len) + u.levelTargetDuration;
            if (l > d)
                return;
            const f = u.fragments
              , h = f.length
              , p = u.edge;
            let g = null;
            const m = this.fragPrevious;
            if (a < p) {
                const v = s.maxFragLookUpTolerance
                  , _ = a > p - v ? 0 : v;
                g = kp(m, f, Math.max(f[0].start, a), _),
                !g && m && m.start < f[0].start && (g = f[0])
            } else
                g = f[h - 1];
            if (!g)
                return;
            if (g = this.mapToInitFragWhenRequired(g),
            g.sn !== "initSegment") {
                const v = g.sn - u.startSN
                  , _ = f[v - 1];
                _ && _.cc === g.cc && this.fragmentTracker.getState(_) === gi.NOT_LOADED && (g = _)
            }
            this.fragmentTracker.getState(g) === gi.NOT_LOADED && this.loadFragment(g, n, a)
        }
    }
    getMaxBufferLength(e) {
        const t = super.getMaxBufferLength();
        return e ? Math.max(t, e) : t
    }
    loadFragment(e, t, n) {
        this.fragCurrent = e,
        e.sn === "initSegment" ? this._loadInitSegment(e, t) : (this.startFragRequested = !0,
        super.loadFragment(e, t, n))
    }
    get mediaBufferTimeRanges() {
        return new uG(this.tracksBuffered[this.currentTrackId] || [])
    }
}
class uG {
    constructor(e) {
        this.buffered = void 0;
        const t = (n, s, r) => {
            if (s = s >>> 0,
            s > r - 1)
                throw new DOMException(`Failed to execute '${n}' on 'TimeRanges': The index provided (${s}) is greater than the maximum bound (${r})`);
            return e[s][n]
        }
        ;
        this.buffered = {
            get length() {
                return e.length
            },
            end(n) {
                return t("end", n, e.length)
            },
            start(n) {
                return t("start", n, e.length)
            }
        }
    }
}
class dG extends nx {
    constructor(e) {
        super(e, "[subtitle-track-controller]"),
        this.media = null,
        this.tracks = [],
        this.groupIds = null,
        this.tracksInGroup = [],
        this.trackId = -1,
        this.currentTrack = null,
        this.selectDefaultTrack = !0,
        this.queuedDefaultTrack = -1,
        this.asyncPollTrackChange = () => this.pollTrackChange(0),
        this.useTextTrackPolling = !1,
        this.subtitlePollingInterval = -1,
        this._subtitleDisplay = !0,
        this.onTextTracksChanged = () => {
            if (this.useTextTrackPolling || self.clearInterval(this.subtitlePollingInterval),
            !this.media || !this.hls.config.renderTextTracksNatively)
                return;
            let t = null;
            const n = Ch(this.media.textTracks);
            for (let r = 0; r < n.length; r++)
                if (n[r].mode === "hidden")
                    t = n[r];
                else if (n[r].mode === "showing") {
                    t = n[r];
                    break
                }
            const s = this.findTrackForTextTrack(t);
            this.subtitleTrack !== s && this.setSubtitleTrack(s)
        }
        ,
        this.registerListeners()
    }
    destroy() {
        this.unregisterListeners(),
        this.tracks.length = 0,
        this.tracksInGroup.length = 0,
        this.currentTrack = null,
        this.onTextTracksChanged = this.asyncPollTrackChange = null,
        super.destroy()
    }
    get subtitleDisplay() {
        return this._subtitleDisplay
    }
    set subtitleDisplay(e) {
        this._subtitleDisplay = e,
        this.trackId > -1 && this.toggleTrackModes()
    }
    registerListeners() {
        const {hls: e} = this;
        e.on(P.MEDIA_ATTACHED, this.onMediaAttached, this),
        e.on(P.MEDIA_DETACHING, this.onMediaDetaching, this),
        e.on(P.MANIFEST_LOADING, this.onManifestLoading, this),
        e.on(P.MANIFEST_PARSED, this.onManifestParsed, this),
        e.on(P.LEVEL_LOADING, this.onLevelLoading, this),
        e.on(P.LEVEL_SWITCHING, this.onLevelSwitching, this),
        e.on(P.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this),
        e.on(P.ERROR, this.onError, this)
    }
    unregisterListeners() {
        const {hls: e} = this;
        e.off(P.MEDIA_ATTACHED, this.onMediaAttached, this),
        e.off(P.MEDIA_DETACHING, this.onMediaDetaching, this),
        e.off(P.MANIFEST_LOADING, this.onManifestLoading, this),
        e.off(P.MANIFEST_PARSED, this.onManifestParsed, this),
        e.off(P.LEVEL_LOADING, this.onLevelLoading, this),
        e.off(P.LEVEL_SWITCHING, this.onLevelSwitching, this),
        e.off(P.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this),
        e.off(P.ERROR, this.onError, this)
    }
    onMediaAttached(e, t) {
        this.media = t.media,
        this.media && (this.queuedDefaultTrack > -1 && (this.subtitleTrack = this.queuedDefaultTrack,
        this.queuedDefaultTrack = -1),
        this.useTextTrackPolling = !(this.media.textTracks && "onchange"in this.media.textTracks),
        this.useTextTrackPolling ? this.pollTrackChange(500) : this.media.textTracks.addEventListener("change", this.asyncPollTrackChange))
    }
    pollTrackChange(e) {
        self.clearInterval(this.subtitlePollingInterval),
        this.subtitlePollingInterval = self.setInterval(this.onTextTracksChanged, e)
    }
    onMediaDetaching() {
        if (!this.media)
            return;
        self.clearInterval(this.subtitlePollingInterval),
        this.useTextTrackPolling || this.media.textTracks.removeEventListener("change", this.asyncPollTrackChange),
        this.trackId > -1 && (this.queuedDefaultTrack = this.trackId),
        Ch(this.media.textTracks).forEach(t => {
            Ac(t)
        }
        ),
        this.subtitleTrack = -1,
        this.media = null
    }
    onManifestLoading() {
        this.tracks = [],
        this.groupIds = null,
        this.tracksInGroup = [],
        this.trackId = -1,
        this.currentTrack = null,
        this.selectDefaultTrack = !0
    }
    onManifestParsed(e, t) {
        this.tracks = t.subtitleTracks
    }
    onSubtitleTrackLoaded(e, t) {
        const {id: n, groupId: s, details: r} = t
          , o = this.tracksInGroup[n];
        if (!o || o.groupId !== s) {
            this.warn(`Subtitle track with id:${n} and group:${s} not found in active group ${o == null ? void 0 : o.groupId}`);
            return
        }
        const a = o.details;
        o.details = t.details,
        this.log(`Subtitle track ${n} "${o.name}" lang:${o.lang} group:${s} loaded [${r.startSN}-${r.endSN}]`),
        n === this.trackId && this.playlistLoaded(n, t, a)
    }
    onLevelLoading(e, t) {
        this.switchLevel(t.level)
    }
    onLevelSwitching(e, t) {
        this.switchLevel(t.level)
    }
    switchLevel(e) {
        const t = this.hls.levels[e];
        if (!t)
            return;
        const n = t.subtitleGroups || null
          , s = this.groupIds;
        let r = this.currentTrack;
        if (!n || (s == null ? void 0 : s.length) !== (n == null ? void 0 : n.length) || n != null && n.some(o => (s == null ? void 0 : s.indexOf(o)) === -1)) {
            this.groupIds = n,
            this.trackId = -1,
            this.currentTrack = null;
            const o = this.tracks.filter(u => !n || n.indexOf(u.groupId) !== -1);
            if (o.length)
                this.selectDefaultTrack && !o.some(u => u.default) && (this.selectDefaultTrack = !1),
                o.forEach( (u, d) => {
                    u.id = d
                }
                );
            else if (!r && !this.tracksInGroup.length)
                return;
            this.tracksInGroup = o;
            const a = this.hls.config.subtitlePreference;
            if (!r && a) {
                this.selectDefaultTrack = !1;
                const u = Nr(a, o);
                if (u > -1)
                    r = o[u];
                else {
                    const d = Nr(a, this.tracks);
                    r = this.tracks[d]
                }
            }
            let l = this.findTrackId(r);
            l === -1 && r && (l = this.findTrackId(null));
            const c = {
                subtitleTracks: o
            };
            this.log(`Updating subtitle tracks, ${o.length} track(s) found in "${n == null ? void 0 : n.join(",")}" group-id`),
            this.hls.trigger(P.SUBTITLE_TRACKS_UPDATED, c),
            l !== -1 && this.trackId === -1 && this.setSubtitleTrack(l)
        } else
            this.shouldReloadPlaylist(r) && this.setSubtitleTrack(this.trackId)
    }
    findTrackId(e) {
        const t = this.tracksInGroup
          , n = this.selectDefaultTrack;
        for (let s = 0; s < t.length; s++) {
            const r = t[s];
            if (!(n && !r.default || !n && !e) && (!e || Hc(r, e)))
                return s
        }
        if (e) {
            for (let s = 0; s < t.length; s++) {
                const r = t[s];
                if (uu(e.attrs, r.attrs, ["LANGUAGE", "ASSOC-LANGUAGE", "CHARACTERISTICS"]))
                    return s
            }
            for (let s = 0; s < t.length; s++) {
                const r = t[s];
                if (uu(e.attrs, r.attrs, ["LANGUAGE"]))
                    return s
            }
        }
        return -1
    }
    findTrackForTextTrack(e) {
        if (e) {
            const t = this.tracksInGroup;
            for (let n = 0; n < t.length; n++) {
                const s = t[n];
                if (q1(s, e))
                    return n
            }
        }
        return -1
    }
    onError(e, t) {
        t.fatal || !t.context || t.context.type === en.SUBTITLE_TRACK && t.context.id === this.trackId && (!this.groupIds || this.groupIds.indexOf(t.context.groupId) !== -1) && this.checkRetry(t)
    }
    get allSubtitleTracks() {
        return this.tracks
    }
    get subtitleTracks() {
        return this.tracksInGroup
    }
    get subtitleTrack() {
        return this.trackId
    }
    set subtitleTrack(e) {
        this.selectDefaultTrack = !1,
        this.setSubtitleTrack(e)
    }
    setSubtitleOption(e) {
        if (this.hls.config.subtitlePreference = e,
        e) {
            const t = this.allSubtitleTracks;
            if (this.selectDefaultTrack = !1,
            t.length) {
                const n = this.currentTrack;
                if (n && Hc(e, n))
                    return n;
                const s = Nr(e, this.tracksInGroup);
                if (s > -1) {
                    const r = this.tracksInGroup[s];
                    return this.setSubtitleTrack(s),
                    r
                } else {
                    if (n)
                        return null;
                    {
                        const r = Nr(e, t);
                        if (r > -1)
                            return t[r]
                    }
                }
            }
        }
        return null
    }
    loadPlaylist(e) {
        super.loadPlaylist();
        const t = this.currentTrack;
        if (this.shouldLoadPlaylist(t) && t) {
            const n = t.id
              , s = t.groupId;
            let r = t.url;
            if (e)
                try {
                    r = e.addDirectives(r)
                } catch (o) {
                    this.warn(`Could not construct new URL with HLS Delivery Directives: ${o}`)
                }
            this.log(`Loading subtitle playlist for id ${n}`),
            this.hls.trigger(P.SUBTITLE_TRACK_LOADING, {
                url: r,
                id: n,
                groupId: s,
                deliveryDirectives: e || null
            })
        }
    }
    toggleTrackModes() {
        const {media: e} = this;
        if (!e)
            return;
        const t = Ch(e.textTracks)
          , n = this.currentTrack;
        let s;
        if (n && (s = t.filter(r => q1(n, r))[0],
        s || this.warn(`Unable to find subtitle TextTrack with name "${n.name}" and language "${n.lang}"`)),
        [].slice.call(t).forEach(r => {
            r.mode !== "disabled" && r !== s && (r.mode = "disabled")
        }
        ),
        s) {
            const r = this.subtitleDisplay ? "showing" : "hidden";
            s.mode !== r && (s.mode = r)
        }
    }
    setSubtitleTrack(e) {
        const t = this.tracksInGroup;
        if (!this.media) {
            this.queuedDefaultTrack = e;
            return
        }
        if (e < -1 || e >= t.length || !pt(e)) {
            this.warn(`Invalid subtitle track id: ${e}`);
            return
        }
        this.clearTimer(),
        this.selectDefaultTrack = !1;
        const n = this.currentTrack
          , s = t[e] || null;
        if (this.trackId = e,
        this.currentTrack = s,
        this.toggleTrackModes(),
        !s) {
            this.hls.trigger(P.SUBTITLE_TRACK_SWITCH, {
                id: e
            });
            return
        }
        const r = !!s.details && !s.details.live;
        if (e === this.trackId && s === n && r)
            return;
        this.log(`Switching to subtitle-track ${e}` + (s ? ` "${s.name}" lang:${s.lang} group:${s.groupId}` : ""));
        const {id: o, groupId: a="", name: l, type: c, url: u} = s;
        this.hls.trigger(P.SUBTITLE_TRACK_SWITCH, {
            id: o,
            groupId: a,
            name: l,
            type: c,
            url: u
        });
        const d = this.switchParams(s.url, n == null ? void 0 : n.details, s.details);
        this.loadPlaylist(d)
    }
}
class fG {
    constructor(e) {
        this.buffers = void 0,
        this.queues = {
            video: [],
            audio: [],
            audiovideo: []
        },
        this.buffers = e
    }
    append(e, t, n) {
        const s = this.queues[t];
        s.push(e),
        s.length === 1 && !n && this.executeNext(t)
    }
    insertAbort(e, t) {
        this.queues[t].unshift(e),
        this.executeNext(t)
    }
    appendBlocker(e) {
        let t;
        const n = new Promise(r => {
            t = r
        }
        )
          , s = {
            execute: t,
            onStart: () => {}
            ,
            onComplete: () => {}
            ,
            onError: () => {}
        };
        return this.append(s, e),
        n
    }
    executeNext(e) {
        const t = this.queues[e];
        if (t.length) {
            const n = t[0];
            try {
                n.execute()
            } catch (s) {
                de.warn(`[buffer-operation-queue]: Exception executing "${e}" SourceBuffer operation: ${s}`),
                n.onError(s);
                const r = this.buffers[e];
                r != null && r.updating || this.shiftAndExecuteNext(e)
            }
        }
    }
    shiftAndExecuteNext(e) {
        this.queues[e].shift(),
        this.executeNext(e)
    }
    current(e) {
        return this.queues[e][0]
    }
}
const yS = /(avc[1234]|hvc1|hev1|dvh[1e]|vp09|av01)(?:\.[^.,]+)+/;
class hG {
    constructor(e) {
        this.details = null,
        this._objectUrl = null,
        this.operationQueue = void 0,
        this.listeners = void 0,
        this.hls = void 0,
        this.bufferCodecEventsExpected = 0,
        this._bufferCodecEventsTotal = 0,
        this.media = null,
        this.mediaSource = null,
        this.lastMpegAudioChunk = null,
        this.appendSource = void 0,
        this.appendErrors = {
            audio: 0,
            video: 0,
            audiovideo: 0
        },
        this.tracks = {},
        this.pendingTracks = {},
        this.sourceBuffer = void 0,
        this.log = void 0,
        this.warn = void 0,
        this.error = void 0,
        this._onEndStreaming = n => {
            !this.hls || this.hls.pauseBuffering()
        }
        ,
        this._onStartStreaming = n => {
            !this.hls || this.hls.resumeBuffering()
        }
        ,
        this._onMediaSourceOpen = () => {
            const {media: n, mediaSource: s} = this;
            this.log("Media source opened"),
            n && (n.removeEventListener("emptied", this._onMediaEmptied),
            this.updateMediaElementDuration(),
            this.hls.trigger(P.MEDIA_ATTACHED, {
                media: n,
                mediaSource: s
            })),
            s && s.removeEventListener("sourceopen", this._onMediaSourceOpen),
            this.checkPendingTracks()
        }
        ,
        this._onMediaSourceClose = () => {
            this.log("Media source closed")
        }
        ,
        this._onMediaSourceEnded = () => {
            this.log("Media source ended")
        }
        ,
        this._onMediaEmptied = () => {
            const {mediaSrc: n, _objectUrl: s} = this;
            n !== s && de.error(`Media element src was set while attaching MediaSource (${s} > ${n})`)
        }
        ,
        this.hls = e;
        const t = "[buffer-controller]";
        this.appendSource = SH(kl(e.config.preferManagedMediaSource)),
        this.log = de.log.bind(de, t),
        this.warn = de.warn.bind(de, t),
        this.error = de.error.bind(de, t),
        this._initSourceBuffer(),
        this.registerListeners()
    }
    hasSourceTypes() {
        return this.getSourceBufferTypes().length > 0 || Object.keys(this.pendingTracks).length > 0
    }
    destroy() {
        this.unregisterListeners(),
        this.details = null,
        this.lastMpegAudioChunk = null,
        this.hls = null
    }
    registerListeners() {
        const {hls: e} = this;
        e.on(P.MEDIA_ATTACHING, this.onMediaAttaching, this),
        e.on(P.MEDIA_DETACHING, this.onMediaDetaching, this),
        e.on(P.MANIFEST_LOADING, this.onManifestLoading, this),
        e.on(P.MANIFEST_PARSED, this.onManifestParsed, this),
        e.on(P.BUFFER_RESET, this.onBufferReset, this),
        e.on(P.BUFFER_APPENDING, this.onBufferAppending, this),
        e.on(P.BUFFER_CODECS, this.onBufferCodecs, this),
        e.on(P.BUFFER_EOS, this.onBufferEos, this),
        e.on(P.BUFFER_FLUSHING, this.onBufferFlushing, this),
        e.on(P.LEVEL_UPDATED, this.onLevelUpdated, this),
        e.on(P.FRAG_PARSED, this.onFragParsed, this),
        e.on(P.FRAG_CHANGED, this.onFragChanged, this)
    }
    unregisterListeners() {
        const {hls: e} = this;
        e.off(P.MEDIA_ATTACHING, this.onMediaAttaching, this),
        e.off(P.MEDIA_DETACHING, this.onMediaDetaching, this),
        e.off(P.MANIFEST_LOADING, this.onManifestLoading, this),
        e.off(P.MANIFEST_PARSED, this.onManifestParsed, this),
        e.off(P.BUFFER_RESET, this.onBufferReset, this),
        e.off(P.BUFFER_APPENDING, this.onBufferAppending, this),
        e.off(P.BUFFER_CODECS, this.onBufferCodecs, this),
        e.off(P.BUFFER_EOS, this.onBufferEos, this),
        e.off(P.BUFFER_FLUSHING, this.onBufferFlushing, this),
        e.off(P.LEVEL_UPDATED, this.onLevelUpdated, this),
        e.off(P.FRAG_PARSED, this.onFragParsed, this),
        e.off(P.FRAG_CHANGED, this.onFragChanged, this)
    }
    _initSourceBuffer() {
        this.sourceBuffer = {},
        this.operationQueue = new fG(this.sourceBuffer),
        this.listeners = {
            audio: [],
            video: [],
            audiovideo: []
        },
        this.appendErrors = {
            audio: 0,
            video: 0,
            audiovideo: 0
        },
        this.lastMpegAudioChunk = null
    }
    onManifestLoading() {
        this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = 0,
        this.details = null
    }
    onManifestParsed(e, t) {
        let n = 2;
        (t.audio && !t.video || !t.altAudio) && (n = 1),
        this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = n,
        this.log(`${this.bufferCodecEventsExpected} bufferCodec event(s) expected`)
    }
    onMediaAttaching(e, t) {
        const n = this.media = t.media
          , s = kl(this.appendSource);
        if (n && s) {
            var r;
            const o = this.mediaSource = new s;
            this.log(`created media source: ${(r = o.constructor) == null ? void 0 : r.name}`),
            o.addEventListener("sourceopen", this._onMediaSourceOpen),
            o.addEventListener("sourceended", this._onMediaSourceEnded),
            o.addEventListener("sourceclose", this._onMediaSourceClose),
            this.appendSource && (o.addEventListener("startstreaming", this._onStartStreaming),
            o.addEventListener("endstreaming", this._onEndStreaming));
            const a = this._objectUrl = self.URL.createObjectURL(o);
            if (this.appendSource)
                try {
                    n.removeAttribute("src");
                    const l = self.ManagedMediaSource;
                    n.disableRemotePlayback = n.disableRemotePlayback || l && o instanceof l,
                    bS(n),
                    pG(n, a),
                    n.load()
                } catch {
                    n.src = a
                }
            else
                n.src = a;
            n.addEventListener("emptied", this._onMediaEmptied)
        }
    }
    onMediaDetaching() {
        const {media: e, mediaSource: t, _objectUrl: n} = this;
        if (t) {
            if (this.log("media source detaching"),
            t.readyState === "open")
                try {
                    t.endOfStream()
                } catch (s) {
                    this.warn(`onMediaDetaching: ${s.message} while calling endOfStream`)
                }
            this.onBufferReset(),
            t.removeEventListener("sourceopen", this._onMediaSourceOpen),
            t.removeEventListener("sourceended", this._onMediaSourceEnded),
            t.removeEventListener("sourceclose", this._onMediaSourceClose),
            this.appendSource && (t.removeEventListener("startstreaming", this._onStartStreaming),
            t.removeEventListener("endstreaming", this._onEndStreaming)),
            e && (e.removeEventListener("emptied", this._onMediaEmptied),
            n && self.URL.revokeObjectURL(n),
            this.mediaSrc === n ? (e.removeAttribute("src"),
            this.appendSource && bS(e),
            e.load()) : this.warn("media|source.src was changed by a third party - skip cleanup")),
            this.mediaSource = null,
            this.media = null,
            this._objectUrl = null,
            this.bufferCodecEventsExpected = this._bufferCodecEventsTotal,
            this.pendingTracks = {},
            this.tracks = {}
        }
        this.hls.trigger(P.MEDIA_DETACHED, void 0)
    }
    onBufferReset() {
        this.getSourceBufferTypes().forEach(e => {
            this.resetBuffer(e)
        }
        ),
        this._initSourceBuffer()
    }
    resetBuffer(e) {
        const t = this.sourceBuffer[e];
        try {
            if (t) {
                var n;
                this.removeBufferListeners(e),
                this.sourceBuffer[e] = void 0,
                (n = this.mediaSource) != null && n.sourceBuffers.length && this.mediaSource.removeSourceBuffer(t)
            }
        } catch (s) {
            this.warn(`onBufferReset ${e}`, s)
        }
    }
    onBufferCodecs(e, t) {
        const n = this.getSourceBufferTypes().length
          , s = Object.keys(t);
        if (s.forEach(o => {
            if (n) {
                const l = this.tracks[o];
                if (l && typeof l.buffer.changeType == "function") {
                    var a;
                    const {id: c, codec: u, levelCodec: d, container: f, metadata: h} = t[o]
                      , p = Hb(l.codec, l.levelCodec)
                      , g = p == null ? void 0 : p.replace(yS, "$1");
                    let m = Hb(u, d);
                    const v = (a = m) == null ? void 0 : a.replace(yS, "$1");
                    if (m && g !== v) {
                        o.slice(0, 5) === "audio" && (m = Mp(m, this.appendSource));
                        const _ = `${f};codecs=${m}`;
                        this.appendChangeType(o, _),
                        this.log(`switching codec ${p} to ${m}`),
                        this.tracks[o] = {
                            buffer: l.buffer,
                            codec: u,
                            container: f,
                            levelCodec: d,
                            metadata: h,
                            id: c
                        }
                    }
                }
            } else
                this.pendingTracks[o] = t[o]
        }
        ),
        n)
            return;
        const r = Math.max(this.bufferCodecEventsExpected - 1, 0);
        this.bufferCodecEventsExpected !== r && (this.log(`${r} bufferCodec event(s) expected ${s.join(",")}`),
        this.bufferCodecEventsExpected = r),
        this.mediaSource && this.mediaSource.readyState === "open" && this.checkPendingTracks()
    }
    appendChangeType(e, t) {
        const {operationQueue: n} = this
          , s = {
            execute: () => {
                const r = this.sourceBuffer[e];
                r && (this.log(`changing ${e} sourceBuffer type to ${t}`),
                r.changeType(t)),
                n.shiftAndExecuteNext(e)
            }
            ,
            onStart: () => {}
            ,
            onComplete: () => {}
            ,
            onError: r => {
                this.warn(`Failed to change ${e} SourceBuffer type`, r)
            }
        };
        n.append(s, e, !!this.pendingTracks[e])
    }
    onBufferAppending(e, t) {
        const {hls: n, operationQueue: s, tracks: r} = this
          , {data: o, type: a, frag: l, part: c, chunkMeta: u} = t
          , d = u.buffering[a]
          , f = self.performance.now();
        d.start = f;
        const h = l.stats.buffering
          , p = c ? c.stats.buffering : null;
        h.start === 0 && (h.start = f),
        p && p.start === 0 && (p.start = f);
        const g = r.audio;
        let m = !1;
        a === "audio" && (g == null ? void 0 : g.container) === "audio/mpeg" && (m = !this.lastMpegAudioChunk || u.id === 1 || this.lastMpegAudioChunk.sn !== u.sn,
        this.lastMpegAudioChunk = u);
        const v = l.start
          , _ = {
            execute: () => {
                if (d.executeStart = self.performance.now(),
                m) {
                    const y = this.sourceBuffer[a];
                    if (y) {
                        const b = v - y.timestampOffset;
                        Math.abs(b) >= .1 && (this.log(`Updating audio SourceBuffer timestampOffset to ${v} (delta: ${b}) sn: ${l.sn})`),
                        y.timestampOffset = v)
                    }
                }
                this.appendExecutor(o, a)
            }
            ,
            onStart: () => {}
            ,
            onComplete: () => {
                const y = self.performance.now();
                d.executeEnd = d.end = y,
                h.first === 0 && (h.first = y),
                p && p.first === 0 && (p.first = y);
                const {sourceBuffer: b} = this
                  , S = {};
                for (const C in b)
                    S[C] = An.getBuffered(b[C]);
                this.appendErrors[a] = 0,
                a === "audio" || a === "video" ? this.appendErrors.audiovideo = 0 : (this.appendErrors.audio = 0,
                this.appendErrors.video = 0),
                this.hls.trigger(P.BUFFER_APPENDED, {
                    type: a,
                    frag: l,
                    part: c,
                    chunkMeta: u,
                    parent: l.type,
                    timeRanges: S
                })
            }
            ,
            onError: y => {
                const b = {
                    type: Ut.MEDIA_ERROR,
                    parent: l.type,
                    details: Ae.BUFFER_APPEND_ERROR,
                    sourceBufferName: a,
                    frag: l,
                    part: c,
                    chunkMeta: u,
                    error: y,
                    err: y,
                    fatal: !1
                };
                if (y.code === DOMException.QUOTA_EXCEEDED_ERR)
                    b.details = Ae.BUFFER_FULL_ERROR;
                else {
                    const S = ++this.appendErrors[a];
                    b.details = Ae.BUFFER_APPEND_ERROR,
                    this.warn(`Failed ${S}/${n.config.appendErrorMaxRetry} times to append segment in "${a}" sourceBuffer`),
                    S >= n.config.appendErrorMaxRetry && (b.fatal = !0)
                }
                n.trigger(P.ERROR, b)
            }
        };
        s.append(_, a, !!this.pendingTracks[a])
    }
    onBufferFlushing(e, t) {
        const {operationQueue: n} = this
          , s = r => ({
            execute: this.removeExecutor.bind(this, r, t.startOffset, t.endOffset),
            onStart: () => {}
            ,
            onComplete: () => {
                this.hls.trigger(P.BUFFER_FLUSHED, {
                    type: r
                })
            }
            ,
            onError: o => {
                this.warn(`Failed to remove from ${r} SourceBuffer`, o)
            }
        });
        t.type ? n.append(s(t.type), t.type) : this.getSourceBufferTypes().forEach(r => {
            n.append(s(r), r)
        }
        )
    }
    onFragParsed(e, t) {
        const {frag: n, part: s} = t
          , r = []
          , o = s ? s.elementaryStreams : n.elementaryStreams;
        o[gn.AUDIOVIDEO] ? r.push("audiovideo") : (o[gn.AUDIO] && r.push("audio"),
        o[gn.VIDEO] && r.push("video"));
        const a = () => {
            const l = self.performance.now();
            n.stats.buffering.end = l,
            s && (s.stats.buffering.end = l);
            const c = s ? s.stats : n.stats;
            this.hls.trigger(P.FRAG_BUFFERED, {
                frag: n,
                part: s,
                stats: c,
                id: n.type
            })
        }
        ;
        r.length === 0 && this.warn(`Fragments must have at least one ElementaryStreamType set. type: ${n.type} level: ${n.level} sn: ${n.sn}`),
        this.blockBuffers(a, r)
    }
    onFragChanged(e, t) {
        this.trimBuffers()
    }
    onBufferEos(e, t) {
        this.getSourceBufferTypes().reduce( (s, r) => {
            const o = this.sourceBuffer[r];
            return o && (!t.type || t.type === r) && (o.ending = !0,
            o.ended || (o.ended = !0,
            this.log(`${r} sourceBuffer now EOS`))),
            s && !!(!o || o.ended)
        }
        , !0) && (this.log("Queueing mediaSource.endOfStream()"),
        this.blockBuffers( () => {
            this.getSourceBufferTypes().forEach(r => {
                const o = this.sourceBuffer[r];
                o && (o.ending = !1)
            }
            );
            const {mediaSource: s} = this;
            if (!s || s.readyState !== "open") {
                s && this.log(`Could not call mediaSource.endOfStream(). mediaSource.readyState: ${s.readyState}`);
                return
            }
            this.log("Calling mediaSource.endOfStream()"),
            s.endOfStream()
        }
        ))
    }
    onLevelUpdated(e, {details: t}) {
        !t.fragments.length || (this.details = t,
        this.getSourceBufferTypes().length ? this.blockBuffers(this.updateMediaElementDuration.bind(this)) : this.updateMediaElementDuration())
    }
    trimBuffers() {
        const {hls: e, details: t, media: n} = this;
        if (!n || t === null || !this.getSourceBufferTypes().length)
            return;
        const r = e.config
          , o = n.currentTime
          , a = t.levelTargetDuration
          , l = t.live && r.liveBackBufferLength !== null ? r.liveBackBufferLength : r.backBufferLength;
        if (pt(l) && l > 0) {
            const c = Math.max(l, a)
              , u = Math.floor(o / a) * a - c;
            this.flushBackBuffer(o, a, u)
        }
        if (pt(r.frontBufferFlushThreshold) && r.frontBufferFlushThreshold > 0) {
            const c = Math.max(r.maxBufferLength, r.frontBufferFlushThreshold)
              , u = Math.max(c, a)
              , d = Math.floor(o / a) * a + u;
            this.flushFrontBuffer(o, a, d)
        }
    }
    flushBackBuffer(e, t, n) {
        const {details: s, sourceBuffer: r} = this;
        this.getSourceBufferTypes().forEach(a => {
            const l = r[a];
            if (l) {
                const c = An.getBuffered(l);
                if (c.length > 0 && n > c.start(0)) {
                    if (this.hls.trigger(P.BACK_BUFFER_REACHED, {
                        bufferEnd: n
                    }),
                    s != null && s.live)
                        this.hls.trigger(P.LIVE_BACK_BUFFER_REACHED, {
                            bufferEnd: n
                        });
                    else if (l.ended && c.end(c.length - 1) - e < t * 2) {
                        this.log(`Cannot flush ${a} back buffer while SourceBuffer is in ended state`);
                        return
                    }
                    this.hls.trigger(P.BUFFER_FLUSHING, {
                        startOffset: 0,
                        endOffset: n,
                        type: a
                    })
                }
            }
        }
        )
    }
    flushFrontBuffer(e, t, n) {
        const {sourceBuffer: s} = this;
        this.getSourceBufferTypes().forEach(o => {
            const a = s[o];
            if (a) {
                const l = An.getBuffered(a)
                  , c = l.length;
                if (c < 2)
                    return;
                const u = l.start(c - 1)
                  , d = l.end(c - 1);
                if (n > u || e >= u && e <= d)
                    return;
                if (a.ended && e - d < 2 * t) {
                    this.log(`Cannot flush ${o} front buffer while SourceBuffer is in ended state`);
                    return
                }
                this.hls.trigger(P.BUFFER_FLUSHING, {
                    startOffset: u,
                    endOffset: 1 / 0,
                    type: o
                })
            }
        }
        )
    }
    updateMediaElementDuration() {
        if (!this.details || !this.media || !this.mediaSource || this.mediaSource.readyState !== "open")
            return;
        const {details: e, hls: t, media: n, mediaSource: s} = this
          , r = e.fragments[0].start + e.totalduration
          , o = n.duration
          , a = pt(s.duration) ? s.duration : 0;
        e.live && t.config.liveDurationInfinity ? (s.duration = 1 / 0,
        this.updateSeekableRange(e)) : (r > a && r > o || !pt(o)) && (this.log(`Updating Media Source duration to ${r.toFixed(3)}`),
        s.duration = r)
    }
    updateSeekableRange(e) {
        const t = this.mediaSource
          , n = e.fragments;
        if (n.length && e.live && t != null && t.setLiveSeekableRange) {
            const r = Math.max(0, n[0].start)
              , o = Math.max(r, r + e.totalduration);
            this.log(`Media Source duration is set to ${t.duration}. Setting seekable range to ${r}-${o}.`),
            t.setLiveSeekableRange(r, o)
        }
    }
    checkPendingTracks() {
        const {bufferCodecEventsExpected: e, operationQueue: t, pendingTracks: n} = this
          , s = Object.keys(n).length;
        if (s && (!e || s === 2 || "audiovideo"in n)) {
            this.createSourceBuffers(n),
            this.pendingTracks = {};
            const r = this.getSourceBufferTypes();
            if (r.length)
                this.hls.trigger(P.BUFFER_CREATED, {
                    tracks: this.tracks
                }),
                r.forEach(o => {
                    t.executeNext(o)
                }
                );
            else {
                const o = new Error("could not create source buffer for media codec(s)");
                this.hls.trigger(P.ERROR, {
                    type: Ut.MEDIA_ERROR,
                    details: Ae.BUFFER_INCOMPATIBLE_CODECS_ERROR,
                    fatal: !0,
                    error: o,
                    reason: o.message
                })
            }
        }
    }
    createSourceBuffers(e) {
        const {sourceBuffer: t, mediaSource: n} = this;
        if (!n)
            throw Error("createSourceBuffers called when mediaSource was null");
        for (const r in e)
            if (!t[r]) {
                var s;
                const o = e[r];
                if (!o)
                    throw Error(`source buffer exists for track ${r}, however track does not`);
                let a = ((s = o.levelCodec) == null ? void 0 : s.indexOf(",")) === -1 ? o.levelCodec : o.codec;
                a && r.slice(0, 5) === "audio" && (a = Mp(a, this.appendSource));
                const l = `${o.container};codecs=${a}`;
                this.log(`creating sourceBuffer(${l})`);
                try {
                    const c = t[r] = n.addSourceBuffer(l)
                      , u = r;
                    this.addBufferListener(u, "updatestart", this._onSBUpdateStart),
                    this.addBufferListener(u, "updateend", this._onSBUpdateEnd),
                    this.addBufferListener(u, "error", this._onSBUpdateError),
                    this.appendSource && this.addBufferListener(u, "bufferedchange", (d, f) => {
                        const h = f.removedRanges;
                        h != null && h.length && this.hls.trigger(P.BUFFER_FLUSHED, {
                            type: r
                        })
                    }
                    ),
                    this.tracks[r] = {
                        buffer: c,
                        codec: a,
                        container: o.container,
                        levelCodec: o.levelCodec,
                        metadata: o.metadata,
                        id: o.id
                    }
                } catch (c) {
                    this.error(`error while trying to add sourceBuffer: ${c.message}`),
                    this.hls.trigger(P.ERROR, {
                        type: Ut.MEDIA_ERROR,
                        details: Ae.BUFFER_ADD_CODEC_ERROR,
                        fatal: !1,
                        error: c,
                        sourceBufferName: r,
                        mimeType: l
                    })
                }
            }
    }
    get mediaSrc() {
        var e, t;
        const n = ((e = this.media) == null || (t = e.querySelector) == null ? void 0 : t.call(e, "source")) || this.media;
        return n == null ? void 0 : n.src
    }
    _onSBUpdateStart(e) {
        const {operationQueue: t} = this;
        t.current(e).onStart()
    }
    _onSBUpdateEnd(e) {
        var t;
        if (((t = this.mediaSource) == null ? void 0 : t.readyState) === "closed") {
            this.resetBuffer(e);
            return
        }
        const {operationQueue: n} = this;
        n.current(e).onComplete(),
        n.shiftAndExecuteNext(e)
    }
    _onSBUpdateError(e, t) {
        var n;
        const s = new Error(`${e} SourceBuffer error. MediaSource readyState: ${(n = this.mediaSource) == null ? void 0 : n.readyState}`);
        this.error(`${s}`, t),
        this.hls.trigger(P.ERROR, {
            type: Ut.MEDIA_ERROR,
            details: Ae.BUFFER_APPENDING_ERROR,
            sourceBufferName: e,
            error: s,
            fatal: !1
        });
        const r = this.operationQueue.current(e);
        r && r.onError(s)
    }
    removeExecutor(e, t, n) {
        const {media: s, mediaSource: r, operationQueue: o, sourceBuffer: a} = this
          , l = a[e];
        if (!s || !r || !l) {
            this.warn(`Attempting to remove from the ${e} SourceBuffer, but it does not exist`),
            o.shiftAndExecuteNext(e);
            return
        }
        const c = pt(s.duration) ? s.duration : 1 / 0
          , u = pt(r.duration) ? r.duration : 1 / 0
          , d = Math.max(0, t)
          , f = Math.min(n, c, u);
        f > d && (!l.ending || l.ended) ? (l.ended = !1,
        this.log(`Removing [${d},${f}] from the ${e} SourceBuffer`),
        l.remove(d, f)) : o.shiftAndExecuteNext(e)
    }
    appendExecutor(e, t) {
        const n = this.sourceBuffer[t];
        if (!n) {
            if (!this.pendingTracks[t])
                throw new Error(`Attempting to append to the ${t} SourceBuffer, but it does not exist`);
            return
        }
        n.ended = !1,
        n.appendBuffer(e)
    }
    blockBuffers(e, t=this.getSourceBufferTypes()) {
        if (!t.length) {
            this.log("Blocking operation requested, but no SourceBuffers exist"),
            Promise.resolve().then(e);
            return
        }
        const {operationQueue: n} = this
          , s = t.map(r => n.appendBlocker(r));
        Promise.all(s).then( () => {
            e(),
            t.forEach(r => {
                const o = this.sourceBuffer[r];
                o != null && o.updating || n.shiftAndExecuteNext(r)
            }
            )
        }
        )
    }
    getSourceBufferTypes() {
        return Object.keys(this.sourceBuffer)
    }
    addBufferListener(e, t, n) {
        const s = this.sourceBuffer[e];
        if (!s)
            return;
        const r = n.bind(this, e);
        this.listeners[e].push({
            event: t,
            listener: r
        }),
        s.addEventListener(t, r)
    }
    removeBufferListeners(e) {
        const t = this.sourceBuffer[e];
        !t || this.listeners[e].forEach(n => {
            t.removeEventListener(n.event, n.listener)
        }
        )
    }
}
function bS(i) {
    const e = i.querySelectorAll("source");
    [].slice.call(e).forEach(t => {
        i.removeChild(t)
    }
    )
}
function pG(i, e) {
    const t = self.document.createElement("source");
    t.type = "video/mp4",
    t.src = e,
    i.appendChild(t)
}
const mG = {
    42: 225,
    92: 233,
    94: 237,
    95: 243,
    96: 250,
    123: 231,
    124: 247,
    125: 209,
    126: 241,
    127: 9608,
    128: 174,
    129: 176,
    130: 189,
    131: 191,
    132: 8482,
    133: 162,
    134: 163,
    135: 9834,
    136: 224,
    137: 32,
    138: 232,
    139: 226,
    140: 234,
    141: 238,
    142: 244,
    143: 251,
    144: 193,
    145: 201,
    146: 211,
    147: 218,
    148: 220,
    149: 252,
    150: 8216,
    151: 161,
    152: 42,
    153: 8217,
    154: 9473,
    155: 169,
    156: 8480,
    157: 8226,
    158: 8220,
    159: 8221,
    160: 192,
    161: 194,
    162: 199,
    163: 200,
    164: 202,
    165: 203,
    166: 235,
    167: 206,
    168: 207,
    169: 239,
    170: 212,
    171: 217,
    172: 249,
    173: 219,
    174: 171,
    175: 187,
    176: 195,
    177: 227,
    178: 205,
    179: 204,
    180: 236,
    181: 210,
    182: 242,
    183: 213,
    184: 245,
    185: 123,
    186: 125,
    187: 92,
    188: 94,
    189: 95,
    190: 124,
    191: 8764,
    192: 196,
    193: 228,
    194: 214,
    195: 246,
    196: 223,
    197: 165,
    198: 164,
    199: 9475,
    200: 197,
    201: 229,
    202: 216,
    203: 248,
    204: 9487,
    205: 9491,
    206: 9495,
    207: 9499
}
  , AM = i => String.fromCharCode(mG[i] || i)
  , ir = 15
  , ro = 100
  , gG = {
    17: 1,
    18: 3,
    21: 5,
    22: 7,
    23: 9,
    16: 11,
    19: 12,
    20: 14
}
  , vG = {
    17: 2,
    18: 4,
    21: 6,
    22: 8,
    23: 10,
    19: 13,
    20: 15
}
  , _G = {
    25: 1,
    26: 3,
    29: 5,
    30: 7,
    31: 9,
    24: 11,
    27: 12,
    28: 14
}
  , xG = {
    25: 2,
    26: 4,
    29: 6,
    30: 8,
    31: 10,
    27: 13,
    28: 15
}
  , yG = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "black", "transparent"];
class bG {
    constructor() {
        this.time = null,
        this.verboseLevel = 0
    }
    log(e, t) {
        if (this.verboseLevel >= e) {
            const n = typeof t == "function" ? t() : t;
            de.log(`${this.time} [${e}] ${n}`)
        }
    }
}
const Ga = function(e) {
    const t = [];
    for (let n = 0; n < e.length; n++)
        t.push(e[n].toString(16));
    return t
};
class CM {
    constructor() {
        this.foreground = "white",
        this.underline = !1,
        this.italics = !1,
        this.background = "black",
        this.flash = !1
    }
    reset() {
        this.foreground = "white",
        this.underline = !1,
        this.italics = !1,
        this.background = "black",
        this.flash = !1
    }
    setStyles(e) {
        const t = ["foreground", "underline", "italics", "background", "flash"];
        for (let n = 0; n < t.length; n++) {
            const s = t[n];
            e.hasOwnProperty(s) && (this[s] = e[s])
        }
    }
    isDefault() {
        return this.foreground === "white" && !this.underline && !this.italics && this.background === "black" && !this.flash
    }
    equals(e) {
        return this.foreground === e.foreground && this.underline === e.underline && this.italics === e.italics && this.background === e.background && this.flash === e.flash
    }
    copy(e) {
        this.foreground = e.foreground,
        this.underline = e.underline,
        this.italics = e.italics,
        this.background = e.background,
        this.flash = e.flash
    }
    toString() {
        return "color=" + this.foreground + ", underline=" + this.underline + ", italics=" + this.italics + ", background=" + this.background + ", flash=" + this.flash
    }
}
class SG {
    constructor() {
        this.uchar = " ",
        this.penState = new CM
    }
    reset() {
        this.uchar = " ",
        this.penState.reset()
    }
    setChar(e, t) {
        this.uchar = e,
        this.penState.copy(t)
    }
    setPenState(e) {
        this.penState.copy(e)
    }
    equals(e) {
        return this.uchar === e.uchar && this.penState.equals(e.penState)
    }
    copy(e) {
        this.uchar = e.uchar,
        this.penState.copy(e.penState)
    }
    isEmpty() {
        return this.uchar === " " && this.penState.isDefault()
    }
}
class EG {
    constructor(e) {
        this.chars = [],
        this.pos = 0,
        this.currPenState = new CM,
        this.cueStartTime = null,
        this.logger = void 0;
        for (let t = 0; t < ro; t++)
            this.chars.push(new SG);
        this.logger = e
    }
    equals(e) {
        for (let t = 0; t < ro; t++)
            if (!this.chars[t].equals(e.chars[t]))
                return !1;
        return !0
    }
    copy(e) {
        for (let t = 0; t < ro; t++)
            this.chars[t].copy(e.chars[t])
    }
    isEmpty() {
        let e = !0;
        for (let t = 0; t < ro; t++)
            if (!this.chars[t].isEmpty()) {
                e = !1;
                break
            }
        return e
    }
    setCursor(e) {
        this.pos !== e && (this.pos = e),
        this.pos < 0 ? (this.logger.log(3, "Negative cursor position " + this.pos),
        this.pos = 0) : this.pos > ro && (this.logger.log(3, "Too large cursor position " + this.pos),
        this.pos = ro)
    }
    moveCursor(e) {
        const t = this.pos + e;
        if (e > 1)
            for (let n = this.pos + 1; n < t + 1; n++)
                this.chars[n].setPenState(this.currPenState);
        this.setCursor(t)
    }
    backSpace() {
        this.moveCursor(-1),
        this.chars[this.pos].setChar(" ", this.currPenState)
    }
    insertChar(e) {
        e >= 144 && this.backSpace();
        const t = AM(e);
        if (this.pos >= ro) {
            this.logger.log(0, () => "Cannot insert " + e.toString(16) + " (" + t + ") at position " + this.pos + ". Skipping it!");
            return
        }
        this.chars[this.pos].setChar(t, this.currPenState),
        this.moveCursor(1)
    }
    clearFromPos(e) {
        let t;
        for (t = e; t < ro; t++)
            this.chars[t].reset()
    }
    clear() {
        this.clearFromPos(0),
        this.pos = 0,
        this.currPenState.reset()
    }
    clearToEndOfRow() {
        this.clearFromPos(this.pos)
    }
    getTextString() {
        const e = [];
        let t = !0;
        for (let n = 0; n < ro; n++) {
            const s = this.chars[n].uchar;
            s !== " " && (t = !1),
            e.push(s)
        }
        return t ? "" : e.join("")
    }
    setPenStyles(e) {
        this.currPenState.setStyles(e),
        this.chars[this.pos].setPenState(this.currPenState)
    }
}
class P0 {
    constructor(e) {
        this.rows = [],
        this.currRow = ir - 1,
        this.nrRollUpRows = null,
        this.lastOutputScreen = null,
        this.logger = void 0;
        for (let t = 0; t < ir; t++)
            this.rows.push(new EG(e));
        this.logger = e
    }
    reset() {
        for (let e = 0; e < ir; e++)
            this.rows[e].clear();
        this.currRow = ir - 1
    }
    equals(e) {
        let t = !0;
        for (let n = 0; n < ir; n++)
            if (!this.rows[n].equals(e.rows[n])) {
                t = !1;
                break
            }
        return t
    }
    copy(e) {
        for (let t = 0; t < ir; t++)
            this.rows[t].copy(e.rows[t])
    }
    isEmpty() {
        let e = !0;
        for (let t = 0; t < ir; t++)
            if (!this.rows[t].isEmpty()) {
                e = !1;
                break
            }
        return e
    }
    backSpace() {
        this.rows[this.currRow].backSpace()
    }
    clearToEndOfRow() {
        this.rows[this.currRow].clearToEndOfRow()
    }
    insertChar(e) {
        this.rows[this.currRow].insertChar(e)
    }
    setPen(e) {
        this.rows[this.currRow].setPenStyles(e)
    }
    moveCursor(e) {
        this.rows[this.currRow].moveCursor(e)
    }
    setCursor(e) {
        this.logger.log(2, "setCursor: " + e),
        this.rows[this.currRow].setCursor(e)
    }
    setPAC(e) {
        this.logger.log(2, () => "pacData = " + JSON.stringify(e));
        let t = e.row - 1;
        if (this.nrRollUpRows && t < this.nrRollUpRows - 1 && (t = this.nrRollUpRows - 1),
        this.nrRollUpRows && this.currRow !== t) {
            for (let a = 0; a < ir; a++)
                this.rows[a].clear();
            const r = this.currRow + 1 - this.nrRollUpRows
              , o = this.lastOutputScreen;
            if (o) {
                const a = o.rows[r].cueStartTime
                  , l = this.logger.time;
                if (a !== null && l !== null && a < l)
                    for (let c = 0; c < this.nrRollUpRows; c++)
                        this.rows[t - this.nrRollUpRows + c + 1].copy(o.rows[r + c])
            }
        }
        this.currRow = t;
        const n = this.rows[this.currRow];
        if (e.indent !== null) {
            const r = e.indent
              , o = Math.max(r - 1, 0);
            n.setCursor(e.indent),
            e.color = n.chars[o].penState.foreground
        }
        const s = {
            foreground: e.color,
            underline: e.underline,
            italics: e.italics,
            background: "black",
            flash: !1
        };
        this.setPen(s)
    }
    setBkgData(e) {
        this.logger.log(2, () => "bkgData = " + JSON.stringify(e)),
        this.backSpace(),
        this.setPen(e),
        this.insertChar(32)
    }
    setRollUpRows(e) {
        this.nrRollUpRows = e
    }
    rollUp() {
        if (this.nrRollUpRows === null) {
            this.logger.log(3, "roll_up but nrRollUpRows not set yet");
            return
        }
        this.logger.log(1, () => this.getDisplayText());
        const e = this.currRow + 1 - this.nrRollUpRows
          , t = this.rows.splice(e, 1)[0];
        t.clear(),
        this.rows.splice(this.currRow, 0, t),
        this.logger.log(2, "Rolling up")
    }
    getDisplayText(e) {
        e = e || !1;
        const t = [];
        let n = ""
          , s = -1;
        for (let r = 0; r < ir; r++) {
            const o = this.rows[r].getTextString();
            o && (s = r + 1,
            e ? t.push("Row " + s + ": '" + o + "'") : t.push(o.trim()))
        }
        return t.length > 0 && (e ? n = "[" + t.join(" | ") + "]" : n = t.join(`
`)),
        n
    }
    getTextAndFormat() {
        return this.rows
    }
}
class SS {
    constructor(e, t, n) {
        this.chNr = void 0,
        this.outputFilter = void 0,
        this.mode = void 0,
        this.verbose = void 0,
        this.displayedMemory = void 0,
        this.nonDisplayedMemory = void 0,
        this.lastOutputScreen = void 0,
        this.currRollUpRow = void 0,
        this.writeScreen = void 0,
        this.cueStartTime = void 0,
        this.logger = void 0,
        this.chNr = e,
        this.outputFilter = t,
        this.mode = null,
        this.verbose = 0,
        this.displayedMemory = new P0(n),
        this.nonDisplayedMemory = new P0(n),
        this.lastOutputScreen = new P0(n),
        this.currRollUpRow = this.displayedMemory.rows[ir - 1],
        this.writeScreen = this.displayedMemory,
        this.mode = null,
        this.cueStartTime = null,
        this.logger = n
    }
    reset() {
        this.mode = null,
        this.displayedMemory.reset(),
        this.nonDisplayedMemory.reset(),
        this.lastOutputScreen.reset(),
        this.outputFilter.reset(),
        this.currRollUpRow = this.displayedMemory.rows[ir - 1],
        this.writeScreen = this.displayedMemory,
        this.mode = null,
        this.cueStartTime = null
    }
    getHandler() {
        return this.outputFilter
    }
    setHandler(e) {
        this.outputFilter = e
    }
    setPAC(e) {
        this.writeScreen.setPAC(e)
    }
    setBkgData(e) {
        this.writeScreen.setBkgData(e)
    }
    setMode(e) {
        e !== this.mode && (this.mode = e,
        this.logger.log(2, () => "MODE=" + e),
        this.mode === "MODE_POP-ON" ? this.writeScreen = this.nonDisplayedMemory : (this.writeScreen = this.displayedMemory,
        this.writeScreen.reset()),
        this.mode !== "MODE_ROLL-UP" && (this.displayedMemory.nrRollUpRows = null,
        this.nonDisplayedMemory.nrRollUpRows = null),
        this.mode = e)
    }
    insertChars(e) {
        for (let n = 0; n < e.length; n++)
            this.writeScreen.insertChar(e[n]);
        const t = this.writeScreen === this.displayedMemory ? "DISP" : "NON_DISP";
        this.logger.log(2, () => t + ": " + this.writeScreen.getDisplayText(!0)),
        (this.mode === "MODE_PAINT-ON" || this.mode === "MODE_ROLL-UP") && (this.logger.log(1, () => "DISPLAYED: " + this.displayedMemory.getDisplayText(!0)),
        this.outputDataUpdate())
    }
    ccRCL() {
        this.logger.log(2, "RCL - Resume Caption Loading"),
        this.setMode("MODE_POP-ON")
    }
    ccBS() {
        this.logger.log(2, "BS - BackSpace"),
        this.mode !== "MODE_TEXT" && (this.writeScreen.backSpace(),
        this.writeScreen === this.displayedMemory && this.outputDataUpdate())
    }
    ccAOF() {}
    ccAON() {}
    ccDER() {
        this.logger.log(2, "DER- Delete to End of Row"),
        this.writeScreen.clearToEndOfRow(),
        this.outputDataUpdate()
    }
    ccRU(e) {
        this.logger.log(2, "RU(" + e + ") - Roll Up"),
        this.writeScreen = this.displayedMemory,
        this.setMode("MODE_ROLL-UP"),
        this.writeScreen.setRollUpRows(e)
    }
    ccFON() {
        this.logger.log(2, "FON - Flash On"),
        this.writeScreen.setPen({
            flash: !0
        })
    }
    ccRDC() {
        this.logger.log(2, "RDC - Resume Direct Captioning"),
        this.setMode("MODE_PAINT-ON")
    }
    ccTR() {
        this.logger.log(2, "TR"),
        this.setMode("MODE_TEXT")
    }
    ccRTD() {
        this.logger.log(2, "RTD"),
        this.setMode("MODE_TEXT")
    }
    ccEDM() {
        this.logger.log(2, "EDM - Erase Displayed Memory"),
        this.displayedMemory.reset(),
        this.outputDataUpdate(!0)
    }
    ccCR() {
        this.logger.log(2, "CR - Carriage Return"),
        this.writeScreen.rollUp(),
        this.outputDataUpdate(!0)
    }
    ccENM() {
        this.logger.log(2, "ENM - Erase Non-displayed Memory"),
        this.nonDisplayedMemory.reset()
    }
    ccEOC() {
        if (this.logger.log(2, "EOC - End Of Caption"),
        this.mode === "MODE_POP-ON") {
            const e = this.displayedMemory;
            this.displayedMemory = this.nonDisplayedMemory,
            this.nonDisplayedMemory = e,
            this.writeScreen = this.nonDisplayedMemory,
            this.logger.log(1, () => "DISP: " + this.displayedMemory.getDisplayText())
        }
        this.outputDataUpdate(!0)
    }
    ccTO(e) {
        this.logger.log(2, "TO(" + e + ") - Tab Offset"),
        this.writeScreen.moveCursor(e)
    }
    ccMIDROW(e) {
        const t = {
            flash: !1
        };
        if (t.underline = e % 2 === 1,
        t.italics = e >= 46,
        t.italics)
            t.foreground = "white";
        else {
            const n = Math.floor(e / 2) - 16
              , s = ["white", "green", "blue", "cyan", "red", "yellow", "magenta"];
            t.foreground = s[n]
        }
        this.logger.log(2, "MIDROW: " + JSON.stringify(t)),
        this.writeScreen.setPen(t)
    }
    outputDataUpdate(e=!1) {
        const t = this.logger.time;
        t !== null && this.outputFilter && (this.cueStartTime === null && !this.displayedMemory.isEmpty() ? this.cueStartTime = t : this.displayedMemory.equals(this.lastOutputScreen) || (this.outputFilter.newCue(this.cueStartTime, t, this.lastOutputScreen),
        e && this.outputFilter.dispatchCue && this.outputFilter.dispatchCue(),
        this.cueStartTime = this.displayedMemory.isEmpty() ? null : t),
        this.lastOutputScreen.copy(this.displayedMemory))
    }
    cueSplitAtTime(e) {
        this.outputFilter && (this.displayedMemory.isEmpty() || (this.outputFilter.newCue && this.outputFilter.newCue(this.cueStartTime, e, this.displayedMemory),
        this.cueStartTime = e))
    }
}
class ES {
    constructor(e, t, n) {
        this.channels = void 0,
        this.currentChannel = 0,
        this.cmdHistory = TG(),
        this.logger = void 0;
        const s = this.logger = new bG;
        this.channels = [null, new SS(e,t,s), new SS(e + 1,n,s)]
    }
    getHandler(e) {
        return this.channels[e].getHandler()
    }
    setHandler(e, t) {
        this.channels[e].setHandler(t)
    }
    addData(e, t) {
        this.logger.time = e;
        for (let n = 0; n < t.length; n += 2) {
            const s = t[n] & 127
              , r = t[n + 1] & 127;
            let o = !1
              , a = null;
            if (s === 0 && r === 0)
                continue;
            this.logger.log(3, () => "[" + Ga([t[n], t[n + 1]]) + "] -> (" + Ga([s, r]) + ")");
            const l = this.cmdHistory;
            if (s >= 16 && s <= 31) {
                if (wG(s, r, l)) {
                    Nf(null, null, l),
                    this.logger.log(3, () => "Repeated command (" + Ga([s, r]) + ") is dropped");
                    continue
                }
                Nf(s, r, this.cmdHistory),
                o = this.parseCmd(s, r),
                o || (o = this.parseMidrow(s, r)),
                o || (o = this.parsePAC(s, r)),
                o || (o = this.parseBackgroundAttributes(s, r))
            } else
                Nf(null, null, l);
            if (!o && (a = this.parseChars(s, r),
            a)) {
                const u = this.currentChannel;
                u && u > 0 ? this.channels[u].insertChars(a) : this.logger.log(2, "No channel found yet. TEXT-MODE?")
            }
            !o && !a && this.logger.log(2, () => "Couldn't parse cleaned data " + Ga([s, r]) + " orig: " + Ga([t[n], t[n + 1]]))
        }
    }
    parseCmd(e, t) {
        const n = (e === 20 || e === 28 || e === 21 || e === 29) && t >= 32 && t <= 47
          , s = (e === 23 || e === 31) && t >= 33 && t <= 35;
        if (!(n || s))
            return !1;
        const r = e === 20 || e === 21 || e === 23 ? 1 : 2
          , o = this.channels[r];
        return e === 20 || e === 21 || e === 28 || e === 29 ? t === 32 ? o.ccRCL() : t === 33 ? o.ccBS() : t === 34 ? o.ccAOF() : t === 35 ? o.ccAON() : t === 36 ? o.ccDER() : t === 37 ? o.ccRU(2) : t === 38 ? o.ccRU(3) : t === 39 ? o.ccRU(4) : t === 40 ? o.ccFON() : t === 41 ? o.ccRDC() : t === 42 ? o.ccTR() : t === 43 ? o.ccRTD() : t === 44 ? o.ccEDM() : t === 45 ? o.ccCR() : t === 46 ? o.ccENM() : t === 47 && o.ccEOC() : o.ccTO(t - 32),
        this.currentChannel = r,
        !0
    }
    parseMidrow(e, t) {
        let n = 0;
        if ((e === 17 || e === 25) && t >= 32 && t <= 47) {
            if (e === 17 ? n = 1 : n = 2,
            n !== this.currentChannel)
                return this.logger.log(0, "Mismatch channel in midrow parsing"),
                !1;
            const s = this.channels[n];
            return s ? (s.ccMIDROW(t),
            this.logger.log(3, () => "MIDROW (" + Ga([e, t]) + ")"),
            !0) : !1
        }
        return !1
    }
    parsePAC(e, t) {
        let n;
        const s = (e >= 17 && e <= 23 || e >= 25 && e <= 31) && t >= 64 && t <= 127
          , r = (e === 16 || e === 24) && t >= 64 && t <= 95;
        if (!(s || r))
            return !1;
        const o = e <= 23 ? 1 : 2;
        t >= 64 && t <= 95 ? n = o === 1 ? gG[e] : _G[e] : n = o === 1 ? vG[e] : xG[e];
        const a = this.channels[o];
        return a ? (a.setPAC(this.interpretPAC(n, t)),
        this.currentChannel = o,
        !0) : !1
    }
    interpretPAC(e, t) {
        let n;
        const s = {
            color: null,
            italics: !1,
            indent: null,
            underline: !1,
            row: e
        };
        return t > 95 ? n = t - 96 : n = t - 64,
        s.underline = (n & 1) === 1,
        n <= 13 ? s.color = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "white"][Math.floor(n / 2)] : n <= 15 ? (s.italics = !0,
        s.color = "white") : s.indent = Math.floor((n - 16) / 2) * 4,
        s
    }
    parseChars(e, t) {
        let n, s = null, r = null;
        if (e >= 25 ? (n = 2,
        r = e - 8) : (n = 1,
        r = e),
        r >= 17 && r <= 19) {
            let o;
            r === 17 ? o = t + 80 : r === 18 ? o = t + 112 : o = t + 144,
            this.logger.log(2, () => "Special char '" + AM(o) + "' in channel " + n),
            s = [o]
        } else
            e >= 32 && e <= 127 && (s = t === 0 ? [e] : [e, t]);
        return s && this.logger.log(3, () => "Char codes =  " + Ga(s).join(",")),
        s
    }
    parseBackgroundAttributes(e, t) {
        const n = (e === 16 || e === 24) && t >= 32 && t <= 47
          , s = (e === 23 || e === 31) && t >= 45 && t <= 47;
        if (!(n || s))
            return !1;
        let r;
        const o = {};
        e === 16 || e === 24 ? (r = Math.floor((t - 32) / 2),
        o.background = yG[r],
        t % 2 === 1 && (o.background = o.background + "_semi")) : t === 45 ? o.background = "transparent" : (o.foreground = "black",
        t === 47 && (o.underline = !0));
        const a = e <= 23 ? 1 : 2;
        return this.channels[a].setBkgData(o),
        !0
    }
    reset() {
        for (let e = 0; e < Object.keys(this.channels).length; e++) {
            const t = this.channels[e];
            t && t.reset()
        }
        Nf(null, null, this.cmdHistory)
    }
    cueSplitAtTime(e) {
        for (let t = 0; t < this.channels.length; t++) {
            const n = this.channels[t];
            n && n.cueSplitAtTime(e)
        }
    }
}
function Nf(i, e, t) {
    t.a = i,
    t.b = e
}
function wG(i, e, t) {
    return t.a === i && t.b === e
}
function TG() {
    return {
        a: null,
        b: null
    }
}
class Bf {
    constructor(e, t) {
        this.timelineController = void 0,
        this.cueRanges = [],
        this.trackName = void 0,
        this.startTime = null,
        this.endTime = null,
        this.screen = null,
        this.timelineController = e,
        this.trackName = t
    }
    dispatchCue() {
        this.startTime !== null && (this.timelineController.addCues(this.trackName, this.startTime, this.endTime, this.screen, this.cueRanges),
        this.startTime = null)
    }
    newCue(e, t, n) {
        (this.startTime === null || this.startTime > e) && (this.startTime = e),
        this.endTime = t,
        this.screen = n,
        this.timelineController.createCaptionsTrack(this.trackName)
    }
    reset() {
        this.cueRanges = [],
        this.startTime = null
    }
}
var dx = function() {
    if (lu != null && lu.VTTCue)
        return self.VTTCue;
    const i = ["", "lr", "rl"]
      , e = ["start", "middle", "end", "left", "right"];
    function t(a, l) {
        if (typeof l != "string" || !Array.isArray(a))
            return !1;
        const c = l.toLowerCase();
        return ~a.indexOf(c) ? c : !1
    }
    function n(a) {
        return t(i, a)
    }
    function s(a) {
        return t(e, a)
    }
    function r(a, ...l) {
        let c = 1;
        for (; c < arguments.length; c++) {
            const u = arguments[c];
            for (const d in u)
                a[d] = u[d]
        }
        return a
    }
    function o(a, l, c) {
        const u = this
          , d = {
            enumerable: !0
        };
        u.hasBeenReset = !1;
        let f = ""
          , h = !1
          , p = a
          , g = l
          , m = c
          , v = null
          , _ = ""
          , y = !0
          , b = "auto"
          , S = "start"
          , C = 50
          , M = "middle"
          , L = 50
          , T = "middle";
        Object.defineProperty(u, "id", r({}, d, {
            get: function() {
                return f
            },
            set: function(A) {
                f = "" + A
            }
        })),
        Object.defineProperty(u, "pauseOnExit", r({}, d, {
            get: function() {
                return h
            },
            set: function(A) {
                h = !!A
            }
        })),
        Object.defineProperty(u, "startTime", r({}, d, {
            get: function() {
                return p
            },
            set: function(A) {
                if (typeof A != "number")
                    throw new TypeError("Start time must be set to a number.");
                p = A,
                this.hasBeenReset = !0
            }
        })),
        Object.defineProperty(u, "endTime", r({}, d, {
            get: function() {
                return g
            },
            set: function(A) {
                if (typeof A != "number")
                    throw new TypeError("End time must be set to a number.");
                g = A,
                this.hasBeenReset = !0
            }
        })),
        Object.defineProperty(u, "text", r({}, d, {
            get: function() {
                return m
            },
            set: function(A) {
                m = "" + A,
                this.hasBeenReset = !0
            }
        })),
        Object.defineProperty(u, "region", r({}, d, {
            get: function() {
                return v
            },
            set: function(A) {
                v = A,
                this.hasBeenReset = !0
            }
        })),
        Object.defineProperty(u, "vertical", r({}, d, {
            get: function() {
                return _
            },
            set: function(A) {
                const k = n(A);
                if (k === !1)
                    throw new SyntaxError("An invalid or illegal string was specified.");
                _ = k,
                this.hasBeenReset = !0
            }
        })),
        Object.defineProperty(u, "snapToLines", r({}, d, {
            get: function() {
                return y
            },
            set: function(A) {
                y = !!A,
                this.hasBeenReset = !0
            }
        })),
        Object.defineProperty(u, "line", r({}, d, {
            get: function() {
                return b
            },
            set: function(A) {
                if (typeof A != "number" && A !== "auto")
                    throw new SyntaxError("An invalid number or illegal string was specified.");
                b = A,
                this.hasBeenReset = !0
            }
        })),
        Object.defineProperty(u, "lineAlign", r({}, d, {
            get: function() {
                return S
            },
            set: function(A) {
                const k = s(A);
                if (!k)
                    throw new SyntaxError("An invalid or illegal string was specified.");
                S = k,
                this.hasBeenReset = !0
            }
        })),
        Object.defineProperty(u, "position", r({}, d, {
            get: function() {
                return C
            },
            set: function(A) {
                if (A < 0 || A > 100)
                    throw new Error("Position must be between 0 and 100.");
                C = A,
                this.hasBeenReset = !0
            }
        })),
        Object.defineProperty(u, "positionAlign", r({}, d, {
            get: function() {
                return M
            },
            set: function(A) {
                const k = s(A);
                if (!k)
                    throw new SyntaxError("An invalid or illegal string was specified.");
                M = k,
                this.hasBeenReset = !0
            }
        })),
        Object.defineProperty(u, "size", r({}, d, {
            get: function() {
                return L
            },
            set: function(A) {
                if (A < 0 || A > 100)
                    throw new Error("Size must be between 0 and 100.");
                L = A,
                this.hasBeenReset = !0
            }
        })),
        Object.defineProperty(u, "align", r({}, d, {
            get: function() {
                return T
            },
            set: function(A) {
                const k = s(A);
                if (!k)
                    throw new SyntaxError("An invalid or illegal string was specified.");
                T = k,
                this.hasBeenReset = !0
            }
        })),
        u.displayState = void 0
    }
    return o.prototype.getCueAsHTML = function() {
        return self.WebVTT.convertCueToDOMTree(self, this.text)
    }
    ,
    o
}();
class AG {
    decode(e, t) {
        if (!e)
            return "";
        if (typeof e != "string")
            throw new Error("Error - expected string data.");
        return decodeURIComponent(encodeURIComponent(e))
    }
}
function MM(i) {
    function e(n, s, r, o) {
        return (n | 0) * 3600 + (s | 0) * 60 + (r | 0) + parseFloat(o || 0)
    }
    const t = i.match(/^(?:(\d+):)?(\d{2}):(\d{2})(\.\d+)?/);
    return t ? parseFloat(t[2]) > 59 ? e(t[2], t[3], 0, t[4]) : e(t[1], t[2], t[3], t[4]) : null
}
class CG {
    constructor() {
        this.values = Object.create(null)
    }
    set(e, t) {
        !this.get(e) && t !== "" && (this.values[e] = t)
    }
    get(e, t, n) {
        return n ? this.has(e) ? this.values[e] : t[n] : this.has(e) ? this.values[e] : t
    }
    has(e) {
        return e in this.values
    }
    alt(e, t, n) {
        for (let s = 0; s < n.length; ++s)
            if (t === n[s]) {
                this.set(e, t);
                break
            }
    }
    integer(e, t) {
        /^-?\d+$/.test(t) && this.set(e, parseInt(t, 10))
    }
    percent(e, t) {
        if (/^([\d]{1,3})(\.[\d]*)?%$/.test(t)) {
            const n = parseFloat(t);
            if (n >= 0 && n <= 100)
                return this.set(e, n),
                !0
        }
        return !1
    }
}
function RM(i, e, t, n) {
    const s = n ? i.split(n) : [i];
    for (const r in s) {
        if (typeof s[r] != "string")
            continue;
        const o = s[r].split(t);
        if (o.length !== 2)
            continue;
        const a = o[0]
          , l = o[1];
        e(a, l)
    }
}
const j1 = new dx(0,0,"")
  , Vf = j1.align === "middle" ? "middle" : "center";
function MG(i, e, t) {
    const n = i;
    function s() {
        const a = MM(i);
        if (a === null)
            throw new Error("Malformed timestamp: " + n);
        return i = i.replace(/^[^\sa-zA-Z-]+/, ""),
        a
    }
    function r(a, l) {
        const c = new CG;
        RM(a, function(f, h) {
            let p;
            switch (f) {
            case "region":
                for (let g = t.length - 1; g >= 0; g--)
                    if (t[g].id === h) {
                        c.set(f, t[g].region);
                        break
                    }
                break;
            case "vertical":
                c.alt(f, h, ["rl", "lr"]);
                break;
            case "line":
                p = h.split(","),
                c.integer(f, p[0]),
                c.percent(f, p[0]) && c.set("snapToLines", !1),
                c.alt(f, p[0], ["auto"]),
                p.length === 2 && c.alt("lineAlign", p[1], ["start", Vf, "end"]);
                break;
            case "position":
                p = h.split(","),
                c.percent(f, p[0]),
                p.length === 2 && c.alt("positionAlign", p[1], ["start", Vf, "end", "line-left", "line-right", "auto"]);
                break;
            case "size":
                c.percent(f, h);
                break;
            case "align":
                c.alt(f, h, ["start", Vf, "end", "left", "right"]);
                break
            }
        }, /:/, /\s/),
        l.region = c.get("region", null),
        l.vertical = c.get("vertical", "");
        let u = c.get("line", "auto");
        u === "auto" && j1.line === -1 && (u = -1),
        l.line = u,
        l.lineAlign = c.get("lineAlign", "start"),
        l.snapToLines = c.get("snapToLines", !0),
        l.size = c.get("size", 100),
        l.align = c.get("align", Vf);
        let d = c.get("position", "auto");
        d === "auto" && j1.position === 50 && (d = l.align === "start" || l.align === "left" ? 0 : l.align === "end" || l.align === "right" ? 100 : 50),
        l.position = d
    }
    function o() {
        i = i.replace(/^\s+/, "")
    }
    if (o(),
    e.startTime = s(),
    o(),
    i.slice(0, 3) !== "-->")
        throw new Error("Malformed time stamp (time stamps must be separated by '-->'): " + n);
    i = i.slice(3),
    o(),
    e.endTime = s(),
    o(),
    r(i, e)
}
function LM(i) {
    return i.replace(/<br(?: \/)?>/gi, `
`)
}
class RG {
    constructor() {
        this.state = "INITIAL",
        this.buffer = "",
        this.decoder = new AG,
        this.regionList = [],
        this.cue = null,
        this.oncue = void 0,
        this.onparsingerror = void 0,
        this.onflush = void 0
    }
    parse(e) {
        const t = this;
        e && (t.buffer += t.decoder.decode(e, {
            stream: !0
        }));
        function n() {
            let r = t.buffer
              , o = 0;
            for (r = LM(r); o < r.length && r[o] !== "\r" && r[o] !== `
`; )
                ++o;
            const a = r.slice(0, o);
            return r[o] === "\r" && ++o,
            r[o] === `
` && ++o,
            t.buffer = r.slice(o),
            a
        }
        function s(r) {
            RM(r, function(o, a) {}, /:/)
        }
        try {
            let r = "";
            if (t.state === "INITIAL") {
                if (!/\r\n|\n/.test(t.buffer))
                    return this;
                r = n();
                const a = r.match(/^()?WEBVTT([ \t].*)?$/);
                if (!(a != null && a[0]))
                    throw new Error("Malformed WebVTT signature.");
                t.state = "HEADER"
            }
            let o = !1;
            for (; t.buffer; ) {
                if (!/\r\n|\n/.test(t.buffer))
                    return this;
                switch (o ? o = !1 : r = n(),
                t.state) {
                case "HEADER":
                    /:/.test(r) ? s(r) : r || (t.state = "ID");
                    continue;
                case "NOTE":
                    r || (t.state = "ID");
                    continue;
                case "ID":
                    if (/^NOTE($|[ \t])/.test(r)) {
                        t.state = "NOTE";
                        break
                    }
                    if (!r)
                        continue;
                    if (t.cue = new dx(0,0,""),
                    t.state = "CUE",
                    r.indexOf("-->") === -1) {
                        t.cue.id = r;
                        continue
                    }
                case "CUE":
                    if (!t.cue) {
                        t.state = "BADCUE";
                        continue
                    }
                    try {
                        MG(r, t.cue, t.regionList)
                    } catch {
                        t.cue = null,
                        t.state = "BADCUE";
                        continue
                    }
                    t.state = "CUETEXT";
                    continue;
                case "CUETEXT":
                    {
                        const a = r.indexOf("-->") !== -1;
                        if (!r || a && (o = !0)) {
                            t.oncue && t.cue && t.oncue(t.cue),
                            t.cue = null,
                            t.state = "ID";
                            continue
                        }
                        if (t.cue === null)
                            continue;
                        t.cue.text && (t.cue.text += `
`),
                        t.cue.text += r
                    }
                    continue;
                case "BADCUE":
                    r || (t.state = "ID")
                }
            }
        } catch {
            t.state === "CUETEXT" && t.cue && t.oncue && t.oncue(t.cue),
            t.cue = null,
            t.state = t.state === "INITIAL" ? "BADWEBVTT" : "BADCUE"
        }
        return this
    }
    flush() {
        const e = this;
        try {
            if ((e.cue || e.state === "HEADER") && (e.buffer += `

`,
            e.parse()),
            e.state === "INITIAL" || e.state === "BADWEBVTT")
                throw new Error("Malformed WebVTT signature.")
        } catch (t) {
            e.onparsingerror && e.onparsingerror(t)
        }
        return e.onflush && e.onflush(),
        this
    }
}
const LG = /\r\n|\n\r|\n|\r/g
  , D0 = function(e, t, n=0) {
    return e.slice(n, n + t.length) === t
}
  , IG = function(e) {
    let t = parseInt(e.slice(-3));
    const n = parseInt(e.slice(-6, -4))
      , s = parseInt(e.slice(-9, -7))
      , r = e.length > 9 ? parseInt(e.substring(0, e.indexOf(":"))) : 0;
    if (!pt(t) || !pt(n) || !pt(s) || !pt(r))
        throw Error(`Malformed X-TIMESTAMP-MAP: Local:${e}`);
    return t += 1e3 * n,
    t += 60 * 1e3 * s,
    t += 60 * 60 * 1e3 * r,
    t
}
  , F0 = function(e) {
    let t = 5381
      , n = e.length;
    for (; n; )
        t = t * 33 ^ e.charCodeAt(--n);
    return (t >>> 0).toString()
};
function fx(i, e, t) {
    return F0(i.toString()) + F0(e.toString()) + F0(t)
}
const kG = function(e, t, n) {
    let s = e[t]
      , r = e[s.prevCC];
    if (!r || !r.new && s.new) {
        e.ccOffset = e.presentationOffset = s.start,
        s.new = !1;
        return
    }
    for (; (o = r) != null && o.new; ) {
        var o;
        e.ccOffset += s.start - r.start,
        s.new = !1,
        s = r,
        r = e[s.prevCC]
    }
    e.presentationOffset = n
};
function PG(i, e, t, n, s, r, o) {
    const a = new RG
      , l = Hr(new Uint8Array(i)).trim().replace(LG, `
`).split(`
`)
      , c = []
      , u = e ? Yz(e.baseTime, e.timescale) : 0;
    let d = "00:00.000", f = 0, h = 0, p, g = !0;
    a.oncue = function(m) {
        const v = t[n];
        let _ = t.ccOffset;
        const y = (f - u) / 9e4;
        if (v != null && v.new && (h !== void 0 ? _ = t.ccOffset = v.start : kG(t, n, y)),
        y) {
            if (!e) {
                p = new Error("Missing initPTS for VTT MPEGTS");
                return
            }
            _ = y - t.presentationOffset
        }
        const b = m.endTime - m.startTime
          , S = Fs((m.startTime + _ - h) * 9e4, s * 9e4) / 9e4;
        m.startTime = Math.max(S, 0),
        m.endTime = Math.max(S + b, 0);
        const C = m.text.trim();
        m.text = decodeURIComponent(encodeURIComponent(C)),
        m.id || (m.id = fx(m.startTime, m.endTime, C)),
        m.endTime > 0 && c.push(m)
    }
    ,
    a.onparsingerror = function(m) {
        p = m
    }
    ,
    a.onflush = function() {
        if (p) {
            o(p);
            return
        }
        r(c)
    }
    ,
    l.forEach(m => {
        if (g)
            if (D0(m, "X-TIMESTAMP-MAP=")) {
                g = !1,
                m.slice(16).split(",").forEach(v => {
                    D0(v, "LOCAL:") ? d = v.slice(6) : D0(v, "MPEGTS:") && (f = parseInt(v.slice(7)))
                }
                );
                try {
                    h = IG(d) / 1e3
                } catch (v) {
                    p = v
                }
                return
            } else
                m === "" && (g = !1);
        a.parse(m + `
`)
    }
    ),
    a.flush()
}
const O0 = "stpp.ttml.im1t"
  , IM = /^(\d{2,}):(\d{2}):(\d{2}):(\d{2})\.?(\d+)?$/
  , kM = /^(\d*(?:\.\d*)?)(h|m|s|ms|f|t)$/
  , DG = {
    left: "start",
    center: "center",
    right: "end",
    start: "start",
    end: "end"
};
function wS(i, e, t, n) {
    const s = $t(new Uint8Array(i), ["mdat"]);
    if (s.length === 0) {
        n(new Error("Could not parse IMSC1 mdat"));
        return
    }
    const r = s.map(a => Hr(a))
      , o = Xz(e.baseTime, 1, e.timescale);
    try {
        r.forEach(a => t(FG(a, o)))
    } catch (a) {
        n(a)
    }
}
function FG(i, e) {
    const s = new DOMParser().parseFromString(i, "text/xml").getElementsByTagName("tt")[0];
    if (!s)
        throw new Error("Invalid ttml");
    const r = {
        frameRate: 30,
        subFrameRate: 1,
        frameRateMultiplier: 0,
        tickRate: 0
    }
      , o = Object.keys(r).reduce( (d, f) => (d[f] = s.getAttribute(`ttp:${f}`) || r[f],
    d), {})
      , a = s.getAttribute("xml:space") !== "preserve"
      , l = TS(U0(s, "styling", "style"))
      , c = TS(U0(s, "layout", "region"))
      , u = U0(s, "body", "[begin]");
    return [].map.call(u, d => {
        const f = PM(d, a);
        if (!f || !d.hasAttribute("begin"))
            return null;
        const h = B0(d.getAttribute("begin"), o)
          , p = B0(d.getAttribute("dur"), o);
        let g = B0(d.getAttribute("end"), o);
        if (h === null)
            throw AS(d);
        if (g === null) {
            if (p === null)
                throw AS(d);
            g = h + p
        }
        const m = new dx(h - e,g - e,f);
        m.id = fx(m.startTime, m.endTime, m.text);
        const v = c[d.getAttribute("region")]
          , _ = l[d.getAttribute("style")]
          , y = OG(v, _, l)
          , {textAlign: b} = y;
        if (b) {
            const S = DG[b];
            S && (m.lineAlign = S),
            m.align = b
        }
        return Qn(m, y),
        m
    }
    ).filter(d => d !== null)
}
function U0(i, e, t) {
    const n = i.getElementsByTagName(e)[0];
    return n ? [].slice.call(n.querySelectorAll(t)) : []
}
function TS(i) {
    return i.reduce( (e, t) => {
        const n = t.getAttribute("xml:id");
        return n && (e[n] = t),
        e
    }
    , {})
}
function PM(i, e) {
    return [].slice.call(i.childNodes).reduce( (t, n, s) => {
        var r;
        return n.nodeName === "br" && s ? t + `
` : (r = n.childNodes) != null && r.length ? PM(n, e) : e ? t + n.textContent.trim().replace(/\s+/g, " ") : t + n.textContent
    }
    , "")
}
function OG(i, e, t) {
    const n = "http://www.w3.org/ns/ttml#styling";
    let s = null;
    const r = ["displayAlign", "textAlign", "color", "backgroundColor", "fontSize", "fontFamily"]
      , o = i != null && i.hasAttribute("style") ? i.getAttribute("style") : null;
    return o && t.hasOwnProperty(o) && (s = t[o]),
    r.reduce( (a, l) => {
        const c = N0(e, n, l) || N0(i, n, l) || N0(s, n, l);
        return c && (a[l] = c),
        a
    }
    , {})
}
function N0(i, e, t) {
    return i && i.hasAttributeNS(e, t) ? i.getAttributeNS(e, t) : null
}
function AS(i) {
    return new Error(`Could not parse ttml timestamp ${i}`)
}
function B0(i, e) {
    if (!i)
        return null;
    let t = MM(i);
    return t === null && (IM.test(i) ? t = UG(i, e) : kM.test(i) && (t = NG(i, e))),
    t
}
function UG(i, e) {
    const t = IM.exec(i)
      , n = (t[4] | 0) + (t[5] | 0) / e.subFrameRate;
    return (t[1] | 0) * 3600 + (t[2] | 0) * 60 + (t[3] | 0) + n / e.frameRate
}
function NG(i, e) {
    const t = kM.exec(i)
      , n = Number(t[1]);
    switch (t[2]) {
    case "h":
        return n * 3600;
    case "m":
        return n * 60;
    case "ms":
        return n * 1e3;
    case "f":
        return n / e.frameRate;
    case "t":
        return n / e.tickRate
    }
    return n
}
class BG {
    constructor(e) {
        this.hls = void 0,
        this.media = null,
        this.config = void 0,
        this.enabled = !0,
        this.Cues = void 0,
        this.textTracks = [],
        this.tracks = [],
        this.initPTS = [],
        this.unparsedVttFrags = [],
        this.captionsTracks = {},
        this.nonNativeCaptionsTracks = {},
        this.cea608Parser1 = void 0,
        this.cea608Parser2 = void 0,
        this.lastCc = -1,
        this.lastSn = -1,
        this.lastPartIndex = -1,
        this.prevCC = -1,
        this.vttCCs = MS(),
        this.captionsProperties = void 0,
        this.hls = e,
        this.config = e.config,
        this.Cues = e.config.cueHandler,
        this.captionsProperties = {
            textTrack1: {
                label: this.config.captionsTextTrack1Label,
                languageCode: this.config.captionsTextTrack1LanguageCode
            },
            textTrack2: {
                label: this.config.captionsTextTrack2Label,
                languageCode: this.config.captionsTextTrack2LanguageCode
            },
            textTrack3: {
                label: this.config.captionsTextTrack3Label,
                languageCode: this.config.captionsTextTrack3LanguageCode
            },
            textTrack4: {
                label: this.config.captionsTextTrack4Label,
                languageCode: this.config.captionsTextTrack4LanguageCode
            }
        },
        e.on(P.MEDIA_ATTACHING, this.onMediaAttaching, this),
        e.on(P.MEDIA_DETACHING, this.onMediaDetaching, this),
        e.on(P.MANIFEST_LOADING, this.onManifestLoading, this),
        e.on(P.MANIFEST_LOADED, this.onManifestLoaded, this),
        e.on(P.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this),
        e.on(P.FRAG_LOADING, this.onFragLoading, this),
        e.on(P.FRAG_LOADED, this.onFragLoaded, this),
        e.on(P.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this),
        e.on(P.FRAG_DECRYPTED, this.onFragDecrypted, this),
        e.on(P.INIT_PTS_FOUND, this.onInitPtsFound, this),
        e.on(P.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this),
        e.on(P.BUFFER_FLUSHING, this.onBufferFlushing, this)
    }
    destroy() {
        const {hls: e} = this;
        e.off(P.MEDIA_ATTACHING, this.onMediaAttaching, this),
        e.off(P.MEDIA_DETACHING, this.onMediaDetaching, this),
        e.off(P.MANIFEST_LOADING, this.onManifestLoading, this),
        e.off(P.MANIFEST_LOADED, this.onManifestLoaded, this),
        e.off(P.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this),
        e.off(P.FRAG_LOADING, this.onFragLoading, this),
        e.off(P.FRAG_LOADED, this.onFragLoaded, this),
        e.off(P.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this),
        e.off(P.FRAG_DECRYPTED, this.onFragDecrypted, this),
        e.off(P.INIT_PTS_FOUND, this.onInitPtsFound, this),
        e.off(P.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this),
        e.off(P.BUFFER_FLUSHING, this.onBufferFlushing, this),
        this.hls = this.config = null,
        this.cea608Parser1 = this.cea608Parser2 = void 0
    }
    initCea608Parsers() {
        if (this.config.enableCEA708Captions && (!this.cea608Parser1 || !this.cea608Parser2)) {
            const e = new Bf(this,"textTrack1")
              , t = new Bf(this,"textTrack2")
              , n = new Bf(this,"textTrack3")
              , s = new Bf(this,"textTrack4");
            this.cea608Parser1 = new ES(1,e,t),
            this.cea608Parser2 = new ES(3,n,s)
        }
    }
    addCues(e, t, n, s, r) {
        let o = !1;
        for (let a = r.length; a--; ) {
            const l = r[a]
              , c = VG(l[0], l[1], t, n);
            if (c >= 0 && (l[0] = Math.min(l[0], t),
            l[1] = Math.max(l[1], n),
            o = !0,
            c / (n - t) > .5))
                return
        }
        if (o || r.push([t, n]),
        this.config.renderTextTracksNatively) {
            const a = this.captionsTracks[e];
            this.Cues.newCue(a, t, n, s)
        } else {
            const a = this.Cues.newCue(null, t, n, s);
            this.hls.trigger(P.CUES_PARSED, {
                type: "captions",
                cues: a,
                track: e
            })
        }
    }
    onInitPtsFound(e, {frag: t, id: n, initPTS: s, timescale: r}) {
        const {unparsedVttFrags: o} = this;
        n === "main" && (this.initPTS[t.cc] = {
            baseTime: s,
            timescale: r
        }),
        o.length && (this.unparsedVttFrags = [],
        o.forEach(a => {
            this.onFragLoaded(P.FRAG_LOADED, a)
        }
        ))
    }
    getExistingTrack(e, t) {
        const {media: n} = this;
        if (n)
            for (let s = 0; s < n.textTracks.length; s++) {
                const r = n.textTracks[s];
                if (CS(r, {
                    name: e,
                    lang: t,
                    attrs: {}
                }))
                    return r
            }
        return null
    }
    createCaptionsTrack(e) {
        this.config.renderTextTracksNatively ? this.createNativeTrack(e) : this.createNonNativeTrack(e)
    }
    createNativeTrack(e) {
        if (this.captionsTracks[e])
            return;
        const {captionsProperties: t, captionsTracks: n, media: s} = this
          , {label: r, languageCode: o} = t[e]
          , a = this.getExistingTrack(r, o);
        if (a)
            n[e] = a,
            Ac(n[e]),
            QC(n[e], s);
        else {
            const l = this.createTextTrack("captions", r, o);
            l && (l[e] = !0,
            n[e] = l)
        }
    }
    createNonNativeTrack(e) {
        if (this.nonNativeCaptionsTracks[e])
            return;
        const t = this.captionsProperties[e];
        if (!t)
            return;
        const n = t.label
          , s = {
            _id: e,
            label: n,
            kind: "captions",
            default: t.media ? !!t.media.default : !1,
            closedCaptions: t.media
        };
        this.nonNativeCaptionsTracks[e] = s,
        this.hls.trigger(P.NON_NATIVE_TEXT_TRACKS_FOUND, {
            tracks: [s]
        })
    }
    createTextTrack(e, t, n) {
        const s = this.media;
        if (!!s)
            return s.addTextTrack(e, t, n)
    }
    onMediaAttaching(e, t) {
        this.media = t.media,
        this._cleanTracks()
    }
    onMediaDetaching() {
        const {captionsTracks: e} = this;
        Object.keys(e).forEach(t => {
            Ac(e[t]),
            delete e[t]
        }
        ),
        this.nonNativeCaptionsTracks = {}
    }
    onManifestLoading() {
        this.lastCc = -1,
        this.lastSn = -1,
        this.lastPartIndex = -1,
        this.prevCC = -1,
        this.vttCCs = MS(),
        this._cleanTracks(),
        this.tracks = [],
        this.captionsTracks = {},
        this.nonNativeCaptionsTracks = {},
        this.textTracks = [],
        this.unparsedVttFrags = [],
        this.initPTS = [],
        this.cea608Parser1 && this.cea608Parser2 && (this.cea608Parser1.reset(),
        this.cea608Parser2.reset())
    }
    _cleanTracks() {
        const {media: e} = this;
        if (!e)
            return;
        const t = e.textTracks;
        if (t)
            for (let n = 0; n < t.length; n++)
                Ac(t[n])
    }
    onSubtitleTracksUpdated(e, t) {
        const n = t.subtitleTracks || []
          , s = n.some(r => r.textCodec === O0);
        if (this.config.enableWebVTT || s && this.config.enableIMSC1) {
            if (TM(this.tracks, n)) {
                this.tracks = n;
                return
            }
            if (this.textTracks = [],
            this.tracks = n,
            this.config.renderTextTracksNatively) {
                const o = this.media
                  , a = o ? Ch(o.textTracks) : null;
                if (this.tracks.forEach( (l, c) => {
                    let u;
                    if (a) {
                        let d = null;
                        for (let f = 0; f < a.length; f++)
                            if (a[f] && CS(a[f], l)) {
                                d = a[f],
                                a[f] = null;
                                break
                            }
                        d && (u = d)
                    }
                    if (u)
                        Ac(u);
                    else {
                        const d = DM(l);
                        u = this.createTextTrack(d, l.name, l.lang),
                        u && (u.mode = "disabled")
                    }
                    u && this.textTracks.push(u)
                }
                ),
                a != null && a.length) {
                    const l = a.filter(c => c !== null).map(c => c.label);
                    l.length && de.warn(`Media element contains unused subtitle tracks: ${l.join(", ")}. Replace media element for each source to clear TextTracks and captions menu.`)
                }
            } else if (this.tracks.length) {
                const o = this.tracks.map(a => ({
                    label: a.name,
                    kind: a.type.toLowerCase(),
                    default: a.default,
                    subtitleTrack: a
                }));
                this.hls.trigger(P.NON_NATIVE_TEXT_TRACKS_FOUND, {
                    tracks: o
                })
            }
        }
    }
    onManifestLoaded(e, t) {
        this.config.enableCEA708Captions && t.captions && t.captions.forEach(n => {
            const s = /(?:CC|SERVICE)([1-4])/.exec(n.instreamId);
            if (!s)
                return;
            const r = `textTrack${s[1]}`
              , o = this.captionsProperties[r];
            !o || (o.label = n.name,
            n.lang && (o.languageCode = n.lang),
            o.media = n)
        }
        )
    }
    closedCaptionsForLevel(e) {
        const t = this.hls.levels[e.level];
        return t == null ? void 0 : t.attrs["CLOSED-CAPTIONS"]
    }
    onFragLoading(e, t) {
        if (this.enabled && t.frag.type === Ct.MAIN) {
            var n, s;
            const {cea608Parser1: r, cea608Parser2: o, lastSn: a} = this
              , {cc: l, sn: c} = t.frag
              , u = (n = (s = t.part) == null ? void 0 : s.index) != null ? n : -1;
            r && o && (c !== a + 1 || c === a && u !== this.lastPartIndex + 1 || l !== this.lastCc) && (r.reset(),
            o.reset()),
            this.lastCc = l,
            this.lastSn = c,
            this.lastPartIndex = u
        }
    }
    onFragLoaded(e, t) {
        const {frag: n, payload: s} = t;
        if (n.type === Ct.SUBTITLE)
            if (s.byteLength) {
                const r = n.decryptdata
                  , o = "stats"in t;
                if (r == null || !r.encrypted || o) {
                    const a = this.tracks[n.level]
                      , l = this.vttCCs;
                    l[n.cc] || (l[n.cc] = {
                        start: n.start,
                        prevCC: this.prevCC,
                        new: !0
                    },
                    this.prevCC = n.cc),
                    a && a.textCodec === O0 ? this._parseIMSC1(n, s) : this._parseVTTs(t)
                }
            } else
                this.hls.trigger(P.SUBTITLE_FRAG_PROCESSED, {
                    success: !1,
                    frag: n,
                    error: new Error("Empty subtitle payload")
                })
    }
    _parseIMSC1(e, t) {
        const n = this.hls;
        wS(t, this.initPTS[e.cc], s => {
            this._appendCues(s, e.level),
            n.trigger(P.SUBTITLE_FRAG_PROCESSED, {
                success: !0,
                frag: e
            })
        }
        , s => {
            de.log(`Failed to parse IMSC1: ${s}`),
            n.trigger(P.SUBTITLE_FRAG_PROCESSED, {
                success: !1,
                frag: e,
                error: s
            })
        }
        )
    }
    _parseVTTs(e) {
        var t;
        const {frag: n, payload: s} = e
          , {initPTS: r, unparsedVttFrags: o} = this
          , a = r.length - 1;
        if (!r[n.cc] && a === -1) {
            o.push(e);
            return
        }
        const l = this.hls
          , c = (t = n.initSegment) != null && t.data ? qs(n.initSegment.data, new Uint8Array(s)) : s;
        PG(c, this.initPTS[n.cc], this.vttCCs, n.cc, n.start, u => {
            this._appendCues(u, n.level),
            l.trigger(P.SUBTITLE_FRAG_PROCESSED, {
                success: !0,
                frag: n
            })
        }
        , u => {
            const d = u.message === "Missing initPTS for VTT MPEGTS";
            d ? o.push(e) : this._fallbackToIMSC1(n, s),
            de.log(`Failed to parse VTT cue: ${u}`),
            !(d && a > n.cc) && l.trigger(P.SUBTITLE_FRAG_PROCESSED, {
                success: !1,
                frag: n,
                error: u
            })
        }
        )
    }
    _fallbackToIMSC1(e, t) {
        const n = this.tracks[e.level];
        n.textCodec || wS(t, this.initPTS[e.cc], () => {
            n.textCodec = O0,
            this._parseIMSC1(e, t)
        }
        , () => {
            n.textCodec = "wvtt"
        }
        )
    }
    _appendCues(e, t) {
        const n = this.hls;
        if (this.config.renderTextTracksNatively) {
            const s = this.textTracks[t];
            if (!s || s.mode === "disabled")
                return;
            e.forEach(r => eM(s, r))
        } else {
            const s = this.tracks[t];
            if (!s)
                return;
            const r = s.default ? "default" : "subtitles" + t;
            n.trigger(P.CUES_PARSED, {
                type: "subtitles",
                cues: e,
                track: r
            })
        }
    }
    onFragDecrypted(e, t) {
        const {frag: n} = t;
        n.type === Ct.SUBTITLE && this.onFragLoaded(P.FRAG_LOADED, t)
    }
    onSubtitleTracksCleared() {
        this.tracks = [],
        this.captionsTracks = {}
    }
    onFragParsingUserdata(e, t) {
        this.initCea608Parsers();
        const {cea608Parser1: n, cea608Parser2: s} = this;
        if (!this.enabled || !n || !s)
            return;
        const {frag: r, samples: o} = t;
        if (!(r.type === Ct.MAIN && this.closedCaptionsForLevel(r) === "NONE"))
            for (let a = 0; a < o.length; a++) {
                const l = o[a].bytes;
                if (l) {
                    const c = this.extractCea608Data(l);
                    n.addData(o[a].pts, c[0]),
                    s.addData(o[a].pts, c[1])
                }
            }
    }
    onBufferFlushing(e, {startOffset: t, endOffset: n, endOffsetSubtitles: s, type: r}) {
        const {media: o} = this;
        if (!(!o || o.currentTime < n)) {
            if (!r || r === "video") {
                const {captionsTracks: a} = this;
                Object.keys(a).forEach(l => V1(a[l], t, n))
            }
            if (this.config.renderTextTracksNatively && t === 0 && s !== void 0) {
                const {textTracks: a} = this;
                Object.keys(a).forEach(l => V1(a[l], t, s))
            }
        }
    }
    extractCea608Data(e) {
        const t = [[], []]
          , n = e[0] & 31;
        let s = 2;
        for (let r = 0; r < n; r++) {
            const o = e[s++]
              , a = 127 & e[s++]
              , l = 127 & e[s++];
            if (a === 0 && l === 0)
                continue;
            if ((4 & o) !== 0) {
                const u = 3 & o;
                (u === 0 || u === 1) && (t[u].push(a),
                t[u].push(l))
            }
        }
        return t
    }
}
function DM(i) {
    return i.characteristics && /transcribes-spoken-dialog/gi.test(i.characteristics) && /describes-music-and-sound/gi.test(i.characteristics) ? "captions" : "subtitles"
}
function CS(i, e) {
    return !!i && i.kind === DM(e) && q1(e, i)
}
function VG(i, e, t, n) {
    return Math.min(e, n) - Math.max(i, t)
}
function MS() {
    return {
        ccOffset: 0,
        presentationOffset: 0,
        0: {
            start: 0,
            prevCC: -1,
            new: !0
        }
    }
}
class hx {
    constructor(e) {
        this.hls = void 0,
        this.autoLevelCapping = void 0,
        this.firstLevel = void 0,
        this.media = void 0,
        this.restrictedLevels = void 0,
        this.timer = void 0,
        this.clientRect = void 0,
        this.streamController = void 0,
        this.hls = e,
        this.autoLevelCapping = Number.POSITIVE_INFINITY,
        this.firstLevel = -1,
        this.media = null,
        this.restrictedLevels = [],
        this.timer = void 0,
        this.clientRect = null,
        this.registerListeners()
    }
    setStreamController(e) {
        this.streamController = e
    }
    destroy() {
        this.hls && this.unregisterListener(),
        this.timer && this.stopCapping(),
        this.media = null,
        this.clientRect = null,
        this.hls = this.streamController = null
    }
    registerListeners() {
        const {hls: e} = this;
        e.on(P.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this),
        e.on(P.MEDIA_ATTACHING, this.onMediaAttaching, this),
        e.on(P.MANIFEST_PARSED, this.onManifestParsed, this),
        e.on(P.LEVELS_UPDATED, this.onLevelsUpdated, this),
        e.on(P.BUFFER_CODECS, this.onBufferCodecs, this),
        e.on(P.MEDIA_DETACHING, this.onMediaDetaching, this)
    }
    unregisterListener() {
        const {hls: e} = this;
        e.off(P.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this),
        e.off(P.MEDIA_ATTACHING, this.onMediaAttaching, this),
        e.off(P.MANIFEST_PARSED, this.onManifestParsed, this),
        e.off(P.LEVELS_UPDATED, this.onLevelsUpdated, this),
        e.off(P.BUFFER_CODECS, this.onBufferCodecs, this),
        e.off(P.MEDIA_DETACHING, this.onMediaDetaching, this)
    }
    onFpsDropLevelCapping(e, t) {
        const n = this.hls.levels[t.droppedLevel];
        this.isLevelAllowed(n) && this.restrictedLevels.push({
            bitrate: n.bitrate,
            height: n.height,
            width: n.width
        })
    }
    onMediaAttaching(e, t) {
        this.media = t.media instanceof HTMLVideoElement ? t.media : null,
        this.clientRect = null,
        this.timer && this.hls.levels.length && this.detectPlayerSize()
    }
    onManifestParsed(e, t) {
        const n = this.hls;
        this.restrictedLevels = [],
        this.firstLevel = t.firstLevel,
        n.config.capLevelToPlayerSize && t.video && this.startCapping()
    }
    onLevelsUpdated(e, t) {
        this.timer && pt(this.autoLevelCapping) && this.detectPlayerSize()
    }
    onBufferCodecs(e, t) {
        this.hls.config.capLevelToPlayerSize && t.video && this.startCapping()
    }
    onMediaDetaching() {
        this.stopCapping()
    }
    detectPlayerSize() {
        if (this.media) {
            if (this.mediaHeight <= 0 || this.mediaWidth <= 0) {
                this.clientRect = null;
                return
            }
            const e = this.hls.levels;
            if (e.length) {
                const t = this.hls
                  , n = this.getMaxLevel(e.length - 1);
                n !== this.autoLevelCapping && de.log(`Setting autoLevelCapping to ${n}: ${e[n].height}p@${e[n].bitrate} for media ${this.mediaWidth}x${this.mediaHeight}`),
                t.autoLevelCapping = n,
                t.autoLevelCapping > this.autoLevelCapping && this.streamController && this.streamController.nextLevelSwitch(),
                this.autoLevelCapping = t.autoLevelCapping
            }
        }
    }
    getMaxLevel(e) {
        const t = this.hls.levels;
        if (!t.length)
            return -1;
        const n = t.filter( (s, r) => this.isLevelAllowed(s) && r <= e);
        return this.clientRect = null,
        hx.getMaxLevelByMediaSize(n, this.mediaWidth, this.mediaHeight)
    }
    startCapping() {
        this.timer || (this.autoLevelCapping = Number.POSITIVE_INFINITY,
        self.clearInterval(this.timer),
        this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1e3),
        this.detectPlayerSize())
    }
    stopCapping() {
        this.restrictedLevels = [],
        this.firstLevel = -1,
        this.autoLevelCapping = Number.POSITIVE_INFINITY,
        this.timer && (self.clearInterval(this.timer),
        this.timer = void 0)
    }
    getDimensions() {
        if (this.clientRect)
            return this.clientRect;
        const e = this.media
          , t = {
            width: 0,
            height: 0
        };
        if (e) {
            const n = e.getBoundingClientRect();
            t.width = n.width,
            t.height = n.height,
            !t.width && !t.height && (t.width = n.right - n.left || e.width || 0,
            t.height = n.bottom - n.top || e.height || 0)
        }
        return this.clientRect = t,
        t
    }
    get mediaWidth() {
        return this.getDimensions().width * this.contentScaleFactor
    }
    get mediaHeight() {
        return this.getDimensions().height * this.contentScaleFactor
    }
    get contentScaleFactor() {
        let e = 1;
        if (!this.hls.config.ignoreDevicePixelRatio)
            try {
                e = self.devicePixelRatio
            } catch {}
        return e
    }
    isLevelAllowed(e) {
        return !this.restrictedLevels.some(n => e.bitrate === n.bitrate && e.width === n.width && e.height === n.height)
    }
    static getMaxLevelByMediaSize(e, t, n) {
        if (!(e != null && e.length))
            return -1;
        const s = (a, l) => l ? a.width !== l.width || a.height !== l.height : !0;
        let r = e.length - 1;
        const o = Math.max(t, n);
        for (let a = 0; a < e.length; a += 1) {
            const l = e[a];
            if ((l.width >= o || l.height >= o) && s(l, e[a + 1])) {
                r = a;
                break
            }
        }
        return r
    }
}
class $G {
    constructor(e) {
        this.hls = void 0,
        this.isVideoPlaybackQualityAvailable = !1,
        this.timer = void 0,
        this.media = null,
        this.lastTime = void 0,
        this.lastDroppedFrames = 0,
        this.lastDecodedFrames = 0,
        this.streamController = void 0,
        this.hls = e,
        this.registerListeners()
    }
    setStreamController(e) {
        this.streamController = e
    }
    registerListeners() {
        this.hls.on(P.MEDIA_ATTACHING, this.onMediaAttaching, this)
    }
    unregisterListeners() {
        this.hls.off(P.MEDIA_ATTACHING, this.onMediaAttaching, this)
    }
    destroy() {
        this.timer && clearInterval(this.timer),
        this.unregisterListeners(),
        this.isVideoPlaybackQualityAvailable = !1,
        this.media = null
    }
    onMediaAttaching(e, t) {
        const n = this.hls.config;
        if (n.capLevelOnFPSDrop) {
            const s = t.media instanceof self.HTMLVideoElement ? t.media : null;
            this.media = s,
            s && typeof s.getVideoPlaybackQuality == "function" && (this.isVideoPlaybackQualityAvailable = !0),
            self.clearInterval(this.timer),
            this.timer = self.setInterval(this.checkFPSInterval.bind(this), n.fpsDroppedMonitoringPeriod)
        }
    }
    checkFPS(e, t, n) {
        const s = performance.now();
        if (t) {
            if (this.lastTime) {
                const r = s - this.lastTime
                  , o = n - this.lastDroppedFrames
                  , a = t - this.lastDecodedFrames
                  , l = 1e3 * o / r
                  , c = this.hls;
                if (c.trigger(P.FPS_DROP, {
                    currentDropped: o,
                    currentDecoded: a,
                    totalDroppedFrames: n
                }),
                l > 0 && o > c.config.fpsDroppedMonitoringThreshold * a) {
                    let u = c.currentLevel;
                    de.warn("drop FPS ratio greater than max allowed value for currentLevel: " + u),
                    u > 0 && (c.autoLevelCapping === -1 || c.autoLevelCapping >= u) && (u = u - 1,
                    c.trigger(P.FPS_DROP_LEVEL_CAPPING, {
                        level: u,
                        droppedLevel: c.currentLevel
                    }),
                    c.autoLevelCapping = u,
                    this.streamController.nextLevelSwitch())
                }
            }
            this.lastTime = s,
            this.lastDroppedFrames = n,
            this.lastDecodedFrames = t
        }
    }
    checkFPSInterval() {
        const e = this.media;
        if (e)
            if (this.isVideoPlaybackQualityAvailable) {
                const t = e.getVideoPlaybackQuality();
                this.checkFPS(e, t.totalVideoFrames, t.droppedVideoFrames)
            } else
                this.checkFPS(e, e.webkitDecodedFrameCount, e.webkitDroppedFrameCount)
    }
}
const $f = "[eme]";
class zc {
    constructor(e) {
        this.hls = void 0,
        this.config = void 0,
        this.media = null,
        this.keyFormatPromise = null,
        this.keySystemAccessPromises = {},
        this._requestLicenseFailureCount = 0,
        this.mediaKeySessions = [],
        this.keyIdToKeySessionPromise = {},
        this.setMediaKeysQueue = zc.CDMCleanupPromise ? [zc.CDMCleanupPromise] : [],
        this.onMediaEncrypted = this._onMediaEncrypted.bind(this),
        this.onWaitingForKey = this._onWaitingForKey.bind(this),
        this.debug = de.debug.bind(de, $f),
        this.log = de.log.bind(de, $f),
        this.warn = de.warn.bind(de, $f),
        this.error = de.error.bind(de, $f),
        this.hls = e,
        this.config = e.config,
        this.registerListeners()
    }
    destroy() {
        this.unregisterListeners(),
        this.onMediaDetached();
        const e = this.config;
        e.requestMediaKeySystemAccessFunc = null,
        e.licenseXhrSetup = e.licenseResponseCallback = void 0,
        e.drmSystems = e.drmSystemOptions = {},
        this.hls = this.onMediaEncrypted = this.onWaitingForKey = this.keyIdToKeySessionPromise = null,
        this.config = null
    }
    registerListeners() {
        this.hls.on(P.MEDIA_ATTACHED, this.onMediaAttached, this),
        this.hls.on(P.MEDIA_DETACHED, this.onMediaDetached, this),
        this.hls.on(P.MANIFEST_LOADING, this.onManifestLoading, this),
        this.hls.on(P.MANIFEST_LOADED, this.onManifestLoaded, this)
    }
    unregisterListeners() {
        this.hls.off(P.MEDIA_ATTACHED, this.onMediaAttached, this),
        this.hls.off(P.MEDIA_DETACHED, this.onMediaDetached, this),
        this.hls.off(P.MANIFEST_LOADING, this.onManifestLoading, this),
        this.hls.off(P.MANIFEST_LOADED, this.onManifestLoaded, this)
    }
    getLicenseServerUrl(e) {
        const {drmSystems: t, widevineLicenseUrl: n} = this.config
          , s = t[e];
        if (s)
            return s.licenseUrl;
        if (e === Rn.WIDEVINE && n)
            return n;
        throw new Error(`no license server URL configured for key-system "${e}"`)
    }
    getServerCertificateUrl(e) {
        const {drmSystems: t} = this.config
          , n = t[e];
        if (n)
            return n.serverCertificateUrl;
        this.log(`No Server Certificate in config.drmSystems["${e}"]`)
    }
    attemptKeySystemAccess(e) {
        const t = this.hls.levels
          , n = (o, a, l) => !!o && l.indexOf(o) === a
          , s = t.map(o => o.audioCodec).filter(n)
          , r = t.map(o => o.videoCodec).filter(n);
        return s.length + r.length === 0 && r.push("avc1.42e01e"),
        new Promise( (o, a) => {
            const l = c => {
                const u = c.shift();
                this.getMediaKeysPromise(u, s, r).then(d => o({
                    keySystem: u,
                    mediaKeys: d
                })).catch(d => {
                    c.length ? l(c) : d instanceof Is ? a(d) : a(new Is({
                        type: Ut.KEY_SYSTEM_ERROR,
                        details: Ae.KEY_SYSTEM_NO_ACCESS,
                        error: d,
                        fatal: !0
                    },d.message))
                }
                )
            }
            ;
            l(e)
        }
        )
    }
    requestMediaKeySystemAccess(e, t) {
        const {requestMediaKeySystemAccessFunc: n} = this.config;
        if (typeof n != "function") {
            let s = `Configured requestMediaKeySystemAccess is not a function ${n}`;
            return VC === null && self.location.protocol === "http:" && (s = `navigator.requestMediaKeySystemAccess is not available over insecure protocol ${location.protocol}`),
            Promise.reject(new Error(s))
        }
        return n(e, t)
    }
    getMediaKeysPromise(e, t, n) {
        const s = j$(e, t, n, this.config.drmSystemOptions)
          , r = this.keySystemAccessPromises[e];
        let o = r == null ? void 0 : r.keySystemAccess;
        if (!o) {
            this.log(`Requesting encrypted media "${e}" key-system access with config: ${JSON.stringify(s)}`),
            o = this.requestMediaKeySystemAccess(e, s);
            const a = this.keySystemAccessPromises[e] = {
                keySystemAccess: o
            };
            return o.catch(l => {
                this.log(`Failed to obtain access to key-system "${e}": ${l}`)
            }
            ),
            o.then(l => {
                this.log(`Access for key-system "${l.keySystem}" obtained`);
                const c = this.fetchServerCertificate(e);
                return this.log(`Create media-keys for "${e}"`),
                a.mediaKeys = l.createMediaKeys().then(u => (this.log(`Media-keys created for "${e}"`),
                c.then(d => d ? this.setMediaKeysServerCertificate(u, e, d) : u))),
                a.mediaKeys.catch(u => {
                    this.error(`Failed to create media-keys for "${e}"}: ${u}`)
                }
                ),
                a.mediaKeys
            }
            )
        }
        return o.then( () => r.mediaKeys)
    }
    createMediaKeySessionContext({decryptdata: e, keySystem: t, mediaKeys: n}) {
        this.log(`Creating key-system session "${t}" keyId: ${Rr.hexDump(e.keyId || [])}`);
        const s = n.createSession()
          , r = {
            decryptdata: e,
            keySystem: t,
            mediaKeys: n,
            mediaKeysSession: s,
            keyStatus: "status-pending"
        };
        return this.mediaKeySessions.push(r),
        r
    }
    renewKeySession(e) {
        const t = e.decryptdata;
        if (t.pssh) {
            const n = this.createMediaKeySessionContext(e)
              , s = this.getKeyIdString(t)
              , r = "cenc";
            this.keyIdToKeySessionPromise[s] = this.generateRequestWithPreferredKeySession(n, r, t.pssh, "expired")
        } else
            this.warn("Could not renew expired session. Missing pssh initData.");
        this.removeSession(e)
    }
    getKeyIdString(e) {
        if (!e)
            throw new Error("Could not read keyId of undefined decryptdata");
        if (e.keyId === null)
            throw new Error("keyId is null");
        return Rr.hexDump(e.keyId)
    }
    updateKeySession(e, t) {
        var n;
        const s = e.mediaKeysSession;
        return this.log(`Updating key-session "${s.sessionId}" for keyID ${Rr.hexDump(((n = e.decryptdata) == null ? void 0 : n.keyId) || [])}
      } (data length: ${t && t.byteLength})`),
        s.update(t)
    }
    selectKeySystemFormat(e) {
        const t = Object.keys(e.levelkeys || {});
        return this.keyFormatPromise || (this.log(`Selecting key-system from fragment (sn: ${e.sn} ${e.type}: ${e.level}) key formats ${t.join(", ")}`),
        this.keyFormatPromise = this.getKeyFormatPromise(t)),
        this.keyFormatPromise
    }
    getKeyFormatPromise(e) {
        return new Promise( (t, n) => {
            const s = b0(this.config)
              , r = e.map(Db).filter(o => !!o && s.indexOf(o) !== -1);
            return this.getKeySystemSelectionPromise(r).then( ({keySystem: o}) => {
                const a = Ob(o);
                a ? t(a) : n(new Error(`Unable to find format for key-system "${o}"`))
            }
            ).catch(n)
        }
        )
    }
    loadKey(e) {
        const t = e.keyInfo.decryptdata
          , n = this.getKeyIdString(t)
          , s = `(keyId: ${n} format: "${t.keyFormat}" method: ${t.method} uri: ${t.uri})`;
        this.log(`Starting session for key ${s}`);
        let r = this.keyIdToKeySessionPromise[n];
        return r || (r = this.keyIdToKeySessionPromise[n] = this.getKeySystemForKeyPromise(t).then( ({keySystem: o, mediaKeys: a}) => (this.throwIfDestroyed(),
        this.log(`Handle encrypted media sn: ${e.frag.sn} ${e.frag.type}: ${e.frag.level} using key ${s}`),
        this.attemptSetMediaKeys(o, a).then( () => {
            this.throwIfDestroyed();
            const l = this.createMediaKeySessionContext({
                keySystem: o,
                mediaKeys: a,
                decryptdata: t
            })
              , c = "cenc";
            return this.generateRequestWithPreferredKeySession(l, c, t.pssh, "playlist-key")
        }
        ))),
        r.catch(o => this.handleError(o))),
        r
    }
    throwIfDestroyed(e="Invalid state") {
        if (!this.hls)
            throw new Error("invalid state")
    }
    handleError(e) {
        !this.hls || (this.error(e.message),
        e instanceof Is ? this.hls.trigger(P.ERROR, e.data) : this.hls.trigger(P.ERROR, {
            type: Ut.KEY_SYSTEM_ERROR,
            details: Ae.KEY_SYSTEM_NO_KEYS,
            error: e,
            fatal: !0
        }))
    }
    getKeySystemForKeyPromise(e) {
        const t = this.getKeyIdString(e)
          , n = this.keyIdToKeySessionPromise[t];
        if (!n) {
            const s = Db(e.keyFormat)
              , r = s ? [s] : b0(this.config);
            return this.attemptKeySystemAccess(r)
        }
        return n
    }
    getKeySystemSelectionPromise(e) {
        if (e.length || (e = b0(this.config)),
        e.length === 0)
            throw new Is({
                type: Ut.KEY_SYSTEM_ERROR,
                details: Ae.KEY_SYSTEM_NO_CONFIGURED_LICENSE,
                fatal: !0
            },`Missing key-system license configuration options ${JSON.stringify({
                drmSystems: this.config.drmSystems
            })}`);
        return this.attemptKeySystemAccess(e)
    }
    _onMediaEncrypted(e) {
        const {initDataType: t, initData: n} = e
          , s = `"${e.type}" event: init data type: "${t}"`;
        if (this.debug(s),
        n === null)
            return;
        let r, o;
        if (t === "sinf" && this.config.drmSystems[Rn.FAIRPLAY]) {
            const d = ii(new Uint8Array(n));
            try {
                const f = J_(JSON.parse(d).sinf)
                  , h = KC(new Uint8Array(f));
                if (!h)
                    throw new Error("'schm' box missing or not cbcs/cenc with schi > tenc");
                r = h.subarray(8, 24),
                o = Rn.FAIRPLAY
            } catch (f) {
                this.warn(`${s} Failed to parse sinf: ${f}`);
                return
            }
        } else {
            const d = _H(n)
              , f = d.filter(h => h.systemId === Yu.WIDEVINE)[0];
            if (!f) {
                d.length === 0 || d.some(h => !h.systemId) ? this.warn(`${s} contains incomplete or invalid pssh data`) : this.log(`ignoring ${s} for ${d.map(h => Fb(h.systemId)).join(",")} pssh data in favor of playlist keys`);
                return
            }
            if (o = Fb(f.systemId),
            f.version === 0 && f.data) {
                const h = f.data.length - 22;
                r = f.data.subarray(h, h + 16)
            }
        }
        if (!o || !r)
            return;
        const a = Rr.hexDump(r)
          , {keyIdToKeySessionPromise: l, mediaKeySessions: c} = this;
        let u = l[a];
        for (let d = 0; d < c.length; d++) {
            const f = c[d]
              , h = f.decryptdata;
            if (!h.keyId)
                continue;
            const p = Rr.hexDump(h.keyId);
            if (a === p || h.uri.replace(/-/g, "").indexOf(a) !== -1) {
                if (u = l[p],
                h.pssh)
                    break;
                delete l[p],
                h.pssh = new Uint8Array(n),
                h.keyId = r,
                u = l[a] = u.then( () => this.generateRequestWithPreferredKeySession(f, t, n, "encrypted-event-key-match"));
                break
            }
        }
        u || (u = l[a] = this.getKeySystemSelectionPromise([o]).then( ({keySystem: d, mediaKeys: f}) => {
            var h;
            this.throwIfDestroyed();
            const p = new Od("ISO-23001-7",a,(h = Ob(d)) != null ? h : "");
            return p.pssh = new Uint8Array(n),
            p.keyId = r,
            this.attemptSetMediaKeys(d, f).then( () => {
                this.throwIfDestroyed();
                const g = this.createMediaKeySessionContext({
                    decryptdata: p,
                    keySystem: d,
                    mediaKeys: f
                });
                return this.generateRequestWithPreferredKeySession(g, t, n, "encrypted-event-no-match")
            }
            )
        }
        )),
        u.catch(d => this.handleError(d))
    }
    _onWaitingForKey(e) {
        this.log(`"${e.type}" event`)
    }
    attemptSetMediaKeys(e, t) {
        const n = this.setMediaKeysQueue.slice();
        this.log(`Setting media-keys for "${e}"`);
        const s = Promise.all(n).then( () => {
            if (!this.media)
                throw new Error("Attempted to set mediaKeys without media element attached");
            return this.media.setMediaKeys(t)
        }
        );
        return this.setMediaKeysQueue.push(s),
        s.then( () => {
            this.log(`Media-keys set for "${e}"`),
            n.push(s),
            this.setMediaKeysQueue = this.setMediaKeysQueue.filter(r => n.indexOf(r) === -1)
        }
        )
    }
    generateRequestWithPreferredKeySession(e, t, n, s) {
        var r, o;
        const a = (r = this.config.drmSystems) == null || (o = r[e.keySystem]) == null ? void 0 : o.generateRequest;
        if (a)
            try {
                const p = a.call(this.hls, t, n, e);
                if (!p)
                    throw new Error("Invalid response from configured generateRequest filter");
                t = p.initDataType,
                n = e.decryptdata.pssh = p.initData ? new Uint8Array(p.initData) : null
            } catch (p) {
                var l;
                if (this.warn(p.message),
                (l = this.hls) != null && l.config.debug)
                    throw p
            }
        if (n === null)
            return this.log(`Skipping key-session request for "${s}" (no initData)`),
            Promise.resolve(e);
        const c = this.getKeyIdString(e.decryptdata);
        this.log(`Generating key-session request for "${s}": ${c} (init data type: ${t} length: ${n ? n.byteLength : null})`);
        const u = new ux
          , d = e._onmessage = p => {
            const g = e.mediaKeysSession;
            if (!g) {
                u.emit("error", new Error("invalid state"));
                return
            }
            const {messageType: m, message: v} = p;
            this.log(`"${m}" message event for session "${g.sessionId}" message size: ${v.byteLength}`),
            m === "license-request" || m === "license-renewal" ? this.renewLicense(e, v).catch(_ => {
                this.handleError(_),
                u.emit("error", _)
            }
            ) : m === "license-release" ? e.keySystem === Rn.FAIRPLAY && (this.updateKeySession(e, N1("acknowledged")),
            this.removeSession(e)) : this.warn(`unhandled media key message type "${m}"`)
        }
          , f = e._onkeystatuseschange = p => {
            if (!e.mediaKeysSession) {
                u.emit("error", new Error("invalid state"));
                return
            }
            this.onKeyStatusChange(e);
            const m = e.keyStatus;
            u.emit("keyStatus", m),
            m === "expired" && (this.warn(`${e.keySystem} expired for key ${c}`),
            this.renewKeySession(e))
        }
        ;
        e.mediaKeysSession.addEventListener("message", d),
        e.mediaKeysSession.addEventListener("keystatuseschange", f);
        const h = new Promise( (p, g) => {
            u.on("error", g),
            u.on("keyStatus", m => {
                m.startsWith("usable") ? p() : m === "output-restricted" ? g(new Is({
                    type: Ut.KEY_SYSTEM_ERROR,
                    details: Ae.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED,
                    fatal: !1
                },"HDCP level output restricted")) : m === "internal-error" ? g(new Is({
                    type: Ut.KEY_SYSTEM_ERROR,
                    details: Ae.KEY_SYSTEM_STATUS_INTERNAL_ERROR,
                    fatal: !0
                },`key status changed to "${m}"`)) : m === "expired" ? g(new Error("key expired while generating request")) : this.warn(`unhandled key status change "${m}"`)
            }
            )
        }
        );
        return e.mediaKeysSession.generateRequest(t, n).then( () => {
            var p;
            this.log(`Request generated for key-session "${(p = e.mediaKeysSession) == null ? void 0 : p.sessionId}" keyId: ${c}`)
        }
        ).catch(p => {
            throw new Is({
                type: Ut.KEY_SYSTEM_ERROR,
                details: Ae.KEY_SYSTEM_NO_SESSION,
                error: p,
                fatal: !1
            },`Error generating key-session request: ${p}`)
        }
        ).then( () => h).catch(p => {
            throw u.removeAllListeners(),
            this.removeSession(e),
            p
        }
        ).then( () => (u.removeAllListeners(),
        e))
    }
    onKeyStatusChange(e) {
        e.mediaKeysSession.keyStatuses.forEach( (t, n) => {
            this.log(`key status change "${t}" for keyStatuses keyId: ${Rr.hexDump("buffer"in n ? new Uint8Array(n.buffer,n.byteOffset,n.byteLength) : new Uint8Array(n))} session keyId: ${Rr.hexDump(new Uint8Array(e.decryptdata.keyId || []))} uri: ${e.decryptdata.uri}`),
            e.keyStatus = t
        }
        )
    }
    fetchServerCertificate(e) {
        const t = this.config
          , n = t.loader
          , s = new n(t)
          , r = this.getServerCertificateUrl(e);
        return r ? (this.log(`Fetching server certificate for "${e}"`),
        new Promise( (o, a) => {
            const l = {
                responseType: "arraybuffer",
                url: r
            }
              , c = t.certLoadPolicy.default
              , u = {
                loadPolicy: c,
                timeout: c.maxLoadTimeMs,
                maxRetry: 0,
                retryDelay: 0,
                maxRetryDelay: 0
            }
              , d = {
                onSuccess: (f, h, p, g) => {
                    o(f.data)
                }
                ,
                onError: (f, h, p, g) => {
                    a(new Is({
                        type: Ut.KEY_SYSTEM_ERROR,
                        details: Ae.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,
                        fatal: !0,
                        networkDetails: p,
                        response: yi({
                            url: l.url,
                            data: void 0
                        }, f)
                    },`"${e}" certificate request failed (${r}). Status: ${f.code} (${f.text})`))
                }
                ,
                onTimeout: (f, h, p) => {
                    a(new Is({
                        type: Ut.KEY_SYSTEM_ERROR,
                        details: Ae.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,
                        fatal: !0,
                        networkDetails: p,
                        response: {
                            url: l.url,
                            data: void 0
                        }
                    },`"${e}" certificate request timed out (${r})`))
                }
                ,
                onAbort: (f, h, p) => {
                    a(new Error("aborted"))
                }
            };
            s.load(l, u, d)
        }
        )) : Promise.resolve()
    }
    setMediaKeysServerCertificate(e, t, n) {
        return new Promise( (s, r) => {
            e.setServerCertificate(n).then(o => {
                this.log(`setServerCertificate ${o ? "success" : "not supported by CDM"} (${n == null ? void 0 : n.byteLength}) on "${t}"`),
                s(e)
            }
            ).catch(o => {
                r(new Is({
                    type: Ut.KEY_SYSTEM_ERROR,
                    details: Ae.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED,
                    error: o,
                    fatal: !0
                },o.message))
            }
            )
        }
        )
    }
    renewLicense(e, t) {
        return this.requestLicense(e, new Uint8Array(t)).then(n => this.updateKeySession(e, new Uint8Array(n)).catch(s => {
            throw new Is({
                type: Ut.KEY_SYSTEM_ERROR,
                details: Ae.KEY_SYSTEM_SESSION_UPDATE_FAILED,
                error: s,
                fatal: !0
            },s.message)
        }
        ))
    }
    unpackPlayReadyKeyMessage(e, t) {
        const n = String.fromCharCode.apply(null, new Uint16Array(t.buffer));
        if (!n.includes("PlayReadyKeyMessage"))
            return e.setRequestHeader("Content-Type", "text/xml; charset=utf-8"),
            t;
        const s = new DOMParser().parseFromString(n, "application/xml")
          , r = s.querySelectorAll("HttpHeader");
        if (r.length > 0) {
            let u;
            for (let d = 0, f = r.length; d < f; d++) {
                var o, a;
                u = r[d];
                const h = (o = u.querySelector("name")) == null ? void 0 : o.textContent
                  , p = (a = u.querySelector("value")) == null ? void 0 : a.textContent;
                h && p && e.setRequestHeader(h, p)
            }
        }
        const l = s.querySelector("Challenge")
          , c = l == null ? void 0 : l.textContent;
        if (!c)
            throw new Error("Cannot find <Challenge> in key message");
        return N1(atob(c))
    }
    setupLicenseXHR(e, t, n, s) {
        const r = this.config.licenseXhrSetup;
        return r ? Promise.resolve().then( () => {
            if (!n.decryptdata)
                throw new Error("Key removed");
            return r.call(this.hls, e, t, n, s)
        }
        ).catch(o => {
            if (!n.decryptdata)
                throw o;
            return e.open("POST", t, !0),
            r.call(this.hls, e, t, n, s)
        }
        ).then(o => (e.readyState || e.open("POST", t, !0),
        {
            xhr: e,
            licenseChallenge: o || s
        })) : (e.open("POST", t, !0),
        Promise.resolve({
            xhr: e,
            licenseChallenge: s
        }))
    }
    requestLicense(e, t) {
        const n = this.config.keyLoadPolicy.default;
        return new Promise( (s, r) => {
            const o = this.getLicenseServerUrl(e.keySystem);
            this.log(`Sending license request to URL: ${o}`);
            const a = new XMLHttpRequest;
            a.responseType = "arraybuffer",
            a.onreadystatechange = () => {
                if (!this.hls || !e.mediaKeysSession)
                    return r(new Error("invalid state"));
                if (a.readyState === 4)
                    if (a.status === 200) {
                        this._requestLicenseFailureCount = 0;
                        let l = a.response;
                        this.log(`License received ${linstanceof ArrayBuffer ? l.byteLength : l}`);
                        const c = this.config.licenseResponseCallback;
                        if (c)
                            try {
                                l = c.call(this.hls, a, o, e)
                            } catch (u) {
                                this.error(u)
                            }
                        s(l)
                    } else {
                        const l = n.errorRetry
                          , c = l ? l.maxNumRetry : 0;
                        if (this._requestLicenseFailureCount++,
                        this._requestLicenseFailureCount > c || a.status >= 400 && a.status < 500)
                            r(new Is({
                                type: Ut.KEY_SYSTEM_ERROR,
                                details: Ae.KEY_SYSTEM_LICENSE_REQUEST_FAILED,
                                fatal: !0,
                                networkDetails: a,
                                response: {
                                    url: o,
                                    data: void 0,
                                    code: a.status,
                                    text: a.statusText
                                }
                            },`License Request XHR failed (${o}). Status: ${a.status} (${a.statusText})`));
                        else {
                            const u = c - this._requestLicenseFailureCount + 1;
                            this.warn(`Retrying license request, ${u} attempts left`),
                            this.requestLicense(e, t).then(s, r)
                        }
                    }
            }
            ,
            e.licenseXhr && e.licenseXhr.readyState !== XMLHttpRequest.DONE && e.licenseXhr.abort(),
            e.licenseXhr = a,
            this.setupLicenseXHR(a, o, e, t).then( ({xhr: l, licenseChallenge: c}) => {
                e.keySystem == Rn.PLAYREADY && (c = this.unpackPlayReadyKeyMessage(l, c)),
                l.send(c)
            }
            )
        }
        )
    }
    onMediaAttached(e, t) {
        if (!this.config.emeEnabled)
            return;
        const n = t.media;
        this.media = n,
        n.addEventListener("encrypted", this.onMediaEncrypted),
        n.addEventListener("waitingforkey", this.onWaitingForKey)
    }
    onMediaDetached() {
        const e = this.media
          , t = this.mediaKeySessions;
        e && (e.removeEventListener("encrypted", this.onMediaEncrypted),
        e.removeEventListener("waitingforkey", this.onWaitingForKey),
        this.media = null),
        this._requestLicenseFailureCount = 0,
        this.setMediaKeysQueue = [],
        this.mediaKeySessions = [],
        this.keyIdToKeySessionPromise = {},
        Od.clearKeyUriToKeyIdMap();
        const n = t.length;
        zc.CDMCleanupPromise = Promise.all(t.map(s => this.removeSession(s)).concat(e == null ? void 0 : e.setMediaKeys(null).catch(s => {
            this.log(`Could not clear media keys: ${s}`)
        }
        ))).then( () => {
            n && (this.log("finished closing key sessions and clearing media keys"),
            t.length = 0)
        }
        ).catch(s => {
            this.log(`Could not close sessions and clear media keys: ${s}`)
        }
        )
    }
    onManifestLoading() {
        this.keyFormatPromise = null
    }
    onManifestLoaded(e, {sessionKeys: t}) {
        if (!(!t || !this.config.emeEnabled) && !this.keyFormatPromise) {
            const n = t.reduce( (s, r) => (s.indexOf(r.keyFormat) === -1 && s.push(r.keyFormat),
            s), []);
            this.log(`Selecting key-system from session-keys ${n.join(", ")}`),
            this.keyFormatPromise = this.getKeyFormatPromise(n)
        }
    }
    removeSession(e) {
        const {mediaKeysSession: t, licenseXhr: n} = e;
        if (t) {
            this.log(`Remove licenses and keys and close session ${t.sessionId}`),
            e._onmessage && (t.removeEventListener("message", e._onmessage),
            e._onmessage = void 0),
            e._onkeystatuseschange && (t.removeEventListener("keystatuseschange", e._onkeystatuseschange),
            e._onkeystatuseschange = void 0),
            n && n.readyState !== XMLHttpRequest.DONE && n.abort(),
            e.mediaKeysSession = e.decryptdata = e.licenseXhr = void 0;
            const s = this.mediaKeySessions.indexOf(e);
            return s > -1 && this.mediaKeySessions.splice(s, 1),
            t.remove().catch(r => {
                this.log(`Could not remove session: ${r}`)
            }
            ).then( () => t.close()).catch(r => {
                this.log(`Could not close session: ${r}`)
            }
            )
        }
    }
}
zc.CDMCleanupPromise = void 0;
class Is extends Error {
    constructor(e, t) {
        super(t),
        this.data = void 0,
        e.error || (e.error = new Error(t)),
        this.data = e,
        e.err = e.error
    }
}
var Ri;
(function(i) {
    i.MANIFEST = "m",
    i.AUDIO = "a",
    i.VIDEO = "v",
    i.MUXED = "av",
    i.INIT = "i",
    i.CAPTION = "c",
    i.TIMED_TEXT = "tt",
    i.KEY = "k",
    i.OTHER = "o"
}
)(Ri || (Ri = {}));
var K1;
(function(i) {
    i.DASH = "d",
    i.HLS = "h",
    i.SMOOTH = "s",
    i.OTHER = "o"
}
)(K1 || (K1 = {}));
var hl;
(function(i) {
    i.OBJECT = "CMCD-Object",
    i.REQUEST = "CMCD-Request",
    i.SESSION = "CMCD-Session",
    i.STATUS = "CMCD-Status"
}
)(hl || (hl = {}));
const HG = {
    [hl.OBJECT]: ["br", "d", "ot", "tb"],
    [hl.REQUEST]: ["bl", "dl", "mtp", "nor", "nrr", "su"],
    [hl.SESSION]: ["cid", "pr", "sf", "sid", "st", "v"],
    [hl.STATUS]: ["bs", "rtp"]
};
class du {
    constructor(e, t) {
        this.value = void 0,
        this.params = void 0,
        Array.isArray(e) && (e = e.map(n => n instanceof du ? n : new du(n))),
        this.value = e,
        this.params = t
    }
}
class FM {
    constructor(e) {
        this.description = void 0,
        this.description = e
    }
}
const zG = "Dict";
function GG(i) {
    return Array.isArray(i) ? JSON.stringify(i) : i instanceof Map ? "Map{}" : i instanceof Set ? "Set{}" : typeof i == "object" ? JSON.stringify(i) : String(i)
}
function WG(i, e, t, n) {
    return new Error(`failed to ${i} "${GG(e)}" as ${t}`,{
        cause: n
    })
}
const RS = "Bare Item"
  , qG = "Boolean"
  , jG = "Byte Sequence"
  , KG = "Decimal"
  , XG = "Integer";
function YG(i) {
    return i < -999999999999999 || 999999999999999 < i
}
const ZG = /[\x00-\x1f\x7f]+/
  , JG = "Token"
  , QG = "Key";
function Kr(i, e, t) {
    return WG("serialize", i, e, t)
}
function eW(i) {
    if (typeof i != "boolean")
        throw Kr(i, qG);
    return i ? "?1" : "?0"
}
function tW(i) {
    return btoa(String.fromCharCode(...i))
}
function nW(i) {
    if (ArrayBuffer.isView(i) === !1)
        throw Kr(i, jG);
    return `:${tW(i)}:`
}
function OM(i) {
    if (YG(i))
        throw Kr(i, XG);
    return i.toString()
}
function iW(i) {
    return `@${OM(i.getTime() / 1e3)}`
}
function UM(i, e) {
    if (i < 0)
        return -UM(-i, e);
    const t = Math.pow(10, e);
    if (Math.abs(i * t % 1 - .5) < Number.EPSILON) {
        const s = Math.floor(i * t);
        return (s % 2 === 0 ? s : s + 1) / t
    } else
        return Math.round(i * t) / t
}
function sW(i) {
    const e = UM(i, 3);
    if (Math.floor(Math.abs(e)).toString().length > 12)
        throw Kr(i, KG);
    const t = e.toString();
    return t.includes(".") ? t : `${t}.0`
}
const rW = "String";
function oW(i) {
    if (ZG.test(i))
        throw Kr(i, rW);
    return `"${i.replace(/\\/g, "\\\\").replace(/"/g, '\\"')}"`
}
function aW(i) {
    return i.description || i.toString().slice(7, -1)
}
function LS(i) {
    const e = aW(i);
    if (/^([a-zA-Z*])([!#$%&'*+\-.^_`|~\w:/]*)$/.test(e) === !1)
        throw Kr(e, JG);
    return e
}
function X1(i) {
    switch (typeof i) {
    case "number":
        if (!pt(i))
            throw Kr(i, RS);
        return Number.isInteger(i) ? OM(i) : sW(i);
    case "string":
        return oW(i);
    case "symbol":
        return LS(i);
    case "boolean":
        return eW(i);
    case "object":
        if (i instanceof Date)
            return iW(i);
        if (i instanceof Uint8Array)
            return nW(i);
        if (i instanceof FM)
            return LS(i);
    default:
        throw Kr(i, RS)
    }
}
function Y1(i) {
    if (/^[a-z*][a-z0-9\-_.*]*$/.test(i) === !1)
        throw Kr(i, QG);
    return i
}
function px(i) {
    return i == null ? "" : Object.entries(i).map( ([e,t]) => t === !0 ? `;${Y1(e)}` : `;${Y1(e)}=${X1(t)}`).join("")
}
function NM(i) {
    return i instanceof du ? `${X1(i.value)}${px(i.params)}` : X1(i)
}
function lW(i) {
    return `(${i.value.map(NM).join(" ")})${px(i.params)}`
}
function cW(i, e={
    whitespace: !0
}) {
    if (typeof i != "object")
        throw Kr(i, zG);
    const t = i instanceof Map ? i.entries() : Object.entries(i)
      , n = e != null && e.whitespace ? " " : "";
    return Array.from(t).map( ([s,r]) => {
        r instanceof du || (r = new du(r));
        let o = Y1(s);
        return r.value === !0 ? o += px(r.params) : (o += "=",
        Array.isArray(r.value) ? o += lW(r) : o += NM(r)),
        o
    }
    ).join(`,${n}`)
}
function uW(i, e) {
    return cW(i, e)
}
const dW = i => i === "ot" || i === "sf" || i === "st"
  , fW = i => typeof i == "number" ? pt(i) : i != null && i !== "" && i !== !1;
function hW(i, e) {
    const t = new URL(i)
      , n = new URL(e);
    if (t.origin !== n.origin)
        return i;
    const s = t.pathname.split("/").slice(1)
      , r = n.pathname.split("/").slice(1, -1);
    for (; s[0] === r[0]; )
        s.shift(),
        r.shift();
    for (; r.length; )
        r.shift(),
        s.unshift("..");
    return s.join("/")
}
function pW() {
    try {
        return crypto.randomUUID()
    } catch {
        try {
            const e = URL.createObjectURL(new Blob)
              , t = e.toString();
            return URL.revokeObjectURL(e),
            t.slice(t.lastIndexOf("/") + 1)
        } catch {
            let t = new Date().getTime();
            return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, s => {
                const r = (t + Math.random() * 16) % 16 | 0;
                return t = Math.floor(t / 16),
                (s == "x" ? r : r & 3 | 8).toString(16)
            }
            )
        }
    }
}
const Ph = i => Math.round(i)
  , mW = (i, e) => (e != null && e.baseUrl && (i = hW(i, e.baseUrl)),
encodeURIComponent(i))
  , Hf = i => Ph(i / 100) * 100
  , gW = {
    br: Ph,
    d: Ph,
    bl: Hf,
    dl: Hf,
    mtp: Hf,
    nor: mW,
    rtp: Hf,
    tb: Ph
};
function vW(i, e) {
    const t = {};
    if (i == null || typeof i != "object")
        return t;
    const n = Object.keys(i).sort()
      , s = Qn({}, gW, e == null ? void 0 : e.formatters)
      , r = e == null ? void 0 : e.filter;
    return n.forEach(o => {
        if (r != null && r(o))
            return;
        let a = i[o];
        const l = s[o];
        l && (a = l(a, e)),
        !(o === "v" && a === 1) && (o == "pr" && a === 1 || !fW(a) || (dW(o) && typeof a == "string" && (a = new FM(a)),
        t[o] = a))
    }
    ),
    t
}
function BM(i, e={}) {
    return i ? uW(vW(i, e), Qn({
        whitespace: !1
    }, e)) : ""
}
function _W(i, e={}) {
    if (!i)
        return {};
    const t = Object.entries(i)
      , n = Object.entries(HG).concat(Object.entries((e == null ? void 0 : e.customHeaderMap) || {}))
      , s = t.reduce( (r, o) => {
        var a, l;
        const [c,u] = o
          , d = ((a = n.find(f => f[1].includes(c))) == null ? void 0 : a[0]) || hl.REQUEST;
        return (l = r[d]) != null || (r[d] = {}),
        r[d][c] = u,
        r
    }
    , {});
    return Object.entries(s).reduce( (r, [o,a]) => (r[o] = BM(a, e),
    r), {})
}
function xW(i, e, t) {
    return Qn(i, _W(e, t))
}
const yW = "CMCD";
function bW(i, e={}) {
    if (!i)
        return "";
    const t = BM(i, e);
    return `${yW}=${encodeURIComponent(t)}`
}
const IS = /CMCD=[^&#]+/;
function SW(i, e, t) {
    const n = bW(e, t);
    if (!n)
        return i;
    if (IS.test(i))
        return i.replace(IS, n);
    const s = i.includes("?") ? "&" : "?";
    return `${i}${s}${n}`
}
class EW {
    constructor(e) {
        this.hls = void 0,
        this.config = void 0,
        this.media = void 0,
        this.sid = void 0,
        this.cid = void 0,
        this.useHeaders = !1,
        this.includeKeys = void 0,
        this.initialized = !1,
        this.starved = !1,
        this.buffering = !0,
        this.audioBuffer = void 0,
        this.videoBuffer = void 0,
        this.onWaiting = () => {
            this.initialized && (this.starved = !0),
            this.buffering = !0
        }
        ,
        this.onPlaying = () => {
            this.initialized || (this.initialized = !0),
            this.buffering = !1
        }
        ,
        this.applyPlaylistData = s => {
            try {
                this.apply(s, {
                    ot: Ri.MANIFEST,
                    su: !this.initialized
                })
            } catch (r) {
                de.warn("Could not generate manifest CMCD data.", r)
            }
        }
        ,
        this.applyFragmentData = s => {
            try {
                const r = s.frag
                  , o = this.hls.levels[r.level]
                  , a = this.getObjectType(r)
                  , l = {
                    d: r.duration * 1e3,
                    ot: a
                };
                (a === Ri.VIDEO || a === Ri.AUDIO || a == Ri.MUXED) && (l.br = o.bitrate / 1e3,
                l.tb = this.getTopBandwidth(a) / 1e3,
                l.bl = this.getBufferLength(a)),
                this.apply(s, l)
            } catch (r) {
                de.warn("Could not generate segment CMCD data.", r)
            }
        }
        ,
        this.hls = e;
        const t = this.config = e.config
          , {cmcd: n} = t;
        n != null && (t.pLoader = this.createPlaylistLoader(),
        t.fLoader = this.createFragmentLoader(),
        this.sid = n.sessionId || pW(),
        this.cid = n.contentId,
        this.useHeaders = n.useHeaders === !0,
        this.includeKeys = n.includeKeys,
        this.registerListeners())
    }
    registerListeners() {
        const e = this.hls;
        e.on(P.MEDIA_ATTACHED, this.onMediaAttached, this),
        e.on(P.MEDIA_DETACHED, this.onMediaDetached, this),
        e.on(P.BUFFER_CREATED, this.onBufferCreated, this)
    }
    unregisterListeners() {
        const e = this.hls;
        e.off(P.MEDIA_ATTACHED, this.onMediaAttached, this),
        e.off(P.MEDIA_DETACHED, this.onMediaDetached, this),
        e.off(P.BUFFER_CREATED, this.onBufferCreated, this)
    }
    destroy() {
        this.unregisterListeners(),
        this.onMediaDetached(),
        this.hls = this.config = this.audioBuffer = this.videoBuffer = null,
        this.onWaiting = this.onPlaying = null
    }
    onMediaAttached(e, t) {
        this.media = t.media,
        this.media.addEventListener("waiting", this.onWaiting),
        this.media.addEventListener("playing", this.onPlaying)
    }
    onMediaDetached() {
        !this.media || (this.media.removeEventListener("waiting", this.onWaiting),
        this.media.removeEventListener("playing", this.onPlaying),
        this.media = null)
    }
    onBufferCreated(e, t) {
        var n, s;
        this.audioBuffer = (n = t.tracks.audio) == null ? void 0 : n.buffer,
        this.videoBuffer = (s = t.tracks.video) == null ? void 0 : s.buffer
    }
    createData() {
        var e;
        return {
            v: 1,
            sf: K1.HLS,
            sid: this.sid,
            cid: this.cid,
            pr: (e = this.media) == null ? void 0 : e.playbackRate,
            mtp: this.hls.bandwidthEstimate / 1e3
        }
    }
    apply(e, t={}) {
        Qn(t, this.createData());
        const n = t.ot === Ri.INIT || t.ot === Ri.VIDEO || t.ot === Ri.MUXED;
        this.starved && n && (t.bs = !0,
        t.su = !0,
        this.starved = !1),
        t.su == null && (t.su = this.buffering);
        const {includeKeys: s} = this;
        s && (t = Object.keys(t).reduce( (r, o) => (s.includes(o) && (r[o] = t[o]),
        r), {})),
        this.useHeaders ? (e.headers || (e.headers = {}),
        xW(e.headers, t)) : e.url = SW(e.url, t)
    }
    getObjectType(e) {
        const {type: t} = e;
        if (t === "subtitle")
            return Ri.TIMED_TEXT;
        if (e.sn === "initSegment")
            return Ri.INIT;
        if (t === "audio")
            return Ri.AUDIO;
        if (t === "main")
            return this.hls.audioTracks.length ? Ri.VIDEO : Ri.MUXED
    }
    getTopBandwidth(e) {
        let t = 0, n;
        const s = this.hls;
        if (e === Ri.AUDIO)
            n = s.audioTracks;
        else {
            const r = s.maxAutoLevel
              , o = r > -1 ? r + 1 : s.levels.length;
            n = s.levels.slice(0, o)
        }
        for (const r of n)
            r.bitrate > t && (t = r.bitrate);
        return t > 0 ? t : NaN
    }
    getBufferLength(e) {
        const t = this.hls.media
          , n = e === Ri.AUDIO ? this.audioBuffer : this.videoBuffer;
        return !n || !t ? NaN : An.bufferInfo(n, t.currentTime, this.config.maxBufferHole).len * 1e3
    }
    createPlaylistLoader() {
        const {pLoader: e} = this.config
          , t = this.applyPlaylistData
          , n = e || this.config.loader;
        return class {
            constructor(r) {
                this.loader = void 0,
                this.loader = new n(r)
            }
            get stats() {
                return this.loader.stats
            }
            get context() {
                return this.loader.context
            }
            destroy() {
                this.loader.destroy()
            }
            abort() {
                this.loader.abort()
            }
            load(r, o, a) {
                t(r),
                this.loader.load(r, o, a)
            }
        }
    }
    createFragmentLoader() {
        const {fLoader: e} = this.config
          , t = this.applyFragmentData
          , n = e || this.config.loader;
        return class {
            constructor(r) {
                this.loader = void 0,
                this.loader = new n(r)
            }
            get stats() {
                return this.loader.stats
            }
            get context() {
                return this.loader.context
            }
            destroy() {
                this.loader.destroy()
            }
            abort() {
                this.loader.abort()
            }
            load(r, o, a) {
                t(r),
                this.loader.load(r, o, a)
            }
        }
    }
}
const wW = 3e5;
class TW {
    constructor(e) {
        this.hls = void 0,
        this.log = void 0,
        this.loader = null,
        this.uri = null,
        this.pathwayId = ".",
        this.pathwayPriority = null,
        this.timeToLoad = 300,
        this.reloadTimer = -1,
        this.updated = 0,
        this.started = !1,
        this.enabled = !0,
        this.levels = null,
        this.audioTracks = null,
        this.subtitleTracks = null,
        this.penalizedPathways = {},
        this.hls = e,
        this.log = de.log.bind(de, "[content-steering]:"),
        this.registerListeners()
    }
    registerListeners() {
        const e = this.hls;
        e.on(P.MANIFEST_LOADING, this.onManifestLoading, this),
        e.on(P.MANIFEST_LOADED, this.onManifestLoaded, this),
        e.on(P.MANIFEST_PARSED, this.onManifestParsed, this),
        e.on(P.ERROR, this.onError, this)
    }
    unregisterListeners() {
        const e = this.hls;
        !e || (e.off(P.MANIFEST_LOADING, this.onManifestLoading, this),
        e.off(P.MANIFEST_LOADED, this.onManifestLoaded, this),
        e.off(P.MANIFEST_PARSED, this.onManifestParsed, this),
        e.off(P.ERROR, this.onError, this))
    }
    startLoad() {
        if (this.started = !0,
        this.clearTimeout(),
        this.enabled && this.uri) {
            if (this.updated) {
                const e = this.timeToLoad * 1e3 - (performance.now() - this.updated);
                if (e > 0) {
                    this.scheduleRefresh(this.uri, e);
                    return
                }
            }
            this.loadSteeringManifest(this.uri)
        }
    }
    stopLoad() {
        this.started = !1,
        this.loader && (this.loader.destroy(),
        this.loader = null),
        this.clearTimeout()
    }
    clearTimeout() {
        this.reloadTimer !== -1 && (self.clearTimeout(this.reloadTimer),
        this.reloadTimer = -1)
    }
    destroy() {
        this.unregisterListeners(),
        this.stopLoad(),
        this.hls = null,
        this.levels = this.audioTracks = this.subtitleTracks = null
    }
    removeLevel(e) {
        const t = this.levels;
        t && (this.levels = t.filter(n => n !== e))
    }
    onManifestLoading() {
        this.stopLoad(),
        this.enabled = !0,
        this.timeToLoad = 300,
        this.updated = 0,
        this.uri = null,
        this.pathwayId = ".",
        this.levels = this.audioTracks = this.subtitleTracks = null
    }
    onManifestLoaded(e, t) {
        const {contentSteering: n} = t;
        n !== null && (this.pathwayId = n.pathwayId,
        this.uri = n.uri,
        this.started && this.startLoad())
    }
    onManifestParsed(e, t) {
        this.audioTracks = t.audioTracks,
        this.subtitleTracks = t.subtitleTracks
    }
    onError(e, t) {
        const {errorAction: n} = t;
        if ((n == null ? void 0 : n.action) === Ei.SendAlternateToPenaltyBox && n.flags === tr.MoveAllAlternatesMatchingHost) {
            const s = this.levels;
            let r = this.pathwayPriority
              , o = this.pathwayId;
            if (t.context) {
                const {groupId: a, pathwayId: l, type: c} = t.context;
                a && s ? o = this.getPathwayForGroupId(a, c, o) : l && (o = l)
            }
            o in this.penalizedPathways || (this.penalizedPathways[o] = performance.now()),
            !r && s && (r = s.reduce( (a, l) => (a.indexOf(l.pathwayId) === -1 && a.push(l.pathwayId),
            a), [])),
            r && r.length > 1 && (this.updatePathwayPriority(r),
            n.resolved = this.pathwayId !== o),
            n.resolved || de.warn(`Could not resolve ${t.details} ("${t.error.message}") with content-steering for Pathway: ${o} levels: ${s && s.length} priorities: ${JSON.stringify(r)} penalized: ${JSON.stringify(this.penalizedPathways)}`)
        }
    }
    filterParsedLevels(e) {
        this.levels = e;
        let t = this.getLevelsForPathway(this.pathwayId);
        if (t.length === 0) {
            const n = e[0].pathwayId;
            this.log(`No levels found in Pathway ${this.pathwayId}. Setting initial Pathway to "${n}"`),
            t = this.getLevelsForPathway(n),
            this.pathwayId = n
        }
        return t.length !== e.length && this.log(`Found ${t.length}/${e.length} levels in Pathway "${this.pathwayId}"`),
        t
    }
    getLevelsForPathway(e) {
        return this.levels === null ? [] : this.levels.filter(t => e === t.pathwayId)
    }
    updatePathwayPriority(e) {
        this.pathwayPriority = e;
        let t;
        const n = this.penalizedPathways
          , s = performance.now();
        Object.keys(n).forEach(r => {
            s - n[r] > wW && delete n[r]
        }
        );
        for (let r = 0; r < e.length; r++) {
            const o = e[r];
            if (o in n)
                continue;
            if (o === this.pathwayId)
                return;
            const a = this.hls.nextLoadLevel
              , l = this.hls.levels[a];
            if (t = this.getLevelsForPathway(o),
            t.length > 0) {
                this.log(`Setting Pathway to "${o}"`),
                this.pathwayId = o,
                sM(t),
                this.hls.trigger(P.LEVELS_UPDATED, {
                    levels: t
                });
                const c = this.hls.levels[a];
                l && c && this.levels && (c.attrs["STABLE-VARIANT-ID"] !== l.attrs["STABLE-VARIANT-ID"] && c.bitrate !== l.bitrate && this.log(`Unstable Pathways change from bitrate ${l.bitrate} to ${c.bitrate}`),
                this.hls.nextLoadLevel = a);
                break
            }
        }
    }
    getPathwayForGroupId(e, t, n) {
        const s = this.getLevelsForPathway(n).concat(this.levels || []);
        for (let r = 0; r < s.length; r++)
            if (t === en.AUDIO_TRACK && s[r].hasAudioGroup(e) || t === en.SUBTITLE_TRACK && s[r].hasSubtitleGroup(e))
                return s[r].pathwayId;
        return n
    }
    clonePathways(e) {
        const t = this.levels;
        if (!t)
            return;
        const n = {}
          , s = {};
        e.forEach(r => {
            const {ID: o, "BASE-ID": a, "URI-REPLACEMENT": l} = r;
            if (t.some(u => u.pathwayId === o))
                return;
            const c = this.getLevelsForPathway(a).map(u => {
                const d = new Un(u.attrs);
                d["PATHWAY-ID"] = o;
                const f = d.AUDIO && `${d.AUDIO}_clone_${o}`
                  , h = d.SUBTITLES && `${d.SUBTITLES}_clone_${o}`;
                f && (n[d.AUDIO] = f,
                d.AUDIO = f),
                h && (s[d.SUBTITLES] = h,
                d.SUBTITLES = h);
                const p = VM(u.uri, d["STABLE-VARIANT-ID"], "PER-VARIANT-URIS", l)
                  , g = new cu({
                    attrs: d,
                    audioCodec: u.audioCodec,
                    bitrate: u.bitrate,
                    height: u.height,
                    name: u.name,
                    url: p,
                    videoCodec: u.videoCodec,
                    width: u.width
                });
                if (u.audioGroups)
                    for (let m = 1; m < u.audioGroups.length; m++)
                        g.addGroupId("audio", `${u.audioGroups[m]}_clone_${o}`);
                if (u.subtitleGroups)
                    for (let m = 1; m < u.subtitleGroups.length; m++)
                        g.addGroupId("text", `${u.subtitleGroups[m]}_clone_${o}`);
                return g
            }
            );
            t.push(...c),
            kS(this.audioTracks, n, l, o),
            kS(this.subtitleTracks, s, l, o)
        }
        )
    }
    loadSteeringManifest(e) {
        const t = this.hls.config
          , n = t.loader;
        this.loader && this.loader.destroy(),
        this.loader = new n(t);
        let s;
        try {
            s = new self.URL(e)
        } catch {
            this.enabled = !1,
            this.log(`Failed to parse Steering Manifest URI: ${e}`);
            return
        }
        if (s.protocol !== "data:") {
            const u = (this.hls.bandwidthEstimate || t.abrEwmaDefaultEstimate) | 0;
            s.searchParams.set("_HLS_pathway", this.pathwayId),
            s.searchParams.set("_HLS_throughput", "" + u)
        }
        const r = {
            responseType: "json",
            url: s.href
        }
          , o = t.steeringManifestLoadPolicy.default
          , a = o.errorRetry || o.timeoutRetry || {}
          , l = {
            loadPolicy: o,
            timeout: o.maxLoadTimeMs,
            maxRetry: a.maxNumRetry || 0,
            retryDelay: a.retryDelayMs || 0,
            maxRetryDelay: a.maxRetryDelayMs || 0
        }
          , c = {
            onSuccess: (u, d, f, h) => {
                this.log(`Loaded steering manifest: "${s}"`);
                const p = u.data;
                if (p.VERSION !== 1) {
                    this.log(`Steering VERSION ${p.VERSION} not supported!`);
                    return
                }
                this.updated = performance.now(),
                this.timeToLoad = p.TTL;
                const {"RELOAD-URI": g, "PATHWAY-CLONES": m, "PATHWAY-PRIORITY": v} = p;
                if (g)
                    try {
                        this.uri = new self.URL(g,s).href
                    } catch {
                        this.enabled = !1,
                        this.log(`Failed to parse Steering Manifest RELOAD-URI: ${g}`);
                        return
                    }
                this.scheduleRefresh(this.uri || f.url),
                m && this.clonePathways(m);
                const _ = {
                    steeringManifest: p,
                    url: s.toString()
                };
                this.hls.trigger(P.STEERING_MANIFEST_LOADED, _),
                v && this.updatePathwayPriority(v)
            }
            ,
            onError: (u, d, f, h) => {
                if (this.log(`Error loading steering manifest: ${u.code} ${u.text} (${d.url})`),
                this.stopLoad(),
                u.code === 410) {
                    this.enabled = !1,
                    this.log(`Steering manifest ${d.url} no longer available`);
                    return
                }
                let p = this.timeToLoad * 1e3;
                if (u.code === 429) {
                    const g = this.loader;
                    if (typeof (g == null ? void 0 : g.getResponseHeader) == "function") {
                        const m = g.getResponseHeader("Retry-After");
                        m && (p = parseFloat(m) * 1e3)
                    }
                    this.log(`Steering manifest ${d.url} rate limited`);
                    return
                }
                this.scheduleRefresh(this.uri || d.url, p)
            }
            ,
            onTimeout: (u, d, f) => {
                this.log(`Timeout loading steering manifest (${d.url})`),
                this.scheduleRefresh(this.uri || d.url)
            }
        };
        this.log(`Requesting steering manifest: ${s}`),
        this.loader.load(r, l, c)
    }
    scheduleRefresh(e, t=this.timeToLoad * 1e3) {
        this.clearTimeout(),
        this.reloadTimer = self.setTimeout( () => {
            var n;
            const s = (n = this.hls) == null ? void 0 : n.media;
            if (s && !s.ended) {
                this.loadSteeringManifest(e);
                return
            }
            this.scheduleRefresh(e, this.timeToLoad * 1e3)
        }
        , t)
    }
}
function kS(i, e, t, n) {
    !i || Object.keys(e).forEach(s => {
        const r = i.filter(o => o.groupId === s).map(o => {
            const a = Qn({}, o);
            return a.details = void 0,
            a.attrs = new Un(a.attrs),
            a.url = a.attrs.URI = VM(o.url, o.attrs["STABLE-RENDITION-ID"], "PER-RENDITION-URIS", t),
            a.groupId = a.attrs["GROUP-ID"] = e[s],
            a.attrs["PATHWAY-ID"] = n,
            a
        }
        );
        i.push(...r)
    }
    )
}
function VM(i, e, t, n) {
    const {HOST: s, PARAMS: r, [t]: o} = n;
    let a;
    e && (a = o == null ? void 0 : o[e],
    a && (i = a));
    const l = new self.URL(i);
    return s && !a && (l.host = s),
    r && Object.keys(r).sort().forEach(c => {
        c && l.searchParams.set(c, r[c])
    }
    ),
    l.href
}
const AW = /^age:\s*[\d.]+\s*$/im;
class $M {
    constructor(e) {
        this.xhrSetup = void 0,
        this.requestTimeout = void 0,
        this.retryTimeout = void 0,
        this.retryDelay = void 0,
        this.config = null,
        this.callbacks = null,
        this.context = null,
        this.loader = null,
        this.stats = void 0,
        this.xhrSetup = e && e.xhrSetup || null,
        this.stats = new Tm,
        this.retryDelay = 0
    }
    destroy() {
        this.callbacks = null,
        this.abortInternal(),
        this.loader = null,
        this.config = null,
        this.context = null,
        this.xhrSetup = null
    }
    abortInternal() {
        const e = this.loader;
        self.clearTimeout(this.requestTimeout),
        self.clearTimeout(this.retryTimeout),
        e && (e.onreadystatechange = null,
        e.onprogress = null,
        e.readyState !== 4 && (this.stats.aborted = !0,
        e.abort()))
    }
    abort() {
        var e;
        this.abortInternal(),
        (e = this.callbacks) != null && e.onAbort && this.callbacks.onAbort(this.stats, this.context, this.loader)
    }
    load(e, t, n) {
        if (this.stats.loading.start)
            throw new Error("Loader can only be used once.");
        this.stats.loading.start = self.performance.now(),
        this.context = e,
        this.config = t,
        this.callbacks = n,
        this.loadInternal()
    }
    loadInternal() {
        const {config: e, context: t} = this;
        if (!e || !t)
            return;
        const n = this.loader = new self.XMLHttpRequest
          , s = this.stats;
        s.loading.first = 0,
        s.loaded = 0,
        s.aborted = !1;
        const r = this.xhrSetup;
        r ? Promise.resolve().then( () => {
            if (!(this.loader !== n || this.stats.aborted))
                return r(n, t.url)
        }
        ).catch(o => {
            if (!(this.loader !== n || this.stats.aborted))
                return n.open("GET", t.url, !0),
                r(n, t.url)
        }
        ).then( () => {
            this.loader !== n || this.stats.aborted || this.openAndSendXhr(n, t, e)
        }
        ).catch(o => {
            this.callbacks.onError({
                code: n.status,
                text: o.message
            }, t, n, s)
        }
        ) : this.openAndSendXhr(n, t, e)
    }
    openAndSendXhr(e, t, n) {
        e.readyState || e.open("GET", t.url, !0);
        const s = t.headers
          , {maxTimeToFirstByteMs: r, maxLoadTimeMs: o} = n.loadPolicy;
        if (s)
            for (const a in s)
                e.setRequestHeader(a, s[a]);
        t.rangeEnd && e.setRequestHeader("Range", "bytes=" + t.rangeStart + "-" + (t.rangeEnd - 1)),
        e.onreadystatechange = this.readystatechange.bind(this),
        e.onprogress = this.loadprogress.bind(this),
        e.responseType = t.responseType,
        self.clearTimeout(this.requestTimeout),
        n.timeout = r && pt(r) ? r : o,
        this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), n.timeout),
        e.send()
    }
    readystatechange() {
        const {context: e, loader: t, stats: n} = this;
        if (!e || !t)
            return;
        const s = t.readyState
          , r = this.config;
        if (!n.aborted && s >= 2 && (n.loading.first === 0 && (n.loading.first = Math.max(self.performance.now(), n.loading.start),
        r.timeout !== r.loadPolicy.maxLoadTimeMs && (self.clearTimeout(this.requestTimeout),
        r.timeout = r.loadPolicy.maxLoadTimeMs,
        this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), r.loadPolicy.maxLoadTimeMs - (n.loading.first - n.loading.start)))),
        s === 4)) {
            self.clearTimeout(this.requestTimeout),
            t.onreadystatechange = null,
            t.onprogress = null;
            const o = t.status
              , a = t.responseType !== "text";
            if (o >= 200 && o < 300 && (a && t.response || t.responseText !== null)) {
                n.loading.end = Math.max(self.performance.now(), n.loading.first);
                const l = a ? t.response : t.responseText
                  , c = t.responseType === "arraybuffer" ? l.byteLength : l.length;
                if (n.loaded = n.total = c,
                n.bwEstimate = n.total * 8e3 / (n.loading.end - n.loading.first),
                !this.callbacks)
                    return;
                const u = this.callbacks.onProgress;
                if (u && u(n, e, l, t),
                !this.callbacks)
                    return;
                const d = {
                    url: t.responseURL,
                    data: l,
                    code: o
                };
                this.callbacks.onSuccess(d, n, e, t)
            } else {
                const l = r.loadPolicy.errorRetry
                  , c = n.retry
                  , u = {
                    url: e.url,
                    data: void 0,
                    code: o
                };
                Ip(l, c, !1, u) ? this.retry(l) : (de.error(`${o} while loading ${e.url}`),
                this.callbacks.onError({
                    code: o,
                    text: t.statusText
                }, e, t, n))
            }
        }
    }
    loadtimeout() {
        if (!this.config)
            return;
        const e = this.config.loadPolicy.timeoutRetry
          , t = this.stats.retry;
        if (Ip(e, t, !0))
            this.retry(e);
        else {
            var n;
            de.warn(`timeout while loading ${(n = this.context) == null ? void 0 : n.url}`);
            const s = this.callbacks;
            s && (this.abortInternal(),
            s.onTimeout(this.stats, this.context, this.loader))
        }
    }
    retry(e) {
        const {context: t, stats: n} = this;
        this.retryDelay = tx(e, n.retry),
        n.retry++,
        de.warn(`${status ? "HTTP Status " + status : "Timeout"} while loading ${t == null ? void 0 : t.url}, retrying ${n.retry}/${e.maxNumRetry} in ${this.retryDelay}ms`),
        this.abortInternal(),
        this.loader = null,
        self.clearTimeout(this.retryTimeout),
        this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay)
    }
    loadprogress(e) {
        const t = this.stats;
        t.loaded = e.loaded,
        e.lengthComputable && (t.total = e.total)
    }
    getCacheAge() {
        let e = null;
        if (this.loader && AW.test(this.loader.getAllResponseHeaders())) {
            const t = this.loader.getResponseHeader("age");
            e = t ? parseFloat(t) : null
        }
        return e
    }
    getResponseHeader(e) {
        return this.loader && new RegExp(`^${e}:\\s*[\\d.]+\\s*$`,"im").test(this.loader.getAllResponseHeaders()) ? this.loader.getResponseHeader(e) : null
    }
}
function CW() {
    if (self.fetch && self.AbortController && self.ReadableStream && self.Request)
        try {
            return new self.ReadableStream({}),
            !0
        } catch {}
    return !1
}
const MW = /(\d+)-(\d+)\/(\d+)/;
class PS {
    constructor(e) {
        this.fetchSetup = void 0,
        this.requestTimeout = void 0,
        this.request = null,
        this.response = null,
        this.controller = void 0,
        this.context = null,
        this.config = null,
        this.callbacks = null,
        this.stats = void 0,
        this.loader = null,
        this.fetchSetup = e.fetchSetup || kW,
        this.controller = new self.AbortController,
        this.stats = new Tm
    }
    destroy() {
        this.loader = this.callbacks = this.context = this.config = this.request = null,
        this.abortInternal(),
        this.response = null,
        this.fetchSetup = this.controller = this.stats = null
    }
    abortInternal() {
        this.controller && !this.stats.loading.end && (this.stats.aborted = !0,
        this.controller.abort())
    }
    abort() {
        var e;
        this.abortInternal(),
        (e = this.callbacks) != null && e.onAbort && this.callbacks.onAbort(this.stats, this.context, this.response)
    }
    load(e, t, n) {
        const s = this.stats;
        if (s.loading.start)
            throw new Error("Loader can only be used once.");
        s.loading.start = self.performance.now();
        const r = RW(e, this.controller.signal)
          , o = n.onProgress
          , a = e.responseType === "arraybuffer"
          , l = a ? "byteLength" : "length"
          , {maxTimeToFirstByteMs: c, maxLoadTimeMs: u} = t.loadPolicy;
        this.context = e,
        this.config = t,
        this.callbacks = n,
        this.request = this.fetchSetup(e, r),
        self.clearTimeout(this.requestTimeout),
        t.timeout = c && pt(c) ? c : u,
        this.requestTimeout = self.setTimeout( () => {
            this.abortInternal(),
            n.onTimeout(s, e, this.response)
        }
        , t.timeout),
        self.fetch(this.request).then(d => {
            this.response = this.loader = d;
            const f = Math.max(self.performance.now(), s.loading.start);
            if (self.clearTimeout(this.requestTimeout),
            t.timeout = u,
            this.requestTimeout = self.setTimeout( () => {
                this.abortInternal(),
                n.onTimeout(s, e, this.response)
            }
            , u - (f - s.loading.start)),
            !d.ok) {
                const {status: h, statusText: p} = d;
                throw new PW(p || "fetch, bad network response",h,d)
            }
            return s.loading.first = f,
            s.total = IW(d.headers) || s.total,
            o && pt(t.highWaterMark) ? this.loadProgressively(d, s, e, t.highWaterMark, o) : a ? d.arrayBuffer() : e.responseType === "json" ? d.json() : d.text()
        }
        ).then(d => {
            const f = this.response;
            if (!f)
                throw new Error("loader destroyed");
            self.clearTimeout(this.requestTimeout),
            s.loading.end = Math.max(self.performance.now(), s.loading.first);
            const h = d[l];
            h && (s.loaded = s.total = h);
            const p = {
                url: f.url,
                data: d,
                code: f.status
            };
            o && !pt(t.highWaterMark) && o(s, e, d, f),
            n.onSuccess(p, s, e, f)
        }
        ).catch(d => {
            if (self.clearTimeout(this.requestTimeout),
            s.aborted)
                return;
            const f = d && d.code || 0
              , h = d ? d.message : null;
            n.onError({
                code: f,
                text: h
            }, e, d ? d.details : null, s)
        }
        )
    }
    getCacheAge() {
        let e = null;
        if (this.response) {
            const t = this.response.headers.get("age");
            e = t ? parseFloat(t) : null
        }
        return e
    }
    getResponseHeader(e) {
        return this.response ? this.response.headers.get(e) : null
    }
    loadProgressively(e, t, n, s=0, r) {
        const o = new lM
          , a = e.body.getReader()
          , l = () => a.read().then(c => {
            if (c.done)
                return o.dataLength && r(t, n, o.flush(), e),
                Promise.resolve(new ArrayBuffer(0));
            const u = c.value
              , d = u.length;
            return t.loaded += d,
            d < s || o.dataLength ? (o.push(u),
            o.dataLength >= s && r(t, n, o.flush(), e)) : r(t, n, u, e),
            l()
        }
        ).catch( () => Promise.reject());
        return l()
    }
}
function RW(i, e) {
    const t = {
        method: "GET",
        mode: "cors",
        credentials: "same-origin",
        signal: e,
        headers: new self.Headers(Qn({}, i.headers))
    };
    return i.rangeEnd && t.headers.set("Range", "bytes=" + i.rangeStart + "-" + String(i.rangeEnd - 1)),
    t
}
function LW(i) {
    const e = MW.exec(i);
    if (e)
        return parseInt(e[2]) - parseInt(e[1]) + 1
}
function IW(i) {
    const e = i.get("Content-Range");
    if (e) {
        const n = LW(e);
        if (pt(n))
            return n
    }
    const t = i.get("Content-Length");
    if (t)
        return parseInt(t)
}
function kW(i, e) {
    return new self.Request(i.url,e)
}
class PW extends Error {
    constructor(e, t, n) {
        super(e),
        this.code = void 0,
        this.details = void 0,
        this.code = t,
        this.details = n
    }
}
const DW = /\s/
  , FW = {
    newCue(i, e, t, n) {
        const s = [];
        let r, o, a, l, c;
        const u = self.VTTCue || self.TextTrackCue;
        for (let f = 0; f < n.rows.length; f++)
            if (r = n.rows[f],
            a = !0,
            l = 0,
            c = "",
            !r.isEmpty()) {
                var d;
                for (let g = 0; g < r.chars.length; g++)
                    DW.test(r.chars[g].uchar) && a ? l++ : (c += r.chars[g].uchar,
                    a = !1);
                r.cueStartTime = e,
                e === t && (t += 1e-4),
                l >= 16 ? l-- : l++;
                const h = LM(c.trim())
                  , p = fx(e, t, h);
                i != null && (d = i.cues) != null && d.getCueById(p) || (o = new u(e,t,h),
                o.id = p,
                o.line = f + 1,
                o.align = "left",
                o.position = 10 + Math.min(80, Math.floor(l * 8 / 32) * 10),
                s.push(o))
            }
        return i && s.length && (s.sort( (f, h) => f.line === "auto" || h.line === "auto" ? 0 : f.line > 8 && h.line > 8 ? h.line - f.line : f.line - h.line),
        s.forEach(f => eM(i, f))),
        s
    }
}
  , OW = {
    maxTimeToFirstByteMs: 8e3,
    maxLoadTimeMs: 2e4,
    timeoutRetry: null,
    errorRetry: null
}
  , HM = yi(yi({
    autoStartLoad: !0,
    startPosition: -1,
    defaultAudioCodec: void 0,
    debug: !1,
    capLevelOnFPSDrop: !1,
    capLevelToPlayerSize: !1,
    ignoreDevicePixelRatio: !1,
    preferManagedMediaSource: !0,
    initialLiveManifestSize: 1,
    maxBufferLength: 30,
    backBufferLength: 1 / 0,
    frontBufferFlushThreshold: 1 / 0,
    maxBufferSize: 60 * 1e3 * 1e3,
    maxBufferHole: .1,
    highBufferWatchdogPeriod: 2,
    nudgeOffset: .1,
    nudgeMaxRetry: 3,
    maxFragLookUpTolerance: .25,
    liveSyncDurationCount: 3,
    liveMaxLatencyDurationCount: 1 / 0,
    liveSyncDuration: void 0,
    liveMaxLatencyDuration: void 0,
    maxLiveSyncPlaybackRate: 1,
    liveDurationInfinity: !1,
    liveBackBufferLength: null,
    maxMaxBufferLength: 600,
    enableWorker: !0,
    workerPath: null,
    enableSoftwareAES: !0,
    startLevel: void 0,
    startFragPrefetch: !1,
    fpsDroppedMonitoringPeriod: 5e3,
    fpsDroppedMonitoringThreshold: .2,
    appendErrorMaxRetry: 3,
    loader: $M,
    fLoader: void 0,
    pLoader: void 0,
    xhrSetup: void 0,
    licenseXhrSetup: void 0,
    licenseResponseCallback: void 0,
    abrController: cz,
    bufferController: hG,
    capLevelController: hx,
    errorController: ZH,
    fpsController: $G,
    stretchShortVideoTrack: !1,
    maxAudioFramesDrift: 1,
    forceKeyFrameOnDiscontinuity: !0,
    abrEwmaFastLive: 3,
    abrEwmaSlowLive: 9,
    abrEwmaFastVoD: 3,
    abrEwmaSlowVoD: 9,
    abrEwmaDefaultEstimate: 5e5,
    abrEwmaDefaultEstimateMax: 5e6,
    abrBandWidthFactor: .95,
    abrBandWidthUpFactor: .7,
    abrMaxWithRealBitrate: !1,
    maxStarvationDelay: 4,
    maxLoadingDelay: 4,
    minAutoBitrate: 0,
    emeEnabled: !1,
    widevineLicenseUrl: void 0,
    drmSystems: {},
    drmSystemOptions: {},
    requestMediaKeySystemAccessFunc: VC,
    testBandwidth: !0,
    progressive: !1,
    lowLatencyMode: !0,
    cmcd: void 0,
    enableDateRangeMetadataCues: !0,
    enableEmsgMetadataCues: !0,
    enableID3MetadataCues: !0,
    useMediaCapabilities: !0,
    certLoadPolicy: {
        default: OW
    },
    keyLoadPolicy: {
        default: {
            maxTimeToFirstByteMs: 8e3,
            maxLoadTimeMs: 2e4,
            timeoutRetry: {
                maxNumRetry: 1,
                retryDelayMs: 1e3,
                maxRetryDelayMs: 2e4,
                backoff: "linear"
            },
            errorRetry: {
                maxNumRetry: 8,
                retryDelayMs: 1e3,
                maxRetryDelayMs: 2e4,
                backoff: "linear"
            }
        }
    },
    manifestLoadPolicy: {
        default: {
            maxTimeToFirstByteMs: 1 / 0,
            maxLoadTimeMs: 2e4,
            timeoutRetry: {
                maxNumRetry: 2,
                retryDelayMs: 0,
                maxRetryDelayMs: 0
            },
            errorRetry: {
                maxNumRetry: 1,
                retryDelayMs: 1e3,
                maxRetryDelayMs: 8e3
            }
        }
    },
    playlistLoadPolicy: {
        default: {
            maxTimeToFirstByteMs: 1e4,
            maxLoadTimeMs: 2e4,
            timeoutRetry: {
                maxNumRetry: 2,
                retryDelayMs: 0,
                maxRetryDelayMs: 0
            },
            errorRetry: {
                maxNumRetry: 2,
                retryDelayMs: 1e3,
                maxRetryDelayMs: 8e3
            }
        }
    },
    fragLoadPolicy: {
        default: {
            maxTimeToFirstByteMs: 1e4,
            maxLoadTimeMs: 12e4,
            timeoutRetry: {
                maxNumRetry: 4,
                retryDelayMs: 0,
                maxRetryDelayMs: 0
            },
            errorRetry: {
                maxNumRetry: 6,
                retryDelayMs: 1e3,
                maxRetryDelayMs: 8e3
            }
        }
    },
    steeringManifestLoadPolicy: {
        default: {
            maxTimeToFirstByteMs: 1e4,
            maxLoadTimeMs: 2e4,
            timeoutRetry: {
                maxNumRetry: 2,
                retryDelayMs: 0,
                maxRetryDelayMs: 0
            },
            errorRetry: {
                maxNumRetry: 1,
                retryDelayMs: 1e3,
                maxRetryDelayMs: 8e3
            }
        }
    },
    manifestLoadingTimeOut: 1e4,
    manifestLoadingMaxRetry: 1,
    manifestLoadingRetryDelay: 1e3,
    manifestLoadingMaxRetryTimeout: 64e3,
    levelLoadingTimeOut: 1e4,
    levelLoadingMaxRetry: 4,
    levelLoadingRetryDelay: 1e3,
    levelLoadingMaxRetryTimeout: 64e3,
    fragLoadingTimeOut: 2e4,
    fragLoadingMaxRetry: 6,
    fragLoadingRetryDelay: 1e3,
    fragLoadingMaxRetryTimeout: 64e3
}, UW()), {}, {
    subtitleStreamController: cG,
    subtitleTrackController: dG,
    timelineController: BG,
    audioStreamController: aG,
    audioTrackController: lG,
    emeController: zc,
    cmcdController: EW,
    contentSteeringController: TW
});
function UW() {
    return {
        cueHandler: FW,
        enableWebVTT: !0,
        enableIMSC1: !0,
        enableCEA708Captions: !0,
        captionsTextTrack1Label: "English",
        captionsTextTrack1LanguageCode: "en",
        captionsTextTrack2Label: "Spanish",
        captionsTextTrack2LanguageCode: "es",
        captionsTextTrack3Label: "Unknown CC",
        captionsTextTrack3LanguageCode: "",
        captionsTextTrack4Label: "Unknown CC",
        captionsTextTrack4LanguageCode: "",
        renderTextTracksNatively: !0
    }
}
function NW(i, e) {
    if ((e.liveSyncDurationCount || e.liveMaxLatencyDurationCount) && (e.liveSyncDuration || e.liveMaxLatencyDuration))
        throw new Error("Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration");
    if (e.liveMaxLatencyDurationCount !== void 0 && (e.liveSyncDurationCount === void 0 || e.liveMaxLatencyDurationCount <= e.liveSyncDurationCount))
        throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be greater than "liveSyncDurationCount"');
    if (e.liveMaxLatencyDuration !== void 0 && (e.liveSyncDuration === void 0 || e.liveMaxLatencyDuration <= e.liveSyncDuration))
        throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be greater than "liveSyncDuration"');
    const t = Z1(i)
      , n = ["manifest", "level", "frag"]
      , s = ["TimeOut", "MaxRetry", "RetryDelay", "MaxRetryTimeout"];
    return n.forEach(r => {
        const o = `${r === "level" ? "playlist" : r}LoadPolicy`
          , a = e[o] === void 0
          , l = [];
        s.forEach(c => {
            const u = `${r}Loading${c}`
              , d = e[u];
            if (d !== void 0 && a) {
                l.push(u);
                const f = t[o].default;
                switch (e[o] = {
                    default: f
                },
                c) {
                case "TimeOut":
                    f.maxLoadTimeMs = d,
                    f.maxTimeToFirstByteMs = d;
                    break;
                case "MaxRetry":
                    f.errorRetry.maxNumRetry = d,
                    f.timeoutRetry.maxNumRetry = d;
                    break;
                case "RetryDelay":
                    f.errorRetry.retryDelayMs = d,
                    f.timeoutRetry.retryDelayMs = d;
                    break;
                case "MaxRetryTimeout":
                    f.errorRetry.maxRetryDelayMs = d,
                    f.timeoutRetry.maxRetryDelayMs = d;
                    break
                }
            }
        }
        ),
        l.length && de.warn(`hls.js config: "${l.join('", "')}" setting(s) are deprecated, use "${o}": ${JSON.stringify(e[o])}`)
    }
    ),
    yi(yi({}, t), e)
}
function Z1(i) {
    return i && typeof i == "object" ? Array.isArray(i) ? i.map(Z1) : Object.keys(i).reduce( (e, t) => (e[t] = Z1(i[t]),
    e), {}) : i
}
function BW(i) {
    const e = i.loader;
    e !== PS && e !== $M ? (de.log("[config]: Custom loader detected, cannot enable progressive streaming"),
    i.progressive = !1) : CW() && (i.loader = PS,
    i.progressive = !0,
    i.enableSoftwareAES = !0,
    de.log("[config]: Progressive streaming enabled, using FetchLoader"))
}
let V0;
class VW extends nx {
    constructor(e, t) {
        super(e, "[level-controller]"),
        this._levels = [],
        this._firstLevel = -1,
        this._maxAutoLevel = -1,
        this._startLevel = void 0,
        this.currentLevel = null,
        this.currentLevelIndex = -1,
        this.manualLevelIndex = -1,
        this.steering = void 0,
        this.onParsedComplete = void 0,
        this.steering = t,
        this._registerListeners()
    }
    _registerListeners() {
        const {hls: e} = this;
        e.on(P.MANIFEST_LOADING, this.onManifestLoading, this),
        e.on(P.MANIFEST_LOADED, this.onManifestLoaded, this),
        e.on(P.LEVEL_LOADED, this.onLevelLoaded, this),
        e.on(P.LEVELS_UPDATED, this.onLevelsUpdated, this),
        e.on(P.FRAG_BUFFERED, this.onFragBuffered, this),
        e.on(P.ERROR, this.onError, this)
    }
    _unregisterListeners() {
        const {hls: e} = this;
        e.off(P.MANIFEST_LOADING, this.onManifestLoading, this),
        e.off(P.MANIFEST_LOADED, this.onManifestLoaded, this),
        e.off(P.LEVEL_LOADED, this.onLevelLoaded, this),
        e.off(P.LEVELS_UPDATED, this.onLevelsUpdated, this),
        e.off(P.FRAG_BUFFERED, this.onFragBuffered, this),
        e.off(P.ERROR, this.onError, this)
    }
    destroy() {
        this._unregisterListeners(),
        this.steering = null,
        this.resetLevels(),
        super.destroy()
    }
    stopLoad() {
        this._levels.forEach(t => {
            t.loadError = 0,
            t.fragmentError = 0
        }
        ),
        super.stopLoad()
    }
    resetLevels() {
        this._startLevel = void 0,
        this.manualLevelIndex = -1,
        this.currentLevelIndex = -1,
        this.currentLevel = null,
        this._levels = [],
        this._maxAutoLevel = -1
    }
    onManifestLoading(e, t) {
        this.resetLevels()
    }
    onManifestLoaded(e, t) {
        const n = this.hls.config.preferManagedMediaSource
          , s = []
          , r = {}
          , o = {};
        let a = !1
          , l = !1
          , c = !1;
        t.levels.forEach(u => {
            var d, f;
            const h = u.attrs;
            let {audioCodec: p, videoCodec: g} = u;
            ((d = p) == null ? void 0 : d.indexOf("mp4a.40.34")) !== -1 && (V0 || (V0 = /chrome|firefox/i.test(navigator.userAgent)),
            V0 && (u.audioCodec = p = void 0)),
            p && (u.audioCodec = p = Mp(p, n)),
            ((f = g) == null ? void 0 : f.indexOf("avc1")) === 0 && (g = u.videoCodec = AH(g));
            const {width: m, height: v, unknownCodecs: _} = u;
            if (a || (a = !!(m && v)),
            l || (l = !!g),
            c || (c = !!p),
            _ != null && _.length || p && !T0(p, "audio", n) || g && !T0(g, "video", n))
                return;
            const {CODECS: y, "FRAME-RATE": b, "HDCP-LEVEL": S, "PATHWAY-ID": C, RESOLUTION: M, "VIDEO-RANGE": L} = h
              , A = `${`${C || "."}-`}${u.bitrate}-${M}-${b}-${y}-${L}-${S}`;
            if (r[A])
                if (r[A].uri !== u.url && !u.attrs["PATHWAY-ID"]) {
                    const k = o[A] += 1;
                    u.attrs["PATHWAY-ID"] = new Array(k + 1).join(".");
                    const D = new cu(u);
                    r[A] = D,
                    s.push(D)
                } else
                    r[A].addGroupId("audio", h.AUDIO),
                    r[A].addGroupId("text", h.SUBTITLES);
            else {
                const k = new cu(u);
                r[A] = k,
                o[A] = 1,
                s.push(k)
            }
        }
        ),
        this.filterAndSortMediaOptions(s, t, a, l, c)
    }
    filterAndSortMediaOptions(e, t, n, s, r) {
        let o = []
          , a = []
          , l = e;
        if ((n || s) && r && (l = l.filter( ({videoCodec: p, videoRange: g, width: m, height: v}) => (!!p || !!(m && v)) && BH(g))),
        l.length === 0) {
            Promise.resolve().then( () => {
                if (this.hls) {
                    t.levels.length && this.warn(`One or more CODECS in variant not supported: ${JSON.stringify(t.levels[0].attrs)}`);
                    const p = new Error("no level with compatible codecs found in manifest");
                    this.hls.trigger(P.ERROR, {
                        type: Ut.MEDIA_ERROR,
                        details: Ae.MANIFEST_INCOMPATIBLE_CODECS_ERROR,
                        fatal: !0,
                        url: t.url,
                        error: p,
                        reason: p.message
                    })
                }
            }
            );
            return
        }
        if (t.audioTracks) {
            const {preferManagedMediaSource: p} = this.hls.config;
            o = t.audioTracks.filter(g => !g.audioCodec || T0(g.audioCodec, "audio", p)),
            DS(o)
        }
        t.subtitles && (a = t.subtitles,
        DS(a));
        const c = l.slice(0);
        l.sort( (p, g) => {
            if (p.attrs["HDCP-LEVEL"] !== g.attrs["HDCP-LEVEL"])
                return (p.attrs["HDCP-LEVEL"] || "") > (g.attrs["HDCP-LEVEL"] || "") ? 1 : -1;
            if (n && p.height !== g.height)
                return p.height - g.height;
            if (p.frameRate !== g.frameRate)
                return p.frameRate - g.frameRate;
            if (p.videoRange !== g.videoRange)
                return Rp.indexOf(p.videoRange) - Rp.indexOf(g.videoRange);
            if (p.videoCodec !== g.videoCodec) {
                const m = $b(p.videoCodec)
                  , v = $b(g.videoCodec);
                if (m !== v)
                    return v - m
            }
            if (p.uri === g.uri && p.codecSet !== g.codecSet) {
                const m = Cp(p.codecSet)
                  , v = Cp(g.codecSet);
                if (m !== v)
                    return v - m
            }
            return p.averageBitrate !== g.averageBitrate ? p.averageBitrate - g.averageBitrate : 0
        }
        );
        let u = c[0];
        if (this.steering && (l = this.steering.filterParsedLevels(l),
        l.length !== c.length)) {
            for (let p = 0; p < c.length; p++)
                if (c[p].pathwayId === l[0].pathwayId) {
                    u = c[p];
                    break
                }
        }
        this._levels = l;
        for (let p = 0; p < l.length; p++)
            if (l[p] === u) {
                var d;
                this._firstLevel = p;
                const g = u.bitrate
                  , m = this.hls.bandwidthEstimate;
                if (this.log(`manifest loaded, ${l.length} level(s) found, first bitrate: ${g}`),
                ((d = this.hls.userConfig) == null ? void 0 : d.abrEwmaDefaultEstimate) === void 0) {
                    const v = Math.min(g, this.hls.config.abrEwmaDefaultEstimateMax);
                    v > m && m === HM.abrEwmaDefaultEstimate && (this.hls.bandwidthEstimate = v)
                }
                break
            }
        const f = r && !s
          , h = {
            levels: l,
            audioTracks: o,
            subtitleTracks: a,
            sessionData: t.sessionData,
            sessionKeys: t.sessionKeys,
            firstLevel: this._firstLevel,
            stats: t.stats,
            audio: r,
            video: s,
            altAudio: !f && o.some(p => !!p.url)
        };
        this.hls.trigger(P.MANIFEST_PARSED, h),
        (this.hls.config.autoStartLoad || this.hls.forceStartLoad) && this.hls.startLoad(this.hls.config.startPosition)
    }
    get levels() {
        return this._levels.length === 0 ? null : this._levels
    }
    get level() {
        return this.currentLevelIndex
    }
    set level(e) {
        const t = this._levels;
        if (t.length === 0)
            return;
        if (e < 0 || e >= t.length) {
            const u = new Error("invalid level idx")
              , d = e < 0;
            if (this.hls.trigger(P.ERROR, {
                type: Ut.OTHER_ERROR,
                details: Ae.LEVEL_SWITCH_ERROR,
                level: e,
                fatal: d,
                error: u,
                reason: u.message
            }),
            d)
                return;
            e = Math.min(e, t.length - 1)
        }
        const n = this.currentLevelIndex
          , s = this.currentLevel
          , r = s ? s.attrs["PATHWAY-ID"] : void 0
          , o = t[e]
          , a = o.attrs["PATHWAY-ID"];
        if (this.currentLevelIndex = e,
        this.currentLevel = o,
        n === e && o.details && s && r === a)
            return;
        this.log(`Switching to level ${e} (${o.height ? o.height + "p " : ""}${o.videoRange ? o.videoRange + " " : ""}${o.codecSet ? o.codecSet + " " : ""}@${o.bitrate})${a ? " with Pathway " + a : ""} from level ${n}${r ? " with Pathway " + r : ""}`);
        const l = {
            level: e,
            attrs: o.attrs,
            details: o.details,
            bitrate: o.bitrate,
            averageBitrate: o.averageBitrate,
            maxBitrate: o.maxBitrate,
            realBitrate: o.realBitrate,
            width: o.width,
            height: o.height,
            codecSet: o.codecSet,
            audioCodec: o.audioCodec,
            videoCodec: o.videoCodec,
            audioGroups: o.audioGroups,
            subtitleGroups: o.subtitleGroups,
            loaded: o.loaded,
            loadError: o.loadError,
            fragmentError: o.fragmentError,
            name: o.name,
            id: o.id,
            uri: o.uri,
            url: o.url,
            urlId: 0,
            audioGroupIds: o.audioGroupIds,
            textGroupIds: o.textGroupIds
        };
        this.hls.trigger(P.LEVEL_SWITCHING, l);
        const c = o.details;
        if (!c || c.live) {
            const u = this.switchParams(o.uri, s == null ? void 0 : s.details, c);
            this.loadPlaylist(u)
        }
    }
    get manualLevel() {
        return this.manualLevelIndex
    }
    set manualLevel(e) {
        this.manualLevelIndex = e,
        this._startLevel === void 0 && (this._startLevel = e),
        e !== -1 && (this.level = e)
    }
    get firstLevel() {
        return this._firstLevel
    }
    set firstLevel(e) {
        this._firstLevel = e
    }
    get startLevel() {
        if (this._startLevel === void 0) {
            const e = this.hls.config.startLevel;
            return e !== void 0 ? e : this.hls.firstAutoLevel
        }
        return this._startLevel
    }
    set startLevel(e) {
        this._startLevel = e
    }
    onError(e, t) {
        t.fatal || !t.context || t.context.type === en.LEVEL && t.context.level === this.level && this.checkRetry(t)
    }
    onFragBuffered(e, {frag: t}) {
        if (t !== void 0 && t.type === Ct.MAIN) {
            const n = t.elementaryStreams;
            if (!Object.keys(n).some(r => !!n[r]))
                return;
            const s = this._levels[t.level];
            s != null && s.loadError && (this.log(`Resetting level error count of ${s.loadError} on frag buffered`),
            s.loadError = 0)
        }
    }
    onLevelLoaded(e, t) {
        var n;
        const {level: s, details: r} = t
          , o = this._levels[s];
        if (!o) {
            var a;
            this.warn(`Invalid level index ${s}`),
            (a = t.deliveryDirectives) != null && a.skip && (r.deltaUpdateFailed = !0);
            return
        }
        s === this.currentLevelIndex ? (o.fragmentError === 0 && (o.loadError = 0),
        this.playlistLoaded(s, t, o.details)) : (n = t.deliveryDirectives) != null && n.skip && (r.deltaUpdateFailed = !0)
    }
    loadPlaylist(e) {
        super.loadPlaylist();
        const t = this.currentLevelIndex
          , n = this.currentLevel;
        if (n && this.shouldLoadPlaylist(n)) {
            let s = n.uri;
            if (e)
                try {
                    s = e.addDirectives(s)
                } catch (o) {
                    this.warn(`Could not construct new URL with HLS Delivery Directives: ${o}`)
                }
            const r = n.attrs["PATHWAY-ID"];
            this.log(`Loading level index ${t}${(e == null ? void 0 : e.msn) !== void 0 ? " at sn " + e.msn + " part " + e.part : ""} with${r ? " Pathway " + r : ""} ${s}`),
            this.clearTimer(),
            this.hls.trigger(P.LEVEL_LOADING, {
                url: s,
                level: t,
                pathwayId: n.attrs["PATHWAY-ID"],
                id: 0,
                deliveryDirectives: e || null
            })
        }
    }
    get nextLoadLevel() {
        return this.manualLevelIndex !== -1 ? this.manualLevelIndex : this.hls.nextAutoLevel
    }
    set nextLoadLevel(e) {
        this.level = e,
        this.manualLevelIndex === -1 && (this.hls.nextAutoLevel = e)
    }
    removeLevel(e) {
        var t;
        const n = this._levels.filter( (s, r) => r !== e ? !0 : (this.steering && this.steering.removeLevel(s),
        s === this.currentLevel && (this.currentLevel = null,
        this.currentLevelIndex = -1,
        s.details && s.details.fragments.forEach(o => o.level = -1)),
        !1));
        sM(n),
        this._levels = n,
        this.currentLevelIndex > -1 && (t = this.currentLevel) != null && t.details && (this.currentLevelIndex = this.currentLevel.details.fragments[0].level),
        this.hls.trigger(P.LEVELS_UPDATED, {
            levels: n
        })
    }
    onLevelsUpdated(e, {levels: t}) {
        this._levels = t
    }
    checkMaxAutoUpdated() {
        const {autoLevelCapping: e, maxAutoLevel: t, maxHdcpLevel: n} = this.hls;
        this._maxAutoLevel !== t && (this._maxAutoLevel = t,
        this.hls.trigger(P.MAX_AUTO_LEVEL_UPDATED, {
            autoLevelCapping: e,
            levels: this.levels,
            maxAutoLevel: t,
            minAutoLevel: this.hls.minAutoLevel,
            maxHdcpLevel: n
        }))
    }
}
function DS(i) {
    const e = {};
    i.forEach(t => {
        const n = t.groupId || "";
        t.id = e[n] = e[n] || 0,
        e[n]++
    }
    )
}
class $W {
    constructor(e) {
        this.config = void 0,
        this.keyUriToKeyInfo = {},
        this.emeController = null,
        this.config = e
    }
    abort(e) {
        for (const n in this.keyUriToKeyInfo) {
            const s = this.keyUriToKeyInfo[n].loader;
            if (s) {
                var t;
                if (e && e !== ((t = s.context) == null ? void 0 : t.frag.type))
                    return;
                s.abort()
            }
        }
    }
    detach() {
        for (const e in this.keyUriToKeyInfo) {
            const t = this.keyUriToKeyInfo[e];
            (t.mediaKeySessionContext || t.decryptdata.isCommonEncryption) && delete this.keyUriToKeyInfo[e]
        }
    }
    destroy() {
        this.detach();
        for (const e in this.keyUriToKeyInfo) {
            const t = this.keyUriToKeyInfo[e].loader;
            t && t.destroy()
        }
        this.keyUriToKeyInfo = {}
    }
    createKeyLoadError(e, t=Ae.KEY_LOAD_ERROR, n, s, r) {
        return new _o({
            type: Ut.NETWORK_ERROR,
            details: t,
            fatal: !1,
            frag: e,
            response: r,
            error: n,
            networkDetails: s
        })
    }
    loadClear(e, t) {
        if (this.emeController && this.config.emeEnabled) {
            const {sn: n, cc: s} = e;
            for (let r = 0; r < t.length; r++) {
                const o = t[r];
                if (s <= o.cc && (n === "initSegment" || o.sn === "initSegment" || n < o.sn)) {
                    this.emeController.selectKeySystemFormat(o).then(a => {
                        o.setKeyFormat(a)
                    }
                    );
                    break
                }
            }
        }
    }
    load(e) {
        return !e.decryptdata && e.encrypted && this.emeController ? this.emeController.selectKeySystemFormat(e).then(t => this.loadInternal(e, t)) : this.loadInternal(e)
    }
    loadInternal(e, t) {
        var n, s;
        t && e.setKeyFormat(t);
        const r = e.decryptdata;
        if (!r) {
            const c = new Error(t ? `Expected frag.decryptdata to be defined after setting format ${t}` : "Missing decryption data on fragment in onKeyLoading");
            return Promise.reject(this.createKeyLoadError(e, Ae.KEY_LOAD_ERROR, c))
        }
        const o = r.uri;
        if (!o)
            return Promise.reject(this.createKeyLoadError(e, Ae.KEY_LOAD_ERROR, new Error(`Invalid key URI: "${o}"`)));
        let a = this.keyUriToKeyInfo[o];
        if ((n = a) != null && n.decryptdata.key)
            return r.key = a.decryptdata.key,
            Promise.resolve({
                frag: e,
                keyInfo: a
            });
        if ((s = a) != null && s.keyLoadPromise) {
            var l;
            switch ((l = a.mediaKeySessionContext) == null ? void 0 : l.keyStatus) {
            case void 0:
            case "status-pending":
            case "usable":
            case "usable-in-future":
                return a.keyLoadPromise.then(c => (r.key = c.keyInfo.decryptdata.key,
                {
                    frag: e,
                    keyInfo: a
                }))
            }
        }
        switch (a = this.keyUriToKeyInfo[o] = {
            decryptdata: r,
            keyLoadPromise: null,
            loader: null,
            mediaKeySessionContext: null
        },
        r.method) {
        case "ISO-23001-7":
        case "SAMPLE-AES":
        case "SAMPLE-AES-CENC":
        case "SAMPLE-AES-CTR":
            return r.keyFormat === "identity" ? this.loadKeyHTTP(a, e) : this.loadKeyEME(a, e);
        case "AES-128":
            return this.loadKeyHTTP(a, e);
        default:
            return Promise.reject(this.createKeyLoadError(e, Ae.KEY_LOAD_ERROR, new Error(`Key supplied with unsupported METHOD: "${r.method}"`)))
        }
    }
    loadKeyEME(e, t) {
        const n = {
            frag: t,
            keyInfo: e
        };
        if (this.emeController && this.config.emeEnabled) {
            const s = this.emeController.loadKey(n);
            if (s)
                return (e.keyLoadPromise = s.then(r => (e.mediaKeySessionContext = r,
                n))).catch(r => {
                    throw e.keyLoadPromise = null,
                    r
                }
                )
        }
        return Promise.resolve(n)
    }
    loadKeyHTTP(e, t) {
        const n = this.config
          , s = n.loader
          , r = new s(n);
        return t.keyLoader = e.loader = r,
        e.keyLoadPromise = new Promise( (o, a) => {
            const l = {
                keyInfo: e,
                frag: t,
                responseType: "arraybuffer",
                url: e.decryptdata.uri
            }
              , c = n.keyLoadPolicy.default
              , u = {
                loadPolicy: c,
                timeout: c.maxLoadTimeMs,
                maxRetry: 0,
                retryDelay: 0,
                maxRetryDelay: 0
            }
              , d = {
                onSuccess: (f, h, p, g) => {
                    const {frag: m, keyInfo: v, url: _} = p;
                    if (!m.decryptdata || v !== this.keyUriToKeyInfo[_])
                        return a(this.createKeyLoadError(m, Ae.KEY_LOAD_ERROR, new Error("after key load, decryptdata unset or changed"), g));
                    v.decryptdata.key = m.decryptdata.key = new Uint8Array(f.data),
                    m.keyLoader = null,
                    v.loader = null,
                    o({
                        frag: m,
                        keyInfo: v
                    })
                }
                ,
                onError: (f, h, p, g) => {
                    this.resetLoader(h),
                    a(this.createKeyLoadError(t, Ae.KEY_LOAD_ERROR, new Error(`HTTP Error ${f.code} loading key ${f.text}`), p, yi({
                        url: l.url,
                        data: void 0
                    }, f)))
                }
                ,
                onTimeout: (f, h, p) => {
                    this.resetLoader(h),
                    a(this.createKeyLoadError(t, Ae.KEY_LOAD_TIMEOUT, new Error("key loading timed out"), p))
                }
                ,
                onAbort: (f, h, p) => {
                    this.resetLoader(h),
                    a(this.createKeyLoadError(t, Ae.INTERNAL_ABORTED, new Error("key loading aborted"), p))
                }
            };
            r.load(l, u, d)
        }
        )
    }
    resetLoader(e) {
        const {frag: t, keyInfo: n, url: s} = e
          , r = n.loader;
        t.keyLoader === r && (t.keyLoader = null,
        n.loader = null),
        delete this.keyUriToKeyInfo[s],
        r && r.destroy()
    }
}
function zM() {
    return self.SourceBuffer || self.WebKitSourceBuffer
}
function GM() {
    if (!kl())
        return !1;
    const e = zM();
    return !e || e.prototype && typeof e.prototype.appendBuffer == "function" && typeof e.prototype.remove == "function"
}
function HW() {
    if (!GM())
        return !1;
    const i = kl();
    return typeof (i == null ? void 0 : i.isTypeSupported) == "function" && (["avc1.42E01E,mp4a.40.2", "av01.0.01M.08", "vp09.00.50.08"].some(e => i.isTypeSupported(Ud(e, "video"))) || ["mp4a.40.2", "fLaC"].some(e => i.isTypeSupported(Ud(e, "audio"))))
}
function zW() {
    var i;
    const e = zM();
    return typeof (e == null || (i = e.prototype) == null ? void 0 : i.changeType) == "function"
}
const GW = 250
  , Dh = 2
  , WW = .1
  , qW = .05;
class jW {
    constructor(e, t, n, s) {
        this.config = void 0,
        this.media = null,
        this.fragmentTracker = void 0,
        this.hls = void 0,
        this.nudgeRetry = 0,
        this.stallReported = !1,
        this.stalled = null,
        this.moved = !1,
        this.seeking = !1,
        this.config = e,
        this.media = t,
        this.fragmentTracker = n,
        this.hls = s
    }
    destroy() {
        this.media = null,
        this.hls = this.fragmentTracker = null
    }
    poll(e, t) {
        const {config: n, media: s, stalled: r} = this;
        if (s === null)
            return;
        const {currentTime: o, seeking: a} = s
          , l = this.seeking && !a
          , c = !this.seeking && a;
        if (this.seeking = a,
        o !== e) {
            if (this.moved = !0,
            a || (this.nudgeRetry = 0),
            r !== null) {
                if (this.stallReported) {
                    const m = self.performance.now() - r;
                    de.warn(`playback not stuck anymore @${o}, after ${Math.round(m)}ms`),
                    this.stallReported = !1
                }
                this.stalled = null
            }
            return
        }
        if (c || l) {
            this.stalled = null;
            return
        }
        if (s.paused && !a || s.ended || s.playbackRate === 0 || !An.getBuffered(s).length) {
            this.nudgeRetry = 0;
            return
        }
        const u = An.bufferInfo(s, o, 0)
          , d = u.nextStart || 0;
        if (a) {
            const m = u.len > Dh
              , v = !d || t && t.start <= o || d - o > Dh && !this.fragmentTracker.getPartialFragment(o);
            if (m || v)
                return;
            this.moved = !1
        }
        if (!this.moved && this.stalled !== null) {
            var f;
            if (!(u.len > 0) && !d)
                return;
            const v = Math.max(d, u.start || 0) - o
              , _ = this.hls.levels ? this.hls.levels[this.hls.currentLevel] : null
              , b = (_ == null || (f = _.details) == null ? void 0 : f.live) ? _.details.targetduration * 2 : Dh
              , S = this.fragmentTracker.getPartialFragment(o);
            if (v > 0 && (v <= b || S)) {
                s.paused || this._trySkipBufferHole(S);
                return
            }
        }
        const h = self.performance.now();
        if (r === null) {
            this.stalled = h;
            return
        }
        const p = h - r;
        if (!a && p >= GW && (this._reportStall(u),
        !this.media))
            return;
        const g = An.bufferInfo(s, o, n.maxBufferHole);
        this._tryFixBufferStall(g, p)
    }
    _tryFixBufferStall(e, t) {
        const {config: n, fragmentTracker: s, media: r} = this;
        if (r === null)
            return;
        const o = r.currentTime
          , a = s.getPartialFragment(o);
        a && (this._trySkipBufferHole(a) || !this.media) || (e.len > n.maxBufferHole || e.nextStart && e.nextStart - o < n.maxBufferHole) && t > n.highBufferWatchdogPeriod * 1e3 && (de.warn("Trying to nudge playhead over buffer-hole"),
        this.stalled = null,
        this._tryNudgeBuffer())
    }
    _reportStall(e) {
        const {hls: t, media: n, stallReported: s} = this;
        if (!s && n) {
            this.stallReported = !0;
            const r = new Error(`Playback stalling at @${n.currentTime} due to low buffer (${JSON.stringify(e)})`);
            de.warn(r.message),
            t.trigger(P.ERROR, {
                type: Ut.MEDIA_ERROR,
                details: Ae.BUFFER_STALLED_ERROR,
                fatal: !1,
                error: r,
                buffer: e.len
            })
        }
    }
    _trySkipBufferHole(e) {
        const {config: t, hls: n, media: s} = this;
        if (s === null)
            return 0;
        const r = s.currentTime
          , o = An.bufferInfo(s, r, 0)
          , a = r < o.start ? o.start : o.nextStart;
        if (a) {
            const l = o.len <= t.maxBufferHole
              , c = o.len > 0 && o.len < 1 && s.readyState < 3
              , u = a - r;
            if (u > 0 && (l || c)) {
                if (u > t.maxBufferHole) {
                    const {fragmentTracker: f} = this;
                    let h = !1;
                    if (r === 0) {
                        const p = f.getAppendedFrag(0, Ct.MAIN);
                        p && a < p.end && (h = !0)
                    }
                    if (!h) {
                        const p = e || f.getAppendedFrag(r, Ct.MAIN);
                        if (p) {
                            let g = !1
                              , m = p.end;
                            for (; m < a; ) {
                                const v = f.getPartialFragment(m);
                                if (v)
                                    m += v.duration;
                                else {
                                    g = !0;
                                    break
                                }
                            }
                            if (g)
                                return 0
                        }
                    }
                }
                const d = Math.max(a + qW, r + WW);
                if (de.warn(`skipping hole, adjusting currentTime from ${r} to ${d}`),
                this.moved = !0,
                this.stalled = null,
                s.currentTime = d,
                e && !e.gap) {
                    const f = new Error(`fragment loaded with buffer holes, seeking from ${r} to ${d}`);
                    n.trigger(P.ERROR, {
                        type: Ut.MEDIA_ERROR,
                        details: Ae.BUFFER_SEEK_OVER_HOLE,
                        fatal: !1,
                        error: f,
                        reason: f.message,
                        frag: e
                    })
                }
                return d
            }
        }
        return 0
    }
    _tryNudgeBuffer() {
        const {config: e, hls: t, media: n, nudgeRetry: s} = this;
        if (n === null)
            return;
        const r = n.currentTime;
        if (this.nudgeRetry++,
        s < e.nudgeMaxRetry) {
            const o = r + (s + 1) * e.nudgeOffset
              , a = new Error(`Nudging 'currentTime' from ${r} to ${o}`);
            de.warn(a.message),
            n.currentTime = o,
            t.trigger(P.ERROR, {
                type: Ut.MEDIA_ERROR,
                details: Ae.BUFFER_NUDGE_ON_STALL,
                error: a,
                fatal: !1
            })
        } else {
            const o = new Error(`Playhead still not moving while enough data buffered @${r} after ${e.nudgeMaxRetry} nudges`);
            de.error(o.message),
            t.trigger(P.ERROR, {
                type: Ut.MEDIA_ERROR,
                details: Ae.BUFFER_STALLED_ERROR,
                error: o,
                fatal: !0
            })
        }
    }
}
const KW = 100;
class XW extends rx {
    constructor(e, t, n) {
        super(e, t, n, "[stream-controller]", Ct.MAIN),
        this.audioCodecSwap = !1,
        this.gapController = null,
        this.level = -1,
        this._forceStartLoad = !1,
        this.altAudio = !1,
        this.audioOnly = !1,
        this.fragPlaying = null,
        this.onvplaying = null,
        this.onvseeked = null,
        this.fragLastKbps = 0,
        this.couldBacktrack = !1,
        this.backtrackFragment = null,
        this.audioCodecSwitch = !1,
        this.videoBuffer = null,
        this._registerListeners()
    }
    _registerListeners() {
        const {hls: e} = this;
        e.on(P.MEDIA_ATTACHED, this.onMediaAttached, this),
        e.on(P.MEDIA_DETACHING, this.onMediaDetaching, this),
        e.on(P.MANIFEST_LOADING, this.onManifestLoading, this),
        e.on(P.MANIFEST_PARSED, this.onManifestParsed, this),
        e.on(P.LEVEL_LOADING, this.onLevelLoading, this),
        e.on(P.LEVEL_LOADED, this.onLevelLoaded, this),
        e.on(P.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this),
        e.on(P.ERROR, this.onError, this),
        e.on(P.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this),
        e.on(P.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this),
        e.on(P.BUFFER_CREATED, this.onBufferCreated, this),
        e.on(P.BUFFER_FLUSHED, this.onBufferFlushed, this),
        e.on(P.LEVELS_UPDATED, this.onLevelsUpdated, this),
        e.on(P.FRAG_BUFFERED, this.onFragBuffered, this)
    }
    _unregisterListeners() {
        const {hls: e} = this;
        e.off(P.MEDIA_ATTACHED, this.onMediaAttached, this),
        e.off(P.MEDIA_DETACHING, this.onMediaDetaching, this),
        e.off(P.MANIFEST_LOADING, this.onManifestLoading, this),
        e.off(P.MANIFEST_PARSED, this.onManifestParsed, this),
        e.off(P.LEVEL_LOADED, this.onLevelLoaded, this),
        e.off(P.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this),
        e.off(P.ERROR, this.onError, this),
        e.off(P.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this),
        e.off(P.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this),
        e.off(P.BUFFER_CREATED, this.onBufferCreated, this),
        e.off(P.BUFFER_FLUSHED, this.onBufferFlushed, this),
        e.off(P.LEVELS_UPDATED, this.onLevelsUpdated, this),
        e.off(P.FRAG_BUFFERED, this.onFragBuffered, this)
    }
    onHandlerDestroying() {
        this._unregisterListeners(),
        super.onHandlerDestroying()
    }
    startLoad(e) {
        if (this.levels) {
            const {lastCurrentTime: t, hls: n} = this;
            if (this.stopLoad(),
            this.setInterval(KW),
            this.level = -1,
            !this.startFragRequested) {
                let s = n.startLevel;
                s === -1 && (n.config.testBandwidth && this.levels.length > 1 ? (s = 0,
                this.bitrateTest = !0) : s = n.firstAutoLevel),
                n.nextLoadLevel = s,
                this.level = n.loadLevel,
                this.loadedmetadata = !1
            }
            t > 0 && e === -1 && (this.log(`Override startPosition with lastCurrentTime @${t.toFixed(3)}`),
            e = t),
            this.state = Ve.IDLE,
            this.nextLoadPosition = this.startPosition = this.lastCurrentTime = e,
            this.tick()
        } else
            this._forceStartLoad = !0,
            this.state = Ve.STOPPED
    }
    stopLoad() {
        this._forceStartLoad = !1,
        super.stopLoad()
    }
    doTick() {
        switch (this.state) {
        case Ve.WAITING_LEVEL:
            {
                const {levels: t, level: n} = this
                  , s = t == null ? void 0 : t[n]
                  , r = s == null ? void 0 : s.details;
                if (r && (!r.live || this.levelLastLoaded === s)) {
                    if (this.waitForCdnTuneIn(r))
                        break;
                    this.state = Ve.IDLE;
                    break
                } else if (this.hls.nextLoadLevel !== this.level) {
                    this.state = Ve.IDLE;
                    break
                }
                break
            }
        case Ve.FRAG_LOADING_WAITING_RETRY:
            {
                var e;
                const t = self.performance.now()
                  , n = this.retryDate;
                if (!n || t >= n || (e = this.media) != null && e.seeking) {
                    const {levels: s, level: r} = this
                      , o = s == null ? void 0 : s[r];
                    this.resetStartWhenNotLoaded(o || null),
                    this.state = Ve.IDLE
                }
            }
            break
        }
        this.state === Ve.IDLE && this.doTickIdle(),
        this.onTickEnd()
    }
    onTickEnd() {
        super.onTickEnd(),
        this.checkBuffer(),
        this.checkFragmentChanged()
    }
    doTickIdle() {
        const {hls: e, levelLastLoaded: t, levels: n, media: s} = this;
        if (t === null || !s && (this.startFragRequested || !e.config.startFragPrefetch) || this.altAudio && this.audioOnly)
            return;
        const r = e.nextLoadLevel;
        if (!(n != null && n[r]))
            return;
        const o = n[r]
          , a = this.getMainFwdBufferInfo();
        if (a === null)
            return;
        const l = this.getLevelDetails();
        if (l && this._streamEnded(a, l)) {
            const g = {};
            this.altAudio && (g.type = "video"),
            this.hls.trigger(P.BUFFER_EOS, g),
            this.state = Ve.ENDED;
            return
        }
        e.loadLevel !== r && e.manualLevel === -1 && this.log(`Adapting to level ${r} from level ${this.level}`),
        this.level = e.nextLoadLevel = r;
        const c = o.details;
        if (!c || this.state === Ve.WAITING_LEVEL || c.live && this.levelLastLoaded !== o) {
            this.level = r,
            this.state = Ve.WAITING_LEVEL;
            return
        }
        const u = a.len
          , d = this.getMaxBufferLength(o.maxBitrate);
        if (u >= d)
            return;
        this.backtrackFragment && this.backtrackFragment.start > a.end && (this.backtrackFragment = null);
        const f = this.backtrackFragment ? this.backtrackFragment.start : a.end;
        let h = this.getNextFragment(f, c);
        if (this.couldBacktrack && !this.fragPrevious && h && h.sn !== "initSegment" && this.fragmentTracker.getState(h) !== gi.OK) {
            var p;
            const m = ((p = this.backtrackFragment) != null ? p : h).sn - c.startSN
              , v = c.fragments[m - 1];
            v && h.cc === v.cc && (h = v,
            this.fragmentTracker.removeFragment(v))
        } else
            this.backtrackFragment && a.len && (this.backtrackFragment = null);
        if (h && this.isLoopLoading(h, f)) {
            if (!h.gap) {
                const m = this.audioOnly && !this.altAudio ? gn.AUDIO : gn.VIDEO
                  , v = (m === gn.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;
                v && this.afterBufferFlushed(v, m, Ct.MAIN)
            }
            h = this.getNextFragmentLoopLoading(h, c, a, Ct.MAIN, d)
        }
        !h || (h.initSegment && !h.initSegment.data && !this.bitrateTest && (h = h.initSegment),
        this.loadFragment(h, o, f))
    }
    loadFragment(e, t, n) {
        const s = this.fragmentTracker.getState(e);
        this.fragCurrent = e,
        s === gi.NOT_LOADED || s === gi.PARTIAL ? e.sn === "initSegment" ? this._loadInitSegment(e, t) : this.bitrateTest ? (this.log(`Fragment ${e.sn} of level ${e.level} is being downloaded to test bitrate and will not be buffered`),
        this._loadBitrateTestFrag(e, t)) : (this.startFragRequested = !0,
        super.loadFragment(e, t, n)) : this.clearTrackerIfNeeded(e)
    }
    getBufferedFrag(e) {
        return this.fragmentTracker.getBufferedFrag(e, Ct.MAIN)
    }
    followingBufferedFrag(e) {
        return e ? this.getBufferedFrag(e.end + .5) : null
    }
    immediateLevelSwitch() {
        this.abortCurrentFrag(),
        this.flushMainBuffer(0, Number.POSITIVE_INFINITY)
    }
    nextLevelSwitch() {
        const {levels: e, media: t} = this;
        if (t != null && t.readyState) {
            let n;
            const s = this.getAppendedFrag(t.currentTime);
            s && s.start > 1 && this.flushMainBuffer(0, s.start - 1);
            const r = this.getLevelDetails();
            if (r != null && r.live) {
                const a = this.getMainFwdBufferInfo();
                if (!a || a.len < r.targetduration * 2)
                    return
            }
            if (!t.paused && e) {
                const a = this.hls.nextLoadLevel
                  , l = e[a]
                  , c = this.fragLastKbps;
                c && this.fragCurrent ? n = this.fragCurrent.duration * l.maxBitrate / (1e3 * c) + 1 : n = 0
            } else
                n = 0;
            const o = this.getBufferedFrag(t.currentTime + n);
            if (o) {
                const a = this.followingBufferedFrag(o);
                if (a) {
                    this.abortCurrentFrag();
                    const l = a.maxStartPTS ? a.maxStartPTS : a.start
                      , c = a.duration
                      , u = Math.max(o.end, l + Math.min(Math.max(c - this.config.maxFragLookUpTolerance, c * (this.couldBacktrack ? .5 : .125)), c * (this.couldBacktrack ? .75 : .25)));
                    this.flushMainBuffer(u, Number.POSITIVE_INFINITY)
                }
            }
        }
    }
    abortCurrentFrag() {
        const e = this.fragCurrent;
        switch (this.fragCurrent = null,
        this.backtrackFragment = null,
        e && (e.abortRequests(),
        this.fragmentTracker.removeFragment(e)),
        this.state) {
        case Ve.KEY_LOADING:
        case Ve.FRAG_LOADING:
        case Ve.FRAG_LOADING_WAITING_RETRY:
        case Ve.PARSING:
        case Ve.PARSED:
            this.state = Ve.IDLE;
            break
        }
        this.nextLoadPosition = this.getLoadPosition()
    }
    flushMainBuffer(e, t) {
        super.flushMainBuffer(e, t, this.altAudio ? "video" : null)
    }
    onMediaAttached(e, t) {
        super.onMediaAttached(e, t);
        const n = t.media;
        this.onvplaying = this.onMediaPlaying.bind(this),
        this.onvseeked = this.onMediaSeeked.bind(this),
        n.addEventListener("playing", this.onvplaying),
        n.addEventListener("seeked", this.onvseeked),
        this.gapController = new jW(this.config,n,this.fragmentTracker,this.hls)
    }
    onMediaDetaching() {
        const {media: e} = this;
        e && this.onvplaying && this.onvseeked && (e.removeEventListener("playing", this.onvplaying),
        e.removeEventListener("seeked", this.onvseeked),
        this.onvplaying = this.onvseeked = null,
        this.videoBuffer = null),
        this.fragPlaying = null,
        this.gapController && (this.gapController.destroy(),
        this.gapController = null),
        super.onMediaDetaching()
    }
    onMediaPlaying() {
        this.tick()
    }
    onMediaSeeked() {
        const e = this.media
          , t = e ? e.currentTime : null;
        pt(t) && this.log(`Media seeked to ${t.toFixed(3)}`);
        const n = this.getMainFwdBufferInfo();
        if (n === null || n.len === 0) {
            this.warn(`Main forward buffer length on "seeked" event ${n ? n.len : "empty"})`);
            return
        }
        this.tick()
    }
    onManifestLoading() {
        this.log("Trigger BUFFER_RESET"),
        this.hls.trigger(P.BUFFER_RESET, void 0),
        this.fragmentTracker.removeAllFragments(),
        this.couldBacktrack = !1,
        this.startPosition = this.lastCurrentTime = this.fragLastKbps = 0,
        this.levels = this.fragPlaying = this.backtrackFragment = this.levelLastLoaded = null,
        this.altAudio = this.audioOnly = this.startFragRequested = !1
    }
    onManifestParsed(e, t) {
        let n = !1
          , s = !1;
        t.levels.forEach(r => {
            const o = r.audioCodec;
            o && (n = n || o.indexOf("mp4a.40.2") !== -1,
            s = s || o.indexOf("mp4a.40.5") !== -1)
        }
        ),
        this.audioCodecSwitch = n && s && !zW(),
        this.audioCodecSwitch && this.log("Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC"),
        this.levels = t.levels,
        this.startFragRequested = !1
    }
    onLevelLoading(e, t) {
        const {levels: n} = this;
        if (!n || this.state !== Ve.IDLE)
            return;
        const s = n[t.level];
        (!s.details || s.details.live && this.levelLastLoaded !== s || this.waitForCdnTuneIn(s.details)) && (this.state = Ve.WAITING_LEVEL)
    }
    onLevelLoaded(e, t) {
        var n;
        const {levels: s} = this
          , r = t.level
          , o = t.details
          , a = o.totalduration;
        if (!s) {
            this.warn(`Levels were reset while loading level ${r}`);
            return
        }
        this.log(`Level ${r} loaded [${o.startSN},${o.endSN}]${o.lastPartSn ? `[part-${o.lastPartSn}-${o.lastPartIndex}]` : ""}, cc [${o.startCC}, ${o.endCC}] duration:${a}`);
        const l = s[r]
          , c = this.fragCurrent;
        c && (this.state === Ve.FRAG_LOADING || this.state === Ve.FRAG_LOADING_WAITING_RETRY) && c.level !== t.level && c.loader && this.abortCurrentFrag();
        let u = 0;
        if (o.live || (n = l.details) != null && n.live) {
            var d;
            if (this.checkLiveUpdate(o),
            o.deltaUpdateFailed)
                return;
            u = this.alignPlaylists(o, l.details, (d = this.levelLastLoaded) == null ? void 0 : d.details)
        }
        if (l.details = o,
        this.levelLastLoaded = l,
        this.hls.trigger(P.LEVEL_UPDATED, {
            details: o,
            level: r
        }),
        this.state === Ve.WAITING_LEVEL) {
            if (this.waitForCdnTuneIn(o))
                return;
            this.state = Ve.IDLE
        }
        this.startFragRequested ? o.live && this.synchronizeToLiveEdge(o) : this.setStartPosition(o, u),
        this.tick()
    }
    _handleFragmentLoadProgress(e) {
        var t;
        const {frag: n, part: s, payload: r} = e
          , {levels: o} = this;
        if (!o) {
            this.warn(`Levels were reset while fragment load was in progress. Fragment ${n.sn} of level ${n.level} will not be buffered`);
            return
        }
        const a = o[n.level]
          , l = a.details;
        if (!l) {
            this.warn(`Dropping fragment ${n.sn} of level ${n.level} after level details were reset`),
            this.fragmentTracker.removeFragment(n);
            return
        }
        const c = a.videoCodec
          , u = l.PTSKnown || !l.live
          , d = (t = n.initSegment) == null ? void 0 : t.data
          , f = this._getAudioCodec(a)
          , h = this.transmuxer = this.transmuxer || new wM(this.hls,Ct.MAIN,this._handleTransmuxComplete.bind(this),this._handleTransmuxerFlush.bind(this))
          , p = s ? s.index : -1
          , g = p !== -1
          , m = new ix(n.level,n.sn,n.stats.chunkCount,r.byteLength,p,g)
          , v = this.initPTS[n.cc];
        h.push(r, d, f, c, n, s, l.totalduration, u, m, v)
    }
    onAudioTrackSwitching(e, t) {
        const n = this.altAudio;
        if (!!!t.url) {
            if (this.mediaBuffer !== this.media) {
                this.log("Switching on main audio, use media.buffered to schedule main fragment loading"),
                this.mediaBuffer = this.media;
                const o = this.fragCurrent;
                o && (this.log("Switching to main audio track, cancel main fragment load"),
                o.abortRequests(),
                this.fragmentTracker.removeFragment(o)),
                this.resetTransmuxer(),
                this.resetLoadingState()
            } else
                this.audioOnly && this.resetTransmuxer();
            const r = this.hls;
            n && (r.trigger(P.BUFFER_FLUSHING, {
                startOffset: 0,
                endOffset: Number.POSITIVE_INFINITY,
                type: null
            }),
            this.fragmentTracker.removeAllFragments()),
            r.trigger(P.AUDIO_TRACK_SWITCHED, t)
        }
    }
    onAudioTrackSwitched(e, t) {
        const n = t.id
          , s = !!this.hls.audioTracks[n].url;
        if (s) {
            const r = this.videoBuffer;
            r && this.mediaBuffer !== r && (this.log("Switching on alternate audio, use video.buffered to schedule main fragment loading"),
            this.mediaBuffer = r)
        }
        this.altAudio = s,
        this.tick()
    }
    onBufferCreated(e, t) {
        const n = t.tracks;
        let s, r, o = !1;
        for (const a in n) {
            const l = n[a];
            if (l.id === "main") {
                if (r = a,
                s = l,
                a === "video") {
                    const c = n[a];
                    c && (this.videoBuffer = c.buffer)
                }
            } else
                o = !0
        }
        o && s ? (this.log(`Alternate track found, use ${r}.buffered to schedule main fragment loading`),
        this.mediaBuffer = s.buffer) : this.mediaBuffer = this.media
    }
    onFragBuffered(e, t) {
        const {frag: n, part: s} = t;
        if (n && n.type !== Ct.MAIN)
            return;
        if (this.fragContextChanged(n)) {
            this.warn(`Fragment ${n.sn}${s ? " p: " + s.index : ""} of level ${n.level} finished buffering, but was aborted. state: ${this.state}`),
            this.state === Ve.PARSED && (this.state = Ve.IDLE);
            return
        }
        const r = s ? s.stats : n.stats;
        this.fragLastKbps = Math.round(8 * r.total / (r.buffering.end - r.loading.first)),
        n.sn !== "initSegment" && (this.fragPrevious = n),
        this.fragBufferedComplete(n, s)
    }
    onError(e, t) {
        var n;
        if (t.fatal) {
            this.state = Ve.ERROR;
            return
        }
        switch (t.details) {
        case Ae.FRAG_GAP:
        case Ae.FRAG_PARSING_ERROR:
        case Ae.FRAG_DECRYPT_ERROR:
        case Ae.FRAG_LOAD_ERROR:
        case Ae.FRAG_LOAD_TIMEOUT:
        case Ae.KEY_LOAD_ERROR:
        case Ae.KEY_LOAD_TIMEOUT:
            this.onFragmentOrKeyLoadError(Ct.MAIN, t);
            break;
        case Ae.LEVEL_LOAD_ERROR:
        case Ae.LEVEL_LOAD_TIMEOUT:
        case Ae.LEVEL_PARSING_ERROR:
            !t.levelRetry && this.state === Ve.WAITING_LEVEL && ((n = t.context) == null ? void 0 : n.type) === en.LEVEL && (this.state = Ve.IDLE);
            break;
        case Ae.BUFFER_APPEND_ERROR:
        case Ae.BUFFER_FULL_ERROR:
            if (!t.parent || t.parent !== "main")
                return;
            if (t.details === Ae.BUFFER_APPEND_ERROR) {
                this.resetLoadingState();
                return
            }
            this.reduceLengthAndFlushBuffer(t) && this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
            break;
        case Ae.INTERNAL_EXCEPTION:
            this.recoverWorkerError(t);
            break
        }
    }
    checkBuffer() {
        const {media: e, gapController: t} = this;
        if (!(!e || !t || !e.readyState)) {
            if (this.loadedmetadata || !An.getBuffered(e).length) {
                const n = this.state !== Ve.IDLE ? this.fragCurrent : null;
                t.poll(this.lastCurrentTime, n)
            }
            this.lastCurrentTime = e.currentTime
        }
    }
    onFragLoadEmergencyAborted() {
        this.state = Ve.IDLE,
        this.loadedmetadata || (this.startFragRequested = !1,
        this.nextLoadPosition = this.startPosition),
        this.tickImmediate()
    }
    onBufferFlushed(e, {type: t}) {
        if (t !== gn.AUDIO || this.audioOnly && !this.altAudio) {
            const n = (t === gn.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;
            this.afterBufferFlushed(n, t, Ct.MAIN),
            this.tick()
        }
    }
    onLevelsUpdated(e, t) {
        this.level > -1 && this.fragCurrent && (this.level = this.fragCurrent.level),
        this.levels = t.levels
    }
    swapAudioCodec() {
        this.audioCodecSwap = !this.audioCodecSwap
    }
    seekToStartPos() {
        const {media: e} = this;
        if (!e)
            return;
        const t = e.currentTime;
        let n = this.startPosition;
        if (n >= 0 && t < n) {
            if (e.seeking) {
                this.log(`could not seek to ${n}, already seeking at ${t}`);
                return
            }
            const s = An.getBuffered(e)
              , o = (s.length ? s.start(0) : 0) - n;
            o > 0 && (o < this.config.maxBufferHole || o < this.config.maxFragLookUpTolerance) && (this.log(`adjusting start position by ${o} to match buffer start`),
            n += o,
            this.startPosition = n),
            this.log(`seek to target start position ${n} from current time ${t}`),
            e.currentTime = n
        }
    }
    _getAudioCodec(e) {
        let t = this.config.defaultAudioCodec || e.audioCodec;
        return this.audioCodecSwap && t && (this.log("Swapping audio codec"),
        t.indexOf("mp4a.40.5") !== -1 ? t = "mp4a.40.2" : t = "mp4a.40.5"),
        t
    }
    _loadBitrateTestFrag(e, t) {
        e.bitrateTest = !0,
        this._doFragLoad(e, t).then(n => {
            const {hls: s} = this;
            if (!n || this.fragContextChanged(e))
                return;
            t.fragmentError = 0,
            this.state = Ve.IDLE,
            this.startFragRequested = !1,
            this.bitrateTest = !1;
            const r = e.stats;
            r.parsing.start = r.parsing.end = r.buffering.start = r.buffering.end = self.performance.now(),
            s.trigger(P.FRAG_LOADED, n),
            e.bitrateTest = !1
        }
        )
    }
    _handleTransmuxComplete(e) {
        var t;
        const n = "main"
          , {hls: s} = this
          , {remuxResult: r, chunkMeta: o} = e
          , a = this.getCurrentContext(o);
        if (!a) {
            this.resetWhenMissingContext(o);
            return
        }
        const {frag: l, part: c, level: u} = a
          , {video: d, text: f, id3: h, initSegment: p} = r
          , {details: g} = u
          , m = this.altAudio ? void 0 : r.audio;
        if (this.fragContextChanged(l)) {
            this.fragmentTracker.removeFragment(l);
            return
        }
        if (this.state = Ve.PARSING,
        p) {
            if (p != null && p.tracks) {
                const y = l.initSegment || l;
                this._bufferInitSegment(u, p.tracks, y, o),
                s.trigger(P.FRAG_PARSING_INIT_SEGMENT, {
                    frag: y,
                    id: n,
                    tracks: p.tracks
                })
            }
            const v = p.initPTS
              , _ = p.timescale;
            pt(v) && (this.initPTS[l.cc] = {
                baseTime: v,
                timescale: _
            },
            s.trigger(P.INIT_PTS_FOUND, {
                frag: l,
                id: n,
                initPTS: v,
                timescale: _
            }))
        }
        if (d && g && l.sn !== "initSegment") {
            const v = g.fragments[l.sn - 1 - g.startSN]
              , _ = l.sn === g.startSN
              , y = !v || l.cc > v.cc;
            if (r.independent !== !1) {
                const {startPTS: b, endPTS: S, startDTS: C, endDTS: M} = d;
                if (c)
                    c.elementaryStreams[d.type] = {
                        startPTS: b,
                        endPTS: S,
                        startDTS: C,
                        endDTS: M
                    };
                else if (d.firstKeyFrame && d.independent && o.id === 1 && !y && (this.couldBacktrack = !0),
                d.dropped && d.independent) {
                    const L = this.getMainFwdBufferInfo()
                      , T = (L ? L.end : this.getLoadPosition()) + this.config.maxBufferHole
                      , A = d.firstKeyFramePTS ? d.firstKeyFramePTS : b;
                    if (!_ && T < A - this.config.maxBufferHole && !y) {
                        this.backtrack(l);
                        return
                    } else
                        y && (l.gap = !0);
                    l.setElementaryStreamInfo(d.type, l.start, S, l.start, M, !0)
                } else
                    _ && b > Dh && (l.gap = !0);
                l.setElementaryStreamInfo(d.type, b, S, C, M),
                this.backtrackFragment && (this.backtrackFragment = l),
                this.bufferFragmentData(d, l, c, o, _ || y)
            } else if (_ || y)
                l.gap = !0;
            else {
                this.backtrack(l);
                return
            }
        }
        if (m) {
            const {startPTS: v, endPTS: _, startDTS: y, endDTS: b} = m;
            c && (c.elementaryStreams[gn.AUDIO] = {
                startPTS: v,
                endPTS: _,
                startDTS: y,
                endDTS: b
            }),
            l.setElementaryStreamInfo(gn.AUDIO, v, _, y, b),
            this.bufferFragmentData(m, l, c, o)
        }
        if (g && h != null && (t = h.samples) != null && t.length) {
            const v = {
                id: n,
                frag: l,
                details: g,
                samples: h.samples
            };
            s.trigger(P.FRAG_PARSING_METADATA, v)
        }
        if (g && f) {
            const v = {
                id: n,
                frag: l,
                details: g,
                samples: f.samples
            };
            s.trigger(P.FRAG_PARSING_USERDATA, v)
        }
    }
    _bufferInitSegment(e, t, n, s) {
        if (this.state !== Ve.PARSING)
            return;
        this.audioOnly = !!t.audio && !t.video,
        this.altAudio && !this.audioOnly && delete t.audio;
        const {audio: r, video: o, audiovideo: a} = t;
        if (r) {
            let l = e.audioCodec;
            const c = navigator.userAgent.toLowerCase();
            if (this.audioCodecSwitch) {
                l && (l.indexOf("mp4a.40.5") !== -1 ? l = "mp4a.40.2" : l = "mp4a.40.5");
                const u = r.metadata;
                u && "channelCount"in u && (u.channelCount || 1) !== 1 && c.indexOf("firefox") === -1 && (l = "mp4a.40.5")
            }
            l && l.indexOf("mp4a.40.5") !== -1 && c.indexOf("android") !== -1 && r.container !== "audio/mpeg" && (l = "mp4a.40.2",
            this.log(`Android: force audio codec to ${l}`)),
            e.audioCodec && e.audioCodec !== l && this.log(`Swapping manifest audio codec "${e.audioCodec}" for "${l}"`),
            r.levelCodec = l,
            r.id = "main",
            this.log(`Init audio buffer, container:${r.container}, codecs[selected/level/parsed]=[${l || ""}/${e.audioCodec || ""}/${r.codec}]`)
        }
        o && (o.levelCodec = e.videoCodec,
        o.id = "main",
        this.log(`Init video buffer, container:${o.container}, codecs[level/parsed]=[${e.videoCodec || ""}/${o.codec}]`)),
        a && this.log(`Init audiovideo buffer, container:${a.container}, codecs[level/parsed]=[${e.codecs}/${a.codec}]`),
        this.hls.trigger(P.BUFFER_CODECS, t),
        Object.keys(t).forEach(l => {
            const u = t[l].initSegment;
            u != null && u.byteLength && this.hls.trigger(P.BUFFER_APPENDING, {
                type: l,
                data: u,
                frag: n,
                part: null,
                chunkMeta: s,
                parent: n.type
            })
        }
        ),
        this.tickImmediate()
    }
    getMainFwdBufferInfo() {
        return this.getFwdBufferInfo(this.mediaBuffer ? this.mediaBuffer : this.media, Ct.MAIN)
    }
    backtrack(e) {
        this.couldBacktrack = !0,
        this.backtrackFragment = e,
        this.resetTransmuxer(),
        this.flushBufferGap(e),
        this.fragmentTracker.removeFragment(e),
        this.fragPrevious = null,
        this.nextLoadPosition = e.start,
        this.state = Ve.IDLE
    }
    checkFragmentChanged() {
        const e = this.media;
        let t = null;
        if (e && e.readyState > 1 && e.seeking === !1) {
            const n = e.currentTime;
            if (An.isBuffered(e, n) ? t = this.getAppendedFrag(n) : An.isBuffered(e, n + .1) && (t = this.getAppendedFrag(n + .1)),
            t) {
                this.backtrackFragment = null;
                const s = this.fragPlaying
                  , r = t.level;
                (!s || t.sn !== s.sn || s.level !== r) && (this.fragPlaying = t,
                this.hls.trigger(P.FRAG_CHANGED, {
                    frag: t
                }),
                (!s || s.level !== r) && this.hls.trigger(P.LEVEL_SWITCHED, {
                    level: r
                }))
            }
        }
    }
    get nextLevel() {
        const e = this.nextBufferedFrag;
        return e ? e.level : -1
    }
    get currentFrag() {
        const e = this.media;
        return e ? this.fragPlaying || this.getAppendedFrag(e.currentTime) : null
    }
    get currentProgramDateTime() {
        const e = this.media;
        if (e) {
            const t = e.currentTime
              , n = this.currentFrag;
            if (n && pt(t) && pt(n.programDateTime)) {
                const s = n.programDateTime + (t - n.start) * 1e3;
                return new Date(s)
            }
        }
        return null
    }
    get currentLevel() {
        const e = this.currentFrag;
        return e ? e.level : -1
    }
    get nextBufferedFrag() {
        const e = this.currentFrag;
        return e ? this.followingBufferedFrag(e) : null
    }
    get forceStartLoad() {
        return this._forceStartLoad
    }
}
class Mo {
    static get version() {
        return "1.5.17"
    }
    static isMSESupported() {
        return GM()
    }
    static isSupported() {
        return HW()
    }
    static getMediaSource() {
        return kl()
    }
    static get Events() {
        return P
    }
    static get ErrorTypes() {
        return Ut
    }
    static get ErrorDetails() {
        return Ae
    }
    static get DefaultConfig() {
        return Mo.defaultConfig ? Mo.defaultConfig : HM
    }
    static set DefaultConfig(e) {
        Mo.defaultConfig = e
    }
    constructor(e={}) {
        this.config = void 0,
        this.userConfig = void 0,
        this.coreComponents = void 0,
        this.networkControllers = void 0,
        this.started = !1,
        this._emitter = new ux,
        this._autoLevelCapping = -1,
        this._maxHdcpLevel = null,
        this.abrController = void 0,
        this.bufferController = void 0,
        this.capLevelController = void 0,
        this.latencyController = void 0,
        this.levelController = void 0,
        this.streamController = void 0,
        this.audioTrackController = void 0,
        this.subtitleTrackController = void 0,
        this.emeController = void 0,
        this.cmcdController = void 0,
        this._media = null,
        this.url = null,
        this.triggeringException = void 0,
        U$(e.debug || !1, "Hls instance");
        const t = this.config = NW(Mo.DefaultConfig, e);
        this.userConfig = e,
        t.progressive && BW(t);
        const {abrController: n, bufferController: s, capLevelController: r, errorController: o, fpsController: a} = t
          , l = new o(this)
          , c = this.abrController = new n(this)
          , u = this.bufferController = new s(this)
          , d = this.capLevelController = new r(this)
          , f = new a(this)
          , h = new IH(this)
          , p = new OH(this)
          , g = t.contentSteeringController
          , m = g ? new g(this) : null
          , v = this.levelController = new VW(this,m)
          , _ = new dz(this)
          , y = new $W(this.config)
          , b = this.streamController = new XW(this,_,y);
        d.setStreamController(b),
        f.setStreamController(b);
        const S = [h, v, b];
        m && S.splice(1, 0, m),
        this.networkControllers = S;
        const C = [c, u, d, f, p, _];
        this.audioTrackController = this.createController(t.audioTrackController, S);
        const M = t.audioStreamController;
        M && S.push(new M(this,_,y)),
        this.subtitleTrackController = this.createController(t.subtitleTrackController, S);
        const L = t.subtitleStreamController;
        L && S.push(new L(this,_,y)),
        this.createController(t.timelineController, C),
        y.emeController = this.emeController = this.createController(t.emeController, C),
        this.cmcdController = this.createController(t.cmcdController, C),
        this.latencyController = this.createController(UH, C),
        this.coreComponents = C,
        S.push(l);
        const T = l.onErrorOut;
        typeof T == "function" && this.on(P.ERROR, T, l)
    }
    createController(e, t) {
        if (e) {
            const n = new e(this);
            return t && t.push(n),
            n
        }
        return null
    }
    on(e, t, n=this) {
        this._emitter.on(e, t, n)
    }
    once(e, t, n=this) {
        this._emitter.once(e, t, n)
    }
    removeAllListeners(e) {
        this._emitter.removeAllListeners(e)
    }
    off(e, t, n=this, s) {
        this._emitter.off(e, t, n, s)
    }
    listeners(e) {
        return this._emitter.listeners(e)
    }
    emit(e, t, n) {
        return this._emitter.emit(e, t, n)
    }
    trigger(e, t) {
        if (this.config.debug)
            return this.emit(e, e, t);
        try {
            return this.emit(e, e, t)
        } catch (n) {
            if (de.error("An internal error happened while handling event " + e + '. Error message: "' + n.message + '". Here is a stacktrace:', n),
            !this.triggeringException) {
                this.triggeringException = !0;
                const s = e === P.ERROR;
                this.trigger(P.ERROR, {
                    type: Ut.OTHER_ERROR,
                    details: Ae.INTERNAL_EXCEPTION,
                    fatal: s,
                    event: e,
                    error: n
                }),
                this.triggeringException = !1
            }
        }
        return !1
    }
    listenerCount(e) {
        return this._emitter.listenerCount(e)
    }
    destroy() {
        de.log("destroy"),
        this.trigger(P.DESTROYING, void 0),
        this.detachMedia(),
        this.removeAllListeners(),
        this._autoLevelCapping = -1,
        this.url = null,
        this.networkControllers.forEach(t => t.destroy()),
        this.networkControllers.length = 0,
        this.coreComponents.forEach(t => t.destroy()),
        this.coreComponents.length = 0;
        const e = this.config;
        e.xhrSetup = e.fetchSetup = void 0,
        this.userConfig = null
    }
    attachMedia(e) {
        de.log("attachMedia"),
        this._media = e,
        this.trigger(P.MEDIA_ATTACHING, {
            media: e
        })
    }
    detachMedia() {
        de.log("detachMedia"),
        this.trigger(P.MEDIA_DETACHING, void 0),
        this._media = null
    }
    loadSource(e) {
        this.stopLoad();
        const t = this.media
          , n = this.url
          , s = this.url = Z_.buildAbsoluteURL(self.location.href, e, {
            alwaysNormalize: !0
        });
        this._autoLevelCapping = -1,
        this._maxHdcpLevel = null,
        de.log(`loadSource:${s}`),
        t && n && (n !== s || this.bufferController.hasSourceTypes()) && (this.detachMedia(),
        this.attachMedia(t)),
        this.trigger(P.MANIFEST_LOADING, {
            url: e
        })
    }
    startLoad(e=-1) {
        de.log(`startLoad(${e})`),
        this.started = !0,
        this.networkControllers.forEach(t => {
            t.startLoad(e)
        }
        )
    }
    stopLoad() {
        de.log("stopLoad"),
        this.started = !1,
        this.networkControllers.forEach(e => {
            e.stopLoad()
        }
        )
    }
    resumeBuffering() {
        this.started && this.networkControllers.forEach(e => {
            "fragmentLoader"in e && e.startLoad(-1)
        }
        )
    }
    pauseBuffering() {
        this.networkControllers.forEach(e => {
            "fragmentLoader"in e && e.stopLoad()
        }
        )
    }
    swapAudioCodec() {
        de.log("swapAudioCodec"),
        this.streamController.swapAudioCodec()
    }
    recoverMediaError() {
        de.log("recoverMediaError");
        const e = this._media;
        this.detachMedia(),
        e && this.attachMedia(e)
    }
    removeLevel(e) {
        this.levelController.removeLevel(e)
    }
    get levels() {
        const e = this.levelController.levels;
        return e || []
    }
    get currentLevel() {
        return this.streamController.currentLevel
    }
    set currentLevel(e) {
        de.log(`set currentLevel:${e}`),
        this.levelController.manualLevel = e,
        this.streamController.immediateLevelSwitch()
    }
    get nextLevel() {
        return this.streamController.nextLevel
    }
    set nextLevel(e) {
        de.log(`set nextLevel:${e}`),
        this.levelController.manualLevel = e,
        this.streamController.nextLevelSwitch()
    }
    get loadLevel() {
        return this.levelController.level
    }
    set loadLevel(e) {
        de.log(`set loadLevel:${e}`),
        this.levelController.manualLevel = e
    }
    get nextLoadLevel() {
        return this.levelController.nextLoadLevel
    }
    set nextLoadLevel(e) {
        this.levelController.nextLoadLevel = e
    }
    get firstLevel() {
        return Math.max(this.levelController.firstLevel, this.minAutoLevel)
    }
    set firstLevel(e) {
        de.log(`set firstLevel:${e}`),
        this.levelController.firstLevel = e
    }
    get startLevel() {
        const e = this.levelController.startLevel;
        return e === -1 && this.abrController.forcedAutoLevel > -1 ? this.abrController.forcedAutoLevel : e
    }
    set startLevel(e) {
        de.log(`set startLevel:${e}`),
        e !== -1 && (e = Math.max(e, this.minAutoLevel)),
        this.levelController.startLevel = e
    }
    get capLevelToPlayerSize() {
        return this.config.capLevelToPlayerSize
    }
    set capLevelToPlayerSize(e) {
        const t = !!e;
        t !== this.config.capLevelToPlayerSize && (t ? this.capLevelController.startCapping() : (this.capLevelController.stopCapping(),
        this.autoLevelCapping = -1,
        this.streamController.nextLevelSwitch()),
        this.config.capLevelToPlayerSize = t)
    }
    get autoLevelCapping() {
        return this._autoLevelCapping
    }
    get bandwidthEstimate() {
        const {bwEstimator: e} = this.abrController;
        return e ? e.getEstimate() : NaN
    }
    set bandwidthEstimate(e) {
        this.abrController.resetEstimator(e)
    }
    get ttfbEstimate() {
        const {bwEstimator: e} = this.abrController;
        return e ? e.getEstimateTTFB() : NaN
    }
    set autoLevelCapping(e) {
        this._autoLevelCapping !== e && (de.log(`set autoLevelCapping:${e}`),
        this._autoLevelCapping = e,
        this.levelController.checkMaxAutoUpdated())
    }
    get maxHdcpLevel() {
        return this._maxHdcpLevel
    }
    set maxHdcpLevel(e) {
        NH(e) && this._maxHdcpLevel !== e && (this._maxHdcpLevel = e,
        this.levelController.checkMaxAutoUpdated())
    }
    get autoLevelEnabled() {
        return this.levelController.manualLevel === -1
    }
    get manualLevel() {
        return this.levelController.manualLevel
    }
    get minAutoLevel() {
        const {levels: e, config: {minAutoBitrate: t}} = this;
        if (!e)
            return 0;
        const n = e.length;
        for (let s = 0; s < n; s++)
            if (e[s].maxBitrate >= t)
                return s;
        return 0
    }
    get maxAutoLevel() {
        const {levels: e, autoLevelCapping: t, maxHdcpLevel: n} = this;
        let s;
        if (t === -1 && e != null && e.length ? s = e.length - 1 : s = t,
        n)
            for (let r = s; r--; ) {
                const o = e[r].attrs["HDCP-LEVEL"];
                if (o && o <= n)
                    return r
            }
        return s
    }
    get firstAutoLevel() {
        return this.abrController.firstAutoLevel
    }
    get nextAutoLevel() {
        return this.abrController.nextAutoLevel
    }
    set nextAutoLevel(e) {
        this.abrController.nextAutoLevel = e
    }
    get playingDate() {
        return this.streamController.currentProgramDateTime
    }
    get mainForwardBufferInfo() {
        return this.streamController.getMainFwdBufferInfo()
    }
    setAudioOption(e) {
        var t;
        return (t = this.audioTrackController) == null ? void 0 : t.setAudioOption(e)
    }
    setSubtitleOption(e) {
        var t;
        return (t = this.subtitleTrackController) == null || t.setSubtitleOption(e),
        null
    }
    get allAudioTracks() {
        const e = this.audioTrackController;
        return e ? e.allAudioTracks : []
    }
    get audioTracks() {
        const e = this.audioTrackController;
        return e ? e.audioTracks : []
    }
    get audioTrack() {
        const e = this.audioTrackController;
        return e ? e.audioTrack : -1
    }
    set audioTrack(e) {
        const t = this.audioTrackController;
        t && (t.audioTrack = e)
    }
    get allSubtitleTracks() {
        const e = this.subtitleTrackController;
        return e ? e.allSubtitleTracks : []
    }
    get subtitleTracks() {
        const e = this.subtitleTrackController;
        return e ? e.subtitleTracks : []
    }
    get subtitleTrack() {
        const e = this.subtitleTrackController;
        return e ? e.subtitleTrack : -1
    }
    get media() {
        return this._media
    }
    set subtitleTrack(e) {
        const t = this.subtitleTrackController;
        t && (t.subtitleTrack = e)
    }
    get subtitleDisplay() {
        const e = this.subtitleTrackController;
        return e ? e.subtitleDisplay : !1
    }
    set subtitleDisplay(e) {
        const t = this.subtitleTrackController;
        t && (t.subtitleDisplay = e)
    }
    get lowLatencyMode() {
        return this.config.lowLatencyMode
    }
    set lowLatencyMode(e) {
        this.config.lowLatencyMode = e
    }
    get liveSyncPosition() {
        return this.latencyController.liveSyncPosition
    }
    get latency() {
        return this.latencyController.latency
    }
    get maxLatency() {
        return this.latencyController.maxLatency
    }
    get targetLatency() {
        return this.latencyController.targetLatency
    }
    get drift() {
        return this.latencyController.drift
    }
    get forceStartLoad() {
        return this.streamController.forceStartLoad
    }
}
Mo.defaultConfig = void 0;
const YW = {
    viewBox: "0 0 24 24",
    fill: "currentColor"
}
  , ZW = ["d"]
  , Ys = ut({
    __name: "MIcon",
    props: {
        path: {}
    },
    setup(i) {
        const e = i;
        return (t, n) => (w(),
        R("svg", YW, [x("path", {
            d: e.path
        }, null, 8, ZW)]))
    }
})
  , zf = 11526 / 51
  , $0 = 400
  , FS = ut({
    __name: "HandyEmulator",
    props: {
        position: {
            default: 0
        }
    },
    setup(i) {
        const e = i
          , t = xe({});
        let n = null;
        const s = new Image;
        s.src = "/handy.positions.vertical.webp",
        Ln( () => {
            n = t.value.getContext("2d"),
            t.value.width = $0,
            t.value.height = zf,
            r(e.position)
        }
        ),
        Bt( () => e.position, () => r(e.position));
        const r = o => {
            if (!n)
                return;
            const a = Math.floor(o / 100 * 51);
            n.drawImage(s, 0, a * zf, $0, zf, 0, 0, $0, zf)
        }
        ;
        return (o, a) => (w(),
        R("canvas", {
            ref_key: "canvas",
            ref: t
        }, null, 512))
    }
})
  , JW = ut({
    __name: "RangeSlider",
    props: {
        modelValue: {}
    },
    emits: ["update:modelValue"],
    setup(i, {emit: e}) {
        const t = i
          , n = e
          , s = xe(!1)
          , r = xe();
        Ln( () => {
            document.addEventListener("mousemove", o),
            document.addEventListener("mouseup", l)
        }
        ),
        Ms( () => {
            document.removeEventListener("mousemove", o),
            document.removeEventListener("mouseup", l)
        }
        );
        const o = c => {
            if (!s.value)
                return;
            const u = c.clientX
              , d = r.value.offsetWidth
              , {left: f} = r.value.getBoundingClientRect();
            let p = (u - f) / d;
            p > 1 && (p = 1),
            p < 0 && (p = 0),
            n("update:modelValue", p)
        }
          , a = c => {
            s.value = !0,
            o(c)
        }
          , l = () => {
            s.value = !1
        }
        ;
        return (c, u) => (w(),
        R("div", null, [x("div", {
            class: "bg-white/20 relative cursor-pointer select-none w-full h-full rounded-full",
            ref_key: "seekbar",
            ref: r,
            onMousedown: a,
            onMouseup: l
        }, [x("div", {
            class: "bg-white h-full rounded-l-full",
            style: xs(`width: ${t.modelValue * 100}%`)
        }, null, 4), x("div", {
            class: "h-3 w-3 absolute -top-1 rounded-full bg-white",
            style: xs(`left: calc(${t.modelValue * 100}% - 6px)`)
        }, null, 4)], 544)]))
    }
})
  , QW = {
    class: "bg-white/50 rounded-full relative z-0 lg:!h-1",
    style: {
        height: "2px"
    }
}
  , eq = ["viewBox"]
  , tq = ["id"]
  , nq = ["points"]
  , iq = ["clip-path"]
  , OS = ut({
    __name: "Seekbar",
    props: {
        value: {},
        max: {},
        actions: {}
    },
    emits: ["seek"],
    setup(i, {emit: e}) {
        const t = i
          , n = e
          , s = Math.random().toString(36).substr(2, 9)
          , r = xe()
          , o = xe({
            enabled: !1,
            progress: 0,
            overallProgress: 0
        });
        Ln( () => {
            window.addEventListener("mousemove", a),
            window.addEventListener("mouseup", l)
        }
        ),
        Ms( () => {
            window.removeEventListener("mousemove", a),
            window.removeEventListener("mouseup", l)
        }
        );
        const a = h => {
            const p = h.touches ? h.touches[0].clientX : h.clientX
              , g = r.value.offsetWidth
              , {left: m} = r.value.getBoundingClientRect();
            let _ = (p - m) / g;
            _ > 1 && (_ = 1),
            _ < 0 && (_ = 0),
            o.value.overallProgress = _,
            o.value.enabled && (o.value.progress = _)
        }
          , l = () => {
            !o.value.enabled || (n("seek", o.value.progress * t.max),
            o.value.enabled = !1)
        }
          , c = h => {
            o.value.enabled = !0,
            a(h)
        }
          , u = Vt( () => o.value.enabled ? o.value.progress * 100 : t.value / t.max * 100)
          , d = Vt( () => {
            if (!t.actions || !t.actions.length)
                return "";
            let h = Math.max(9 / 3600 * t.max, .75);
            const p = [];
            let g = 0
              , m = ""
              , v = 0;
            for (let _ = 0; _ < t.max; _ += h) {
                const y = [];
                for (let S = v; S < t.actions.length; S++) {
                    if (t.actions[S][0] / 1e3 >= _ + h) {
                        v = S;
                        break
                    }
                    y.push(t.actions[S])
                }
                const b = f(y);
                b > g && (g = b),
                p.push([_, b])
            }
            if (!p.length)
                return "";
            p[0][1] = 0,
            p[p.length - 1][1] = 0;
            for (let _ = 0; _ < p.length; _++) {
                let y = p[_][1] / g * 100;
                y = Math.round(Math.abs(100 - y)),
                m += `${p[_][0]},${y || 0} `
            }
            return m
        }
        )
          , f = h => {
            let p = 0;
            if (h.length === 0)
                return p;
            for (let g = 0; g < h.length - 1; g++) {
                let m = h[g]
                  , v = h[g + 1];
                if (m[0] !== v[0]) {
                    if (v[0] < m[0]) {
                        let _ = v;
                        v = m,
                        m = _
                    }
                    p += 1e3 * Math.abs(v[1] - m[1]) / Math.abs(v[0] - m[0])
                }
            }
            return p / h.length
        }
        ;
        return (h, p) => (w(),
        R("div", {
            class: "w-full cursor-pointer py-2 touch-none select-none group",
            ref_key: "seekbar",
            ref: r,
            onMousedown: c,
            onTouchstart: c,
            onTouchmove: a,
            onTouchcancel: p[0] || (p[0] = g => o.value.enabled = !1),
            onTouchend: l
        }, [x("div", QW, [x("div", {
            class: "h-full bg-white rounded-l-full",
            style: xs(`width: ${u.value}%`)
        }, null, 4), x("div", {
            class: Pt(["absolute bg-zinc-300/20 rounded-full flex items-center justify-center top-1/2 transform -translate-y-1/2", {
                "!bg-zinc-300/50": o.value.enabled
            }]),
            style: xs([{
                height: "22px",
                width: "22px"
            }, `left: calc(${u.value}% - 11px)`])
        }, p[1] || (p[1] = [x("div", {
            class: "bg-white rounded-full",
            style: {
                height: "8px",
                width: "8px"
            }
        }, null, -1)]), 6), x("div", {
            class: Pt(["absolute bg-zinc-900 shadow text-white text-sm font-medium rounded-full py-1 px-2 -top-16 lg:-top-10 hidden group-hover:block", {
                "!block": o.value.enabled
            }]),
            style: xs(`left: calc(${o.value.overallProgress * 100}% - 26.5px)`)
        }, ee(E(fl)(t.max * o.value.overallProgress)), 7), (w(),
        R("svg", {
            viewBox: `0 0 ${t.max} 100`,
            preserveAspectRatio: "none",
            class: "absolute left-0 -z-10 w-full h-6 lg:!-top-6",
            style: {
                top: "-24px"
            }
        }, [x("defs", null, [x("clipPath", {
            id: `hotspots-${E(s)}`,
            clipPathUnits: "userSpaceOnUse"
        }, [x("polygon", {
            points: d.value
        }, null, 8, nq)], 8, tq)]), x("g", {
            "clip-path": `url(#hotspots-${E(s)})`
        }, [p[2] || (p[2] = x("rect", {
            x: "0",
            y: "0",
            width: "100%",
            height: "100%",
            fill: "rgba(33,29,27,0.75)"
        }, null, -1)), x("rect", {
            x: "0",
            y: "0",
            width: "100%",
            height: "100%",
            fill: "#635b58",
            style: xs(`transform: translate3d(-${100 - u.value}%, 0px, 0px);`)
        }, null, 4)], 8, iq)], 8, eq))])], 544))
    }
})
  , sq = {
    class: "flex flex-col"
}
  , rq = {
    key: 2,
    class: "font-medium text-center text-base lg:text-xl flex items-center flex-col"
}
  , oq = {
    class: "mt-3 mx-auto flex gap-3"
}
  , aq = {
    key: 0,
    class: "absolute right-4 top-4 rounded-lg bg-zinc-900/75 p-2 z-40 lg:block lg:w-1/5 overflow-hidden"
}
  , lq = {
    class: "bg-white rounded-lg w-full aspect-video overflow-hidden pointer-events-none"
}
  , cq = {
    key: 0
}
  , uq = {
    key: 0,
    class: "text-start"
}
  , dq = {
    key: 0,
    class: "absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2"
}
  , fq = {
    class: "font-medium"
}
  , hq = {
    class: "flex items-center flex-grow"
}
  , pq = {
    class: "flex justify-between items-center"
}
  , mq = {
    class: "font-medium"
}
  , gq = {
    key: 0,
    class: "absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-white"
}
  , vq = {
    class: "flex justify-between"
}
  , _q = {
    class: "whitespace-nowrap",
    style: {
        "flex-basis": "96px",
        "flex-grow": "0",
        "flex-shrink": "0"
    }
}
  , xq = {
    class: "font-bold"
}
  , yq = {
    class: "flex gap-x-2 items-center group"
}
  , bq = {
    class: "flex justify-between items-center gap-x-2"
}
  , Sq = {
    class: "bg-zinc-900 text-xs font-medium py-0.5 px-1.5 rounded-full shadow"
}
  , Eq = {
    class: "min-height-div text-white text-lg font-bold flex items-center justify-center"
}
  , wq = {
    key: 0,
    class: "rounded-lg bg-zinc-900/75 p-2 z-40 flex lg:hidden overflow-hidden"
}
  , Tq = {
    class: "bg-white rounded-lg flex-grow max-w-full aspect-video overflow-hidden pointer-events-none"
}
  , Aq = {
    key: 0,
    class: "flex flex-col flex-shrink max-w-xs"
}
  , mx = ut({
    __name: "Player",
    props: {
        video: {},
        isOverlay: {}
    },
    setup(i) {
        const e = i
          , t = Zr()
          , {handy: n, ui: s, autoblow: r, bluetoothFleshyThrust: o} = Pn(t)
          , a = xe()
          , {isMobile: l} = Ks()
          , c = ei({
            hls: new Mo,
            sources: [],
            actions: [],
            el: {},
            state: {
                settings: !1,
                state: 1,
                ui: !0,
                currentTime: 0,
                lastCurrentTime: 0,
                duration: 0,
                playing: !1,
                fullscreen: !1,
                loading: !0,
                source: void 0,
                volume: 0
            },
            intervals: {
                status: -1,
                progress: -1
            },
            timeouts: {
                hidePlayer: -1
            }
        });
        Ln(async () => {
            c.el = document.querySelector("#player");
            try {
                c.sources = await ct.videos.getSources(e.video.id)
            } catch (D) {
                console.log(D)
            }
            if (!c.sources || !c.sources.length) {
                c.state.message = "No video sources found",
                c.state.state = 2,
                hm.capture("Video File Removed", {
                    videoId: e.video.id
                });
                return
            }
            ct.videos.viewVideo(e.video.id).then();
            try {
                c.actions = await ct.videos.getScript(e.video.script.url)
            } catch (D) {
                console.log(D),
                c.state.message = "No video script found",
                c.state.state = 2;
                return
            }
            document.addEventListener("keydown", u),
            c.state.volume = c.el.volume,
            c.state.duration = e.video.duration,
            c.el.addEventListener("loadedmetadata", () => {
                c.state.duration = c.el.duration,
                c.state.lastCurrentTime > 0 && g(c.state.lastCurrentTime),
                p(!1)
            }
            ),
            c.el.addEventListener("canplay", () => {
                c.state.loading = !1,
                c.state.playing && (n.value.play(Math.floor(c.state.currentTime * 1e3)),
                r.value.play(Math.floor(c.state.currentTime * 1e3)))
            }
            ),
            c.el.addEventListener("waiting", () => {
                c.state.loading = !0,
                console.warn(" #change Video waiting - ", r.value.iscsvsent, h(c.el), r.value.connected, c.state.playing),
                M()
            }
            ),
            c.el.addEventListener("timeupdate", () => {
                !(c && c.el) || (c.state.currentTime = c.el.currentTime)
            }
            ),
            c.el.addEventListener("volumechange", () => {
                c.state.volume = c.el.volume
            }
            ),
            c.el.addEventListener("pause", () => {
                c.state.playing && !h(c.el) && (console.warn(" #change Video pause - resetting positions", r.value.iscsvsent, h(c.el), r.value.connected),
                M()),
                c.state.playing = !1
            }
            ),
            c.el.addEventListener("play", () => {
                r.value.iscsvsent && h(c.el) && r.value.play(Math.floor(c.state.currentTime * 1e3)),
                o.value.connected && (console.log(" #change Video play - resetting positions"),
                o.value.resetPosition()),
                n.value.play(Math.floor(c.state.currentTime * 1e3)),
                c.state.playing = !0,
                c.state.loading = !1
            }
            ),
            document.addEventListener("fullscreenchange", () => {
                c.state.fullscreen = document.fullscreenElement !== null
            }
            ),
            document.addEventListener("webkitfullscreenchange", () => {
                c.state.fullscreen = document.fullscreenElement !== null
            }
            ),
            c.el.addEventListener("webkitendfullscreen", () => {
                c.el.setAttribute("playsinline", ""),
                c.state.fullscreen = !1
            }
            ),
            c.el.addEventListener("seeking", () => {
                o.value.connected && (console.log(" #change Video seeked - resetting positions"),
                o.value.resetPosition())
            }
            ),
            c.intervals.status = setInterval(d, 10),
            await S(),
            await C(),
            m(v(c.sources))
        }
        ),
        Ms( () => {
            c.hls.stopLoad(),
            document.removeEventListener("keydown", u),
            M(),
            clearInterval(c.intervals.status),
            clearInterval(c.intervals.progress)
        }
        );
        const u = D => {
            var F, z;
            if (!(((F = document.activeElement) == null ? void 0 : F.tagName.toLowerCase()) === "input" || ((z = document.activeElement) == null ? void 0 : z.tagName.toLowerCase()) === "textarea" || !c.el) && !(D.ctrlKey || D.shiftKey))
                switch (D.preventDefault(),
                D.key) {
                case " ":
                    c.state.playing && (c.state.ui = !0),
                    p(!1),
                    _();
                    break;
                case "ArrowRight":
                    g(c.state.currentTime + 10);
                    break;
                case "ArrowLeft":
                    g(c.state.currentTime - 10);
                    break;
                case "f":
                    f();
                    break
                }
        }
          , d = () => c.state.loading = c.el.readyState < 3
          , f = () => {
            const D = a.value;
            if (c.state.fullscreen)
                document.cancelFullScreen ? document.cancelFullScreen() : document.mozCancelFullScreen ? document.mozCancelFullScreen() : document.webkitExitFullscreen && document.webkitExitFullscreen();
            else {
                D.requestFullscreen ? D.requestFullscreen() : D.webkitRequestFullscreen ? D.webkitRequestFullscreen() : D.mozRequestFullScreen ? D.mozRequestFullScreen() : D.msRequestFullscreen ? D.msRequestFullscreen() : D.webkitEnterFullscreen && D.webkitEnterFullscreen();
                const F = c.el;
                "webkitEnterFullscreen"in F && (F.removeAttribute("playsinline"),
                F.webkitEnterFullscreen(),
                c.state.fullscreen = !0)
            }
        }
          , h = D => D.currentTime > 0 && !D.paused && !D.ended && D.readyState > D.HAVE_CURRENT_DATA
          , p = async (D=!0) => {
            if (r.value.connected && !r.value.iscsvsent) {
                c.state.state = 2,
                c.state.message = "Failed to prepare video.";
                return
            }
            h(c.el) ? (c.el.pause(),
            D && (c.state.ui = !0)) : (c.el.play(),
            D && (c.state.ui = !1))
        }
          , g = D => {
            c.el.currentTime = D,
            c.state.currentTime = D
        }
          , m = (D, F) => {
            if (c.state.lastCurrentTime = c.state.currentTime,
            c.state.source = D,
            c.state.loading = !0,
            D.format === "mp4")
                c.el.src = D.url.startsWith("http") ? D.url : `/api/${D.url}`,
                p(!1);
            else if (D.format === "hls") {
                const z = D.url.startsWith("http") ? D.url : `/api/${D.url}`;
                Mo.isSupported() ? (c.hls.stopLoad(),
                c.hls.loadSource(z),
                c.hls.attachMedia(c.el),
                c.hls.on(Mo.Events.MANIFEST_PARSED, () => p(!1))) : (c.el.src = z,
                p(!1))
            }
            F && localStorage.setItem("quality", D.quality)
        }
          , v = D => {
            const F = D.map(H => parseInt(H.quality))
              , z = parseInt(localStorage.getItem("quality") || "") || 720;
            let G = F.findIndex(H => H <= z);
            return G > -1 ? D[G] : D[0]
        }
          , _ = () => {
            clearTimeout(c.timeouts.hidePlayer),
            c.timeouts.hidePlayer = setTimeout( () => {
                c.state.playing && (c.state.ui = !1)
            }
            , 2500)
        }
          , y = D => c.el.volume = D;
        Bt( () => c.state.volume, D => y(D));
        const b = Vt( () => c.state.duration > 0 ? c.state.duration : e.video.duration / 1e3)
          , S = async () => {
            try {
                c.state.message = "Preparing...",
                c.state.state = 1;
                let D = !1;
                if (h(c.el) && (c.el.pause(),
                D = !0),
                await n.value.prepare(Gs(e.video.script.url)),
                c.state.state = 0,
                c.state.message = void 0,
                D)
                    try {
                        c.el.play().then()
                    } catch {}
            } catch (D) {
                console.log(D),
                c.state.state = 2,
                c.state.message = "Failed to prepare video"
            }
        }
          , C = async () => {
            try {
                c.state.message = "Preparing...",
                c.state.state = 1;
                let D = !1;
                if (h(c.el) && (await c.el.pause(),
                D = !0),
                await r.value.prepare(Gs(e.video.script.url)),
                c.state.state = 0,
                c.state.message = void 0,
                D)
                    try {
                        c.el.play().then()
                    } catch (F) {
                        console.log(F)
                    }
            } catch (D) {
                console.log(D),
                c.state.state = 2,
                c.state.message = "Failed to prepare video"
            }
        }
        ;
        Bt( () => n.value.connected, async D => {
            !D || await S()
        }
        ),
        Bt( () => r.value.connected, async D => {
            !D || await C()
        }
        );
        const M = () => {
            clearInterval(A),
            t.devices.forEach(D => {
                switch (D.connector) {
                case cn.Autoblow:
                    r.value.iscsvsent && !h(c.el) && t.autoblow.stop();
                    break;
                case cn.Handy:
                    t.handy.stop();
                    break;
                case cn.Intiface:
                    D.instance.stop();
                    break;
                case cn.Bluetooth:
                    D.instance.stop();
                    break;
                case cn.BluetoothFleshyThrust:
                    t.bluetoothFleshyThrust.resetPosition()
                }
            }
            )
        }
          , L = () => {
            const D = c.el.currentTime * 1e3;
            if (!c.el || !h(c.el)) {
                requestAnimationFrame(L);
                return
            }
            const F = c.actions;
            let z = -1;
            for (let K = 0; K < F.length; K++)
                if (F[K][0] >= D) {
                    z = K;
                    break
                }
            if (z === -1) {
                requestAnimationFrame(L);
                return
            }
            const G = F[z]
              , H = F[z - 1]
              , X = G[0] - D;
            if (H !== void 0) {
                const K = H[1] + (G[1] - H[1]) * (D - H[0]) / (G[0] - H[0]);
                k.value = Math.round(K)
            }
            if (z === T) {
                requestAnimationFrame(L);
                return
            }
            T = z,
            console.log(`[Player] pos=${G[1]} in=${X.toFixed(0)}ms`),
            t.devices.forEach(K => {
                switch (K.connector) {
                case cn.OSR:
                    t.osr.move(G[1], X);
                    break;
                case cn.LOOB:
                    t.loob.move(G[1], X);
                    break;
                case cn.Handy:
                    break;
                case cn.Autoblow:
                    break;
                case cn.BluetoothFleshyThrust:
                    o.value.connected && o.value.move(G[1], X);
                    break;
                default:
                    try {
                        if (K.instance.messageAttributes(2) && K.instance.linear(t.bluetooth.limit(G[1]) / 100, X),
                        K.instance.messageAttributes(0)) {
                            clearInterval(A);
                            const ce = 125
                              , ue = Math.floor(X / ce);
                            let Ie = 0;
                            A = setInterval( () => {
                                Ie++;
                                const ke = Ie / ue;
                                if (ke >= 1) {
                                    clearInterval(A),
                                    K.instance.vibrate(t.bluetooth.limit(100 - G[1]) / 100);
                                    return
                                }
                                let We = G[1] + (H[1] - G[1]) * ke;
                                We = Math.max(0, Math.min(100, We)),
                                K.instance.vibrate(t.bluetooth.limit(100 - We) / 100)
                            }
                            , ce)
                        }
                        K.instance.messageAttributes(1) && K.instance.rotate(t.bluetooth.limit(100 - G[1]) / 100, H[1] > G[1])
                    } catch (ce) {
                        console.log(ce)
                    }
                }
            }
            ),
            requestAnimationFrame(L)
        }
        ;
        let T = -1
          , A = -1;
        const k = xe(0);
        return requestAnimationFrame(L),
        (D, F) => {
            var z;
            return w(),
            R("div", sq, [E(it)().isProduction ? (w(),
            R("div", {
                key: 0,
                class: "relative aspect-video overflow-hidden",
                ref_key: "container",
                ref: a
            }, [zt(x("div", {
                onClick: F[1] || (F[1] = () => {
                    c.state.state === 3 && (E(s).open = !0)
                }
                ),
                class: Pt(["h-full w-full flex items-center justify-center absolute z-10 bg-black/90 text-white flex-col", {
                    "cursor-pointer": c.state.state === 3
                }])
            }, [c.state.state === 1 ? (w(),
            Re(Th, {
                key: 0,
                class: "h-16 w-16 text-white",
                loading: !0
            })) : c.state.state === 2 ? (w(),
            Re(Ys, {
                key: 1,
                path: E(S$),
                class: "h-16 w-16"
            }, null, 8, ["path"])) : le("", !0), c.state.state === 3 ? (w(),
            R("div", rq, [F[21] || (F[21] = x("p", {
                class: "text-2xl font-medium"
            }, "Interactive Content", -1)), F[22] || (F[22] = x("span", {
                class: "text-zinc-300 mt-6"
            }, "Please Buy or Connect your Handy to continue watching this video", -1)), x("div", oq, [O(je, {
                theme: "green",
                class: "mx-auto"
            }, {
                default: Y( () => F[19] || (F[19] = [J("Buy Or Connect")])),
                _: 1
            }), O(je, {
                onClick: F[0] || (F[0] = Vn( () => {}
                , ["stop"])),
                href: D.video.stream_url,
                target: "_blank",
                theme: "light"
            }, {
                default: Y( () => F[20] || (F[20] = [J("Continue Video")])),
                _: 1
            }, 8, ["href"])])])) : (w(),
            R("span", {
                key: 3,
                class: Pt(["font-medium text-center text-xl absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 mt-12", {
                    "text-base mt-16": !c.state.fullscreen
                }])
            }, ee(c.state.message), 3))], 2), [[$n, c.state.state != 0]]), !E(t).devices.length && !E(l) && !E(it)().isAuthorized ? (w(),
            R("div", aq, [x("a", {
                href: "https://www.thehandy.com/?ref=faptap&utm_source=faptap&utm_medium=affiliate&utm_campaign=The+Handy+Affiliate+program&tap_s=3539267-2a196b&tm_subid1=player",
                target: "_blank",
                "data-ph-capture-attribute-invideo-handy-ad": "1",
                onClick: F[2] || (F[2] = () => {
                    c.state.playing && p()
                }
                ),
                class: "leading-normal flex flex-col gap-2 w-full h-full"
            }, [x("div", lq, [O(FS, {
                position: k.value,
                class: "w-full h-full"
            }, null, 8, ["position"])]), e.isOverlay ? le("", !0) : (w(),
            R("div", cq, [E(it)().isProduction ? (w(),
            R("div", uq, F[23] || (F[23] = [x("p", {
                class: "font-medium text-white"
            }, "This Video is Interactive", -1), x("p", {
                class: "text-sm text-zinc-300"
            }, [J("Feel what you see with "), x("b", {
                class: "font-medium text-white"
            }, "The Handy"), J(" - the interactive, automatic stroker that syncs up with every "), x("span", {
                class: "font-medium text-white"
            }, "FapTap"), J(" video")], -1)]))) : le("", !0), F[25] || (F[25] = x("p", null, [J("Use Code "), x("b", {
                class: "font-bold text-green-400"
            }, "FAPTAP"), J(" for "), x("b", {
                class: "font-bold text-green-400"
            }, "10% OFF")], -1)), O(je, {
                class: "w-full",
                theme: "green"
            }, {
                default: Y( () => F[24] || (F[24] = [J("Buy Now")])),
                _: 1
            })]))])])) : le("", !0), zt(x("div", null, [x("div", {
                class: Pt(["flex flex-col text-zinc-300 transition-colors absolute w-full h-full top-0 left-0 z-30 xl:hidden", {
                    "bg-black/50": c.state.ui
                }])
            }, [c.state.loading ? (w(),
            R("div", dq, [O(Th, {
                loading: "",
                class: "h-16 w-16 text-white drop-shadow"
            })])) : (w(),
            R("div", {
                key: 1,
                class: Pt(["flex items-center gap-x-2 absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2", {
                    invisible: !c.state.ui && !c.state.loading
                }])
            }, [x("button", {
                onClick: F[3] || (F[3] = G => g(c.state.currentTime - 10)),
                class: "p-4"
            }, [O(Ys, {
                path: E(A$),
                name: "rewind-10",
                class: "h-6 w-6"
            }, null, 8, ["path"])]), x("button", {
                onClick: F[4] || (F[4] = G => p())
            }, [c.state.playing ? (w(),
            Re(Ys, {
                key: 0,
                path: E(Lb),
                class: "h-16 w-16"
            }, null, 8, ["path"])) : (w(),
            Re(Ys, {
                key: 1,
                path: E(Ib),
                class: "h-16 w-16"
            }, null, 8, ["path"]))]), x("button", {
                onClick: F[5] || (F[5] = G => g(c.state.currentTime + 10)),
                class: "p-4"
            }, [O(Ys, {
                path: E(w$),
                class: "h-6 w-6"
            }, null, 8, ["path"])])], 2)), x("div", {
                class: Pt(["row-span-1 flex justify-end transition-transform", c.state.ui ? "" : ["-translate-y-16"]])
            }, [x("button", {
                onClick: F[6] || (F[6] = G => c.state.settings = !0),
                class: "p-2"
            }, [O(Ys, {
                path: E(E$),
                class: "w-6 h-6"
            }, null, 8, ["path"])])], 2), x("div", {
                class: "flex-grow flex",
                onClick: F[7] || (F[7] = G => c.state.ui = !c.state.ui)
            }), x("div", {
                class: Pt(["p-2 flex items-center text-sm gap-x-2 transition-transform", c.state.ui ? "" : ["translate-y-16"]])
            }, [x("div", {
                class: Pt(["w-12 flex items-center justify-start ml-2", {
                    "w-14": c.state.duration >= 3600
                }])
            }, [x("span", fq, ee(E(fl)(c.state.currentTime)), 1)], 2), x("div", hq, [O(OS, {
                class: "w-full flex-1 mx-4 ml-1",
                max: c.state.duration,
                value: c.state.currentTime,
                actions: c.actions,
                onSeek: F[8] || (F[8] = G => g(G))
            }, null, 8, ["max", "value", "actions"])]), x("div", pq, [x("span", mq, ee(E(fl)(b.value)), 1), x("button", {
                class: "ml-2",
                onClick: f
            }, [O(Ys, {
                path: c.state.fullscreen ? E(Rb) : E(Mb),
                class: "h-8 w-8"
            }, null, 8, ["path"])])])], 2)], 2), x("div", {
                onMousemove: F[15] || (F[15] = G => (c.state.ui = !0,
                _())),
                class: Pt([{
                    "cursor-none": !c.state.ui
                }, "flex-col h-full text-zinc-300 transition-colors absolute w-full top-0 left-0 z-30 hidden xl:flex"])
            }, [c.state.loading ? (w(),
            R("div", gq, [O(Th, {
                loading: "",
                class: "h-16 w-16"
            })])) : le("", !0), x("div", {
                class: "flex-grow flex",
                onDblclick: f,
                onClick: F[9] || (F[9] = G => p(!1))
            }, null, 32), x("div", {
                class: Pt(["px-3 py-2 text-sm transition-transform bg-gradient-to-t from-black/80 to-transparent", c.state.ui ? "" : ["translate-y-20"]])
            }, [O(OS, {
                class: "w-full",
                max: c.state.duration,
                value: c.state.currentTime,
                actions: c.actions,
                onSeek: F[10] || (F[10] = G => g(G))
            }, null, 8, ["max", "value", "actions"]), x("div", vq, [x("div", {
                class: Pt(["w-12 flex items-center gap-x-3 justify-start", {
                    "w-14": c.state.duration >= 3600
                }])
            }, [x("button", {
                onClick: F[11] || (F[11] = G => p(!1)),
                class: "hover:text-white"
            }, [O(Ys, {
                path: c.state.playing ? E(Lb) : E(Ib),
                class: "h-7 w-7"
            }, null, 8, ["path"])]), x("div", _q, [x("span", xq, ee(E(fl)(c.state.currentTime)), 1), F[26] || (F[26] = J(" / ")), x("span", null, ee(E(fl)(b.value)), 1)]), x("div", yq, [x("button", {
                class: "hover:!text-white",
                onClick: F[12] || (F[12] = G => y(c.state.volume > 0 ? 0 : 1))
            }, [O(Ys, {
                path: c.state.volume > 0 ? E(C$) : E(M$),
                class: "w-6 h-6"
            }, null, 8, ["path"])]), O(JW, {
                class: "h-1 w-20",
                modelValue: c.state.volume,
                "onUpdate:modelValue": F[13] || (F[13] = G => c.state.volume = G)
            }, null, 8, ["modelValue"])])], 2), x("div", bq, [c.state.source ? (w(),
            R("button", {
                key: 0,
                ref: "qualityChooser",
                onClick: F[14] || (F[14] = G => c.state.settings = !0),
                class: "hover:!text-white flex items-center"
            }, [x("span", Sq, ee((z = c.state.source) == null ? void 0 : z.quality) + "p ", 1), O(Ys, {
                path: E(T$),
                class: "w-6 h-6 ml-1"
            }, null, 8, ["path"])], 512)) : le("", !0), x("button", {
                class: "hover:!text-white",
                onClick: f
            }, [O(Ys, {
                path: c.state.fullscreen ? E(Rb) : E(Mb),
                class: "h-8 w-8"
            }, null, 8, ["path"])])])])], 2)], 34)], 512), [[$n, c.state.state === 0]]), (w(),
            Re(ys(E(l) ? dr : ji), {
                modelValue: c.state.settings,
                "onUpdate:modelValue": F[16] || (F[16] = G => c.state.settings = G),
                target: D.$refs.qualityChooser,
                teleport: !1,
                placement: "top-end",
                offset: 8,
                class: "w-40"
            }, {
                default: Y( () => [(w(!0),
                R(Ge, null, Ht(c.sources, G => (w(),
                Re(Ot, {
                    class: "text-center",
                    active: c.state.source && c.state.source.quality === G.quality,
                    onClick: H => (m(G, !0),
                    c.state.settings = !1)
                }, {
                    default: Y( () => [J(ee(G.quality) + "p ", 1)]),
                    _: 2
                }, 1032, ["active", "onClick"]))), 256))]),
                _: 1
            }, 8, ["modelValue", "target"])), F[27] || (F[27] = x("video", {
                id: "player",
                playsinline: "",
                loop: "",
                class: "absolute w-full h-full bg-black"
            }, null, -1))], 512)) : (w(),
            R("div", {
                key: 1,
                class: "relative aspect-video overflow-hidden",
                ref_key: "container",
                ref: a
            }, [zt(x("div", {
                onClick: F[17] || (F[17] = () => {
                    c.state.state === 3 && (E(s).open = !0)
                }
                ),
                class: Pt(["h-full w-full flex items-center justify-center absolute z-10 bg-black/90 text-white flex-col", {
                    "cursor-pointer": c.state.state === 3
                }])
            }, F[28] || (F[28] = [x("video", {
                id: "player",
                playsinline: "",
                loop: "",
                class: "absolute w-full h-full bg-black"
            }, null, -1)]), 2), [[$n, c.state.state != 0]])], 512)), x("div", Eq, [!E(t).devices.length && E(l) && !E(it)().isAuthorized ? (w(),
            R("div", wq, [x("a", {
                href: "https://www.thehandy.com/?ref=faptap&utm_source=faptap&utm_medium=affiliate&utm_campaign=The+Handy+Affiliate+program&tap_s=3539267-2a196b&tm_subid1=player",
                target: "_blank",
                "data-ph-capture-attribute-invideo-handy-ad": "1",
                onClick: F[18] || (F[18] = () => {
                    c.state.playing && p()
                }
                ),
                class: "leading-normal flex gap-2 w-full h-full"
            }, [x("div", Tq, [O(FS, {
                position: k.value,
                class: "w-full h-full object-contain"
            }, null, 8, ["position"])]), e.isOverlay ? le("", !0) : (w(),
            R("div", Aq, [F[30] || (F[30] = pa('<div class="text-start"><p class="font-medium text-white">This Video is Interactive</p><p class="text-sm text-zinc-300">Feel what you see with <b class="font-medium text-white">The Handy</b> - the interactive, automatic stroker that syncs up with every <span class="font-medium text-white">FapTap</span> video</p></div><p>Use Code <b class="font-bold text-green-400">FAPTAP</b> for <b class="font-bold text-green-400">10% OFF</b></p>', 2)), O(je, {
                class: "w-full",
                theme: "green"
            }, {
                default: Y( () => F[29] || (F[29] = [J("Buy Now")])),
                _: 1
            })]))])])) : le("", !0)])])
        }
    }
})
  , WM = async i => {
    const e = await ct.videos.getScript(i.script.url)
      , t = {
        metadata: {
            title: i.name,
            description: i.description,
            performers: i.performers ? i.performers.map(s => s.name) : [],
            video_url: i.stream_url,
            tags: i.tags ? i.tags.map(s => s.name) : [],
            duration: i.duration * 1e3,
            average_speed: i.script.average_speed,
            creator: i.user.username
        },
        actions: e.map(s => ({
            at: s[0],
            pos: s[1]
        }))
    }
      , n = document.createElement("a");
    n.setAttribute("href", "data:text/plain;charset=utf-8," + encodeURIComponent(JSON.stringify(t))),
    n.setAttribute("download", `${i.name}.funscript`),
    n.style.display = "none",
    document.body.appendChild(n),
    n.click(),
    document.body.removeChild(n)
}
  , Cq = ["src", "type", "quality"]
  , qM = ut({
    __name: "VRPlayer",
    props: {
        video: {}
    },
    setup(i) {
        const e = Zr()
          , t = i
          , n = xe([]);
        let s = []
          , r = {}
          , o = !1;
        Ln(async () => {
            var g;
            const p = await ct.videos.getSources(t.video.id);
            n.value = p.map(m => ({
                url: m.url.startsWith("http") ? m.url : `/api/${m.url}`,
                type: m.format === "mp4" ? "video/mp4" : "application/x-mpegurl",
                quality: m.quality + "p"
            }));
            try {
                s = await ct.videos.getScript(t.video.script.url)
            } catch (m) {
                console.log(m);
                return
            }
            (g = document.querySelector("dl8-advertisement")) == null || g.setAttribute("on-request-advertisement", "onRequestAdvertisement"),
            window.onRequestAdvertisement = h,
            await a(),
            await new Promise(m => setTimeout(m, 100)),
            r = document.querySelector("dl8-video"),
            r.addEventListener("play", () => {
                o = !0,
                e.handy.play(Math.floor(r.currentTime * 1e3))
            }
            ),
            r.addEventListener("seeked", () => {
                e.handy.play(Math.floor(r.currentTime * 1e3))
            }
            ),
            r.addEventListener("pause", () => {
                o = !1,
                c()
            }
            ),
            await ct.videos.viewVideo(t.video.id),
            await l()
        }
        ),
        Zd( () => {
            r.pause(),
            c()
        }
        );
        const a = () => {
            new Promise( (p, g) => {
                if ("__dl8__iframe"in window) {
                    p(null);
                    return
                }
                const m = document.createElement("script");
                m.src = "/vr.js",
                m.onload = p,
                m.onerror = g,
                document.head.appendChild(m)
            }
            )
        }
          , l = async () => {
            try {
                await e.handy.prepare(Gs(t.video.script.url));
                try {
                    r.pause(),
                    r.play().then()
                } catch {}
            } catch (p) {
                console.log(p)
            }
        }
        ;
        Bt( () => e.handy.connected, async p => {
            !p || await l()
        }
        );
        const c = () => {
            e.devices.forEach(p => {
                switch (p.connector) {
                case cn.Handy:
                    e.handy.stop();
                    break;
                case cn.Intiface:
                    p.instance.stop();
                    break;
                case cn.Bluetooth:
                    p.instance.stop();
                    break
                }
            }
            )
        }
          , u = () => {
            if (!o) {
                requestAnimationFrame(u);
                return
            }
            const p = r.currentTime * 1e3;
            let g = -1;
            for (let y = 0; y < s.length; y++)
                if (s[y][0] >= p) {
                    g = y;
                    break
                }
            if (g === -1 || g === d) {
                requestAnimationFrame(u);
                return
            }
            const m = s[g]
              , v = s[g - 1];
            d = g;
            const _ = m[0] - p;
            console.log(`[Player] pos=${m[1]} in=${_.toFixed(0)}ms`),
            e.devices.forEach(y => {
                switch (y.connector) {
                case cn.OSR:
                    e.osr.move(m[1], _);
                    break;
                case cn.LOOB:
                    e.loob.move(m[1], _);
                    break;
                case cn.Handy:
                    break;
                default:
                    try {
                        if (y.instance.messageAttributes(2) && y.instance.linear(e.bluetooth.limit(m[1]) / 100, _),
                        y.instance.messageAttributes(0)) {
                            clearInterval(f);
                            const b = 125
                              , S = Math.floor(_ / b);
                            let C = 0;
                            f = setInterval( () => {
                                C++;
                                const M = C / S;
                                if (M >= 1) {
                                    clearInterval(f),
                                    y.instance.vibrate(e.bluetooth.limit(100 - m[1]) / 100);
                                    return
                                }
                                let L = m[1] + (v[1] - m[1]) * M;
                                L = Math.max(0, Math.min(100, L)),
                                y.instance.vibrate(e.bluetooth.limit(100 - L) / 100)
                            }
                            , b)
                        }
                        y.instance.messageAttributes(1) && y.instance.rotate(e.bluetooth.limit(100 - m[1]) / 100, v[1] > m[1])
                    } catch (b) {
                        console.log(b)
                    }
                }
            }
            ),
            requestAnimationFrame(u)
        }
        ;
        let d = -1
          , f = -1;
        requestAnimationFrame(u);
        const h = (p, g, m) => {
            switch (p.spot) {
            case "DESKTOP_PAUSE_CENTRE_RECTANGLE_300X250":
            case "MOBILE_PAUSE_CENTRE_RECTANGLE_300X250":
                return m({
                    type: "image",
                    payload: {
                        uri: "/affiliates/vr/slr.1.png",
                        adLink: "https://www.sexlikereal.com/?a=63e4b20bb7a0b71d6e675d47"
                    }
                });
            case "VR_HUD_BOTTOM_BANNER_468X60":
                return m({
                    type: "image",
                    payload: {
                        uri: "/affiliates/vr/slr.2.png",
                        adLink: "https://www.sexlikereal.com/?a=63e4b20bb7a0b71d6e675d47"
                    }
                })
            }
            return m(null)
        }
        ;
        return (p, g) => {
            const m = li("dl8-advertisement")
              , v = li("dl8-video");
            return w(),
            R("div", null, [O(v, {
                poster: E(Gs)(p.video.thumbnail_url),
                title: t.video.name,
                author: t.video.user.username,
                format: "STEREO_FISHEYE_200_LR",
                height: "100%",
                width: "100%"
            }, {
                default: Y( () => [(w(!0),
                R(Ge, null, Ht(n.value, _ => (w(),
                R("source", {
                    src: _.url,
                    type: _.type,
                    quality: _.quality
                }, null, 8, Cq))), 256)), O(m)]),
                _: 1
            }, 8, ["poster", "title", "author"])])
        }
    }
});
const Mq = ["href", "data-ph-capture-attribute-product"]
  , Rq = {
    class: "aspect-square overflow-hidden bg-[#F6F5F3] shrink-0"
}
  , Lq = ["src"]
  , Iq = {
    key: 0,
    class: "p-2.5"
}
  , kq = {
    class: "line-clamp-2 h-12 text-zinc-200"
}
  , Pq = {
    class: "text-sm text-zinc-400"
}
  , Dq = {
    class: "font-bold text-blue-500 text-base"
}
  , Fq = {
    class: "flex justify-between items-end mt-1.5"
}
  , Oq = {
    class: "text-4xl lg:text-3xl font-bold text-blue-500"
}
  , Uq = {
    class: "text-lg font-medium text-red-400 line-through"
}
  , Nq = {
    key: 1,
    class: "p-2.5"
}
  , Bq = {
    class: "line-clamp-2 h-12 text-zinc-200"
}
  , Vq = {
    class: "text-sm text-zinc-400"
}
  , $q = {
    class: "font-bold text-blue-500 text-base"
}
  , Hq = {
    class: "flex justify-between items-end mt-1.5"
}
  , zq = {
    class: "text-4xl lg:text-3xl font-bold text-blue-500"
}
  , Gq = {
    class: "text-lg font-medium text-red-400 line-through"
}
  , Cm = ut({
    __name: "ProductScroller",
    props: {
        products: {},
        vertical: {
            type: Boolean
        },
        subId: {}
    },
    setup(i) {
        const e = i;
        Zr();
        const t = Vt( () => {
            let s = e.products.filter(o => o.category !== "bundles");
            return [...e.products.filter(o => o.category === "bundles"), ...s]
        }
        )
          , n = s => {
            const r = s.discount_original_price ? s.discount_original_price : s.price
              , o = s.price - s.price * .1;
            return Math.round((r - o) / r * 100)
        }
        ;
        return (s, r) => (w(),
        Re(Er, {
            gap: "gap-4"
        }, {
            default: Y( () => [(w(!0),
            R(Ge, null, Ht(t.value, o => (w(),
            R("a", {
                class: Pt(["bg-zinc-800 rounded-lg overflow-hidden group h-full flex", s.vertical ? ["flex-row", "!h-32", "w-80"] : ["flex-col", "w-52"]]),
                href: `${o.url}?ref=faptap&utm_source=faptap&utm_medium=affiliate&utm_campaign=The+Handy+Affiliate+program&tap_s=3539267-2a196b&tm_subid1=${s.subId}`,
                "data-ph-capture-attribute-product": o.name,
                target: "_blank"
            }, [x("div", Rq, [x("img", {
                src: o.image,
                class: "object-cover w-full h-full group-hover:scale-105 transition-transform"
            }, null, 8, Lq)]), o.discount_original_price ? (w(),
            R("div", Iq, [x("p", kq, ee(o.name), 1), x("div", Pq, [r[0] || (r[0] = J("Get ")), x("b", Dq, ee(((1 - o.price / o.discount_original_price) * 100).toFixed(0)) + "% OFF", 1)]), x("div", Fq, [x("p", Oq, ee(Intl.NumberFormat("en-US", {
                style: "currency",
                currency: o.currency,
                minimumFractionDigits: 0,
                maximumFractionDigits: 0
            }).format(o.price)), 1), x("p", Uq, ee(Intl.NumberFormat("en-US", {
                style: "currency",
                currency: o.currency,
                minimumFractionDigits: 0,
                maximumFractionDigits: 0
            }).format(o.discount_original_price ? o.discount_original_price : o.price)), 1)])])) : (w(),
            R("div", Nq, [x("p", Bq, ee(o.name), 1), x("div", Vq, [x("b", $q, ee(n(o)) + "% OFF", 1), r[1] || (r[1] = J(" - Code ")), r[2] || (r[2] = x("b", {
                class: "font-bold text-blue-500"
            }, "FAPTAP", -1))]), x("div", Hq, [x("p", zq, ee(Intl.NumberFormat("en-US", {
                style: "currency",
                currency: o.currency,
                minimumFractionDigits: 0,
                maximumFractionDigits: 0
            }).format(o.price - o.price * .1)), 1), x("p", Gq, ee(Intl.NumberFormat("en-US", {
                style: "currency",
                currency: o.currency,
                minimumFractionDigits: 0,
                maximumFractionDigits: 0
            }).format(o.discount_original_price ? o.discount_original_price : o.price)), 1)])]))], 10, Mq))), 256))]),
            _: 1
        }))
    }
})
  , Wq = {
    key: 0,
    class: "text-white text-center mt-4 mb-2"
}
  , qq = {
    key: 1,
    class: "text-white text-center mb-2",
    style: {
        color: "lightgreen"
    }
}
  , jq = ["href"]
  , Kq = {
    key: 1,
    target: "_blank",
    rel: "nofollow",
    href: "https://www.sexlikereal.com/tags/interactive-sex-toys-vr?a=63e4b20bb7a0b71d6e675d47",
    class: "bg-blue-900/50 cursor-pointer p-2.5 lg:rounded-md block lg:flex gap-3 items-center justify-between lg:mt-2.5"
}
  , Xq = {
    class: "flex items-center gap-x-3 flex-col lg:flex-row"
}
  , Yq = {
    key: 4,
    "data-ph-capture-attribute-adulttime-banner": "1",
    target: "_blank",
    rel: "nofollow",
    href: "https://www.g2fame.com/adulttime/go.php?pr=8&su=1&si=247&ad=280096&cl=/toys&ar=&campaign=457485&buffer=",
    class: "bg-blue-700/50 cursor-pointer p-2.5 lg:rounded-md block lg:flex gap-3 items-center justify-between lg:mt-2.5"
}
  , Zq = {
    class: "text-white flex flex-col gap-y-2 mt-3 px-2 md:px-0"
}
  , Jq = ["title"]
  , Qq = {
    class: "font-medium flex justify-between text-sm -mt-2 text-zinc-400"
}
  , ej = ["title"]
  , tj = {
    class: "flex items-center gap-1"
}
  , nj = ["title"]
  , ij = {
    class: "flex flex-col-reverse lg:flex-row lg:items-center justify-between gap-y-2"
}
  , sj = {
    class: "flex items-center gap-x-8 justify-between"
}
  , rj = {
    class: "flex flex-col"
}
  , oj = {
    class: "text-sm text-white font-medium"
}
  , aj = {
    class: "text-xs text-zinc-500"
}
  , lj = {
    class: "flex gap-1.5"
}
  , cj = {
    name: "watch",
    components: {
        VRPlayer: qM,
        ProductScroller: Cm
    }
}
  , uj = ut({
    ...cj,
    async setup(i) {
        var m;
        let e, t;
        const {isProduction: n} = it()
          , {isAuthorized: s, user: r, isAdmin: o} = it()
          , a = Ki();
        Ks(),
        Pn(Zr());
        const {authDialog: l} = Pn(Xi())
          , c = ti()
          , u = xe((m = c.currentRoute.value.query.overlay) != null ? m : null)
          , d = ([e,t] = As( () => ct.videos.getVideo(a.params.id)),
        e = await e,
        t(),
        e)
          , f = xe(!1)
          , h = xe(!0);
        let p;
        try {
            p = ([e,t] = As( () => ct.products.getProducts()),
            e = await e,
            t(),
            e)
        } catch (v) {
            console.log(v)
        }
        const g = v => {
            window.location.reload()
        }
        ;
        return Ln( () => {
            window.scroll({
                top: 0
            })
        }
        ),
        ci(n ? `${d.name} FapTap` : "Demo"),
        (v, _) => {
            const y = li("router-link");
            return w(),
            R(Ge, null, [E(s) ? le("", !0) : (w(),
            R(Ge, {
                key: 0
            }, [E(it)().isProduction ? (w(),
            R("div", Wq, [x("p", null, [x("span", {
                onClick: _[0] || (_[0] = b => l.value = !0),
                class: "text-blue-500 cursor-pointer"
            }, "Sign up / Log in"), _[4] || (_[4] = x("span", {
                style: {
                    "font-weight": "100",
                    color: "lightgrey"
                }
            }, " to remove ads and use FaptapAI.", -1))])])) : le("", !0), E(it)().isProduction ? (w(),
            R("div", qq, _[5] || (_[5] = [J(" \u{1F389} NEW: We are hiring a community manager! "), x("span", {
                style: {
                    "font-weight": "100",
                    color: "lightgrey"
                }
            }, [J(" Read more "), x("a", {
                href: "/careers/community-manager",
                style: {
                    "text-decoration": "underline"
                }
            }, "here"), J(".")], -1)]))) : le("", !0)], 64)), E(d).vr ? (w(),
            Re(qM, {
                key: 1,
                video: E(d),
                class: "aspect-video bg-black overflow-hidden -mt-2 lg:mt-0 lg:max-h-[60vh] w-full lg:rounded-md"
            }, null, 8, ["video"])) : (w(),
            Re(mx, {
                key: 2,
                video: E(d),
                isOverlay: u.value,
                class: "aspect-video -mt-2 lg:mt-0 lg:max-h-[60vh] w-full lg:rounded-md"
            }, null, 8, ["video", "isOverlay"])), E(d).stream_url.startsWith("https://www.sexlikereal.com/scenes/") ? (w(),
            R(Ge, {
                key: 3
            }, [E(d).user.username.toLowerCase() === "realcumber" ? (w(),
            R("a", {
                key: 0,
                target: "_blank",
                rel: "nofollow",
                href: E(d).stream_url,
                class: "bg-blue-900/50 cursor-pointer p-2.5 lg:rounded-md block lg:flex gap-3 items-center justify-between lg:mt-2.5"
            }, [_[7] || (_[7] = x("p", null, [x("span", null, [J("Continue watching the complete video in better quality on "), x("b", null, "SexLikeReal")])], -1)), O(je, {
                theme: "blue",
                class: "w-full mt-3 lg:w-auto lg:mt-0"
            }, {
                default: Y( () => _[6] || (_[6] = [J("Watch Now")])),
                _: 1
            })], 8, jq)) : (w(),
            R("a", Kq, [_[10] || (_[10] = x("p", null, [x("span", null, [J("Watch this video in better quality and many more on "), x("b", null, "SexLikeReal")])], -1)), x("span", Xq, [_[9] || (_[9] = x("span", null, [J("Use Code "), x("b", null, "FAPTAP"), J(" for "), x("b", null, "57% OFF")], -1)), O(je, {
                theme: "blue",
                class: "w-full mt-3 lg:w-auto lg:mt-0"
            }, {
                default: Y( () => _[8] || (_[8] = [J("Watch Now")])),
                _: 1
            })])]))], 64)) : le("", !0), E(d).stream_url.startsWith("https://members.adulttime") ? (w(),
            R("a", Yq, [_[12] || (_[12] = x("p", null, [x("span", null, [J("Watch this video in better quality and 1000+ others on "), x("b", null, "AdultTime")])], -1)), O(je, {
                theme: "blue",
                class: "w-full mt-3 lg:w-auto lg:mt-0"
            }, {
                default: Y( () => _[11] || (_[11] = [J("Watch Now")])),
                _: 1
            })])) : le("", !0), x("div", Zq, [x("h1", {
                title: E(d).name,
                class: "font-medium text-xl lg:text-2xl leading-none"
            }, ee(E(d).name), 9, Jq), x("div", Qq, [x("span", {
                title: E(d).views.toString()
            }, ee(E(vr)(E(d).views)) + " views \u2022 " + ee(E(j_)(new Date(E(d).created_at))) + " ago ", 9, ej), x("span", tj, [J(ee(E(d).script.average_speed) + " ", 1), O(ze, {
                name: "speedometer",
                class: "h-4 w-4"
            }), _[13] || (_[13] = J(" \u2022 ")), x("span", {
                title: E(d).script.total_actions.toString()
            }, ee(E(vr)(E(d).script.total_actions)) + " actions", 9, nj)])]), x("div", ij, [x("div", sj, [O(y, {
                to: `/u/${E(d).user.username}`,
                class: "flex gap-x-3 items-center"
            }, {
                default: Y( () => [O(Bo, {
                    image: E(d).user.avatar_url,
                    icon: "account",
                    class: "h-9 w-9"
                }, null, 8, ["image"]), x("div", rj, [x("span", oj, ee(E(d).user.username), 1), x("span", aj, ee(E(d).user.subscribers) + " subscribers", 1)])]),
                _: 1
            }, 8, ["to"]), x("div", lj, [E(d).user.profile.support_url && E(d).user.profile.support_url.length ? (w(),
            Re(je, {
                key: 0,
                href: E(d).user.profile.support_url,
                class: "lg:w-28",
                theme: "green"
            }, {
                default: Y( () => [O(ze, {
                    name: "currency",
                    class: "h-5 w-5 lg:hidden"
                }), _[14] || (_[14] = x("span", {
                    class: "hidden lg:!block"
                }, "Support", -1))]),
                _: 1
            }, 8, ["href"])) : le("", !0), O(wm, {
                user: E(d).user,
                class: "w-28"
            }, null, 8, ["user"])])]), O(Er, {
                gap: "gap-2",
                class: "-mx-2 lg:mx-0"
            }, {
                default: Y( () => {
                    var b, S, C, M;
                    return [O(OC, {
                        "thing-type": E(gp).Video,
                        "thing-id": (b = E(d)) == null ? void 0 : b.id,
                        likes: (S = E(d)) == null ? void 0 : S.rating.likes,
                        liked: (C = E(d)) == null ? void 0 : C.rating.liked
                    }, null, 8, ["thing-type", "thing-id", "likes", "liked"]), E(s) && (((M = E(r)) == null ? void 0 : M.id) === E(d).user.id || E(o)) ? (w(),
                    Re(je, {
                        key: 0,
                        onClick: _[1] || (_[1] = L => f.value = !0),
                        class: "flex items-center justify-center gap-x-2"
                    }, {
                        default: Y( () => [O(ze, {
                            name: "pencil",
                            class: "h-5 w-5"
                        }), _[15] || (_[15] = x("span", {
                            class: "text-white font-semibold"
                        }, "Edit", -1))]),
                        _: 1
                    })) : le("", !0), E(d).downloadable ? (w(),
                    Re(je, {
                        key: 1,
                        onClick: _[2] || (_[2] = L => E(s) ? E(WM)(E(d)) : l.value = !0),
                        class: "flex items-center justify-center gap-x-2 !px-3"
                    }, {
                        default: Y( () => [O(ze, {
                            name: "download",
                            class: "h-5 w-5"
                        }), _[16] || (_[16] = x("span", null, "Script", -1))]),
                        _: 1
                    })) : le("", !0), E(d).stream_url && !E(d).stream_url.startsWith("https://members.adulttime") ? (w(),
                    Re(je, {
                        key: 2,
                        href: E(d).stream_url,
                        class: "flex items-center justify-center gap-x-2 !px-3"
                    }, {
                        default: Y( () => [O(ze, {
                            name: "link",
                            class: "h-5 w-5"
                        }), _[17] || (_[17] = x("span", null, "Source", -1))]),
                        _: 1
                    }, 8, ["href"])) : le("", !0)]
                }
                ),
                _: 1
            })]), E(d).description ? (w(),
            Re(Y_, {
                key: 0,
                class: "text-sm mt-3",
                height: 80,
                text: E(d).description
            }, null, 8, ["text"])) : le("", !0), E(d).performers && E(d).performers.length > 0 || E(d).tags && E(d).tags.length > 0 ? (w(),
            Re(Er, {
                key: 1,
                gap: "gap-1.5",
                class: "-mx-2 lg:mx-0"
            }, {
                default: Y( () => [(w(!0),
                R(Ge, null, Ht(E(d).performers, b => (w(),
                Re(je, {
                    to: `/p/${b.slug}`
                }, {
                    default: Y( () => [x("span", null, ee(b.name), 1)]),
                    _: 2
                }, 1032, ["to"]))), 256)), (w(!0),
                R(Ge, null, Ht(E(d).tags, b => (w(),
                Re(je, {
                    to: `/t/${b.slug}`
                }, {
                    default: Y( () => [J(ee(b.name), 1)]),
                    _: 2
                }, 1032, ["to"]))), 256))]),
                _: 1
            })) : le("", !0)]), O(Cm, {
                vertical: "",
                class: "my-4",
                subId: "products-video",
                products: E(p)
            }, null, 8, ["products"]), h.value ? (w(),
            Re(JV, {
                key: 5,
                "thing-id": E(d).id,
                "thing-type": E(gp).Video,
                class: "my-3 max-w-3xl text-white"
            }, null, 8, ["thing-id", "thing-type"])) : le("", !0), E(d) ? (w(),
            Re($l, {
                key: 6,
                video: E(d).id,
                filters: !1
            }, null, 8, ["video"])) : le("", !0), O(mr, {
                modelValue: f.value,
                "onUpdate:modelValue": _[3] || (_[3] = b => f.value = b),
                title: "Edit Video"
            }, {
                default: Y( () => [O(b$, {
                    video: E(d),
                    onSubmitVideo: g
                }, null, 8, ["video"])]),
                _: 1
            }, 8, ["modelValue"])], 64)
        }
    }
})
  , dj = {
    key: 0,
    class: "bg-red-600 rounded-md p-2 text-sm"
}
  , fj = {
    class: "flex flex-col gap-y-1"
}
  , hj = {
    class: "flex flex-col gap-y-1"
}
  , pj = {
    class: "flex flex-col gap-y-1"
}
  , mj = {
    class: "flex"
}
  , gj = {
    ref: "el",
    class: "flex items-center"
}
  , vj = {
    class: "w-64 p-3"
}
  , _j = {
    class: "text-zinc-300 mt-3 text-sm"
}
  , xj = ["href"]
  , yj = {
    class: "mt-1"
}
  , bj = {
    class: "flex gap-3"
}
  , Sj = {
    class: "mt-1"
}
  , Ej = ["value"]
  , wj = {
    class: "flex gap-3"
}
  , Tj = ut({
    __name: "FunscriptForm",
    props: {
        funscript: {}
    },
    emits: ["submit-funscript"],
    setup(i, {emit: e}) {
        const t = i
          , n = e
          , s = xe(!1)
          , r = ti()
          , o = ei({
            loading: !1,
            performers: [],
            tags: [],
            providers: [],
            projections: ["MONO_FLAT", "MONO_360", "STEREO_FLAT_LR", "STEREO_FLAT_LR_SQUARE", "STEREO_FLAT_TB", "STEREO_FLAT_TB_SQUARE", "STEREO_180_LR", "STEREO_180_LR_SPHERICAL", "STEREO_180_TB", "STEREO_180_TB_SPHERICAL", "STEREO_360_LR", "STEREO_360_TB", "STEREO_FISHEYE_200_LR"],
            fields: {
                name: "",
                description: "",
                stream_url: "",
                downloadable: !0,
                performers: [],
                tags: [],
                orientation: 0,
                vr: !1,
                projection: "MONO_FLAT"
            }
        });
        Ln( () => {
            t.funscript && (o.fields.id = t.funscript.id,
            o.fields.name = t.funscript.video.name,
            o.fields.downloadable = t.funscript.video.downloadable,
            o.fields.description = t.funscript.video.description,
            o.fields.stream_url = t.funscript.video.stream_url,
            o.fields.orientation = t.funscript.video.orientation,
            o.fields.vr = t.funscript.video.vr,
            o.fields.projection = t.funscript.video.projection,
            t.funscript.video.tags && (o.fields.tags = t.funscript.video.tags.map(d => d.name)),
            t.funscript.video.performers && (o.fields.performers = t.funscript.video.performers.map(d => d.name))),
            ct.providers.getProviders().then(d => o.providers = d)
        }
        );
        const a = async () => {
            try {
                o.loading = !0,
                o.error = void 0;
                let d;
                o.fields.id ? d = await ct.funscripts.updateFunscriptVideo(o.fields) : d = await ct.funscripts.createFunscriptVideo(o.fields),
                n("submit-funscript")
            } catch (d) {
                o.error = d
            } finally {
                o.loading = !1
            }
        }
          , l = async d => {
            if (d.length < 2) {
                o.tags = [];
                return
            }
            const f = await ct.tags.getTags({
                query: d,
                orderBy: "videos"
            });
            o.tags = f.map(h => h.name)
        }
          , c = async d => {
            if (d.length < 2) {
                o.tags = [];
                return
            }
            const f = await ct.performers.getPerformers({
                page: 1,
                limit: 10,
                query: d
            });
            o.performers = f.map(h => h.name)
        }
          , u = async () => {
            if (!!o.fields.id) {
                o.loading = !0;
                try {
                    await ct.funscripts.deleteFunscript(o.fields.id),
                    r.push("/funscripts"),
                    n("submit-funscript")
                } catch (d) {
                    console.log(d),
                    o.error = d
                } finally {
                    o.loading = !1
                }
            }
        }
        ;
        return (d, f) => (w(),
        R("form", {
            onSubmit: Vn(a, ["prevent"]),
            class: "flex flex-col gap-y-3 mt-4"
        }, [o.error ? (w(),
        R("div", dj, ee(o.error), 1)) : le("", !0), x("div", fj, [O(vn, {
            required: "",
            modelValue: o.fields.name,
            "onUpdate:modelValue": f[0] || (f[0] = h => o.fields.name = h),
            placeholder: "Title"
        }, null, 8, ["modelValue"])]), x("div", hj, [O(vn, {
            rows: "3",
            textarea: !0,
            modelValue: o.fields.description,
            "onUpdate:modelValue": f[1] || (f[1] = h => o.fields.description = h),
            placeholder: "Description"
        }, null, 8, ["modelValue"])]), x("div", pj, [x("div", mj, [O(vn, {
            class: "flex-1",
            required: "",
            modelValue: o.fields.stream_url,
            "onUpdate:modelValue": f[2] || (f[2] = h => o.fields.stream_url = h),
            placeholder: "Stream URL"
        }, null, 8, ["modelValue"]), x("div", gj, [O(je, {
            onClick: f[3] || (f[3] = h => s.value = !0),
            type: "button",
            theme: "transparent",
            class: "!pr-0"
        }, {
            default: Y( () => [O(ze, {
                name: "help-outline",
                class: "h-6 w-6 text-zinc-400"
            })]),
            _: 1
        })], 512), O(ji, {
            modelValue: s.value,
            "onUpdate:modelValue": f[4] || (f[4] = h => s.value = h),
            target: d.$refs.el,
            placement: "right",
            offset: 8
        }, {
            default: Y( () => [x("div", vj, [f[10] || (f[10] = x("p", {
                class: "text-white font-medium"
            }, "Supported sites", -1)), x("ul", _j, [(w(!0),
            R(Ge, null, Ht(o.providers, h => (w(),
            R("li", null, [x("a", {
                href: `https://${h}`,
                target: "_blank",
                class: "hover:text-white"
            }, "https://" + ee(h), 9, xj)]))), 256))])])]),
            _: 1
        }, 8, ["modelValue", "target"])])]), x("div", null, [O(wp, {
            class: "mt-1",
            onSearch: l,
            modelValue: o.fields.tags,
            "onUpdate:modelValue": f[5] || (f[5] = h => o.fields.tags = h),
            options: o.tags,
            max: 20,
            placeholder: "Tags",
            create: !0
        }, null, 8, ["modelValue", "options"])]), x("div", null, [O(wp, {
            class: "mt-1",
            onSearch: c,
            modelValue: o.fields.performers,
            "onUpdate:modelValue": f[6] || (f[6] = h => o.fields.performers = h),
            options: o.performers,
            max: 10,
            placeholder: "Performers",
            create: !0
        }, null, 8, ["modelValue", "options"])]), x("div", yj, [zt(x("select", {
            "onUpdate:modelValue": f[7] || (f[7] = h => o.fields.orientation = h),
            class: "w-full bg-zinc-800 rounded px-2 py-2 focus-visible:outline-none focus:ring-2 ring-blue-500"
        }, f[11] || (f[11] = [x("option", {
            value: 0
        }, "Straight", -1), x("option", {
            value: 1
        }, "Transgender", -1), x("option", {
            value: 2
        }, "Gay", -1)]), 512), [[wd, o.fields.orientation]])]), x("div", bj, [f[12] || (f[12] = x("span", {
            class: "font-medium text-sm text-zinc-400"
        }, "VR", -1)), zt(x("input", {
            type: "checkbox",
            "onUpdate:modelValue": f[8] || (f[8] = h => o.fields.vr = h)
        }, null, 512), [[Fc, o.fields.vr]])]), zt(x("div", Sj, [zt(x("select", {
            "onUpdate:modelValue": f[9] || (f[9] = h => o.fields.projection = h),
            class: "w-full bg-zinc-800 rounded px-2 py-2 focus-visible:outline-none focus:ring-2 ring-blue-500"
        }, [(w(!0),
        R(Ge, null, Ht(o.projections, h => (w(),
        R("option", {
            value: h
        }, ee(h), 9, Ej))), 256))], 512), [[wd, o.fields.projection]])], 512), [[$n, o.fields.vr]]), x("div", wj, [o.fields.id ? (w(),
        Re(je, {
            key: 0,
            loading: o.loading,
            theme: "red",
            onClick: u,
            class: "shrink-0"
        }, {
            default: Y( () => f[13] || (f[13] = [J("Delete")])),
            _: 1
        }, 8, ["loading"])) : le("", !0), O(je, {
            loading: o.loading,
            theme: "blue",
            class: "flex-1"
        }, {
            default: Y( () => [J(ee(o.fields.id ? "Edit" : "Create"), 1)]),
            _: 1
        }, 8, ["loading"])])], 32))
    }
})
  , Aj = {
    key: 0,
    class: "text-white text-center mt-4 mb-2"
}
  , Cj = ["href"]
  , Mj = {
    key: 1,
    target: "_blank",
    rel: "nofollow",
    href: "https://www.sexlikereal.com/tags/interactive-sex-toys-vr?a=63e4b20bb7a0b71d6e675d47",
    class: "bg-blue-900/50 cursor-pointer p-2.5 lg:rounded-md block lg:flex gap-3 items-center justify-between lg:mt-2.5"
}
  , Rj = {
    class: "flex items-center gap-x-3 flex-col lg:flex-row"
}
  , Lj = {
    key: 4,
    "data-ph-capture-attribute-adulttime-banner": "1",
    target: "_blank",
    rel: "nofollow",
    href: "https://www.g2fame.com/adulttime/go.php?pr=8&su=1&si=247&ad=280096&cl=/toys&ar=&campaign=457485&buffer=",
    class: "bg-blue-700/50 cursor-pointer p-2.5 lg:rounded-md block lg:flex gap-3 items-center justify-between lg:mt-2.5"
}
  , Ij = {
    class: "text-white flex flex-col gap-y-2 mt-3 px-2 md:px-0"
}
  , kj = ["title"]
  , Pj = {
    class: "font-medium flex justify-between text-sm -mt-2 text-zinc-400"
}
  , Dj = ["title"]
  , Fj = {
    class: "flex items-center gap-1"
}
  , Oj = ["title"]
  , Uj = {
    class: "flex flex-col-reverse lg:flex-row lg:items-center justify-between gap-y-2"
}
  , Nj = {
    class: "flex items-center gap-x-8 justify-between"
}
  , Bj = {
    class: "flex flex-col"
}
  , Vj = {
    class: "text-sm text-white font-medium"
}
  , $j = {
    class: "text-xs text-zinc-500"
}
  , Hj = {
    class: "flex gap-1.5"
}
  , zj = {
    name: "watchFunscript",
    components: {
        Player: mx,
        ProductScroller: Cm
    }
}
  , Gj = ut({
    ...zj,
    async setup(i) {
        let e, t;
        const {isAuthorized: n, user: s, isAdmin: r, isProduction: o} = it()
          , a = Ki()
          , {isMobile: l} = Ks();
        Pn(Zr());
        const {authDialog: c} = Pn(Xi())
          , u = ([e,t] = As( () => ct.funscripts.getFunscript(a.params.id)),
        e = await e,
        t(),
        e)
          , d = xe(!1);
        xe(a.query.comments === "true" || l),
        u.video && (u.video.script.url = u.script_url,
        u.video.script.hotspots = u.script_hotspots,
        u.video.script.average_speed = u.script_avg_speed,
        u.video.script.total_actions = u.script_total_actions);
        let f;
        try {
            f = ([e,t] = As( () => ct.products.getProducts()),
            e = await e,
            t(),
            e)
        } catch (h) {
            console.log(h)
        }
        return Ln( () => {
            window.scroll({
                top: 0
            })
        }
        ),
        ci(o ? `${u.video.name} FapTap` : "Demo"),
        (h, p) => {
            const g = li("VRPlayer")
              , m = li("router-link");
            return w(),
            R(Ge, null, [E(n) ? le("", !0) : (w(),
            R(Ge, {
                key: 0
            }, [E(it)().isProduction ? (w(),
            R("div", Aj, [x("p", null, [x("span", {
                onClick: p[0] || (p[0] = v => c.value = !0),
                class: "text-blue-500 cursor-pointer"
            }, "Sign up / Log in"), p[5] || (p[5] = J(" to remove ads and request scripts."))])])) : le("", !0)], 64)), E(u).video.vr ? (w(),
            Re(g, {
                key: 1,
                video: E(u).video,
                class: "aspect-video bg-black overflow-hidden -mt-2 lg:mt-0 lg:max-h-[60vh] w-full lg:rounded-md"
            }, null, 8, ["video"])) : le("", !0), E(u).video ? (w(),
            Re(mx, {
                key: 2,
                video: E(u).video,
                class: "aspect-video -mt-2 lg:mt-0 lg:max-h-[60vh] w-full lg:rounded-md"
            }, null, 8, ["video"])) : le("", !0), E(u).video.stream_url.startsWith("https://www.sexlikereal.com/scenes/") ? (w(),
            R(Ge, {
                key: 3
            }, [E(u).video.user.username.toLowerCase() === "realcumber" ? (w(),
            R("a", {
                key: 0,
                target: "_blank",
                rel: "nofollow",
                href: E(u).video.stream_url,
                class: "bg-blue-900/50 cursor-pointer p-2.5 lg:rounded-md block lg:flex gap-3 items-center justify-between lg:mt-2.5"
            }, [p[7] || (p[7] = x("p", null, [x("span", null, [J("Continue watching the complete video in better quality on "), x("b", null, "SexLikeReal")])], -1)), O(je, {
                theme: "blue",
                class: "w-full mt-3 lg:w-auto lg:mt-0"
            }, {
                default: Y( () => p[6] || (p[6] = [J("Watch Now")])),
                _: 1
            })], 8, Cj)) : (w(),
            R("a", Mj, [p[10] || (p[10] = x("p", null, [x("span", null, [J("Watch this video in better quality and many more on "), x("b", null, "SexLikeReal")])], -1)), x("span", Rj, [p[9] || (p[9] = x("span", null, [J("Use Code "), x("b", null, "FAPTAP"), J(" for "), x("b", null, "57% OFF")], -1)), O(je, {
                theme: "blue",
                class: "w-full mt-3 lg:w-auto lg:mt-0"
            }, {
                default: Y( () => p[8] || (p[8] = [J("Watch Now")])),
                _: 1
            })])]))], 64)) : le("", !0), E(u).video.stream_url.startsWith("https://members.adulttime") ? (w(),
            R("a", Lj, [p[12] || (p[12] = x("p", null, [x("span", null, [J("Watch this video in better quality and 1000+ others on "), x("b", null, "AdultTime")])], -1)), O(je, {
                theme: "blue",
                class: "w-full mt-3 lg:w-auto lg:mt-0"
            }, {
                default: Y( () => p[11] || (p[11] = [J("Watch Now")])),
                _: 1
            })])) : le("", !0), x("div", Ij, [x("h1", {
                title: E(u).video.name,
                class: "font-medium text-xl lg:text-2xl leading-none"
            }, ee(E(u).video.name), 9, kj), x("div", Pj, [x("span", {
                title: E(u).video.views.toString()
            }, ee(E(vr)(E(u).video.views)) + " views \u2022 " + ee(E(j_)(new Date(E(u).video.created_at))) + " ago ", 9, Dj), x("span", Fj, [J(ee(E(u).script_avg_speed) + " ", 1), O(ze, {
                name: "speedometer",
                class: "h-4 w-4"
            }), p[13] || (p[13] = J(" \u2022 ")), x("span", {
                title: E(u).script_total_actions.toString()
            }, ee(E(vr)(E(u).script_total_actions)) + " actions", 9, Oj)])]), x("div", Uj, [x("div", Nj, [O(m, {
                to: `/u/${E(u).video.user.username}`,
                class: "flex gap-x-3 items-center"
            }, {
                default: Y( () => [O(Bo, {
                    image: E(u).video.user.avatar_url,
                    icon: "account",
                    class: "h-9 w-9"
                }, null, 8, ["image"]), x("div", Bj, [x("span", Vj, ee(E(u).video.user.username), 1), x("span", $j, ee(E(u).video.user.subscribers) + " subscribers", 1)])]),
                _: 1
            }, 8, ["to"]), x("div", Hj, [E(u).video.user.profile.support_url && E(u).video.user.profile.support_url.length ? (w(),
            Re(je, {
                key: 0,
                href: E(u).video.user.profile.support_url,
                class: "lg:w-28",
                theme: "green"
            }, {
                default: Y( () => [O(ze, {
                    name: "currency",
                    class: "h-5 w-5 lg:hidden"
                }), p[14] || (p[14] = x("span", {
                    class: "hidden lg:!block"
                }, "Support", -1))]),
                _: 1
            }, 8, ["href"])) : le("", !0), O(wm, {
                user: E(u).video.user,
                class: "w-28"
            }, null, 8, ["user"])])]), O(Er, {
                gap: "gap-2",
                class: "-mx-2 lg:mx-0"
            }, {
                default: Y( () => [E(n) && (E(s).id === E(u).video.user.id || E(r)) ? (w(),
                Re(je, {
                    key: 0,
                    onClick: p[1] || (p[1] = v => d.value = !0),
                    class: "flex items-center justify-center gap-x-2"
                }, {
                    default: Y( () => [O(ze, {
                        name: "pencil",
                        class: "h-5 w-5"
                    }), p[15] || (p[15] = x("span", {
                        class: "text-white font-semibold"
                    }, "Edit", -1))]),
                    _: 1
                })) : le("", !0), E(u).video.script ? (w(),
                Re(je, {
                    key: 1,
                    onClick: p[2] || (p[2] = v => E(WM)(E(u).video)),
                    class: "flex items-center justify-center gap-x-2 !px-3"
                }, {
                    default: Y( () => [O(ze, {
                        name: "download",
                        class: "h-5 w-5"
                    }), p[16] || (p[16] = x("span", null, "Script", -1))]),
                    _: 1
                })) : le("", !0), E(u).video.stream_url ? (w(),
                Re(je, {
                    key: 2,
                    href: E(u).video.stream_url,
                    class: "flex items-center justify-center gap-x-2 !px-3"
                }, {
                    default: Y( () => [O(ze, {
                        name: "link",
                        class: "h-5 w-5"
                    }), p[17] || (p[17] = x("span", null, "Source", -1))]),
                    _: 1
                }, 8, ["href"])) : le("", !0)]),
                _: 1
            })]), E(u).video.description ? (w(),
            Re(Y_, {
                key: 0,
                class: "text-sm mt-3",
                height: 80,
                text: E(u).video.description
            }, null, 8, ["text"])) : le("", !0), E(u).video.performers && E(u).video.performers.length > 0 || E(u).video.tags && E(u).video.tags.length > 0 ? (w(),
            Re(Er, {
                key: 1,
                gap: "gap-1.5",
                class: "-mx-2 lg:mx-0"
            }, {
                default: Y( () => [(w(!0),
                R(Ge, null, Ht(E(u).video.performers, v => (w(),
                Re(je, {
                    to: `/p/${v.slug}`
                }, {
                    default: Y( () => [x("span", null, ee(v.name), 1)]),
                    _: 2
                }, 1032, ["to"]))), 256)), (w(!0),
                R(Ge, null, Ht(E(u).video.tags, v => (w(),
                Re(je, {
                    to: `/t/${v.slug}`
                }, {
                    default: Y( () => [J(ee(v.name), 1)]),
                    _: 2
                }, 1032, ["to"]))), 256))]),
                _: 1
            })) : le("", !0)]), O(Cm, {
                vertical: "",
                class: "my-4",
                subId: "products-video",
                products: E(f)
            }, null, 8, ["products"]), O(mr, {
                modelValue: d.value,
                "onUpdate:modelValue": p[4] || (p[4] = v => d.value = v),
                title: "Edit Funscript"
            }, {
                default: Y( () => [O(Tj, {
                    funscript: E(u),
                    onSubmitFunscript: p[3] || (p[3] = v => d.value = !1)
                }, null, 8, ["funscript"])]),
                _: 1
            }, 8, ["modelValue"])], 64)
        }
    }
})
  , Wj = ["poster", "src"]
  , qj = {
    class: "h-full w-full object-cover"
}
  , jj = {
    key: 0,
    class: "absolute inset-0 bg-red-600 bg-opacity-50"
}
  , Kj = {
    class: "absolute bottom-1.5 right-1.5 flex gap-1.5"
}
  , Xj = {
    key: 0,
    class: "bg-black/90 rounded px-2 backdrop-blur py-0.5 font-medium text-sm lg:text-xs"
}
  , Yj = {
    class: "bg-black/90 rounded px-2 backdrop-blur py-0.5 font-medium text-sm lg:text-xs"
}
  , Zj = {
    key: 2,
    class: "absolute bottom-0 left-0 w-full"
}
  , Jj = {
    class: "relative"
}
  , Qj = {
    class: "bg-gray-300 w-full h-1"
}
  , eK = {
    class: "absolute bottom-full left-1/2 transform -translate-x-1/2 bg-black text-white text-xs rounded px-2 py-1 opacity-0 group-hover:opacity-100 transition-opacity"
}
  , tK = {
    key: 3,
    class: "absolute inset-0 flex items-center justify-center"
}
  , nK = {
    class: "py-1 px-2 md:px-0"
}
  , iK = {
    class: "flex gap-1.5 text-zinc-400 md:text-sm"
}
  , sK = {
    class: "flex-1 justify-end shrink-0 flex gap-1.5"
}
  , rK = {
    class: "flex gap-x-0.5 items-center"
}
  , oK = {
    class: "flex gap-x-0.5 items-center"
}
  , aK = {
    class: "flex gap-x-0.5 items-center"
}
  , lK = {
    class: "absolute top-1.5 right-1.5 flex gap-1.5 z-10 cursor-pointer"
}
  , cK = {
    class: "bg-black/90 rounded px-2 backdrop-blur py-0.5 font-medium text-sm lg:text-xs"
}
  , uK = {
    key: 0,
    class: "text-sm text-center text-red-500 mt-4"
}
  , dK = ut({
    __name: "FunscriptVideosItem",
    props: {
        funscript: {},
        rounded: {
            type: Boolean
        }
    },
    setup(i) {
        ti();
        const e = ei({
            deleting: !1,
            loading: !1,
            error: "",
            fields: {
                id: ""
            }
        })
          , {activeItem: t} = Pn(CC())
          , n = i
          , s = Math.random();
        let r;
        const o = () => {
            r = window.setTimeout( () => {
                t.value = n.funscript.video.id + s
            }
            , 100)
        }
          , a = () => {
            window.clearTimeout(r),
            t.value = void 0
        }
          , l = async f => {
            if (!!f) {
                e.loading = !0,
                e.error = "";
                try {
                    await ct.funscripts.deleteFunscript(f),
                    delete n.funscript.video,
                    e.loading = !1,
                    e.deleting = !1
                } catch (h) {
                    console.log(h),
                    e.error = h,
                    setTimeout( () => {
                        e.error = ""
                    }
                    , 3e3)
                } finally {
                    e.loading = !1
                }
            }
        }
          , c = Vt( () => t.value === n.funscript.video.id + s)
          , u = Vt( () => {
            switch (n.funscript.funscript_status) {
            case "pending":
                return 10;
            case "processing":
                return 50;
            case "polling":
                return 75;
            case "completed":
                return 100;
            case "failed":
                return 0;
            default:
                return 0
            }
        }
        )
          , d = Vt( () => {
            switch (n.funscript.funscript_status) {
            case "pending":
                return "Pending";
            case "processing":
                return "Processing";
            case "polling":
                return "Polling";
            case "failed":
                return "Failed";
            default:
                return ""
            }
        }
        );
        return Ms( () => window.clearTimeout(r)),
        (f, h) => {
            const p = li("router-link")
              , g = Jd("lazy");
            return w(),
            R(Ge, null, [n.funscript.video ? (w(),
            R("div", {
                key: 0,
                onTouchstartPassive: h[2] || (h[2] = m => t.value = n.funscript.video.id + E(s)),
                class: Pt(["text-white overflow-hidden relative group", {
                    "opacity-50": n.funscript.funscript_status !== "completed",
                    "cursor-not-allowed": n.funscript.funscript_status !== "completed"
                }])
            }, [O(p, {
                to: n.funscript.funscript_status === "completed" ? `/f/${n.funscript.id}` : "#",
                onMouseenter: o,
                onMouseleave: a,
                class: Pt(["block aspect-video w-full bg-zinc-800 relative transition-all overflow-hidden lg:rounded-md", {
                    "!bg-black": c.value,
                    "!rounded-md": n.rounded
                }])
            }, {
                default: Y( () => [n.funscript.video.preview_url && c.value ? (w(),
                R("video", {
                    key: 0,
                    onCanplay: h[0] || (h[0] = m => {
                        var v;
                        return (v = m.target) == null ? void 0 : v.play()
                    }
                    ),
                    poster: E(Gs)(n.funscript.video.thumbnail_url),
                    src: c.value ? E(Gs)(n.funscript.video.preview_url) : "",
                    autoplay: "",
                    loop: "",
                    playsinline: "",
                    muted: "",
                    class: "h-full w-full"
                }, null, 40, Wj)) : (w(),
                R(Ge, {
                    key: 1
                }, [zt(x("img", qj, null, 512), [[g, E(Gs)(n.funscript.video.thumbnail_url)]]), n.funscript.funscript_status === "failed" ? (w(),
                R("div", jj)) : le("", !0), x("div", Kj, [n.funscript.video.vr ? (w(),
                R("div", Xj, h[5] || (h[5] = [x("span", null, "VR", -1)]))) : le("", !0), x("div", Yj, ee(E(fl)(n.funscript.video.duration)), 1)])], 64)), n.funscript.funscript_status !== "completed" && n.funscript.funscript_status !== "failed" ? (w(),
                R("div", Zj, [x("div", Jj, [x("div", Qj, [x("div", {
                    class: "bg-white h-1",
                    style: xs({
                        width: u.value + "%"
                    })
                }, null, 4)]), x("div", eK, ee(d.value), 1)])])) : le("", !0), n.funscript.funscript_status === "failed" ? (w(),
                R("div", tK, h[6] || (h[6] = [x("text", {
                    x: "50%",
                    y: "50%",
                    "font-size": "18",
                    "text-anchor": "middle",
                    fill: "white"
                }, "X", -1)]))) : le("", !0)]),
                _: 1
            }, 8, ["to", "class"]), x("div", nK, [x("div", iK, [O(p, {
                to: n.funscript.funscript_status === "completed" ? `/u/${n.funscript.video.user.username}` : "#",
                class: "underline overflow-hidden overflow-ellipsis"
            }, {
                default: Y( () => [J(ee(n.funscript.video.user.username), 1)]),
                _: 1
            }, 8, ["to"]), x("div", sK, [x("span", rK, [O(ze, {
                name: "eye",
                class: "h-4 w-4"
            }), J(" " + ee(E(vr)(n.funscript.video.views)), 1)]), x("span", oK, [O(ze, {
                name: "heart-outline",
                class: "h-4 w-4"
            }), J(" " + ee(n.funscript.video.rating.likes), 1)]), x("span", aK, [O(ze, {
                name: "speedometer",
                class: "h-4 w-4"
            }), J(" " + ee(n.funscript.video.script.average_speed), 1)])])]), O(p, {
                to: n.funscript.funscript_status === "completed" ? `/f/${n.funscript.id}` : "#",
                class: "break-all line-clamp-1 text-lg md:text-base",
                title: n.funscript.video.name
            }, {
                default: Y( () => [J(ee(n.funscript.video.name), 1)]),
                _: 1
            }, 8, ["to", "title"])]), x("div", lK, [x("div", cK, [O(ze, {
                name: "trash",
                class: "h-5 w-5 m-1",
                onClick: h[1] || (h[1] = m => e.deleting = !0)
            })])])], 34)) : le("", !0), O(mr, {
                modelValue: e.deleting,
                "onUpdate:modelValue": h[4] || (h[4] = m => e.deleting = m),
                title: "Delete Video"
            }, {
                default: Y( () => [h[8] || (h[8] = x("p", {
                    class: "my-4 text-zinc-300 text-center"
                }, "Are you sure you want to delete this funscript?", -1)), e.error ? (w(),
                R("span", uK, ee(e.error), 1)) : le("", !0), O(je, {
                    class: "w-full mt-4",
                    loading: e.loading,
                    onClick: h[3] || (h[3] = m => l(n.funscript.id)),
                    theme: "red"
                }, {
                    default: Y( () => h[7] || (h[7] = [J("Delete")])),
                    _: 1
                }, 8, ["loading"])]),
                _: 1
            }, 8, ["modelValue"])], 64)
        }
    }
});
const fK = hC(dK, [["__scopeId", "data-v-a644839a"]])
  , jM = Qd("polling", () => {
    const i = xe(!1);
    function e() {
        i.value = !0
    }
    function t() {
        i.value = !1
    }
    return {
        startPolling: e,
        stopPolling: t,
        polling: i
    }
}
)
  , hK = {
    class: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 2xl:grid-cols-5 gap-4 mt-2 relative"
}
  , pK = {
    key: 1,
    class: "text-white font-medium px-2 lg:px-0"
}
  , mK = {
    key: 2,
    class: "py-12 flex justify-center items-center"
}
  , gK = ut({
    __name: "FunscriptVideosList",
    props: {
        filters: {
            type: Boolean,
            default: !0
        }
    },
    setup(i) {
        const {polling: e, stopPolling: t, startPolling: n} = jM()
          , s = i
          , {isMobile: r} = Ks()
          , o = Ki()
          , a = xe(!1)
          , l = xe(!1)
          , c = xe([])
          , u = xe(1)
          , d = xe(!1)
          , f = ei({
            order: "date",
            ascending: !1,
            orderFilters: {}
        })
          , h = async () => {
            d.value = !0;
            try {
                const y = await ct.funscripts.getFunscripts({
                    page: u.value,
                    limit: 40,
                    orderBy: f.order,
                    asc: f.ascending
                });
                return c.value = u.value === 1 ? y : c.value.concat(y),
                y
            } catch {
                return []
            } finally {
                d.value = !1
            }
        }
          , p = async () => {
            d.value || c.value.length < 40 || window.innerHeight + window.scrollY >= document.body.offsetHeight - 100 && (u.value++,
            await h())
        }
        ;
        Ln( () => {
            window.addEventListener("scroll", p),
            h(),
            v()
        }
        ),
        Ms( () => {
            window.removeEventListener("scroll", p),
            _()
        }
        );
        const g = async (y, b) => {
            f.order = y,
            f.ascending = b,
            u.value = 1,
            await h()
        }
        ;
        Bt(o, async () => {
            u.value = 1,
            await h()
        }
        );
        let m;
        const v = () => {
            m = setInterval(async () => {
                n();
                const y = await h();
                t(),
                y.every(b => b.funscript_status === "completed") && _()
            }
            , 3e4)
        }
          , _ = () => {
            t(),
            clearInterval(m)
        }
        ;
        return (y, b) => (w(),
        R("div", null, [s.filters ? (w(),
        Re(Er, {
            key: 0,
            gap: "gap-1.5"
        }, {
            default: Y( () => {
                var S, C;
                return [O(je, {
                    ref: "dateOrder",
                    onClick: b[0] || (b[0] = M => a.value = !a.value),
                    theme: f.order == "date" ? "blue" : void 0,
                    class: "flex items-center gap-1"
                }, {
                    default: Y( () => [O(ze, {
                        name: f.ascending ? "sort-descending" : "sort-ascending",
                        class: "h-5 w-5"
                    }, null, 8, ["name"]), b[8] || (b[8] = J(" Date "))]),
                    _: 1
                }, 8, ["theme"]), (w(),
                Re(ys(E(r) ? dr : ji), {
                    modelValue: a.value,
                    "onUpdate:modelValue": b[3] || (b[3] = M => a.value = M),
                    target: (S = y.$refs.dateOrder) == null ? void 0 : S.$el,
                    placement: "bottom",
                    class: "text-white text-sm py-1 w-36",
                    offset: 8
                }, {
                    default: Y( () => [O(Ot, {
                        onClick: b[1] || (b[1] = M => (g("date", !0),
                        a.value = !1))
                    }, {
                        default: Y( () => b[9] || (b[9] = [J("Ascending")])),
                        _: 1
                    }), O(Ot, {
                        onClick: b[2] || (b[2] = M => (g("date", !1),
                        a.value = !1))
                    }, {
                        default: Y( () => b[10] || (b[10] = [J("Descending")])),
                        _: 1
                    })]),
                    _: 1
                }, 8, ["modelValue", "target"])), O(je, {
                    ref: "statusOrder",
                    onClick: b[4] || (b[4] = M => l.value = !l.value),
                    theme: f.order == "status" ? "blue" : void 0,
                    class: "flex items-center gap-1"
                }, {
                    default: Y( () => [O(ze, {
                        name: f.ascending ? "flag-outline" : "flag-variant",
                        class: "h-5 w-5"
                    }, null, 8, ["name"]), J(" " + ee(f.order !== "status" ? "Status" : f.ascending ? "Pending" : "Completed"), 1)]),
                    _: 1
                }, 8, ["theme"]), (w(),
                Re(ys(E(r) ? dr : ji), {
                    modelValue: l.value,
                    "onUpdate:modelValue": b[7] || (b[7] = M => l.value = M),
                    target: (C = y.$refs.statusOrder) == null ? void 0 : C.$el,
                    placement: "bottom",
                    class: "text-white text-sm py-1 w-36",
                    offset: 8
                }, {
                    default: Y( () => [O(Ot, {
                        onClick: b[5] || (b[5] = M => (g("status", !0),
                        l.value = !1)),
                        active: f.order === "status" && f.ascending === !0
                    }, {
                        default: Y( () => b[11] || (b[11] = [J("Pending")])),
                        _: 1
                    }, 8, ["active"]), O(Ot, {
                        onClick: b[6] || (b[6] = M => (g("status", !1),
                        l.value = !1)),
                        active: f.order === "status" && f.ascending === !1
                    }, {
                        default: Y( () => b[12] || (b[12] = [J("Completed")])),
                        _: 1
                    }, 8, ["active"])]),
                    _: 1
                }, 8, ["modelValue", "target"]))]
            }
            ),
            _: 1
        })) : le("", !0), x("div", hK, [c.value.length ? (w(!0),
        R(Ge, {
            key: 0
        }, Ht(c.value, (S, C) => (w(),
        Re(fK, {
            key: S.id,
            funscript: S
        }, null, 8, ["funscript"]))), 128)) : (w(),
        R("p", pK, "Sorry, no funscripts found.")), d.value ? (w(),
        R("div", mK, [O(ze, {
            name: "loading",
            class: "h-10 w-10 text-blue-500 animate-spin"
        })])) : le("", !0)])]))
    }
})
  , vK = {
    class: "flex justify-between items-center"
}
  , _K = {
    class: "flex items-center"
}
  , xK = {
    class: "text-white font-thin text-xl"
}
  , yK = {
    key: 0,
    class: "flex justify-start items-center mt-2 ml-4"
}
  , bK = ut({
    __name: "Funscripts",
    setup(i) {
        const {isProduction: e} = it()
          , {polling: t} = jM()
          , n = Ki()
          , s = ti()
          , r = Vt( () => "My Funscripts (Beta)")
          , o = () => {
            s.push("/funscripts/create")
        }
        ;
        return Bt( () => r.value, () => ci(e ? `${r.value} FapTap` : "Demo"), {
            immediate: !0
        }),
        Ti( () => ci(e ? `${r.value} FapTap` : "Demo")),
        (a, l) => (w(),
        R(Ge, null, [x("div", vK, [x("div", _K, [x("h2", xK, ee(r.value), 1), E(t) ? (w(),
        R("div", yK, [O(ze, {
            name: "loading",
            class: "h-5 w-5 text-blue-500 animate-spin"
        }), l[0] || (l[0] = x("span", {
            class: "text-white ml-2"
        }, "Checking updates...", -1))])) : le("", !0)]), O(je, {
            onClick: o,
            theme: "blue",
            class: "flex gap-x-1.5 items-center"
        }, {
            default: Y( () => [O(ze, {
                name: "plus",
                class: "h-5 w-5"
            }), l[1] || (l[1] = x("span", null, "Funscript", -1))]),
            _: 1
        })]), O(gK, {
            query: E(n).query.q
        }, null, 8, ["query"])], 64))
    }
})
  , SK = {
    key: 0,
    class: "lg:gap-8 border-b border-zinc-800 px-2 lg:px-8 py-0.5 lg:py-0 sticky top-0 bg-zinc-900"
}
  , EK = {
    key: 1,
    class: "container"
}
  , wK = ut({
    __name: "Faptapai",
    setup(i) {
        const {isProduction: e} = it();
        return Ti( () => ci(e ? "FapTapAI (Beta) The Interactive Porn Experience" : "Demo")),
        (t, n) => E(it)().isProduction ? (w(),
        R("div", SK, n[0] || (n[0] = [pa('<h1 class="text-3xl font-bold text-center mb-6">Sync Any Video with Faptap AI (Beta)</h1><p class="mb-4">Faptap can automatically generate a funscript for any video on Pornhub using our proprietary \u201CFaptap AI\u201D.</p><p class="mb-4">If you&#39;re a scripter, you can download the generated script to use as a starting point for your handmade scripts, saving you a tremendous amount of time.</p><p class="mb-4">If you&#39;re a toy user, you can use FaptapAI to have the video of your dreams scripted ~instantly. No more fapping to second-choice videos!</p><h2 class="text-2xl font-semibold mb-4 mt-12">How to Generate a Funscript with FaptapAI</h2><ol class="list-decimal list-inside mb-6"><li class="mb-2">You must be logged in. Registration is free.</li><li class="mb-2">Once logged in, click \u201C<strong>FaptapAI</strong>\u201D in the navbar.</li><li class="mb-2">Then click the \u201C<strong>+ Funscript</strong>\u201D button and enter a Pornhub URL. The URL must be in the following format: <br><code>https://www.pornhub.com/view_video.php?viewkey=XXXXXXXXXXXXX</code></li><li class="mb-2">Click \u201C<strong>Fetch Metadata</strong>\u201D and once it populates, click \u201C<strong>Create</strong>\u201D.</li><li class="mb-2">After that, your new video should appear within 10 seconds. If it doesn&#39;t, refresh the \u201C<strong>My Funscripts</strong>\u201D page. It will display as \u201C<strong>pending</strong>\u201D until it&#39;s been processed.</li></ol><h2 class="text-2xl font-semibold mb-4 mt-12">Tips for Best Results</h2><ul class="list-disc list-inside mb-6"><li class="mb-2">The video should use a tripod (camera shouldn&#39;t move; but scene changes are fine)</li><li class="mb-2">The penis and orifice should normally be visible</li><li class="mb-2">There should just be 1 guy and 1 girl (the current model was only trained and tested on heterosexual scenes with a single couple)</li><li class="mb-2">The 2 people should be having some kind of sex. (The AI will get confused during the intro of a porn movie, for example, where there&#39;s nothing actually happening.)</li><li class="mb-2">Faptap AI will take more time if many other users are using it at the same time.</li></ul>', 8)]))) : (w(),
        R("div", EK, n[1] || (n[1] = [x("h1", {
            class: "font-semibold mt-12 text-3xl mb-6"
        }, " Environment Configuration Notice ", -1), x("p", {
            class: "mb-6"
        }, [J(" Our codebase operates in two modes: development and production. The current environment is set to development "), x("code", null, "(CI_ENVIRONMENT=development).")], -1), x("p", {
            class: "mb-6"
        }, " In development mode, certain images and videos are hidden to facilitate testing and debugging. If you require full functionality or are preparing for deployment, you will need to switch to production mode. ", -1)])))
    }
})
  , TK = {
    class: "flex flex-col gap-y-3"
}
  , AK = {
    class: "flex justify-center items-center"
}
  , CK = {
    key: 0,
    class: "text-white font-medium text-xl"
}
  , MK = {
    key: 1,
    class: "text-white font-medium text-xl"
}
  , RK = {
    key: 0,
    class: "bg-red-600 rounded-md p-2 text-sm"
}
  , LK = {
    class: "flex flex-col gap-y-6"
}
  , IK = {
    class: "flex flex-col md:flex-row"
}
  , kK = {
    class: "md:w-1/4"
}
  , PK = {
    key: 0,
    class: "hidden md:block text-white font-medium text-right pr-4 pt-2"
}
  , DK = {
    key: 1,
    class: "hidden md:block text-white font-medium text-right pr-4 pt-2"
}
  , FK = {
    class: "md:w-3/4 grid grid-cols-1 gap-2"
}
  , OK = {
    class: "flex"
}
  , UK = {
    key: 0,
    class: "text-xs text-zinc-400"
}
  , NK = {
    class: "flex flex-col md:flex-row md:items-center"
}
  , BK = {
    class: "md:w-3/4"
}
  , VK = {
    class: "text-white"
}
  , $K = {
    class: "flex flex-col md:flex-row md:items-center"
}
  , HK = {
    class: "md:w-3/4 flex flex-wrap gap-2"
}
  , zK = {
    class: "flex flex-col md:flex-row md:items-center"
}
  , GK = {
    class: "md:w-3/4 flex flex-wrap gap-2"
}
  , WK = {
    class: "flex gap-3 md:w-3/4 md:self-end"
}
  , qK = {
    key: 1,
    class: "flex justify-end text-white italic opacity-50"
}
  , jK = {
    key: 2,
    class: "flex justify-end text-white italic opacity-50"
}
  , KK = {
    class: "flex justify-end text-white italic opacity-50"
}
  , XK = ut({
    __name: "CreateUserFunscript",
    props: {
        video: {}
    },
    emits: ["submit-funscript"],
    setup(i, {emit: e}) {
        const t = e;
        xe(!1);
        const n = ti()
          , s = xe(!0)
          , r = ei({
            loading: !1,
            performers: [],
            tags: [],
            providers: [],
            projections: ["MONO_FLAT", "MONO_360", "STEREO_FLAT_LR", "STEREO_FLAT_LR_SQUARE", "STEREO_FLAT_TB", "STEREO_FLAT_TB_SQUARE", "STEREO_180_LR", "STEREO_180_LR_SPHERICAL", "STEREO_180_TB", "STEREO_180_TB_SPHERICAL", "STEREO_360_LR", "STEREO_360_TB", "STEREO_FISHEYE_200_LR"],
            fields: {
                name: "",
                description: "",
                stream_url: "",
                downloadable: !0,
                performers: [],
                tags: [],
                orientation: 0,
                vr: !1,
                projection: "MONO_FLAT"
            }
        })
          , o = xe(null)
          , a = xe(0)
          , l = xe(3)
          , c = xe(30)
          , u = async () => {
            const m = await ct.funscripts.getQueueCount();
            a.value = m.funscripts_in_queue
        }
          , d = async () => {
            const m = await ct.funscripts.getFunscriptCountLast24Hours();
            s.value ? c.value -= m.count : l.value -= m.count
        }
        ;
        Ln(async () => {
            const m = await ct.providers.getProviders();
            r.providers = m;
            let v = it().isPremium;
            s.value = !!v,
            await u(),
            await d()
        }
        ),
        iI(async (m, v, _) => {
            await u(),
            await d(),
            _()
        }
        );
        const f = m => {
            const v = m.replace(/porngub\.com|pornhub\.org/, "pornhub.com");
            return console.log("called normalizeUrl", v),
            v
        }
          , h = async () => {
            console.log("called fetchMetadata");
            try {
                r.loading = !0,
                r.error = void 0,
                r.fields.stream_url = f(r.fields.stream_url);
                const m = await ct.videos.getMetadata(r.fields.stream_url);
                console.log("getMetadata fun called", m),
                o.value = {
                    title: m.title,
                    description: m.title,
                    tags: m.tags.filter(v => v !== "Suggest"),
                    performers: m.pornstars.filter(v => v !== "Suggest")
                }
            } catch (m) {
                console.log(m),
                r.error = "Oops, that failed! Please try again in 5 seconds.",
                setTimeout( () => {
                    r.error = void 0
                }
                , 5e3)
            } finally {
                r.loading = !1
            }
        }
          , p = async () => {
            if (!(s.value && c.value === 0 || !s.value && l.value === 0))
                try {
                    r.loading = !0,
                    r.error = void 0,
                    r.fields.stream_url = f(r.fields.stream_url),
                    o.value && (o.value.tags.includes("AI") || o.value.tags.push("AI"),
                    o.value.tags.includes("Faptap AI") || o.value.tags.push("Faptap AI"),
                    r.fields.name = o.value.title,
                    r.fields.description = o.value.description,
                    r.fields.tags = o.value.tags,
                    r.fields.performers = o.value.performers),
                    await ct.funscripts.createFunscriptVideo(r.fields),
                    r.fields.name = "",
                    r.fields.description = "",
                    r.fields.stream_url = "",
                    r.fields.downloadable = !0,
                    r.fields.performers = [],
                    r.fields.tags = [],
                    r.fields.orientation = 0,
                    r.fields.vr = !1,
                    r.fields.projection = "MONO_FLAT",
                    o.value = null,
                    await d(),
                    n.push("/funscripts")
                } catch (m) {
                    r.error = m
                } finally {
                    r.loading = !1
                }
        }
          , g = async () => {
            if (!!r.fields.id) {
                r.loading = !0;
                try {
                    await ct.funscripts.deleteFunscript(r.fields.id),
                    n.push("/funscripts"),
                    t("submit-funscript", r.fields),
                    await d()
                } catch (m) {
                    r.error = m
                } finally {
                    r.loading = !1
                }
            }
        }
        ;
        return (m, v) => (w(),
        R("div", TK, [x("div", AK, [E(it)().isProduction ? (w(),
        R("h2", CK, "Create Funscript from Pornhub Video")) : (w(),
        R("h2", MK, "Create Funscript from YouTube video"))]), x("form", {
            onSubmit: Vn(p, ["prevent"]),
            class: "flex flex-col gap-y-3 mt-4 mx-8"
        }, [r.error ? (w(),
        R("div", RK, ee(r.error), 1)) : le("", !0), x("div", LK, [x("div", IK, [x("div", kK, [E(it)().isProduction ? (w(),
        R("label", PK, "Pornhub.com Video URL")) : (w(),
        R("label", DK, "YouTube.com Video URL"))]), x("div", FK, [x("div", OK, [O(vn, {
            class: "flex-1",
            required: "",
            modelValue: r.fields.stream_url,
            "onUpdate:modelValue": v[0] || (v[0] = _ => r.fields.stream_url = _),
            placeholder: "Stream URL"
        }, null, 8, ["modelValue"]), E(it)().isProduction ? (w(),
        Re(je, {
            key: 0,
            onClick: h,
            type: "button",
            theme: "blue",
            class: "ml-2",
            disabled: r.loading
        }, {
            default: Y( () => [J(ee(r.loading ? "Fetching..." : "Fetch Metadata"), 1)]),
            _: 1
        }, 8, ["disabled"])) : le("", !0)]), r.fields.stream_url ? le("", !0) : (w(),
        R("p", UK, " Videos over 30 minutes will be rejected "))])]), o.value ? (w(),
        R(Ge, {
            key: 0
        }, [x("div", NK, [v[1] || (v[1] = x("div", {
            class: "md:w-1/4"
        }, [x("label", {
            class: "hidden md:block text-white font-medium text-right pr-4"
        }, "Title")], -1)), x("div", BK, [x("p", VK, ee(o.value.title), 1)])]), x("div", $K, [v[2] || (v[2] = x("div", {
            class: "md:w-1/4"
        }, [x("label", {
            class: "hidden md:block text-white font-medium text-right pr-4"
        }, "Tags")], -1)), x("div", HK, [(w(!0),
        R(Ge, null, Ht(o.value.tags, (_, y) => (w(),
        R("div", {
            key: y,
            class: "bg-zinc-700 rounded text-sm px-2.5 py-0.5 flex items-center gap-x-1 grow-0 shrink-0"
        }, [x("span", null, ee(_), 1)]))), 128))])]), x("div", zK, [v[3] || (v[3] = x("div", {
            class: "md:w-1/4"
        }, [x("label", {
            class: "hidden md:block text-white font-medium text-right pr-4"
        }, "Performers")], -1)), x("div", GK, [(w(!0),
        R(Ge, null, Ht(o.value.performers, (_, y) => (w(),
        R("div", {
            key: y,
            class: "bg-zinc-700 rounded text-sm px-2.5 py-0.5 flex items-center gap-x-1 grow-0 shrink-0"
        }, [x("span", null, ee(_), 1)]))), 128))])])], 64)) : le("", !0), x("div", WK, [r.fields.id ? (w(),
        Re(je, {
            key: 0,
            loading: r.loading,
            theme: "red",
            onClick: g,
            class: "shrink-0"
        }, {
            default: Y( () => v[4] || (v[4] = [J("Delete")])),
            _: 1
        }, 8, ["loading"])) : le("", !0), E(it)().isProduction ? (w(),
        Re(je, {
            key: 1,
            disabled: l.value <= 0 || !o.value,
            loading: r.loading,
            theme: "blue",
            class: "flex-1"
        }, {
            default: Y( () => [J(ee(r.fields.id ? "Edit" : "Create"), 1)]),
            _: 1
        }, 8, ["disabled", "loading"])) : (w(),
        Re(je, {
            key: 2,
            loading: r.loading,
            theme: "blue",
            class: "flex-1"
        }, {
            default: Y( () => [J(ee(r.fields.id ? "Edit" : "Create"), 1)]),
            _: 1
        }, 8, ["loading"]))]), s.value ? le("", !0) : (w(),
        R("div", qK, " Remaining funscripts today: " + ee(l.value), 1)), s.value && c.value == 0 ? (w(),
        R("div", jK, [J(" Remaining funscripts today: " + ee(c.value) + " \xA0 ", 1), v[5] || (v[5] = x("small", {
            class: "mt-1"
        }, "[Max Limit (30) Reached for today]", -1))])) : le("", !0), x("div", KK, " Current funscripts in queue: " + ee(a.value), 1)])], 32)]))
    }
})
  , YK = {
    class: "lg:gap-8 border-b border-zinc-800 px-2 lg:px-8 py-0.5 lg:py-0 z-50 sticky top-0 bg-zinc-900"
}
  , ZK = ut({
    __name: "Careers",
    setup(i) {
        const {isProduction: e} = it();
        return Ti( () => ci(e ? "FapTap The Interactive Porn Experience" : "Demo")),
        (t, n) => (w(),
        R("div", YK, n[0] || (n[0] = [pa('<h1 class="text-3xl font-bold text-center mb-6">Seeking Faptap Community Manager - $1,000+ Monthly</h1><p class="mb-4">Are you an active user of Reddit or imageboards or Eroscripts? Do you thrive in digital spaces and love to connect with like-minded individuals? Are you passionate about syncing porn and male sex toys? Join our team as a community manager! This <em>remote</em> position is perfect for someone who lives and breathes the internet and has a deep understanding of online culture.</p><h2 class="text-2xl font-semibold mb-4 mt-12">Key Responsibilities:</h2><ul class="list-disc list-inside ml-6 mb-6"><li class="mb-2">Engage actively with online communities, particularly on Reddit, 4chan, Discord, or similar platforms, with a preference for Reddit.</li><li class="mb-2">Participate in discussions, create content, and foster a positive and interactive environment. </li><li class="mb-2">Use online platforms to engage with and understand the needs and interests of specific online communities.</li><li class="mb-2">Be involved in discussions related to adult themes, including the use of toys and syncing with adult content.</li><li class="mb-2">Moderate the community and its content.</li></ul><h2 class="text-2xl font-semibold mb-4 mt-12">Requirements:</h2><ul class="list-disc list-inside ml-6 mb-6"><li class="mb-2">Native or extremely proficient English skills, with excellent communication abilities.</li><li class="mb-2">Fast typing skills (85+ WPM) capable of quickly responding to online conversations and creating content.</li><li class="mb-2">A self-identified &quot;terminally online&quot; individual who is deeply immersed in internet culture.</li><li class="mb-2">Passionate about engaging in adult-themed discussions and content, with an open and non-judgmental attitude.</li><li class="mb-2">Must be a heavy user of Reddit or similar platforms, with a strong understanding of these online communities.</li><li class="mb-2">Ability to work independently and manage your own schedule in a remote work environment. Must be able to work daily, 5-6 days per week, as online communities do not sleep. (Another shift can cover the weekends/off hours).</li></ul><h2 class="text-2xl font-semibold mb-4 mt-12">Compensation:</h2><p class="mb-4">Pay range: $1,000-$1,500 per month, depending on experience and engagement levels.</p><h2 class="text-2xl font-semibold mb-4 mt-12">How to Apply:</h2><p class="mb-4">If you are excited about this opportunity and meet the qualifications, please email us several paragraphs explaining why you\u2019d be a great candidate. You may attach your resume but it is not strictly required. You should send it to <a href="mailto:support@faptap.net" class="text-blue-500">support@faptap.net</a> and should include \u201CCOMMAPP\u201D verbatim in the subject line.</p>', 10)])))
    }
})
  , JK = {
    class: "inset-0 flex justify-center items-center absolute opacity-80 bg-gray-900"
}
  , US = ut({
    __name: "Loader",
    setup(i) {
        return (e, t) => (w(),
        R("div", JK, [O(ze, {
            name: "loading",
            class: "h-10 w-10 text-blue-500 animate-spin"
        })]))
    }
});
/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const gx = "168"
  , QK = 0
  , NS = 1
  , eX = 2
  , KM = 1
  , tX = 2
  , ho = 3
  , Ta = 0
  , os = 1
  , Ao = 2
  , _a = 0
  , Gc = 1
  , BS = 2
  , VS = 3
  , $S = 4
  , nX = 5
  , al = 100
  , iX = 101
  , sX = 102
  , rX = 103
  , oX = 104
  , aX = 200
  , lX = 201
  , cX = 202
  , uX = 203
  , J1 = 204
  , Q1 = 205
  , dX = 206
  , fX = 207
  , hX = 208
  , pX = 209
  , mX = 210
  , gX = 211
  , vX = 212
  , _X = 213
  , xX = 214
  , yX = 0
  , bX = 1
  , SX = 2
  , Op = 3
  , EX = 4
  , wX = 5
  , TX = 6
  , AX = 7
  , XM = 0
  , CX = 1
  , MX = 2
  , xa = 0
  , RX = 1
  , LX = 2
  , IX = 3
  , kX = 4
  , PX = 5
  , DX = 6
  , FX = 7
  , YM = 300
  , fu = 301
  , hu = 302
  , ev = 303
  , tv = 304
  , Mm = 306
  , nv = 1e3
  , pl = 1001
  , iv = 1002
  , Ns = 1003
  , OX = 1004
  , Gf = 1005
  , ur = 1006
  , H0 = 1007
  , ml = 1008
  , Fo = 1009
  , ZM = 1010
  , JM = 1011
  , Nd = 1012
  , vx = 1013
  , Pl = 1014
  , Ro = 1015
  , of = 1016
  , _x = 1017
  , xx = 1018
  , pu = 1020
  , QM = 35902
  , e3 = 1021
  , t3 = 1022
  , fr = 1023
  , n3 = 1024
  , i3 = 1025
  , Wc = 1026
  , mu = 1027
  , s3 = 1028
  , yx = 1029
  , r3 = 1030
  , bx = 1031
  , Sx = 1033
  , Fh = 33776
  , Oh = 33777
  , Uh = 33778
  , Nh = 33779
  , sv = 35840
  , rv = 35841
  , ov = 35842
  , av = 35843
  , lv = 36196
  , cv = 37492
  , uv = 37496
  , dv = 37808
  , fv = 37809
  , hv = 37810
  , pv = 37811
  , mv = 37812
  , gv = 37813
  , vv = 37814
  , _v = 37815
  , xv = 37816
  , yv = 37817
  , bv = 37818
  , Sv = 37819
  , Ev = 37820
  , wv = 37821
  , Bh = 36492
  , Tv = 36494
  , Av = 36495
  , o3 = 36283
  , Cv = 36284
  , Mv = 36285
  , Rv = 36286
  , UX = 3200
  , NX = 3201
  , a3 = 0
  , BX = 1
  , aa = ""
  , Lr = "srgb"
  , ka = "srgb-linear"
  , Ex = "display-p3"
  , Rm = "display-p3-linear"
  , Up = "linear"
  , In = "srgb"
  , Np = "rec709"
  , Bp = "p3"
  , Ql = 7680
  , HS = 519
  , VX = 512
  , $X = 513
  , HX = 514
  , l3 = 515
  , zX = 516
  , GX = 517
  , WX = 518
  , qX = 519
  , zS = 35044
  , GS = "300 es"
  , Lo = 2e3
  , Vp = 2001;
class Tu {
    addEventListener(e, t) {
        this._listeners === void 0 && (this._listeners = {});
        const n = this._listeners;
        n[e] === void 0 && (n[e] = []),
        n[e].indexOf(t) === -1 && n[e].push(t)
    }
    hasEventListener(e, t) {
        if (this._listeners === void 0)
            return !1;
        const n = this._listeners;
        return n[e] !== void 0 && n[e].indexOf(t) !== -1
    }
    removeEventListener(e, t) {
        if (this._listeners === void 0)
            return;
        const s = this._listeners[e];
        if (s !== void 0) {
            const r = s.indexOf(t);
            r !== -1 && s.splice(r, 1)
        }
    }
    dispatchEvent(e) {
        if (this._listeners === void 0)
            return;
        const n = this._listeners[e.type];
        if (n !== void 0) {
            e.target = this;
            const s = n.slice(0);
            for (let r = 0, o = s.length; r < o; r++)
                s[r].call(this, e);
            e.target = null
        }
    }
}
const Ai = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"]
  , z0 = Math.PI / 180
  , Lv = 180 / Math.PI;
function af() {
    const i = Math.random() * 4294967295 | 0
      , e = Math.random() * 4294967295 | 0
      , t = Math.random() * 4294967295 | 0
      , n = Math.random() * 4294967295 | 0;
    return (Ai[i & 255] + Ai[i >> 8 & 255] + Ai[i >> 16 & 255] + Ai[i >> 24 & 255] + "-" + Ai[e & 255] + Ai[e >> 8 & 255] + "-" + Ai[e >> 16 & 15 | 64] + Ai[e >> 24 & 255] + "-" + Ai[t & 63 | 128] + Ai[t >> 8 & 255] + "-" + Ai[t >> 16 & 255] + Ai[t >> 24 & 255] + Ai[n & 255] + Ai[n >> 8 & 255] + Ai[n >> 16 & 255] + Ai[n >> 24 & 255]).toLowerCase()
}
function is(i, e, t) {
    return Math.max(e, Math.min(t, i))
}
function jX(i, e) {
    return (i % e + e) % e
}
function G0(i, e, t) {
    return (1 - t) * i + t * e
}
function Ou(i, e) {
    switch (e.constructor) {
    case Float32Array:
        return i;
    case Uint32Array:
        return i / 4294967295;
    case Uint16Array:
        return i / 65535;
    case Uint8Array:
        return i / 255;
    case Int32Array:
        return Math.max(i / 2147483647, -1);
    case Int16Array:
        return Math.max(i / 32767, -1);
    case Int8Array:
        return Math.max(i / 127, -1);
    default:
        throw new Error("Invalid component type.")
    }
}
function Zi(i, e) {
    switch (e.constructor) {
    case Float32Array:
        return i;
    case Uint32Array:
        return Math.round(i * 4294967295);
    case Uint16Array:
        return Math.round(i * 65535);
    case Uint8Array:
        return Math.round(i * 255);
    case Int32Array:
        return Math.round(i * 2147483647);
    case Int16Array:
        return Math.round(i * 32767);
    case Int8Array:
        return Math.round(i * 127);
    default:
        throw new Error("Invalid component type.")
    }
}
class nn {
    constructor(e=0, t=0) {
        nn.prototype.isVector2 = !0,
        this.x = e,
        this.y = t
    }
    get width() {
        return this.x
    }
    set width(e) {
        this.x = e
    }
    get height() {
        return this.y
    }
    set height(e) {
        this.y = e
    }
    set(e, t) {
        return this.x = e,
        this.y = t,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this
    }
    divide(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    applyMatrix3(e) {
        const t = this.x
          , n = this.y
          , s = e.elements;
        return this.x = s[0] * t + s[3] * n + s[6],
        this.y = s[1] * t + s[4] * n + s[7],
        this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this
    }
    clampLength(e, t) {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x),
        this.y = Math.trunc(this.y),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y
    }
    cross(e) {
        return this.x * e.y - this.y * e.x
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    angle() {
        return Math.atan2(-this.y, -this.x) + Math.PI
    }
    angleTo(e) {
        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (t === 0)
            return Math.PI / 2;
        const n = this.dot(e) / t;
        return Math.acos(is(n, -1, 1))
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const t = this.x - e.x
          , n = this.y - e.y;
        return t * t + n * n
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this
    }
    lerpVectors(e, t, n) {
        return this.x = e.x + (t.x - e.x) * n,
        this.y = e.y + (t.y - e.y) * n,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this
    }
    rotateAround(e, t) {
        const n = Math.cos(t)
          , s = Math.sin(t)
          , r = this.x - e.x
          , o = this.y - e.y;
        return this.x = r * n - o * s + e.x,
        this.y = r * s + o * n + e.y,
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y
    }
}
class Kt {
    constructor(e, t, n, s, r, o, a, l, c) {
        Kt.prototype.isMatrix3 = !0,
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        e !== void 0 && this.set(e, t, n, s, r, o, a, l, c)
    }
    set(e, t, n, s, r, o, a, l, c) {
        const u = this.elements;
        return u[0] = e,
        u[1] = s,
        u[2] = a,
        u[3] = t,
        u[4] = r,
        u[5] = l,
        u[6] = n,
        u[7] = o,
        u[8] = c,
        this
    }
    identity() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
        this
    }
    copy(e) {
        const t = this.elements
          , n = e.elements;
        return t[0] = n[0],
        t[1] = n[1],
        t[2] = n[2],
        t[3] = n[3],
        t[4] = n[4],
        t[5] = n[5],
        t[6] = n[6],
        t[7] = n[7],
        t[8] = n[8],
        this
    }
    extractBasis(e, t, n) {
        return e.setFromMatrix3Column(this, 0),
        t.setFromMatrix3Column(this, 1),
        n.setFromMatrix3Column(this, 2),
        this
    }
    setFromMatrix4(e) {
        const t = e.elements;
        return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
        this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, t) {
        const n = e.elements
          , s = t.elements
          , r = this.elements
          , o = n[0]
          , a = n[3]
          , l = n[6]
          , c = n[1]
          , u = n[4]
          , d = n[7]
          , f = n[2]
          , h = n[5]
          , p = n[8]
          , g = s[0]
          , m = s[3]
          , v = s[6]
          , _ = s[1]
          , y = s[4]
          , b = s[7]
          , S = s[2]
          , C = s[5]
          , M = s[8];
        return r[0] = o * g + a * _ + l * S,
        r[3] = o * m + a * y + l * C,
        r[6] = o * v + a * b + l * M,
        r[1] = c * g + u * _ + d * S,
        r[4] = c * m + u * y + d * C,
        r[7] = c * v + u * b + d * M,
        r[2] = f * g + h * _ + p * S,
        r[5] = f * m + h * y + p * C,
        r[8] = f * v + h * b + p * M,
        this
    }
    multiplyScalar(e) {
        const t = this.elements;
        return t[0] *= e,
        t[3] *= e,
        t[6] *= e,
        t[1] *= e,
        t[4] *= e,
        t[7] *= e,
        t[2] *= e,
        t[5] *= e,
        t[8] *= e,
        this
    }
    determinant() {
        const e = this.elements
          , t = e[0]
          , n = e[1]
          , s = e[2]
          , r = e[3]
          , o = e[4]
          , a = e[5]
          , l = e[6]
          , c = e[7]
          , u = e[8];
        return t * o * u - t * a * c - n * r * u + n * a * l + s * r * c - s * o * l
    }
    invert() {
        const e = this.elements
          , t = e[0]
          , n = e[1]
          , s = e[2]
          , r = e[3]
          , o = e[4]
          , a = e[5]
          , l = e[6]
          , c = e[7]
          , u = e[8]
          , d = u * o - a * c
          , f = a * l - u * r
          , h = c * r - o * l
          , p = t * d + n * f + s * h;
        if (p === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const g = 1 / p;
        return e[0] = d * g,
        e[1] = (s * c - u * n) * g,
        e[2] = (a * n - s * o) * g,
        e[3] = f * g,
        e[4] = (u * t - s * l) * g,
        e[5] = (s * r - a * t) * g,
        e[6] = h * g,
        e[7] = (n * l - c * t) * g,
        e[8] = (o * t - n * r) * g,
        this
    }
    transpose() {
        let e;
        const t = this.elements;
        return e = t[1],
        t[1] = t[3],
        t[3] = e,
        e = t[2],
        t[2] = t[6],
        t[6] = e,
        e = t[5],
        t[5] = t[7],
        t[7] = e,
        this
    }
    getNormalMatrix(e) {
        return this.setFromMatrix4(e).invert().transpose()
    }
    transposeIntoArray(e) {
        const t = this.elements;
        return e[0] = t[0],
        e[1] = t[3],
        e[2] = t[6],
        e[3] = t[1],
        e[4] = t[4],
        e[5] = t[7],
        e[6] = t[2],
        e[7] = t[5],
        e[8] = t[8],
        this
    }
    setUvTransform(e, t, n, s, r, o, a) {
        const l = Math.cos(r)
          , c = Math.sin(r);
        return this.set(n * l, n * c, -n * (l * o + c * a) + o + e, -s * c, s * l, -s * (-c * o + l * a) + a + t, 0, 0, 1),
        this
    }
    scale(e, t) {
        return this.premultiply(W0.makeScale(e, t)),
        this
    }
    rotate(e) {
        return this.premultiply(W0.makeRotation(-e)),
        this
    }
    translate(e, t) {
        return this.premultiply(W0.makeTranslation(e, t)),
        this
    }
    makeTranslation(e, t) {
        return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1),
        this
    }
    makeRotation(e) {
        const t = Math.cos(e)
          , n = Math.sin(e);
        return this.set(t, -n, 0, n, t, 0, 0, 0, 1),
        this
    }
    makeScale(e, t) {
        return this.set(e, 0, 0, 0, t, 0, 0, 0, 1),
        this
    }
    equals(e) {
        const t = this.elements
          , n = e.elements;
        for (let s = 0; s < 9; s++)
            if (t[s] !== n[s])
                return !1;
        return !0
    }
    fromArray(e, t=0) {
        for (let n = 0; n < 9; n++)
            this.elements[n] = e[n + t];
        return this
    }
    toArray(e=[], t=0) {
        const n = this.elements;
        return e[t] = n[0],
        e[t + 1] = n[1],
        e[t + 2] = n[2],
        e[t + 3] = n[3],
        e[t + 4] = n[4],
        e[t + 5] = n[5],
        e[t + 6] = n[6],
        e[t + 7] = n[7],
        e[t + 8] = n[8],
        e
    }
    clone() {
        return new this.constructor().fromArray(this.elements)
    }
}
const W0 = new Kt;
function c3(i) {
    for (let e = i.length - 1; e >= 0; --e)
        if (i[e] >= 65535)
            return !0;
    return !1
}
function $p(i) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", i)
}
function KX() {
    const i = $p("canvas");
    return i.style.display = "block",
    i
}
const WS = {};
function hd(i) {
    i in WS || (WS[i] = !0,
    console.warn(i))
}
function XX(i, e, t) {
    return new Promise(function(n, s) {
        function r() {
            switch (i.clientWaitSync(e, i.SYNC_FLUSH_COMMANDS_BIT, 0)) {
            case i.WAIT_FAILED:
                s();
                break;
            case i.TIMEOUT_EXPIRED:
                setTimeout(r, t);
                break;
            default:
                n()
            }
        }
        setTimeout(r, t)
    }
    )
}
const qS = new Kt().set(.8224621, .177538, 0, .0331941, .9668058, 0, .0170827, .0723974, .9105199)
  , jS = new Kt().set(1.2249401, -.2249404, 0, -.0420569, 1.0420571, 0, -.0196376, -.0786361, 1.0982735)
  , Uu = {
    [ka]: {
        transfer: Up,
        primaries: Np,
        luminanceCoefficients: [.2126, .7152, .0722],
        toReference: i => i,
        fromReference: i => i
    },
    [Lr]: {
        transfer: In,
        primaries: Np,
        luminanceCoefficients: [.2126, .7152, .0722],
        toReference: i => i.convertSRGBToLinear(),
        fromReference: i => i.convertLinearToSRGB()
    },
    [Rm]: {
        transfer: Up,
        primaries: Bp,
        luminanceCoefficients: [.2289, .6917, .0793],
        toReference: i => i.applyMatrix3(jS),
        fromReference: i => i.applyMatrix3(qS)
    },
    [Ex]: {
        transfer: In,
        primaries: Bp,
        luminanceCoefficients: [.2289, .6917, .0793],
        toReference: i => i.convertSRGBToLinear().applyMatrix3(jS),
        fromReference: i => i.applyMatrix3(qS).convertLinearToSRGB()
    }
}
  , YX = new Set([ka, Rm])
  , pn = {
    enabled: !0,
    _workingColorSpace: ka,
    get workingColorSpace() {
        return this._workingColorSpace
    },
    set workingColorSpace(i) {
        if (!YX.has(i))
            throw new Error(`Unsupported working color space, "${i}".`);
        this._workingColorSpace = i
    },
    convert: function(i, e, t) {
        if (this.enabled === !1 || e === t || !e || !t)
            return i;
        const n = Uu[e].toReference
          , s = Uu[t].fromReference;
        return s(n(i))
    },
    fromWorkingColorSpace: function(i, e) {
        return this.convert(i, this._workingColorSpace, e)
    },
    toWorkingColorSpace: function(i, e) {
        return this.convert(i, e, this._workingColorSpace)
    },
    getPrimaries: function(i) {
        return Uu[i].primaries
    },
    getTransfer: function(i) {
        return i === aa ? Up : Uu[i].transfer
    },
    getLuminanceCoefficients: function(i, e=this._workingColorSpace) {
        return i.fromArray(Uu[e].luminanceCoefficients)
    }
};
function qc(i) {
    return i < .04045 ? i * .0773993808 : Math.pow(i * .9478672986 + .0521327014, 2.4)
}
function q0(i) {
    return i < .0031308 ? i * 12.92 : 1.055 * Math.pow(i, .41666) - .055
}
let ec;
class ZX {
    static getDataURL(e) {
        if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
            return e.src;
        let t;
        if (e instanceof HTMLCanvasElement)
            t = e;
        else {
            ec === void 0 && (ec = $p("canvas")),
            ec.width = e.width,
            ec.height = e.height;
            const n = ec.getContext("2d");
            e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height),
            t = ec
        }
        return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e),
        t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png")
    }
    static sRGBToLinear(e) {
        if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
            const t = $p("canvas");
            t.width = e.width,
            t.height = e.height;
            const n = t.getContext("2d");
            n.drawImage(e, 0, 0, e.width, e.height);
            const s = n.getImageData(0, 0, e.width, e.height)
              , r = s.data;
            for (let o = 0; o < r.length; o++)
                r[o] = qc(r[o] / 255) * 255;
            return n.putImageData(s, 0, 0),
            t
        } else if (e.data) {
            const t = e.data.slice(0);
            for (let n = 0; n < t.length; n++)
                t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[n] = Math.floor(qc(t[n] / 255) * 255) : t[n] = qc(t[n]);
            return {
                data: t,
                width: e.width,
                height: e.height
            }
        } else
            return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),
            e
    }
}
let JX = 0;
class u3 {
    constructor(e=null) {
        this.isSource = !0,
        Object.defineProperty(this, "id", {
            value: JX++
        }),
        this.uuid = af(),
        this.data = e,
        this.dataReady = !0,
        this.version = 0
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        if (!t && e.images[this.uuid] !== void 0)
            return e.images[this.uuid];
        const n = {
            uuid: this.uuid,
            url: ""
        }
          , s = this.data;
        if (s !== null) {
            let r;
            if (Array.isArray(s)) {
                r = [];
                for (let o = 0, a = s.length; o < a; o++)
                    s[o].isDataTexture ? r.push(j0(s[o].image)) : r.push(j0(s[o]))
            } else
                r = j0(s);
            n.url = r
        }
        return t || (e.images[this.uuid] = n),
        n
    }
}
function j0(i) {
    return typeof HTMLImageElement < "u" && i instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && i instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && i instanceof ImageBitmap ? ZX.getDataURL(i) : i.data ? {
        data: Array.from(i.data),
        width: i.width,
        height: i.height,
        type: i.data.constructor.name
    } : (console.warn("THREE.Texture: Unable to serialize Texture."),
    {})
}
let QX = 0;
class as extends Tu {
    constructor(e=as.DEFAULT_IMAGE, t=as.DEFAULT_MAPPING, n=pl, s=pl, r=ur, o=ml, a=fr, l=Fo, c=as.DEFAULT_ANISOTROPY, u=aa) {
        super(),
        this.isTexture = !0,
        Object.defineProperty(this, "id", {
            value: QX++
        }),
        this.uuid = af(),
        this.name = "",
        this.source = new u3(e),
        this.mipmaps = [],
        this.mapping = t,
        this.channel = 0,
        this.wrapS = n,
        this.wrapT = s,
        this.magFilter = r,
        this.minFilter = o,
        this.anisotropy = c,
        this.format = a,
        this.internalFormat = null,
        this.type = l,
        this.offset = new nn(0,0),
        this.repeat = new nn(1,1),
        this.center = new nn(0,0),
        this.rotation = 0,
        this.matrixAutoUpdate = !0,
        this.matrix = new Kt,
        this.generateMipmaps = !0,
        this.premultiplyAlpha = !1,
        this.flipY = !0,
        this.unpackAlignment = 4,
        this.colorSpace = u,
        this.userData = {},
        this.version = 0,
        this.onUpdate = null,
        this.isRenderTargetTexture = !1,
        this.pmremVersion = 0
    }
    get image() {
        return this.source.data
    }
    set image(e=null) {
        this.source.data = e
    }
    updateMatrix() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.name = e.name,
        this.source = e.source,
        this.mipmaps = e.mipmaps.slice(0),
        this.mapping = e.mapping,
        this.channel = e.channel,
        this.wrapS = e.wrapS,
        this.wrapT = e.wrapT,
        this.magFilter = e.magFilter,
        this.minFilter = e.minFilter,
        this.anisotropy = e.anisotropy,
        this.format = e.format,
        this.internalFormat = e.internalFormat,
        this.type = e.type,
        this.offset.copy(e.offset),
        this.repeat.copy(e.repeat),
        this.center.copy(e.center),
        this.rotation = e.rotation,
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this.matrix.copy(e.matrix),
        this.generateMipmaps = e.generateMipmaps,
        this.premultiplyAlpha = e.premultiplyAlpha,
        this.flipY = e.flipY,
        this.unpackAlignment = e.unpackAlignment,
        this.colorSpace = e.colorSpace,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        this.needsUpdate = !0,
        this
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        if (!t && e.textures[this.uuid] !== void 0)
            return e.textures[this.uuid];
        const n = {
            metadata: {
                version: 4.6,
                type: "Texture",
                generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(e).uuid,
            mapping: this.mapping,
            channel: this.channel,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            internalFormat: this.internalFormat,
            type: this.type,
            colorSpace: this.colorSpace,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            generateMipmaps: this.generateMipmaps,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
        };
        return Object.keys(this.userData).length > 0 && (n.userData = this.userData),
        t || (e.textures[this.uuid] = n),
        n
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    transformUv(e) {
        if (this.mapping !== YM)
            return e;
        if (e.applyMatrix3(this.matrix),
        e.x < 0 || e.x > 1)
            switch (this.wrapS) {
            case nv:
                e.x = e.x - Math.floor(e.x);
                break;
            case pl:
                e.x = e.x < 0 ? 0 : 1;
                break;
            case iv:
                Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
                break
            }
        if (e.y < 0 || e.y > 1)
            switch (this.wrapT) {
            case nv:
                e.y = e.y - Math.floor(e.y);
                break;
            case pl:
                e.y = e.y < 0 ? 0 : 1;
                break;
            case iv:
                Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
                break
            }
        return this.flipY && (e.y = 1 - e.y),
        e
    }
    set needsUpdate(e) {
        e === !0 && (this.version++,
        this.source.needsUpdate = !0)
    }
    set needsPMREMUpdate(e) {
        e === !0 && this.pmremVersion++
    }
}
as.DEFAULT_IMAGE = null;
as.DEFAULT_MAPPING = YM;
as.DEFAULT_ANISOTROPY = 1;
class oi {
    constructor(e=0, t=0, n=0, s=1) {
        oi.prototype.isVector4 = !0,
        this.x = e,
        this.y = t,
        this.z = n,
        this.w = s
    }
    get width() {
        return this.z
    }
    set width(e) {
        this.z = e
    }
    get height() {
        return this.w
    }
    set height(e) {
        this.w = e
    }
    set(e, t, n, s) {
        return this.x = e,
        this.y = t,
        this.z = n,
        this.w = s,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this.z = e,
        this.w = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setZ(e) {
        return this.z = e,
        this
    }
    setW(e) {
        return this.w = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        case 2:
            this.z = t;
            break;
        case 3:
            this.w = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        case 3:
            return this.w;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y,this.z,this.w)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this.z = e.z,
        this.w = e.w !== void 0 ? e.w : 1,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this.z += e.z,
        this.w += e.w,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this.z += e,
        this.w += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this.z = e.z + t.z,
        this.w = e.w + t.w,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this.z += e.z * t,
        this.w += e.w * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this.z -= e.z,
        this.w -= e.w,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this.z -= e,
        this.w -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this.z = e.z - t.z,
        this.w = e.w - t.w,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this.z *= e.z,
        this.w *= e.w,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this.z *= e,
        this.w *= e,
        this
    }
    applyMatrix4(e) {
        const t = this.x
          , n = this.y
          , s = this.z
          , r = this.w
          , o = e.elements;
        return this.x = o[0] * t + o[4] * n + o[8] * s + o[12] * r,
        this.y = o[1] * t + o[5] * n + o[9] * s + o[13] * r,
        this.z = o[2] * t + o[6] * n + o[10] * s + o[14] * r,
        this.w = o[3] * t + o[7] * n + o[11] * s + o[15] * r,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    setAxisAngleFromQuaternion(e) {
        this.w = 2 * Math.acos(e.w);
        const t = Math.sqrt(1 - e.w * e.w);
        return t < 1e-4 ? (this.x = 1,
        this.y = 0,
        this.z = 0) : (this.x = e.x / t,
        this.y = e.y / t,
        this.z = e.z / t),
        this
    }
    setAxisAngleFromRotationMatrix(e) {
        let t, n, s, r;
        const l = e.elements
          , c = l[0]
          , u = l[4]
          , d = l[8]
          , f = l[1]
          , h = l[5]
          , p = l[9]
          , g = l[2]
          , m = l[6]
          , v = l[10];
        if (Math.abs(u - f) < .01 && Math.abs(d - g) < .01 && Math.abs(p - m) < .01) {
            if (Math.abs(u + f) < .1 && Math.abs(d + g) < .1 && Math.abs(p + m) < .1 && Math.abs(c + h + v - 3) < .1)
                return this.set(1, 0, 0, 0),
                this;
            t = Math.PI;
            const y = (c + 1) / 2
              , b = (h + 1) / 2
              , S = (v + 1) / 2
              , C = (u + f) / 4
              , M = (d + g) / 4
              , L = (p + m) / 4;
            return y > b && y > S ? y < .01 ? (n = 0,
            s = .707106781,
            r = .707106781) : (n = Math.sqrt(y),
            s = C / n,
            r = M / n) : b > S ? b < .01 ? (n = .707106781,
            s = 0,
            r = .707106781) : (s = Math.sqrt(b),
            n = C / s,
            r = L / s) : S < .01 ? (n = .707106781,
            s = .707106781,
            r = 0) : (r = Math.sqrt(S),
            n = M / r,
            s = L / r),
            this.set(n, s, r, t),
            this
        }
        let _ = Math.sqrt((m - p) * (m - p) + (d - g) * (d - g) + (f - u) * (f - u));
        return Math.abs(_) < .001 && (_ = 1),
        this.x = (m - p) / _,
        this.y = (d - g) / _,
        this.z = (f - u) / _,
        this.w = Math.acos((c + h + v - 1) / 2),
        this
    }
    setFromMatrixPosition(e) {
        const t = e.elements;
        return this.x = t[12],
        this.y = t[13],
        this.z = t[14],
        this.w = t[15],
        this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this.z = Math.min(this.z, e.z),
        this.w = Math.min(this.w, e.w),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this.z = Math.max(this.z, e.z),
        this.w = Math.max(this.w, e.w),
        this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this.z = Math.max(e.z, Math.min(t.z, this.z)),
        this.w = Math.max(e.w, Math.min(t.w, this.w)),
        this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this.z = Math.max(e, Math.min(t, this.z)),
        this.w = Math.max(e, Math.min(t, this.w)),
        this
    }
    clampLength(e, t) {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this.w = Math.floor(this.w),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this.w = Math.ceil(this.w),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this.w = Math.round(this.w),
        this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x),
        this.y = Math.trunc(this.y),
        this.z = Math.trunc(this.z),
        this.w = Math.trunc(this.w),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this.w = -this.w,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this.z += (e.z - this.z) * t,
        this.w += (e.w - this.w) * t,
        this
    }
    lerpVectors(e, t, n) {
        return this.x = e.x + (t.x - e.x) * n,
        this.y = e.y + (t.y - e.y) * n,
        this.z = e.z + (t.z - e.z) * n,
        this.w = e.w + (t.w - e.w) * n,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this.z = e[t + 2],
        this.w = e[t + 3],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e[t + 2] = this.z,
        e[t + 3] = this.w,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this.z = e.getZ(t),
        this.w = e.getW(t),
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this.z = Math.random(),
        this.w = Math.random(),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y,
        yield this.z,
        yield this.w
    }
}
class eY extends Tu {
    constructor(e=1, t=1, n={}) {
        super(),
        this.isRenderTarget = !0,
        this.width = e,
        this.height = t,
        this.depth = 1,
        this.scissor = new oi(0,0,e,t),
        this.scissorTest = !1,
        this.viewport = new oi(0,0,e,t);
        const s = {
            width: e,
            height: t,
            depth: 1
        };
        n = Object.assign({
            generateMipmaps: !1,
            internalFormat: null,
            minFilter: ur,
            depthBuffer: !0,
            stencilBuffer: !1,
            resolveDepthBuffer: !0,
            resolveStencilBuffer: !0,
            depthTexture: null,
            samples: 0,
            count: 1
        }, n);
        const r = new as(s,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.colorSpace);
        r.flipY = !1,
        r.generateMipmaps = n.generateMipmaps,
        r.internalFormat = n.internalFormat,
        this.textures = [];
        const o = n.count;
        for (let a = 0; a < o; a++)
            this.textures[a] = r.clone(),
            this.textures[a].isRenderTargetTexture = !0;
        this.depthBuffer = n.depthBuffer,
        this.stencilBuffer = n.stencilBuffer,
        this.resolveDepthBuffer = n.resolveDepthBuffer,
        this.resolveStencilBuffer = n.resolveStencilBuffer,
        this.depthTexture = n.depthTexture,
        this.samples = n.samples
    }
    get texture() {
        return this.textures[0]
    }
    set texture(e) {
        this.textures[0] = e
    }
    setSize(e, t, n=1) {
        if (this.width !== e || this.height !== t || this.depth !== n) {
            this.width = e,
            this.height = t,
            this.depth = n;
            for (let s = 0, r = this.textures.length; s < r; s++)
                this.textures[s].image.width = e,
                this.textures[s].image.height = t,
                this.textures[s].image.depth = n;
            this.dispose()
        }
        this.viewport.set(0, 0, e, t),
        this.scissor.set(0, 0, e, t)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.width = e.width,
        this.height = e.height,
        this.depth = e.depth,
        this.scissor.copy(e.scissor),
        this.scissorTest = e.scissorTest,
        this.viewport.copy(e.viewport),
        this.textures.length = 0;
        for (let n = 0, s = e.textures.length; n < s; n++)
            this.textures[n] = e.textures[n].clone(),
            this.textures[n].isRenderTargetTexture = !0;
        const t = Object.assign({}, e.texture.image);
        return this.texture.source = new u3(t),
        this.depthBuffer = e.depthBuffer,
        this.stencilBuffer = e.stencilBuffer,
        this.resolveDepthBuffer = e.resolveDepthBuffer,
        this.resolveStencilBuffer = e.resolveStencilBuffer,
        e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
        this.samples = e.samples,
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
class Dl extends eY {
    constructor(e=1, t=1, n={}) {
        super(e, t, n),
        this.isWebGLRenderTarget = !0
    }
}
class d3 extends as {
    constructor(e=null, t=1, n=1, s=1) {
        super(null),
        this.isDataArrayTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: n,
            depth: s
        },
        this.magFilter = Ns,
        this.minFilter = Ns,
        this.wrapR = pl,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1,
        this.layerUpdates = new Set
    }
    addLayerUpdate(e) {
        this.layerUpdates.add(e)
    }
    clearLayerUpdates() {
        this.layerUpdates.clear()
    }
}
class tY extends as {
    constructor(e=null, t=1, n=1, s=1) {
        super(null),
        this.isData3DTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: n,
            depth: s
        },
        this.magFilter = Ns,
        this.minFilter = Ns,
        this.wrapR = pl,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
class lf {
    constructor(e=0, t=0, n=0, s=1) {
        this.isQuaternion = !0,
        this._x = e,
        this._y = t,
        this._z = n,
        this._w = s
    }
    static slerpFlat(e, t, n, s, r, o, a) {
        let l = n[s + 0]
          , c = n[s + 1]
          , u = n[s + 2]
          , d = n[s + 3];
        const f = r[o + 0]
          , h = r[o + 1]
          , p = r[o + 2]
          , g = r[o + 3];
        if (a === 0) {
            e[t + 0] = l,
            e[t + 1] = c,
            e[t + 2] = u,
            e[t + 3] = d;
            return
        }
        if (a === 1) {
            e[t + 0] = f,
            e[t + 1] = h,
            e[t + 2] = p,
            e[t + 3] = g;
            return
        }
        if (d !== g || l !== f || c !== h || u !== p) {
            let m = 1 - a;
            const v = l * f + c * h + u * p + d * g
              , _ = v >= 0 ? 1 : -1
              , y = 1 - v * v;
            if (y > Number.EPSILON) {
                const S = Math.sqrt(y)
                  , C = Math.atan2(S, v * _);
                m = Math.sin(m * C) / S,
                a = Math.sin(a * C) / S
            }
            const b = a * _;
            if (l = l * m + f * b,
            c = c * m + h * b,
            u = u * m + p * b,
            d = d * m + g * b,
            m === 1 - a) {
                const S = 1 / Math.sqrt(l * l + c * c + u * u + d * d);
                l *= S,
                c *= S,
                u *= S,
                d *= S
            }
        }
        e[t] = l,
        e[t + 1] = c,
        e[t + 2] = u,
        e[t + 3] = d
    }
    static multiplyQuaternionsFlat(e, t, n, s, r, o) {
        const a = n[s]
          , l = n[s + 1]
          , c = n[s + 2]
          , u = n[s + 3]
          , d = r[o]
          , f = r[o + 1]
          , h = r[o + 2]
          , p = r[o + 3];
        return e[t] = a * p + u * d + l * h - c * f,
        e[t + 1] = l * p + u * f + c * d - a * h,
        e[t + 2] = c * p + u * h + a * f - l * d,
        e[t + 3] = u * p - a * d - l * f - c * h,
        e
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e,
        this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e,
        this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e,
        this._onChangeCallback()
    }
    get w() {
        return this._w
    }
    set w(e) {
        this._w = e,
        this._onChangeCallback()
    }
    set(e, t, n, s) {
        return this._x = e,
        this._y = t,
        this._z = n,
        this._w = s,
        this._onChangeCallback(),
        this
    }
    clone() {
        return new this.constructor(this._x,this._y,this._z,this._w)
    }
    copy(e) {
        return this._x = e.x,
        this._y = e.y,
        this._z = e.z,
        this._w = e.w,
        this._onChangeCallback(),
        this
    }
    setFromEuler(e, t=!0) {
        const n = e._x
          , s = e._y
          , r = e._z
          , o = e._order
          , a = Math.cos
          , l = Math.sin
          , c = a(n / 2)
          , u = a(s / 2)
          , d = a(r / 2)
          , f = l(n / 2)
          , h = l(s / 2)
          , p = l(r / 2);
        switch (o) {
        case "XYZ":
            this._x = f * u * d + c * h * p,
            this._y = c * h * d - f * u * p,
            this._z = c * u * p + f * h * d,
            this._w = c * u * d - f * h * p;
            break;
        case "YXZ":
            this._x = f * u * d + c * h * p,
            this._y = c * h * d - f * u * p,
            this._z = c * u * p - f * h * d,
            this._w = c * u * d + f * h * p;
            break;
        case "ZXY":
            this._x = f * u * d - c * h * p,
            this._y = c * h * d + f * u * p,
            this._z = c * u * p + f * h * d,
            this._w = c * u * d - f * h * p;
            break;
        case "ZYX":
            this._x = f * u * d - c * h * p,
            this._y = c * h * d + f * u * p,
            this._z = c * u * p - f * h * d,
            this._w = c * u * d + f * h * p;
            break;
        case "YZX":
            this._x = f * u * d + c * h * p,
            this._y = c * h * d + f * u * p,
            this._z = c * u * p - f * h * d,
            this._w = c * u * d - f * h * p;
            break;
        case "XZY":
            this._x = f * u * d - c * h * p,
            this._y = c * h * d - f * u * p,
            this._z = c * u * p + f * h * d,
            this._w = c * u * d + f * h * p;
            break;
        default:
            console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o)
        }
        return t === !0 && this._onChangeCallback(),
        this
    }
    setFromAxisAngle(e, t) {
        const n = t / 2
          , s = Math.sin(n);
        return this._x = e.x * s,
        this._y = e.y * s,
        this._z = e.z * s,
        this._w = Math.cos(n),
        this._onChangeCallback(),
        this
    }
    setFromRotationMatrix(e) {
        const t = e.elements
          , n = t[0]
          , s = t[4]
          , r = t[8]
          , o = t[1]
          , a = t[5]
          , l = t[9]
          , c = t[2]
          , u = t[6]
          , d = t[10]
          , f = n + a + d;
        if (f > 0) {
            const h = .5 / Math.sqrt(f + 1);
            this._w = .25 / h,
            this._x = (u - l) * h,
            this._y = (r - c) * h,
            this._z = (o - s) * h
        } else if (n > a && n > d) {
            const h = 2 * Math.sqrt(1 + n - a - d);
            this._w = (u - l) / h,
            this._x = .25 * h,
            this._y = (s + o) / h,
            this._z = (r + c) / h
        } else if (a > d) {
            const h = 2 * Math.sqrt(1 + a - n - d);
            this._w = (r - c) / h,
            this._x = (s + o) / h,
            this._y = .25 * h,
            this._z = (l + u) / h
        } else {
            const h = 2 * Math.sqrt(1 + d - n - a);
            this._w = (o - s) / h,
            this._x = (r + c) / h,
            this._y = (l + u) / h,
            this._z = .25 * h
        }
        return this._onChangeCallback(),
        this
    }
    setFromUnitVectors(e, t) {
        let n = e.dot(t) + 1;
        return n < Number.EPSILON ? (n = 0,
        Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y,
        this._y = e.x,
        this._z = 0,
        this._w = n) : (this._x = 0,
        this._y = -e.z,
        this._z = e.y,
        this._w = n)) : (this._x = e.y * t.z - e.z * t.y,
        this._y = e.z * t.x - e.x * t.z,
        this._z = e.x * t.y - e.y * t.x,
        this._w = n),
        this.normalize()
    }
    angleTo(e) {
        return 2 * Math.acos(Math.abs(is(this.dot(e), -1, 1)))
    }
    rotateTowards(e, t) {
        const n = this.angleTo(e);
        if (n === 0)
            return this;
        const s = Math.min(1, t / n);
        return this.slerp(e, s),
        this
    }
    identity() {
        return this.set(0, 0, 0, 1)
    }
    invert() {
        return this.conjugate()
    }
    conjugate() {
        return this._x *= -1,
        this._y *= -1,
        this._z *= -1,
        this._onChangeCallback(),
        this
    }
    dot(e) {
        return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
    }
    lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
    }
    length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
    }
    normalize() {
        let e = this.length();
        return e === 0 ? (this._x = 0,
        this._y = 0,
        this._z = 0,
        this._w = 1) : (e = 1 / e,
        this._x = this._x * e,
        this._y = this._y * e,
        this._z = this._z * e,
        this._w = this._w * e),
        this._onChangeCallback(),
        this
    }
    multiply(e) {
        return this.multiplyQuaternions(this, e)
    }
    premultiply(e) {
        return this.multiplyQuaternions(e, this)
    }
    multiplyQuaternions(e, t) {
        const n = e._x
          , s = e._y
          , r = e._z
          , o = e._w
          , a = t._x
          , l = t._y
          , c = t._z
          , u = t._w;
        return this._x = n * u + o * a + s * c - r * l,
        this._y = s * u + o * l + r * a - n * c,
        this._z = r * u + o * c + n * l - s * a,
        this._w = o * u - n * a - s * l - r * c,
        this._onChangeCallback(),
        this
    }
    slerp(e, t) {
        if (t === 0)
            return this;
        if (t === 1)
            return this.copy(e);
        const n = this._x
          , s = this._y
          , r = this._z
          , o = this._w;
        let a = o * e._w + n * e._x + s * e._y + r * e._z;
        if (a < 0 ? (this._w = -e._w,
        this._x = -e._x,
        this._y = -e._y,
        this._z = -e._z,
        a = -a) : this.copy(e),
        a >= 1)
            return this._w = o,
            this._x = n,
            this._y = s,
            this._z = r,
            this;
        const l = 1 - a * a;
        if (l <= Number.EPSILON) {
            const h = 1 - t;
            return this._w = h * o + t * this._w,
            this._x = h * n + t * this._x,
            this._y = h * s + t * this._y,
            this._z = h * r + t * this._z,
            this.normalize(),
            this
        }
        const c = Math.sqrt(l)
          , u = Math.atan2(c, a)
          , d = Math.sin((1 - t) * u) / c
          , f = Math.sin(t * u) / c;
        return this._w = o * d + this._w * f,
        this._x = n * d + this._x * f,
        this._y = s * d + this._y * f,
        this._z = r * d + this._z * f,
        this._onChangeCallback(),
        this
    }
    slerpQuaternions(e, t, n) {
        return this.copy(e).slerp(t, n)
    }
    random() {
        const e = 2 * Math.PI * Math.random()
          , t = 2 * Math.PI * Math.random()
          , n = Math.random()
          , s = Math.sqrt(1 - n)
          , r = Math.sqrt(n);
        return this.set(s * Math.sin(e), s * Math.cos(e), r * Math.sin(t), r * Math.cos(t))
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
    }
    fromArray(e, t=0) {
        return this._x = e[t],
        this._y = e[t + 1],
        this._z = e[t + 2],
        this._w = e[t + 3],
        this._onChangeCallback(),
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this._x,
        e[t + 1] = this._y,
        e[t + 2] = this._z,
        e[t + 3] = this._w,
        e
    }
    fromBufferAttribute(e, t) {
        return this._x = e.getX(t),
        this._y = e.getY(t),
        this._z = e.getZ(t),
        this._w = e.getW(t),
        this._onChangeCallback(),
        this
    }
    toJSON() {
        return this.toArray()
    }
    _onChange(e) {
        return this._onChangeCallback = e,
        this
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
        yield this._x,
        yield this._y,
        yield this._z,
        yield this._w
    }
}
class Te {
    constructor(e=0, t=0, n=0) {
        Te.prototype.isVector3 = !0,
        this.x = e,
        this.y = t,
        this.z = n
    }
    set(e, t, n) {
        return n === void 0 && (n = this.z),
        this.x = e,
        this.y = t,
        this.z = n,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this.z = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setZ(e) {
        return this.z = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        case 2:
            this.z = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y,this.z)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this.z = e.z,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this.z += e.z,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this.z += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this.z = e.z + t.z,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this.z += e.z * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this.z -= e.z,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this.z -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this.z = e.z - t.z,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this.z *= e.z,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this.z *= e,
        this
    }
    multiplyVectors(e, t) {
        return this.x = e.x * t.x,
        this.y = e.y * t.y,
        this.z = e.z * t.z,
        this
    }
    applyEuler(e) {
        return this.applyQuaternion(KS.setFromEuler(e))
    }
    applyAxisAngle(e, t) {
        return this.applyQuaternion(KS.setFromAxisAngle(e, t))
    }
    applyMatrix3(e) {
        const t = this.x
          , n = this.y
          , s = this.z
          , r = e.elements;
        return this.x = r[0] * t + r[3] * n + r[6] * s,
        this.y = r[1] * t + r[4] * n + r[7] * s,
        this.z = r[2] * t + r[5] * n + r[8] * s,
        this
    }
    applyNormalMatrix(e) {
        return this.applyMatrix3(e).normalize()
    }
    applyMatrix4(e) {
        const t = this.x
          , n = this.y
          , s = this.z
          , r = e.elements
          , o = 1 / (r[3] * t + r[7] * n + r[11] * s + r[15]);
        return this.x = (r[0] * t + r[4] * n + r[8] * s + r[12]) * o,
        this.y = (r[1] * t + r[5] * n + r[9] * s + r[13]) * o,
        this.z = (r[2] * t + r[6] * n + r[10] * s + r[14]) * o,
        this
    }
    applyQuaternion(e) {
        const t = this.x
          , n = this.y
          , s = this.z
          , r = e.x
          , o = e.y
          , a = e.z
          , l = e.w
          , c = 2 * (o * s - a * n)
          , u = 2 * (a * t - r * s)
          , d = 2 * (r * n - o * t);
        return this.x = t + l * c + o * d - a * u,
        this.y = n + l * u + a * c - r * d,
        this.z = s + l * d + r * u - o * c,
        this
    }
    project(e) {
        return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
    }
    unproject(e) {
        return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
    }
    transformDirection(e) {
        const t = this.x
          , n = this.y
          , s = this.z
          , r = e.elements;
        return this.x = r[0] * t + r[4] * n + r[8] * s,
        this.y = r[1] * t + r[5] * n + r[9] * s,
        this.z = r[2] * t + r[6] * n + r[10] * s,
        this.normalize()
    }
    divide(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this.z /= e.z,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this.z = Math.min(this.z, e.z),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this.z = Math.max(this.z, e.z),
        this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this.z = Math.max(e.z, Math.min(t.z, this.z)),
        this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this.z = Math.max(e, Math.min(t, this.z)),
        this
    }
    clampLength(e, t) {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x),
        this.y = Math.trunc(this.y),
        this.z = Math.trunc(this.z),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this.z += (e.z - this.z) * t,
        this
    }
    lerpVectors(e, t, n) {
        return this.x = e.x + (t.x - e.x) * n,
        this.y = e.y + (t.y - e.y) * n,
        this.z = e.z + (t.z - e.z) * n,
        this
    }
    cross(e) {
        return this.crossVectors(this, e)
    }
    crossVectors(e, t) {
        const n = e.x
          , s = e.y
          , r = e.z
          , o = t.x
          , a = t.y
          , l = t.z;
        return this.x = s * l - r * a,
        this.y = r * o - n * l,
        this.z = n * a - s * o,
        this
    }
    projectOnVector(e) {
        const t = e.lengthSq();
        if (t === 0)
            return this.set(0, 0, 0);
        const n = e.dot(this) / t;
        return this.copy(e).multiplyScalar(n)
    }
    projectOnPlane(e) {
        return K0.copy(this).projectOnVector(e),
        this.sub(K0)
    }
    reflect(e) {
        return this.sub(K0.copy(e).multiplyScalar(2 * this.dot(e)))
    }
    angleTo(e) {
        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (t === 0)
            return Math.PI / 2;
        const n = this.dot(e) / t;
        return Math.acos(is(n, -1, 1))
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const t = this.x - e.x
          , n = this.y - e.y
          , s = this.z - e.z;
        return t * t + n * n + s * s
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    }
    setFromSpherical(e) {
        return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
    }
    setFromSphericalCoords(e, t, n) {
        const s = Math.sin(t) * e;
        return this.x = s * Math.sin(n),
        this.y = Math.cos(t) * e,
        this.z = s * Math.cos(n),
        this
    }
    setFromCylindrical(e) {
        return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
    }
    setFromCylindricalCoords(e, t, n) {
        return this.x = e * Math.sin(t),
        this.y = n,
        this.z = e * Math.cos(t),
        this
    }
    setFromMatrixPosition(e) {
        const t = e.elements;
        return this.x = t[12],
        this.y = t[13],
        this.z = t[14],
        this
    }
    setFromMatrixScale(e) {
        const t = this.setFromMatrixColumn(e, 0).length()
          , n = this.setFromMatrixColumn(e, 1).length()
          , s = this.setFromMatrixColumn(e, 2).length();
        return this.x = t,
        this.y = n,
        this.z = s,
        this
    }
    setFromMatrixColumn(e, t) {
        return this.fromArray(e.elements, t * 4)
    }
    setFromMatrix3Column(e, t) {
        return this.fromArray(e.elements, t * 3)
    }
    setFromEuler(e) {
        return this.x = e._x,
        this.y = e._y,
        this.z = e._z,
        this
    }
    setFromColor(e) {
        return this.x = e.r,
        this.y = e.g,
        this.z = e.b,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this.z = e[t + 2],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e[t + 2] = this.z,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this.z = e.getZ(t),
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this.z = Math.random(),
        this
    }
    randomDirection() {
        const e = Math.random() * Math.PI * 2
          , t = Math.random() * 2 - 1
          , n = Math.sqrt(1 - t * t);
        return this.x = n * Math.cos(e),
        this.y = t,
        this.z = n * Math.sin(e),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y,
        yield this.z
    }
}
const K0 = new Te
  , KS = new lf;
class cf {
    constructor(e=new Te(1 / 0,1 / 0,1 / 0), t=new Te(-1 / 0,-1 / 0,-1 / 0)) {
        this.isBox3 = !0,
        this.min = e,
        this.max = t
    }
    set(e, t) {
        return this.min.copy(e),
        this.max.copy(t),
        this
    }
    setFromArray(e) {
        this.makeEmpty();
        for (let t = 0, n = e.length; t < n; t += 3)
            this.expandByPoint(Zs.fromArray(e, t));
        return this
    }
    setFromBufferAttribute(e) {
        this.makeEmpty();
        for (let t = 0, n = e.count; t < n; t++)
            this.expandByPoint(Zs.fromBufferAttribute(e, t));
        return this
    }
    setFromPoints(e) {
        this.makeEmpty();
        for (let t = 0, n = e.length; t < n; t++)
            this.expandByPoint(e[t]);
        return this
    }
    setFromCenterAndSize(e, t) {
        const n = Zs.copy(t).multiplyScalar(.5);
        return this.min.copy(e).sub(n),
        this.max.copy(e).add(n),
        this
    }
    setFromObject(e, t=!1) {
        return this.makeEmpty(),
        this.expandByObject(e, t)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.min.copy(e.min),
        this.max.copy(e.max),
        this
    }
    makeEmpty() {
        return this.min.x = this.min.y = this.min.z = 1 / 0,
        this.max.x = this.max.y = this.max.z = -1 / 0,
        this
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
    }
    getCenter(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
    }
    getSize(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
    }
    expandByPoint(e) {
        return this.min.min(e),
        this.max.max(e),
        this
    }
    expandByVector(e) {
        return this.min.sub(e),
        this.max.add(e),
        this
    }
    expandByScalar(e) {
        return this.min.addScalar(-e),
        this.max.addScalar(e),
        this
    }
    expandByObject(e, t=!1) {
        e.updateWorldMatrix(!1, !1);
        const n = e.geometry;
        if (n !== void 0) {
            const r = n.getAttribute("position");
            if (t === !0 && r !== void 0 && e.isInstancedMesh !== !0)
                for (let o = 0, a = r.count; o < a; o++)
                    e.isMesh === !0 ? e.getVertexPosition(o, Zs) : Zs.fromBufferAttribute(r, o),
                    Zs.applyMatrix4(e.matrixWorld),
                    this.expandByPoint(Zs);
            else
                e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(),
                Wf.copy(e.boundingBox)) : (n.boundingBox === null && n.computeBoundingBox(),
                Wf.copy(n.boundingBox)),
                Wf.applyMatrix4(e.matrixWorld),
                this.union(Wf)
        }
        const s = e.children;
        for (let r = 0, o = s.length; r < o; r++)
            this.expandByObject(s[r], t);
        return this
    }
    containsPoint(e) {
        return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z
    }
    containsBox(e) {
        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
    }
    getParameter(e, t) {
        return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
    }
    intersectsBox(e) {
        return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z
    }
    intersectsSphere(e) {
        return this.clampPoint(e.center, Zs),
        Zs.distanceToSquared(e.center) <= e.radius * e.radius
    }
    intersectsPlane(e) {
        let t, n;
        return e.normal.x > 0 ? (t = e.normal.x * this.min.x,
        n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x,
        n = e.normal.x * this.min.x),
        e.normal.y > 0 ? (t += e.normal.y * this.min.y,
        n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y,
        n += e.normal.y * this.min.y),
        e.normal.z > 0 ? (t += e.normal.z * this.min.z,
        n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z,
        n += e.normal.z * this.min.z),
        t <= -e.constant && n >= -e.constant
    }
    intersectsTriangle(e) {
        if (this.isEmpty())
            return !1;
        this.getCenter(Nu),
        qf.subVectors(this.max, Nu),
        tc.subVectors(e.a, Nu),
        nc.subVectors(e.b, Nu),
        ic.subVectors(e.c, Nu),
        Wo.subVectors(nc, tc),
        qo.subVectors(ic, nc),
        Wa.subVectors(tc, ic);
        let t = [0, -Wo.z, Wo.y, 0, -qo.z, qo.y, 0, -Wa.z, Wa.y, Wo.z, 0, -Wo.x, qo.z, 0, -qo.x, Wa.z, 0, -Wa.x, -Wo.y, Wo.x, 0, -qo.y, qo.x, 0, -Wa.y, Wa.x, 0];
        return !X0(t, tc, nc, ic, qf) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        !X0(t, tc, nc, ic, qf)) ? !1 : (jf.crossVectors(Wo, qo),
        t = [jf.x, jf.y, jf.z],
        X0(t, tc, nc, ic, qf))
    }
    clampPoint(e, t) {
        return t.copy(e).clamp(this.min, this.max)
    }
    distanceToPoint(e) {
        return this.clampPoint(e, Zs).distanceTo(e)
    }
    getBoundingSphere(e) {
        return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center),
        e.radius = this.getSize(Zs).length() * .5),
        e
    }
    intersect(e) {
        return this.min.max(e.min),
        this.max.min(e.max),
        this.isEmpty() && this.makeEmpty(),
        this
    }
    union(e) {
        return this.min.min(e.min),
        this.max.max(e.max),
        this
    }
    applyMatrix4(e) {
        return this.isEmpty() ? this : (oo[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        oo[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        oo[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        oo[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        oo[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        oo[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        oo[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        oo[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(oo),
        this)
    }
    translate(e) {
        return this.min.add(e),
        this.max.add(e),
        this
    }
    equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max)
    }
}
const oo = [new Te, new Te, new Te, new Te, new Te, new Te, new Te, new Te]
  , Zs = new Te
  , Wf = new cf
  , tc = new Te
  , nc = new Te
  , ic = new Te
  , Wo = new Te
  , qo = new Te
  , Wa = new Te
  , Nu = new Te
  , qf = new Te
  , jf = new Te
  , qa = new Te;
function X0(i, e, t, n, s) {
    for (let r = 0, o = i.length - 3; r <= o; r += 3) {
        qa.fromArray(i, r);
        const a = s.x * Math.abs(qa.x) + s.y * Math.abs(qa.y) + s.z * Math.abs(qa.z)
          , l = e.dot(qa)
          , c = t.dot(qa)
          , u = n.dot(qa);
        if (Math.max(-Math.max(l, c, u), Math.min(l, c, u)) > a)
            return !1
    }
    return !0
}
const nY = new cf
  , Bu = new Te
  , Y0 = new Te;
class wx {
    constructor(e=new Te, t=-1) {
        this.isSphere = !0,
        this.center = e,
        this.radius = t
    }
    set(e, t) {
        return this.center.copy(e),
        this.radius = t,
        this
    }
    setFromPoints(e, t) {
        const n = this.center;
        t !== void 0 ? n.copy(t) : nY.setFromPoints(e).getCenter(n);
        let s = 0;
        for (let r = 0, o = e.length; r < o; r++)
            s = Math.max(s, n.distanceToSquared(e[r]));
        return this.radius = Math.sqrt(s),
        this
    }
    copy(e) {
        return this.center.copy(e.center),
        this.radius = e.radius,
        this
    }
    isEmpty() {
        return this.radius < 0
    }
    makeEmpty() {
        return this.center.set(0, 0, 0),
        this.radius = -1,
        this
    }
    containsPoint(e) {
        return e.distanceToSquared(this.center) <= this.radius * this.radius
    }
    distanceToPoint(e) {
        return e.distanceTo(this.center) - this.radius
    }
    intersectsSphere(e) {
        const t = this.radius + e.radius;
        return e.center.distanceToSquared(this.center) <= t * t
    }
    intersectsBox(e) {
        return e.intersectsSphere(this)
    }
    intersectsPlane(e) {
        return Math.abs(e.distanceToPoint(this.center)) <= this.radius
    }
    clampPoint(e, t) {
        const n = this.center.distanceToSquared(e);
        return t.copy(e),
        n > this.radius * this.radius && (t.sub(this.center).normalize(),
        t.multiplyScalar(this.radius).add(this.center)),
        t
    }
    getBoundingBox(e) {
        return this.isEmpty() ? (e.makeEmpty(),
        e) : (e.set(this.center, this.center),
        e.expandByScalar(this.radius),
        e)
    }
    applyMatrix4(e) {
        return this.center.applyMatrix4(e),
        this.radius = this.radius * e.getMaxScaleOnAxis(),
        this
    }
    translate(e) {
        return this.center.add(e),
        this
    }
    expandByPoint(e) {
        if (this.isEmpty())
            return this.center.copy(e),
            this.radius = 0,
            this;
        Bu.subVectors(e, this.center);
        const t = Bu.lengthSq();
        if (t > this.radius * this.radius) {
            const n = Math.sqrt(t)
              , s = (n - this.radius) * .5;
            this.center.addScaledVector(Bu, s / n),
            this.radius += s
        }
        return this
    }
    union(e) {
        return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e),
        this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (Y0.subVectors(e.center, this.center).setLength(e.radius),
        this.expandByPoint(Bu.copy(e.center).add(Y0)),
        this.expandByPoint(Bu.copy(e.center).sub(Y0))),
        this)
    }
    equals(e) {
        return e.center.equals(this.center) && e.radius === this.radius
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const ao = new Te
  , Z0 = new Te
  , Kf = new Te
  , jo = new Te
  , J0 = new Te
  , Xf = new Te
  , Q0 = new Te;
class iY {
    constructor(e=new Te, t=new Te(0,0,-1)) {
        this.origin = e,
        this.direction = t
    }
    set(e, t) {
        return this.origin.copy(e),
        this.direction.copy(t),
        this
    }
    copy(e) {
        return this.origin.copy(e.origin),
        this.direction.copy(e.direction),
        this
    }
    at(e, t) {
        return t.copy(this.origin).addScaledVector(this.direction, e)
    }
    lookAt(e) {
        return this.direction.copy(e).sub(this.origin).normalize(),
        this
    }
    recast(e) {
        return this.origin.copy(this.at(e, ao)),
        this
    }
    closestPointToPoint(e, t) {
        t.subVectors(e, this.origin);
        const n = t.dot(this.direction);
        return n < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, n)
    }
    distanceToPoint(e) {
        return Math.sqrt(this.distanceSqToPoint(e))
    }
    distanceSqToPoint(e) {
        const t = ao.subVectors(e, this.origin).dot(this.direction);
        return t < 0 ? this.origin.distanceToSquared(e) : (ao.copy(this.origin).addScaledVector(this.direction, t),
        ao.distanceToSquared(e))
    }
    distanceSqToSegment(e, t, n, s) {
        Z0.copy(e).add(t).multiplyScalar(.5),
        Kf.copy(t).sub(e).normalize(),
        jo.copy(this.origin).sub(Z0);
        const r = e.distanceTo(t) * .5
          , o = -this.direction.dot(Kf)
          , a = jo.dot(this.direction)
          , l = -jo.dot(Kf)
          , c = jo.lengthSq()
          , u = Math.abs(1 - o * o);
        let d, f, h, p;
        if (u > 0)
            if (d = o * l - a,
            f = o * a - l,
            p = r * u,
            d >= 0)
                if (f >= -p)
                    if (f <= p) {
                        const g = 1 / u;
                        d *= g,
                        f *= g,
                        h = d * (d + o * f + 2 * a) + f * (o * d + f + 2 * l) + c
                    } else
                        f = r,
                        d = Math.max(0, -(o * f + a)),
                        h = -d * d + f * (f + 2 * l) + c;
                else
                    f = -r,
                    d = Math.max(0, -(o * f + a)),
                    h = -d * d + f * (f + 2 * l) + c;
            else
                f <= -p ? (d = Math.max(0, -(-o * r + a)),
                f = d > 0 ? -r : Math.min(Math.max(-r, -l), r),
                h = -d * d + f * (f + 2 * l) + c) : f <= p ? (d = 0,
                f = Math.min(Math.max(-r, -l), r),
                h = f * (f + 2 * l) + c) : (d = Math.max(0, -(o * r + a)),
                f = d > 0 ? r : Math.min(Math.max(-r, -l), r),
                h = -d * d + f * (f + 2 * l) + c);
        else
            f = o > 0 ? -r : r,
            d = Math.max(0, -(o * f + a)),
            h = -d * d + f * (f + 2 * l) + c;
        return n && n.copy(this.origin).addScaledVector(this.direction, d),
        s && s.copy(Z0).addScaledVector(Kf, f),
        h
    }
    intersectSphere(e, t) {
        ao.subVectors(e.center, this.origin);
        const n = ao.dot(this.direction)
          , s = ao.dot(ao) - n * n
          , r = e.radius * e.radius;
        if (s > r)
            return null;
        const o = Math.sqrt(r - s)
          , a = n - o
          , l = n + o;
        return l < 0 ? null : a < 0 ? this.at(l, t) : this.at(a, t)
    }
    intersectsSphere(e) {
        return this.distanceSqToPoint(e.center) <= e.radius * e.radius
    }
    distanceToPlane(e) {
        const t = e.normal.dot(this.direction);
        if (t === 0)
            return e.distanceToPoint(this.origin) === 0 ? 0 : null;
        const n = -(this.origin.dot(e.normal) + e.constant) / t;
        return n >= 0 ? n : null
    }
    intersectPlane(e, t) {
        const n = this.distanceToPlane(e);
        return n === null ? null : this.at(n, t)
    }
    intersectsPlane(e) {
        const t = e.distanceToPoint(this.origin);
        return t === 0 || e.normal.dot(this.direction) * t < 0
    }
    intersectBox(e, t) {
        let n, s, r, o, a, l;
        const c = 1 / this.direction.x
          , u = 1 / this.direction.y
          , d = 1 / this.direction.z
          , f = this.origin;
        return c >= 0 ? (n = (e.min.x - f.x) * c,
        s = (e.max.x - f.x) * c) : (n = (e.max.x - f.x) * c,
        s = (e.min.x - f.x) * c),
        u >= 0 ? (r = (e.min.y - f.y) * u,
        o = (e.max.y - f.y) * u) : (r = (e.max.y - f.y) * u,
        o = (e.min.y - f.y) * u),
        n > o || r > s || ((r > n || isNaN(n)) && (n = r),
        (o < s || isNaN(s)) && (s = o),
        d >= 0 ? (a = (e.min.z - f.z) * d,
        l = (e.max.z - f.z) * d) : (a = (e.max.z - f.z) * d,
        l = (e.min.z - f.z) * d),
        n > l || a > s) || ((a > n || n !== n) && (n = a),
        (l < s || s !== s) && (s = l),
        s < 0) ? null : this.at(n >= 0 ? n : s, t)
    }
    intersectsBox(e) {
        return this.intersectBox(e, ao) !== null
    }
    intersectTriangle(e, t, n, s, r) {
        J0.subVectors(t, e),
        Xf.subVectors(n, e),
        Q0.crossVectors(J0, Xf);
        let o = this.direction.dot(Q0), a;
        if (o > 0) {
            if (s)
                return null;
            a = 1
        } else if (o < 0)
            a = -1,
            o = -o;
        else
            return null;
        jo.subVectors(this.origin, e);
        const l = a * this.direction.dot(Xf.crossVectors(jo, Xf));
        if (l < 0)
            return null;
        const c = a * this.direction.dot(J0.cross(jo));
        if (c < 0 || l + c > o)
            return null;
        const u = -a * jo.dot(Q0);
        return u < 0 ? null : this.at(u / o, r)
    }
    applyMatrix4(e) {
        return this.origin.applyMatrix4(e),
        this.direction.transformDirection(e),
        this
    }
    equals(e) {
        return e.origin.equals(this.origin) && e.direction.equals(this.direction)
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class qn {
    constructor(e, t, n, s, r, o, a, l, c, u, d, f, h, p, g, m) {
        qn.prototype.isMatrix4 = !0,
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        e !== void 0 && this.set(e, t, n, s, r, o, a, l, c, u, d, f, h, p, g, m)
    }
    set(e, t, n, s, r, o, a, l, c, u, d, f, h, p, g, m) {
        const v = this.elements;
        return v[0] = e,
        v[4] = t,
        v[8] = n,
        v[12] = s,
        v[1] = r,
        v[5] = o,
        v[9] = a,
        v[13] = l,
        v[2] = c,
        v[6] = u,
        v[10] = d,
        v[14] = f,
        v[3] = h,
        v[7] = p,
        v[11] = g,
        v[15] = m,
        this
    }
    identity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    }
    clone() {
        return new qn().fromArray(this.elements)
    }
    copy(e) {
        const t = this.elements
          , n = e.elements;
        return t[0] = n[0],
        t[1] = n[1],
        t[2] = n[2],
        t[3] = n[3],
        t[4] = n[4],
        t[5] = n[5],
        t[6] = n[6],
        t[7] = n[7],
        t[8] = n[8],
        t[9] = n[9],
        t[10] = n[10],
        t[11] = n[11],
        t[12] = n[12],
        t[13] = n[13],
        t[14] = n[14],
        t[15] = n[15],
        this
    }
    copyPosition(e) {
        const t = this.elements
          , n = e.elements;
        return t[12] = n[12],
        t[13] = n[13],
        t[14] = n[14],
        this
    }
    setFromMatrix3(e) {
        const t = e.elements;
        return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1),
        this
    }
    extractBasis(e, t, n) {
        return e.setFromMatrixColumn(this, 0),
        t.setFromMatrixColumn(this, 1),
        n.setFromMatrixColumn(this, 2),
        this
    }
    makeBasis(e, t, n) {
        return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1),
        this
    }
    extractRotation(e) {
        const t = this.elements
          , n = e.elements
          , s = 1 / sc.setFromMatrixColumn(e, 0).length()
          , r = 1 / sc.setFromMatrixColumn(e, 1).length()
          , o = 1 / sc.setFromMatrixColumn(e, 2).length();
        return t[0] = n[0] * s,
        t[1] = n[1] * s,
        t[2] = n[2] * s,
        t[3] = 0,
        t[4] = n[4] * r,
        t[5] = n[5] * r,
        t[6] = n[6] * r,
        t[7] = 0,
        t[8] = n[8] * o,
        t[9] = n[9] * o,
        t[10] = n[10] * o,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        this
    }
    makeRotationFromEuler(e) {
        const t = this.elements
          , n = e.x
          , s = e.y
          , r = e.z
          , o = Math.cos(n)
          , a = Math.sin(n)
          , l = Math.cos(s)
          , c = Math.sin(s)
          , u = Math.cos(r)
          , d = Math.sin(r);
        if (e.order === "XYZ") {
            const f = o * u
              , h = o * d
              , p = a * u
              , g = a * d;
            t[0] = l * u,
            t[4] = -l * d,
            t[8] = c,
            t[1] = h + p * c,
            t[5] = f - g * c,
            t[9] = -a * l,
            t[2] = g - f * c,
            t[6] = p + h * c,
            t[10] = o * l
        } else if (e.order === "YXZ") {
            const f = l * u
              , h = l * d
              , p = c * u
              , g = c * d;
            t[0] = f + g * a,
            t[4] = p * a - h,
            t[8] = o * c,
            t[1] = o * d,
            t[5] = o * u,
            t[9] = -a,
            t[2] = h * a - p,
            t[6] = g + f * a,
            t[10] = o * l
        } else if (e.order === "ZXY") {
            const f = l * u
              , h = l * d
              , p = c * u
              , g = c * d;
            t[0] = f - g * a,
            t[4] = -o * d,
            t[8] = p + h * a,
            t[1] = h + p * a,
            t[5] = o * u,
            t[9] = g - f * a,
            t[2] = -o * c,
            t[6] = a,
            t[10] = o * l
        } else if (e.order === "ZYX") {
            const f = o * u
              , h = o * d
              , p = a * u
              , g = a * d;
            t[0] = l * u,
            t[4] = p * c - h,
            t[8] = f * c + g,
            t[1] = l * d,
            t[5] = g * c + f,
            t[9] = h * c - p,
            t[2] = -c,
            t[6] = a * l,
            t[10] = o * l
        } else if (e.order === "YZX") {
            const f = o * l
              , h = o * c
              , p = a * l
              , g = a * c;
            t[0] = l * u,
            t[4] = g - f * d,
            t[8] = p * d + h,
            t[1] = d,
            t[5] = o * u,
            t[9] = -a * u,
            t[2] = -c * u,
            t[6] = h * d + p,
            t[10] = f - g * d
        } else if (e.order === "XZY") {
            const f = o * l
              , h = o * c
              , p = a * l
              , g = a * c;
            t[0] = l * u,
            t[4] = -d,
            t[8] = c * u,
            t[1] = f * d + g,
            t[5] = o * u,
            t[9] = h * d - p,
            t[2] = p * d - h,
            t[6] = a * u,
            t[10] = g * d + f
        }
        return t[3] = 0,
        t[7] = 0,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        this
    }
    makeRotationFromQuaternion(e) {
        return this.compose(sY, e, rY)
    }
    lookAt(e, t, n) {
        const s = this.elements;
        return ps.subVectors(e, t),
        ps.lengthSq() === 0 && (ps.z = 1),
        ps.normalize(),
        Ko.crossVectors(n, ps),
        Ko.lengthSq() === 0 && (Math.abs(n.z) === 1 ? ps.x += 1e-4 : ps.z += 1e-4,
        ps.normalize(),
        Ko.crossVectors(n, ps)),
        Ko.normalize(),
        Yf.crossVectors(ps, Ko),
        s[0] = Ko.x,
        s[4] = Yf.x,
        s[8] = ps.x,
        s[1] = Ko.y,
        s[5] = Yf.y,
        s[9] = ps.y,
        s[2] = Ko.z,
        s[6] = Yf.z,
        s[10] = ps.z,
        this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, t) {
        const n = e.elements
          , s = t.elements
          , r = this.elements
          , o = n[0]
          , a = n[4]
          , l = n[8]
          , c = n[12]
          , u = n[1]
          , d = n[5]
          , f = n[9]
          , h = n[13]
          , p = n[2]
          , g = n[6]
          , m = n[10]
          , v = n[14]
          , _ = n[3]
          , y = n[7]
          , b = n[11]
          , S = n[15]
          , C = s[0]
          , M = s[4]
          , L = s[8]
          , T = s[12]
          , A = s[1]
          , k = s[5]
          , D = s[9]
          , F = s[13]
          , z = s[2]
          , G = s[6]
          , H = s[10]
          , X = s[14]
          , K = s[3]
          , ce = s[7]
          , ue = s[11]
          , Ie = s[15];
        return r[0] = o * C + a * A + l * z + c * K,
        r[4] = o * M + a * k + l * G + c * ce,
        r[8] = o * L + a * D + l * H + c * ue,
        r[12] = o * T + a * F + l * X + c * Ie,
        r[1] = u * C + d * A + f * z + h * K,
        r[5] = u * M + d * k + f * G + h * ce,
        r[9] = u * L + d * D + f * H + h * ue,
        r[13] = u * T + d * F + f * X + h * Ie,
        r[2] = p * C + g * A + m * z + v * K,
        r[6] = p * M + g * k + m * G + v * ce,
        r[10] = p * L + g * D + m * H + v * ue,
        r[14] = p * T + g * F + m * X + v * Ie,
        r[3] = _ * C + y * A + b * z + S * K,
        r[7] = _ * M + y * k + b * G + S * ce,
        r[11] = _ * L + y * D + b * H + S * ue,
        r[15] = _ * T + y * F + b * X + S * Ie,
        this
    }
    multiplyScalar(e) {
        const t = this.elements;
        return t[0] *= e,
        t[4] *= e,
        t[8] *= e,
        t[12] *= e,
        t[1] *= e,
        t[5] *= e,
        t[9] *= e,
        t[13] *= e,
        t[2] *= e,
        t[6] *= e,
        t[10] *= e,
        t[14] *= e,
        t[3] *= e,
        t[7] *= e,
        t[11] *= e,
        t[15] *= e,
        this
    }
    determinant() {
        const e = this.elements
          , t = e[0]
          , n = e[4]
          , s = e[8]
          , r = e[12]
          , o = e[1]
          , a = e[5]
          , l = e[9]
          , c = e[13]
          , u = e[2]
          , d = e[6]
          , f = e[10]
          , h = e[14]
          , p = e[3]
          , g = e[7]
          , m = e[11]
          , v = e[15];
        return p * (+r * l * d - s * c * d - r * a * f + n * c * f + s * a * h - n * l * h) + g * (+t * l * h - t * c * f + r * o * f - s * o * h + s * c * u - r * l * u) + m * (+t * c * d - t * a * h - r * o * d + n * o * h + r * a * u - n * c * u) + v * (-s * a * u - t * l * d + t * a * f + s * o * d - n * o * f + n * l * u)
    }
    transpose() {
        const e = this.elements;
        let t;
        return t = e[1],
        e[1] = e[4],
        e[4] = t,
        t = e[2],
        e[2] = e[8],
        e[8] = t,
        t = e[6],
        e[6] = e[9],
        e[9] = t,
        t = e[3],
        e[3] = e[12],
        e[12] = t,
        t = e[7],
        e[7] = e[13],
        e[13] = t,
        t = e[11],
        e[11] = e[14],
        e[14] = t,
        this
    }
    setPosition(e, t, n) {
        const s = this.elements;
        return e.isVector3 ? (s[12] = e.x,
        s[13] = e.y,
        s[14] = e.z) : (s[12] = e,
        s[13] = t,
        s[14] = n),
        this
    }
    invert() {
        const e = this.elements
          , t = e[0]
          , n = e[1]
          , s = e[2]
          , r = e[3]
          , o = e[4]
          , a = e[5]
          , l = e[6]
          , c = e[7]
          , u = e[8]
          , d = e[9]
          , f = e[10]
          , h = e[11]
          , p = e[12]
          , g = e[13]
          , m = e[14]
          , v = e[15]
          , _ = d * m * c - g * f * c + g * l * h - a * m * h - d * l * v + a * f * v
          , y = p * f * c - u * m * c - p * l * h + o * m * h + u * l * v - o * f * v
          , b = u * g * c - p * d * c + p * a * h - o * g * h - u * a * v + o * d * v
          , S = p * d * l - u * g * l - p * a * f + o * g * f + u * a * m - o * d * m
          , C = t * _ + n * y + s * b + r * S;
        if (C === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const M = 1 / C;
        return e[0] = _ * M,
        e[1] = (g * f * r - d * m * r - g * s * h + n * m * h + d * s * v - n * f * v) * M,
        e[2] = (a * m * r - g * l * r + g * s * c - n * m * c - a * s * v + n * l * v) * M,
        e[3] = (d * l * r - a * f * r - d * s * c + n * f * c + a * s * h - n * l * h) * M,
        e[4] = y * M,
        e[5] = (u * m * r - p * f * r + p * s * h - t * m * h - u * s * v + t * f * v) * M,
        e[6] = (p * l * r - o * m * r - p * s * c + t * m * c + o * s * v - t * l * v) * M,
        e[7] = (o * f * r - u * l * r + u * s * c - t * f * c - o * s * h + t * l * h) * M,
        e[8] = b * M,
        e[9] = (p * d * r - u * g * r - p * n * h + t * g * h + u * n * v - t * d * v) * M,
        e[10] = (o * g * r - p * a * r + p * n * c - t * g * c - o * n * v + t * a * v) * M,
        e[11] = (u * a * r - o * d * r - u * n * c + t * d * c + o * n * h - t * a * h) * M,
        e[12] = S * M,
        e[13] = (u * g * s - p * d * s + p * n * f - t * g * f - u * n * m + t * d * m) * M,
        e[14] = (p * a * s - o * g * s - p * n * l + t * g * l + o * n * m - t * a * m) * M,
        e[15] = (o * d * s - u * a * s + u * n * l - t * d * l - o * n * f + t * a * f) * M,
        this
    }
    scale(e) {
        const t = this.elements
          , n = e.x
          , s = e.y
          , r = e.z;
        return t[0] *= n,
        t[4] *= s,
        t[8] *= r,
        t[1] *= n,
        t[5] *= s,
        t[9] *= r,
        t[2] *= n,
        t[6] *= s,
        t[10] *= r,
        t[3] *= n,
        t[7] *= s,
        t[11] *= r,
        this
    }
    getMaxScaleOnAxis() {
        const e = this.elements
          , t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2]
          , n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6]
          , s = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
        return Math.sqrt(Math.max(t, n, s))
    }
    makeTranslation(e, t, n) {
        return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1),
        this
    }
    makeRotationX(e) {
        const t = Math.cos(e)
          , n = Math.sin(e);
        return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1),
        this
    }
    makeRotationY(e) {
        const t = Math.cos(e)
          , n = Math.sin(e);
        return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1),
        this
    }
    makeRotationZ(e) {
        const t = Math.cos(e)
          , n = Math.sin(e);
        return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    }
    makeRotationAxis(e, t) {
        const n = Math.cos(t)
          , s = Math.sin(t)
          , r = 1 - n
          , o = e.x
          , a = e.y
          , l = e.z
          , c = r * o
          , u = r * a;
        return this.set(c * o + n, c * a - s * l, c * l + s * a, 0, c * a + s * l, u * a + n, u * l - s * o, 0, c * l - s * a, u * l + s * o, r * l * l + n, 0, 0, 0, 0, 1),
        this
    }
    makeScale(e, t, n) {
        return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1),
        this
    }
    makeShear(e, t, n, s, r, o) {
        return this.set(1, n, r, 0, e, 1, o, 0, t, s, 1, 0, 0, 0, 0, 1),
        this
    }
    compose(e, t, n) {
        const s = this.elements
          , r = t._x
          , o = t._y
          , a = t._z
          , l = t._w
          , c = r + r
          , u = o + o
          , d = a + a
          , f = r * c
          , h = r * u
          , p = r * d
          , g = o * u
          , m = o * d
          , v = a * d
          , _ = l * c
          , y = l * u
          , b = l * d
          , S = n.x
          , C = n.y
          , M = n.z;
        return s[0] = (1 - (g + v)) * S,
        s[1] = (h + b) * S,
        s[2] = (p - y) * S,
        s[3] = 0,
        s[4] = (h - b) * C,
        s[5] = (1 - (f + v)) * C,
        s[6] = (m + _) * C,
        s[7] = 0,
        s[8] = (p + y) * M,
        s[9] = (m - _) * M,
        s[10] = (1 - (f + g)) * M,
        s[11] = 0,
        s[12] = e.x,
        s[13] = e.y,
        s[14] = e.z,
        s[15] = 1,
        this
    }
    decompose(e, t, n) {
        const s = this.elements;
        let r = sc.set(s[0], s[1], s[2]).length();
        const o = sc.set(s[4], s[5], s[6]).length()
          , a = sc.set(s[8], s[9], s[10]).length();
        this.determinant() < 0 && (r = -r),
        e.x = s[12],
        e.y = s[13],
        e.z = s[14],
        Js.copy(this);
        const c = 1 / r
          , u = 1 / o
          , d = 1 / a;
        return Js.elements[0] *= c,
        Js.elements[1] *= c,
        Js.elements[2] *= c,
        Js.elements[4] *= u,
        Js.elements[5] *= u,
        Js.elements[6] *= u,
        Js.elements[8] *= d,
        Js.elements[9] *= d,
        Js.elements[10] *= d,
        t.setFromRotationMatrix(Js),
        n.x = r,
        n.y = o,
        n.z = a,
        this
    }
    makePerspective(e, t, n, s, r, o, a=Lo) {
        const l = this.elements
          , c = 2 * r / (t - e)
          , u = 2 * r / (n - s)
          , d = (t + e) / (t - e)
          , f = (n + s) / (n - s);
        let h, p;
        if (a === Lo)
            h = -(o + r) / (o - r),
            p = -2 * o * r / (o - r);
        else if (a === Vp)
            h = -o / (o - r),
            p = -o * r / (o - r);
        else
            throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a);
        return l[0] = c,
        l[4] = 0,
        l[8] = d,
        l[12] = 0,
        l[1] = 0,
        l[5] = u,
        l[9] = f,
        l[13] = 0,
        l[2] = 0,
        l[6] = 0,
        l[10] = h,
        l[14] = p,
        l[3] = 0,
        l[7] = 0,
        l[11] = -1,
        l[15] = 0,
        this
    }
    makeOrthographic(e, t, n, s, r, o, a=Lo) {
        const l = this.elements
          , c = 1 / (t - e)
          , u = 1 / (n - s)
          , d = 1 / (o - r)
          , f = (t + e) * c
          , h = (n + s) * u;
        let p, g;
        if (a === Lo)
            p = (o + r) * d,
            g = -2 * d;
        else if (a === Vp)
            p = r * d,
            g = -1 * d;
        else
            throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a);
        return l[0] = 2 * c,
        l[4] = 0,
        l[8] = 0,
        l[12] = -f,
        l[1] = 0,
        l[5] = 2 * u,
        l[9] = 0,
        l[13] = -h,
        l[2] = 0,
        l[6] = 0,
        l[10] = g,
        l[14] = -p,
        l[3] = 0,
        l[7] = 0,
        l[11] = 0,
        l[15] = 1,
        this
    }
    equals(e) {
        const t = this.elements
          , n = e.elements;
        for (let s = 0; s < 16; s++)
            if (t[s] !== n[s])
                return !1;
        return !0
    }
    fromArray(e, t=0) {
        for (let n = 0; n < 16; n++)
            this.elements[n] = e[n + t];
        return this
    }
    toArray(e=[], t=0) {
        const n = this.elements;
        return e[t] = n[0],
        e[t + 1] = n[1],
        e[t + 2] = n[2],
        e[t + 3] = n[3],
        e[t + 4] = n[4],
        e[t + 5] = n[5],
        e[t + 6] = n[6],
        e[t + 7] = n[7],
        e[t + 8] = n[8],
        e[t + 9] = n[9],
        e[t + 10] = n[10],
        e[t + 11] = n[11],
        e[t + 12] = n[12],
        e[t + 13] = n[13],
        e[t + 14] = n[14],
        e[t + 15] = n[15],
        e
    }
}
const sc = new Te
  , Js = new qn
  , sY = new Te(0,0,0)
  , rY = new Te(1,1,1)
  , Ko = new Te
  , Yf = new Te
  , ps = new Te
  , XS = new qn
  , YS = new lf;
class Xr {
    constructor(e=0, t=0, n=0, s=Xr.DEFAULT_ORDER) {
        this.isEuler = !0,
        this._x = e,
        this._y = t,
        this._z = n,
        this._order = s
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e,
        this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e,
        this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e,
        this._onChangeCallback()
    }
    get order() {
        return this._order
    }
    set order(e) {
        this._order = e,
        this._onChangeCallback()
    }
    set(e, t, n, s=this._order) {
        return this._x = e,
        this._y = t,
        this._z = n,
        this._order = s,
        this._onChangeCallback(),
        this
    }
    clone() {
        return new this.constructor(this._x,this._y,this._z,this._order)
    }
    copy(e) {
        return this._x = e._x,
        this._y = e._y,
        this._z = e._z,
        this._order = e._order,
        this._onChangeCallback(),
        this
    }
    setFromRotationMatrix(e, t=this._order, n=!0) {
        const s = e.elements
          , r = s[0]
          , o = s[4]
          , a = s[8]
          , l = s[1]
          , c = s[5]
          , u = s[9]
          , d = s[2]
          , f = s[6]
          , h = s[10];
        switch (t) {
        case "XYZ":
            this._y = Math.asin(is(a, -1, 1)),
            Math.abs(a) < .9999999 ? (this._x = Math.atan2(-u, h),
            this._z = Math.atan2(-o, r)) : (this._x = Math.atan2(f, c),
            this._z = 0);
            break;
        case "YXZ":
            this._x = Math.asin(-is(u, -1, 1)),
            Math.abs(u) < .9999999 ? (this._y = Math.atan2(a, h),
            this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-d, r),
            this._z = 0);
            break;
        case "ZXY":
            this._x = Math.asin(is(f, -1, 1)),
            Math.abs(f) < .9999999 ? (this._y = Math.atan2(-d, h),
            this._z = Math.atan2(-o, c)) : (this._y = 0,
            this._z = Math.atan2(l, r));
            break;
        case "ZYX":
            this._y = Math.asin(-is(d, -1, 1)),
            Math.abs(d) < .9999999 ? (this._x = Math.atan2(f, h),
            this._z = Math.atan2(l, r)) : (this._x = 0,
            this._z = Math.atan2(-o, c));
            break;
        case "YZX":
            this._z = Math.asin(is(l, -1, 1)),
            Math.abs(l) < .9999999 ? (this._x = Math.atan2(-u, c),
            this._y = Math.atan2(-d, r)) : (this._x = 0,
            this._y = Math.atan2(a, h));
            break;
        case "XZY":
            this._z = Math.asin(-is(o, -1, 1)),
            Math.abs(o) < .9999999 ? (this._x = Math.atan2(f, c),
            this._y = Math.atan2(a, r)) : (this._x = Math.atan2(-u, h),
            this._y = 0);
            break;
        default:
            console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
        }
        return this._order = t,
        n === !0 && this._onChangeCallback(),
        this
    }
    setFromQuaternion(e, t, n) {
        return XS.makeRotationFromQuaternion(e),
        this.setFromRotationMatrix(XS, t, n)
    }
    setFromVector3(e, t=this._order) {
        return this.set(e.x, e.y, e.z, t)
    }
    reorder(e) {
        return YS.setFromEuler(this),
        this.setFromQuaternion(YS, e)
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
    }
    fromArray(e) {
        return this._x = e[0],
        this._y = e[1],
        this._z = e[2],
        e[3] !== void 0 && (this._order = e[3]),
        this._onChangeCallback(),
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this._x,
        e[t + 1] = this._y,
        e[t + 2] = this._z,
        e[t + 3] = this._order,
        e
    }
    _onChange(e) {
        return this._onChangeCallback = e,
        this
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
        yield this._x,
        yield this._y,
        yield this._z,
        yield this._order
    }
}
Xr.DEFAULT_ORDER = "XYZ";
class f3 {
    constructor() {
        this.mask = 1
    }
    set(e) {
        this.mask = (1 << e | 0) >>> 0
    }
    enable(e) {
        this.mask |= 1 << e | 0
    }
    enableAll() {
        this.mask = -1
    }
    toggle(e) {
        this.mask ^= 1 << e | 0
    }
    disable(e) {
        this.mask &= ~(1 << e | 0)
    }
    disableAll() {
        this.mask = 0
    }
    test(e) {
        return (this.mask & e.mask) !== 0
    }
    isEnabled(e) {
        return (this.mask & (1 << e | 0)) !== 0
    }
}
let oY = 0;
const ZS = new Te
  , rc = new lf
  , lo = new qn
  , Zf = new Te
  , Vu = new Te
  , aY = new Te
  , lY = new lf
  , JS = new Te(1,0,0)
  , QS = new Te(0,1,0)
  , eE = new Te(0,0,1)
  , tE = {
    type: "added"
}
  , cY = {
    type: "removed"
}
  , oc = {
    type: "childadded",
    child: null
}
  , eg = {
    type: "childremoved",
    child: null
};
class Fi extends Tu {
    constructor() {
        super(),
        this.isObject3D = !0,
        Object.defineProperty(this, "id", {
            value: oY++
        }),
        this.uuid = af(),
        this.name = "",
        this.type = "Object3D",
        this.parent = null,
        this.children = [],
        this.up = Fi.DEFAULT_UP.clone();
        const e = new Te
          , t = new Xr
          , n = new lf
          , s = new Te(1,1,1);
        function r() {
            n.setFromEuler(t, !1)
        }
        function o() {
            t.setFromQuaternion(n, void 0, !1)
        }
        t._onChange(r),
        n._onChange(o),
        Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: e
            },
            rotation: {
                configurable: !0,
                enumerable: !0,
                value: t
            },
            quaternion: {
                configurable: !0,
                enumerable: !0,
                value: n
            },
            scale: {
                configurable: !0,
                enumerable: !0,
                value: s
            },
            modelViewMatrix: {
                value: new qn
            },
            normalMatrix: {
                value: new Kt
            }
        }),
        this.matrix = new qn,
        this.matrixWorld = new qn,
        this.matrixAutoUpdate = Fi.DEFAULT_MATRIX_AUTO_UPDATE,
        this.matrixWorldAutoUpdate = Fi.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,
        this.matrixWorldNeedsUpdate = !1,
        this.layers = new f3,
        this.visible = !0,
        this.castShadow = !1,
        this.receiveShadow = !1,
        this.frustumCulled = !0,
        this.renderOrder = 0,
        this.animations = [],
        this.userData = {}
    }
    onBeforeShadow() {}
    onAfterShadow() {}
    onBeforeRender() {}
    onAfterRender() {}
    applyMatrix4(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
        this.matrix.premultiply(e),
        this.matrix.decompose(this.position, this.quaternion, this.scale)
    }
    applyQuaternion(e) {
        return this.quaternion.premultiply(e),
        this
    }
    setRotationFromAxisAngle(e, t) {
        this.quaternion.setFromAxisAngle(e, t)
    }
    setRotationFromEuler(e) {
        this.quaternion.setFromEuler(e, !0)
    }
    setRotationFromMatrix(e) {
        this.quaternion.setFromRotationMatrix(e)
    }
    setRotationFromQuaternion(e) {
        this.quaternion.copy(e)
    }
    rotateOnAxis(e, t) {
        return rc.setFromAxisAngle(e, t),
        this.quaternion.multiply(rc),
        this
    }
    rotateOnWorldAxis(e, t) {
        return rc.setFromAxisAngle(e, t),
        this.quaternion.premultiply(rc),
        this
    }
    rotateX(e) {
        return this.rotateOnAxis(JS, e)
    }
    rotateY(e) {
        return this.rotateOnAxis(QS, e)
    }
    rotateZ(e) {
        return this.rotateOnAxis(eE, e)
    }
    translateOnAxis(e, t) {
        return ZS.copy(e).applyQuaternion(this.quaternion),
        this.position.add(ZS.multiplyScalar(t)),
        this
    }
    translateX(e) {
        return this.translateOnAxis(JS, e)
    }
    translateY(e) {
        return this.translateOnAxis(QS, e)
    }
    translateZ(e) {
        return this.translateOnAxis(eE, e)
    }
    localToWorld(e) {
        return this.updateWorldMatrix(!0, !1),
        e.applyMatrix4(this.matrixWorld)
    }
    worldToLocal(e) {
        return this.updateWorldMatrix(!0, !1),
        e.applyMatrix4(lo.copy(this.matrixWorld).invert())
    }
    lookAt(e, t, n) {
        e.isVector3 ? Zf.copy(e) : Zf.set(e, t, n);
        const s = this.parent;
        this.updateWorldMatrix(!0, !1),
        Vu.setFromMatrixPosition(this.matrixWorld),
        this.isCamera || this.isLight ? lo.lookAt(Vu, Zf, this.up) : lo.lookAt(Zf, Vu, this.up),
        this.quaternion.setFromRotationMatrix(lo),
        s && (lo.extractRotation(s.matrixWorld),
        rc.setFromRotationMatrix(lo),
        this.quaternion.premultiply(rc.invert()))
    }
    add(e) {
        if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++)
                this.add(arguments[t]);
            return this
        }
        return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e),
        this) : (e && e.isObject3D ? (e.removeFromParent(),
        e.parent = this,
        this.children.push(e),
        e.dispatchEvent(tE),
        oc.child = e,
        this.dispatchEvent(oc),
        oc.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e),
        this)
    }
    remove(e) {
        if (arguments.length > 1) {
            for (let n = 0; n < arguments.length; n++)
                this.remove(arguments[n]);
            return this
        }
        const t = this.children.indexOf(e);
        return t !== -1 && (e.parent = null,
        this.children.splice(t, 1),
        e.dispatchEvent(cY),
        eg.child = e,
        this.dispatchEvent(eg),
        eg.child = null),
        this
    }
    removeFromParent() {
        const e = this.parent;
        return e !== null && e.remove(this),
        this
    }
    clear() {
        return this.remove(...this.children)
    }
    attach(e) {
        return this.updateWorldMatrix(!0, !1),
        lo.copy(this.matrixWorld).invert(),
        e.parent !== null && (e.parent.updateWorldMatrix(!0, !1),
        lo.multiply(e.parent.matrixWorld)),
        e.applyMatrix4(lo),
        e.removeFromParent(),
        e.parent = this,
        this.children.push(e),
        e.updateWorldMatrix(!1, !0),
        e.dispatchEvent(tE),
        oc.child = e,
        this.dispatchEvent(oc),
        oc.child = null,
        this
    }
    getObjectById(e) {
        return this.getObjectByProperty("id", e)
    }
    getObjectByName(e) {
        return this.getObjectByProperty("name", e)
    }
    getObjectByProperty(e, t) {
        if (this[e] === t)
            return this;
        for (let n = 0, s = this.children.length; n < s; n++) {
            const o = this.children[n].getObjectByProperty(e, t);
            if (o !== void 0)
                return o
        }
    }
    getObjectsByProperty(e, t, n=[]) {
        this[e] === t && n.push(this);
        const s = this.children;
        for (let r = 0, o = s.length; r < o; r++)
            s[r].getObjectsByProperty(e, t, n);
        return n
    }
    getWorldPosition(e) {
        return this.updateWorldMatrix(!0, !1),
        e.setFromMatrixPosition(this.matrixWorld)
    }
    getWorldQuaternion(e) {
        return this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose(Vu, e, aY),
        e
    }
    getWorldScale(e) {
        return this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose(Vu, lY, e),
        e
    }
    getWorldDirection(e) {
        this.updateWorldMatrix(!0, !1);
        const t = this.matrixWorld.elements;
        return e.set(t[8], t[9], t[10]).normalize()
    }
    raycast() {}
    traverse(e) {
        e(this);
        const t = this.children;
        for (let n = 0, s = t.length; n < s; n++)
            t[n].traverse(e)
    }
    traverseVisible(e) {
        if (this.visible === !1)
            return;
        e(this);
        const t = this.children;
        for (let n = 0, s = t.length; n < s; n++)
            t[n].traverseVisible(e)
    }
    traverseAncestors(e) {
        const t = this.parent;
        t !== null && (e(t),
        t.traverseAncestors(e))
    }
    updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale),
        this.matrixWorldNeedsUpdate = !0
    }
    updateMatrixWorld(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
        (this.matrixWorldNeedsUpdate || e) && (this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)),
        this.matrixWorldNeedsUpdate = !1,
        e = !0);
        const t = this.children;
        for (let n = 0, s = t.length; n < s; n++)
            t[n].updateMatrixWorld(e)
    }
    updateWorldMatrix(e, t) {
        const n = this.parent;
        if (e === !0 && n !== null && n.updateWorldMatrix(!0, !1),
        this.matrixAutoUpdate && this.updateMatrix(),
        this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)),
        t === !0) {
            const s = this.children;
            for (let r = 0, o = s.length; r < o; r++)
                s[r].updateWorldMatrix(!1, !0)
        }
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string"
          , n = {};
        t && (e = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
            nodes: {}
        },
        n.metadata = {
            version: 4.6,
            type: "Object",
            generator: "Object3D.toJSON"
        });
        const s = {};
        s.uuid = this.uuid,
        s.type = this.type,
        this.name !== "" && (s.name = this.name),
        this.castShadow === !0 && (s.castShadow = !0),
        this.receiveShadow === !0 && (s.receiveShadow = !0),
        this.visible === !1 && (s.visible = !1),
        this.frustumCulled === !1 && (s.frustumCulled = !1),
        this.renderOrder !== 0 && (s.renderOrder = this.renderOrder),
        Object.keys(this.userData).length > 0 && (s.userData = this.userData),
        s.layers = this.layers.mask,
        s.matrix = this.matrix.toArray(),
        s.up = this.up.toArray(),
        this.matrixAutoUpdate === !1 && (s.matrixAutoUpdate = !1),
        this.isInstancedMesh && (s.type = "InstancedMesh",
        s.count = this.count,
        s.instanceMatrix = this.instanceMatrix.toJSON(),
        this.instanceColor !== null && (s.instanceColor = this.instanceColor.toJSON())),
        this.isBatchedMesh && (s.type = "BatchedMesh",
        s.perObjectFrustumCulled = this.perObjectFrustumCulled,
        s.sortObjects = this.sortObjects,
        s.drawRanges = this._drawRanges,
        s.reservedRanges = this._reservedRanges,
        s.visibility = this._visibility,
        s.active = this._active,
        s.bounds = this._bounds.map(a => ({
            boxInitialized: a.boxInitialized,
            boxMin: a.box.min.toArray(),
            boxMax: a.box.max.toArray(),
            sphereInitialized: a.sphereInitialized,
            sphereRadius: a.sphere.radius,
            sphereCenter: a.sphere.center.toArray()
        })),
        s.maxInstanceCount = this._maxInstanceCount,
        s.maxVertexCount = this._maxVertexCount,
        s.maxIndexCount = this._maxIndexCount,
        s.geometryInitialized = this._geometryInitialized,
        s.geometryCount = this._geometryCount,
        s.matricesTexture = this._matricesTexture.toJSON(e),
        this._colorsTexture !== null && (s.colorsTexture = this._colorsTexture.toJSON(e)),
        this.boundingSphere !== null && (s.boundingSphere = {
            center: s.boundingSphere.center.toArray(),
            radius: s.boundingSphere.radius
        }),
        this.boundingBox !== null && (s.boundingBox = {
            min: s.boundingBox.min.toArray(),
            max: s.boundingBox.max.toArray()
        }));
        function r(a, l) {
            return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)),
            l.uuid
        }
        if (this.isScene)
            this.background && (this.background.isColor ? s.background = this.background.toJSON() : this.background.isTexture && (s.background = this.background.toJSON(e).uuid)),
            this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (s.environment = this.environment.toJSON(e).uuid);
        else if (this.isMesh || this.isLine || this.isPoints) {
            s.geometry = r(e.geometries, this.geometry);
            const a = this.geometry.parameters;
            if (a !== void 0 && a.shapes !== void 0) {
                const l = a.shapes;
                if (Array.isArray(l))
                    for (let c = 0, u = l.length; c < u; c++) {
                        const d = l[c];
                        r(e.shapes, d)
                    }
                else
                    r(e.shapes, l)
            }
        }
        if (this.isSkinnedMesh && (s.bindMode = this.bindMode,
        s.bindMatrix = this.bindMatrix.toArray(),
        this.skeleton !== void 0 && (r(e.skeletons, this.skeleton),
        s.skeleton = this.skeleton.uuid)),
        this.material !== void 0)
            if (Array.isArray(this.material)) {
                const a = [];
                for (let l = 0, c = this.material.length; l < c; l++)
                    a.push(r(e.materials, this.material[l]));
                s.material = a
            } else
                s.material = r(e.materials, this.material);
        if (this.children.length > 0) {
            s.children = [];
            for (let a = 0; a < this.children.length; a++)
                s.children.push(this.children[a].toJSON(e).object)
        }
        if (this.animations.length > 0) {
            s.animations = [];
            for (let a = 0; a < this.animations.length; a++) {
                const l = this.animations[a];
                s.animations.push(r(e.animations, l))
            }
        }
        if (t) {
            const a = o(e.geometries)
              , l = o(e.materials)
              , c = o(e.textures)
              , u = o(e.images)
              , d = o(e.shapes)
              , f = o(e.skeletons)
              , h = o(e.animations)
              , p = o(e.nodes);
            a.length > 0 && (n.geometries = a),
            l.length > 0 && (n.materials = l),
            c.length > 0 && (n.textures = c),
            u.length > 0 && (n.images = u),
            d.length > 0 && (n.shapes = d),
            f.length > 0 && (n.skeletons = f),
            h.length > 0 && (n.animations = h),
            p.length > 0 && (n.nodes = p)
        }
        return n.object = s,
        n;
        function o(a) {
            const l = [];
            for (const c in a) {
                const u = a[c];
                delete u.metadata,
                l.push(u)
            }
            return l
        }
    }
    clone(e) {
        return new this.constructor().copy(this, e)
    }
    copy(e, t=!0) {
        if (this.name = e.name,
        this.up.copy(e.up),
        this.position.copy(e.position),
        this.rotation.order = e.rotation.order,
        this.quaternion.copy(e.quaternion),
        this.scale.copy(e.scale),
        this.matrix.copy(e.matrix),
        this.matrixWorld.copy(e.matrixWorld),
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate,
        this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate,
        this.layers.mask = e.layers.mask,
        this.visible = e.visible,
        this.castShadow = e.castShadow,
        this.receiveShadow = e.receiveShadow,
        this.frustumCulled = e.frustumCulled,
        this.renderOrder = e.renderOrder,
        this.animations = e.animations.slice(),
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        t === !0)
            for (let n = 0; n < e.children.length; n++) {
                const s = e.children[n];
                this.add(s.clone())
            }
        return this
    }
}
Fi.DEFAULT_UP = new Te(0,1,0);
Fi.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Fi.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const Qs = new Te
  , co = new Te
  , tg = new Te
  , uo = new Te
  , ac = new Te
  , lc = new Te
  , nE = new Te
  , ng = new Te
  , ig = new Te
  , sg = new Te;
class Dr {
    constructor(e=new Te, t=new Te, n=new Te) {
        this.a = e,
        this.b = t,
        this.c = n
    }
    static getNormal(e, t, n, s) {
        s.subVectors(n, t),
        Qs.subVectors(e, t),
        s.cross(Qs);
        const r = s.lengthSq();
        return r > 0 ? s.multiplyScalar(1 / Math.sqrt(r)) : s.set(0, 0, 0)
    }
    static getBarycoord(e, t, n, s, r) {
        Qs.subVectors(s, t),
        co.subVectors(n, t),
        tg.subVectors(e, t);
        const o = Qs.dot(Qs)
          , a = Qs.dot(co)
          , l = Qs.dot(tg)
          , c = co.dot(co)
          , u = co.dot(tg)
          , d = o * c - a * a;
        if (d === 0)
            return r.set(0, 0, 0),
            null;
        const f = 1 / d
          , h = (c * l - a * u) * f
          , p = (o * u - a * l) * f;
        return r.set(1 - h - p, p, h)
    }
    static containsPoint(e, t, n, s) {
        return this.getBarycoord(e, t, n, s, uo) === null ? !1 : uo.x >= 0 && uo.y >= 0 && uo.x + uo.y <= 1
    }
    static getInterpolation(e, t, n, s, r, o, a, l) {
        return this.getBarycoord(e, t, n, s, uo) === null ? (l.x = 0,
        l.y = 0,
        "z"in l && (l.z = 0),
        "w"in l && (l.w = 0),
        null) : (l.setScalar(0),
        l.addScaledVector(r, uo.x),
        l.addScaledVector(o, uo.y),
        l.addScaledVector(a, uo.z),
        l)
    }
    static isFrontFacing(e, t, n, s) {
        return Qs.subVectors(n, t),
        co.subVectors(e, t),
        Qs.cross(co).dot(s) < 0
    }
    set(e, t, n) {
        return this.a.copy(e),
        this.b.copy(t),
        this.c.copy(n),
        this
    }
    setFromPointsAndIndices(e, t, n, s) {
        return this.a.copy(e[t]),
        this.b.copy(e[n]),
        this.c.copy(e[s]),
        this
    }
    setFromAttributeAndIndices(e, t, n, s) {
        return this.a.fromBufferAttribute(e, t),
        this.b.fromBufferAttribute(e, n),
        this.c.fromBufferAttribute(e, s),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.a.copy(e.a),
        this.b.copy(e.b),
        this.c.copy(e.c),
        this
    }
    getArea() {
        return Qs.subVectors(this.c, this.b),
        co.subVectors(this.a, this.b),
        Qs.cross(co).length() * .5
    }
    getMidpoint(e) {
        return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
    }
    getNormal(e) {
        return Dr.getNormal(this.a, this.b, this.c, e)
    }
    getPlane(e) {
        return e.setFromCoplanarPoints(this.a, this.b, this.c)
    }
    getBarycoord(e, t) {
        return Dr.getBarycoord(e, this.a, this.b, this.c, t)
    }
    getInterpolation(e, t, n, s, r) {
        return Dr.getInterpolation(e, this.a, this.b, this.c, t, n, s, r)
    }
    containsPoint(e) {
        return Dr.containsPoint(e, this.a, this.b, this.c)
    }
    isFrontFacing(e) {
        return Dr.isFrontFacing(this.a, this.b, this.c, e)
    }
    intersectsBox(e) {
        return e.intersectsTriangle(this)
    }
    closestPointToPoint(e, t) {
        const n = this.a
          , s = this.b
          , r = this.c;
        let o, a;
        ac.subVectors(s, n),
        lc.subVectors(r, n),
        ng.subVectors(e, n);
        const l = ac.dot(ng)
          , c = lc.dot(ng);
        if (l <= 0 && c <= 0)
            return t.copy(n);
        ig.subVectors(e, s);
        const u = ac.dot(ig)
          , d = lc.dot(ig);
        if (u >= 0 && d <= u)
            return t.copy(s);
        const f = l * d - u * c;
        if (f <= 0 && l >= 0 && u <= 0)
            return o = l / (l - u),
            t.copy(n).addScaledVector(ac, o);
        sg.subVectors(e, r);
        const h = ac.dot(sg)
          , p = lc.dot(sg);
        if (p >= 0 && h <= p)
            return t.copy(r);
        const g = h * c - l * p;
        if (g <= 0 && c >= 0 && p <= 0)
            return a = c / (c - p),
            t.copy(n).addScaledVector(lc, a);
        const m = u * p - h * d;
        if (m <= 0 && d - u >= 0 && h - p >= 0)
            return nE.subVectors(r, s),
            a = (d - u) / (d - u + (h - p)),
            t.copy(s).addScaledVector(nE, a);
        const v = 1 / (m + g + f);
        return o = g * v,
        a = f * v,
        t.copy(n).addScaledVector(ac, o).addScaledVector(lc, a)
    }
    equals(e) {
        return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
    }
}
const h3 = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
}
  , Xo = {
    h: 0,
    s: 0,
    l: 0
}
  , Jf = {
    h: 0,
    s: 0,
    l: 0
};
function rg(i, e, t) {
    return t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6 ? i + (e - i) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? i + (e - i) * 6 * (2 / 3 - t) : i
}
class un {
    constructor(e, t, n) {
        return this.isColor = !0,
        this.r = 1,
        this.g = 1,
        this.b = 1,
        this.set(e, t, n)
    }
    set(e, t, n) {
        if (t === void 0 && n === void 0) {
            const s = e;
            s && s.isColor ? this.copy(s) : typeof s == "number" ? this.setHex(s) : typeof s == "string" && this.setStyle(s)
        } else
            this.setRGB(e, t, n);
        return this
    }
    setScalar(e) {
        return this.r = e,
        this.g = e,
        this.b = e,
        this
    }
    setHex(e, t=Lr) {
        return e = Math.floor(e),
        this.r = (e >> 16 & 255) / 255,
        this.g = (e >> 8 & 255) / 255,
        this.b = (e & 255) / 255,
        pn.toWorkingColorSpace(this, t),
        this
    }
    setRGB(e, t, n, s=pn.workingColorSpace) {
        return this.r = e,
        this.g = t,
        this.b = n,
        pn.toWorkingColorSpace(this, s),
        this
    }
    setHSL(e, t, n, s=pn.workingColorSpace) {
        if (e = jX(e, 1),
        t = is(t, 0, 1),
        n = is(n, 0, 1),
        t === 0)
            this.r = this.g = this.b = n;
        else {
            const r = n <= .5 ? n * (1 + t) : n + t - n * t
              , o = 2 * n - r;
            this.r = rg(o, r, e + 1 / 3),
            this.g = rg(o, r, e),
            this.b = rg(o, r, e - 1 / 3)
        }
        return pn.toWorkingColorSpace(this, s),
        this
    }
    setStyle(e, t=Lr) {
        function n(r) {
            r !== void 0 && parseFloat(r) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
        }
        let s;
        if (s = /^(\w+)\(([^\)]*)\)/.exec(e)) {
            let r;
            const o = s[1]
              , a = s[2];
            switch (o) {
            case "rgb":
            case "rgba":
                if (r = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                    return n(r[4]),
                    this.setRGB(Math.min(255, parseInt(r[1], 10)) / 255, Math.min(255, parseInt(r[2], 10)) / 255, Math.min(255, parseInt(r[3], 10)) / 255, t);
                if (r = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                    return n(r[4]),
                    this.setRGB(Math.min(100, parseInt(r[1], 10)) / 100, Math.min(100, parseInt(r[2], 10)) / 100, Math.min(100, parseInt(r[3], 10)) / 100, t);
                break;
            case "hsl":
            case "hsla":
                if (r = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                    return n(r[4]),
                    this.setHSL(parseFloat(r[1]) / 360, parseFloat(r[2]) / 100, parseFloat(r[3]) / 100, t);
                break;
            default:
                console.warn("THREE.Color: Unknown color model " + e)
            }
        } else if (s = /^\#([A-Fa-f\d]+)$/.exec(e)) {
            const r = s[1]
              , o = r.length;
            if (o === 3)
                return this.setRGB(parseInt(r.charAt(0), 16) / 15, parseInt(r.charAt(1), 16) / 15, parseInt(r.charAt(2), 16) / 15, t);
            if (o === 6)
                return this.setHex(parseInt(r, 16), t);
            console.warn("THREE.Color: Invalid hex color " + e)
        } else if (e && e.length > 0)
            return this.setColorName(e, t);
        return this
    }
    setColorName(e, t=Lr) {
        const n = h3[e.toLowerCase()];
        return n !== void 0 ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e),
        this
    }
    clone() {
        return new this.constructor(this.r,this.g,this.b)
    }
    copy(e) {
        return this.r = e.r,
        this.g = e.g,
        this.b = e.b,
        this
    }
    copySRGBToLinear(e) {
        return this.r = qc(e.r),
        this.g = qc(e.g),
        this.b = qc(e.b),
        this
    }
    copyLinearToSRGB(e) {
        return this.r = q0(e.r),
        this.g = q0(e.g),
        this.b = q0(e.b),
        this
    }
    convertSRGBToLinear() {
        return this.copySRGBToLinear(this),
        this
    }
    convertLinearToSRGB() {
        return this.copyLinearToSRGB(this),
        this
    }
    getHex(e=Lr) {
        return pn.fromWorkingColorSpace(Ci.copy(this), e),
        Math.round(is(Ci.r * 255, 0, 255)) * 65536 + Math.round(is(Ci.g * 255, 0, 255)) * 256 + Math.round(is(Ci.b * 255, 0, 255))
    }
    getHexString(e=Lr) {
        return ("000000" + this.getHex(e).toString(16)).slice(-6)
    }
    getHSL(e, t=pn.workingColorSpace) {
        pn.fromWorkingColorSpace(Ci.copy(this), t);
        const n = Ci.r
          , s = Ci.g
          , r = Ci.b
          , o = Math.max(n, s, r)
          , a = Math.min(n, s, r);
        let l, c;
        const u = (a + o) / 2;
        if (a === o)
            l = 0,
            c = 0;
        else {
            const d = o - a;
            switch (c = u <= .5 ? d / (o + a) : d / (2 - o - a),
            o) {
            case n:
                l = (s - r) / d + (s < r ? 6 : 0);
                break;
            case s:
                l = (r - n) / d + 2;
                break;
            case r:
                l = (n - s) / d + 4;
                break
            }
            l /= 6
        }
        return e.h = l,
        e.s = c,
        e.l = u,
        e
    }
    getRGB(e, t=pn.workingColorSpace) {
        return pn.fromWorkingColorSpace(Ci.copy(this), t),
        e.r = Ci.r,
        e.g = Ci.g,
        e.b = Ci.b,
        e
    }
    getStyle(e=Lr) {
        pn.fromWorkingColorSpace(Ci.copy(this), e);
        const t = Ci.r
          , n = Ci.g
          , s = Ci.b;
        return e !== Lr ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${s.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(n * 255)},${Math.round(s * 255)})`
    }
    offsetHSL(e, t, n) {
        return this.getHSL(Xo),
        this.setHSL(Xo.h + e, Xo.s + t, Xo.l + n)
    }
    add(e) {
        return this.r += e.r,
        this.g += e.g,
        this.b += e.b,
        this
    }
    addColors(e, t) {
        return this.r = e.r + t.r,
        this.g = e.g + t.g,
        this.b = e.b + t.b,
        this
    }
    addScalar(e) {
        return this.r += e,
        this.g += e,
        this.b += e,
        this
    }
    sub(e) {
        return this.r = Math.max(0, this.r - e.r),
        this.g = Math.max(0, this.g - e.g),
        this.b = Math.max(0, this.b - e.b),
        this
    }
    multiply(e) {
        return this.r *= e.r,
        this.g *= e.g,
        this.b *= e.b,
        this
    }
    multiplyScalar(e) {
        return this.r *= e,
        this.g *= e,
        this.b *= e,
        this
    }
    lerp(e, t) {
        return this.r += (e.r - this.r) * t,
        this.g += (e.g - this.g) * t,
        this.b += (e.b - this.b) * t,
        this
    }
    lerpColors(e, t, n) {
        return this.r = e.r + (t.r - e.r) * n,
        this.g = e.g + (t.g - e.g) * n,
        this.b = e.b + (t.b - e.b) * n,
        this
    }
    lerpHSL(e, t) {
        this.getHSL(Xo),
        e.getHSL(Jf);
        const n = G0(Xo.h, Jf.h, t)
          , s = G0(Xo.s, Jf.s, t)
          , r = G0(Xo.l, Jf.l, t);
        return this.setHSL(n, s, r),
        this
    }
    setFromVector3(e) {
        return this.r = e.x,
        this.g = e.y,
        this.b = e.z,
        this
    }
    applyMatrix3(e) {
        const t = this.r
          , n = this.g
          , s = this.b
          , r = e.elements;
        return this.r = r[0] * t + r[3] * n + r[6] * s,
        this.g = r[1] * t + r[4] * n + r[7] * s,
        this.b = r[2] * t + r[5] * n + r[8] * s,
        this
    }
    equals(e) {
        return e.r === this.r && e.g === this.g && e.b === this.b
    }
    fromArray(e, t=0) {
        return this.r = e[t],
        this.g = e[t + 1],
        this.b = e[t + 2],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.r,
        e[t + 1] = this.g,
        e[t + 2] = this.b,
        e
    }
    fromBufferAttribute(e, t) {
        return this.r = e.getX(t),
        this.g = e.getY(t),
        this.b = e.getZ(t),
        this
    }
    toJSON() {
        return this.getHex()
    }
    *[Symbol.iterator]() {
        yield this.r,
        yield this.g,
        yield this.b
    }
}
const Ci = new un;
un.NAMES = h3;
let uY = 0;
class uf extends Tu {
    constructor() {
        super(),
        this.isMaterial = !0,
        Object.defineProperty(this, "id", {
            value: uY++
        }),
        this.uuid = af(),
        this.name = "",
        this.type = "Material",
        this.blending = Gc,
        this.side = Ta,
        this.vertexColors = !1,
        this.opacity = 1,
        this.transparent = !1,
        this.alphaHash = !1,
        this.blendSrc = J1,
        this.blendDst = Q1,
        this.blendEquation = al,
        this.blendSrcAlpha = null,
        this.blendDstAlpha = null,
        this.blendEquationAlpha = null,
        this.blendColor = new un(0,0,0),
        this.blendAlpha = 0,
        this.depthFunc = Op,
        this.depthTest = !0,
        this.depthWrite = !0,
        this.stencilWriteMask = 255,
        this.stencilFunc = HS,
        this.stencilRef = 0,
        this.stencilFuncMask = 255,
        this.stencilFail = Ql,
        this.stencilZFail = Ql,
        this.stencilZPass = Ql,
        this.stencilWrite = !1,
        this.clippingPlanes = null,
        this.clipIntersection = !1,
        this.clipShadows = !1,
        this.shadowSide = null,
        this.colorWrite = !0,
        this.precision = null,
        this.polygonOffset = !1,
        this.polygonOffsetFactor = 0,
        this.polygonOffsetUnits = 0,
        this.dithering = !1,
        this.alphaToCoverage = !1,
        this.premultipliedAlpha = !1,
        this.forceSinglePass = !1,
        this.visible = !0,
        this.toneMapped = !0,
        this.userData = {},
        this.version = 0,
        this._alphaTest = 0
    }
    get alphaTest() {
        return this._alphaTest
    }
    set alphaTest(e) {
        this._alphaTest > 0 != e > 0 && this.version++,
        this._alphaTest = e
    }
    onBeforeRender() {}
    onBeforeCompile() {}
    customProgramCacheKey() {
        return this.onBeforeCompile.toString()
    }
    setValues(e) {
        if (e !== void 0)
            for (const t in e) {
                const n = e[t];
                if (n === void 0) {
                    console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
                    continue
                }
                const s = this[t];
                if (s === void 0) {
                    console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
                    continue
                }
                s && s.isColor ? s.set(n) : s && s.isVector3 && n && n.isVector3 ? s.copy(n) : this[t] = n
            }
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        t && (e = {
            textures: {},
            images: {}
        });
        const n = {
            metadata: {
                version: 4.6,
                type: "Material",
                generator: "Material.toJSON"
            }
        };
        n.uuid = this.uuid,
        n.type = this.type,
        this.name !== "" && (n.name = this.name),
        this.color && this.color.isColor && (n.color = this.color.getHex()),
        this.roughness !== void 0 && (n.roughness = this.roughness),
        this.metalness !== void 0 && (n.metalness = this.metalness),
        this.sheen !== void 0 && (n.sheen = this.sheen),
        this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()),
        this.sheenRoughness !== void 0 && (n.sheenRoughness = this.sheenRoughness),
        this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()),
        this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity),
        this.specular && this.specular.isColor && (n.specular = this.specular.getHex()),
        this.specularIntensity !== void 0 && (n.specularIntensity = this.specularIntensity),
        this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()),
        this.shininess !== void 0 && (n.shininess = this.shininess),
        this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat),
        this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness),
        this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
        this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
        this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid,
        n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
        this.dispersion !== void 0 && (n.dispersion = this.dispersion),
        this.iridescence !== void 0 && (n.iridescence = this.iridescence),
        this.iridescenceIOR !== void 0 && (n.iridescenceIOR = this.iridescenceIOR),
        this.iridescenceThicknessRange !== void 0 && (n.iridescenceThicknessRange = this.iridescenceThicknessRange),
        this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
        this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid),
        this.anisotropy !== void 0 && (n.anisotropy = this.anisotropy),
        this.anisotropyRotation !== void 0 && (n.anisotropyRotation = this.anisotropyRotation),
        this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
        this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid),
        this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid),
        this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid),
        this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid,
        n.lightMapIntensity = this.lightMapIntensity),
        this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid,
        n.aoMapIntensity = this.aoMapIntensity),
        this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid,
        n.bumpScale = this.bumpScale),
        this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid,
        n.normalMapType = this.normalMapType,
        n.normalScale = this.normalScale.toArray()),
        this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid,
        n.displacementScale = this.displacementScale,
        n.displacementBias = this.displacementBias),
        this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid),
        this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid),
        this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid),
        this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid),
        this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
        this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid),
        this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid,
        this.combine !== void 0 && (n.combine = this.combine)),
        this.envMapRotation !== void 0 && (n.envMapRotation = this.envMapRotation.toArray()),
        this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity),
        this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity),
        this.refractionRatio !== void 0 && (n.refractionRatio = this.refractionRatio),
        this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid),
        this.transmission !== void 0 && (n.transmission = this.transmission),
        this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid),
        this.thickness !== void 0 && (n.thickness = this.thickness),
        this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid),
        this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance),
        this.attenuationColor !== void 0 && (n.attenuationColor = this.attenuationColor.getHex()),
        this.size !== void 0 && (n.size = this.size),
        this.shadowSide !== null && (n.shadowSide = this.shadowSide),
        this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation),
        this.blending !== Gc && (n.blending = this.blending),
        this.side !== Ta && (n.side = this.side),
        this.vertexColors === !0 && (n.vertexColors = !0),
        this.opacity < 1 && (n.opacity = this.opacity),
        this.transparent === !0 && (n.transparent = !0),
        this.blendSrc !== J1 && (n.blendSrc = this.blendSrc),
        this.blendDst !== Q1 && (n.blendDst = this.blendDst),
        this.blendEquation !== al && (n.blendEquation = this.blendEquation),
        this.blendSrcAlpha !== null && (n.blendSrcAlpha = this.blendSrcAlpha),
        this.blendDstAlpha !== null && (n.blendDstAlpha = this.blendDstAlpha),
        this.blendEquationAlpha !== null && (n.blendEquationAlpha = this.blendEquationAlpha),
        this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()),
        this.blendAlpha !== 0 && (n.blendAlpha = this.blendAlpha),
        this.depthFunc !== Op && (n.depthFunc = this.depthFunc),
        this.depthTest === !1 && (n.depthTest = this.depthTest),
        this.depthWrite === !1 && (n.depthWrite = this.depthWrite),
        this.colorWrite === !1 && (n.colorWrite = this.colorWrite),
        this.stencilWriteMask !== 255 && (n.stencilWriteMask = this.stencilWriteMask),
        this.stencilFunc !== HS && (n.stencilFunc = this.stencilFunc),
        this.stencilRef !== 0 && (n.stencilRef = this.stencilRef),
        this.stencilFuncMask !== 255 && (n.stencilFuncMask = this.stencilFuncMask),
        this.stencilFail !== Ql && (n.stencilFail = this.stencilFail),
        this.stencilZFail !== Ql && (n.stencilZFail = this.stencilZFail),
        this.stencilZPass !== Ql && (n.stencilZPass = this.stencilZPass),
        this.stencilWrite === !0 && (n.stencilWrite = this.stencilWrite),
        this.rotation !== void 0 && this.rotation !== 0 && (n.rotation = this.rotation),
        this.polygonOffset === !0 && (n.polygonOffset = !0),
        this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor),
        this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits),
        this.linewidth !== void 0 && this.linewidth !== 1 && (n.linewidth = this.linewidth),
        this.dashSize !== void 0 && (n.dashSize = this.dashSize),
        this.gapSize !== void 0 && (n.gapSize = this.gapSize),
        this.scale !== void 0 && (n.scale = this.scale),
        this.dithering === !0 && (n.dithering = !0),
        this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
        this.alphaHash === !0 && (n.alphaHash = !0),
        this.alphaToCoverage === !0 && (n.alphaToCoverage = !0),
        this.premultipliedAlpha === !0 && (n.premultipliedAlpha = !0),
        this.forceSinglePass === !0 && (n.forceSinglePass = !0),
        this.wireframe === !0 && (n.wireframe = !0),
        this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth),
        this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap),
        this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin),
        this.flatShading === !0 && (n.flatShading = !0),
        this.visible === !1 && (n.visible = !1),
        this.toneMapped === !1 && (n.toneMapped = !1),
        this.fog === !1 && (n.fog = !1),
        Object.keys(this.userData).length > 0 && (n.userData = this.userData);
        function s(r) {
            const o = [];
            for (const a in r) {
                const l = r[a];
                delete l.metadata,
                o.push(l)
            }
            return o
        }
        if (t) {
            const r = s(e.textures)
              , o = s(e.images);
            r.length > 0 && (n.textures = r),
            o.length > 0 && (n.images = o)
        }
        return n
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.name = e.name,
        this.blending = e.blending,
        this.side = e.side,
        this.vertexColors = e.vertexColors,
        this.opacity = e.opacity,
        this.transparent = e.transparent,
        this.blendSrc = e.blendSrc,
        this.blendDst = e.blendDst,
        this.blendEquation = e.blendEquation,
        this.blendSrcAlpha = e.blendSrcAlpha,
        this.blendDstAlpha = e.blendDstAlpha,
        this.blendEquationAlpha = e.blendEquationAlpha,
        this.blendColor.copy(e.blendColor),
        this.blendAlpha = e.blendAlpha,
        this.depthFunc = e.depthFunc,
        this.depthTest = e.depthTest,
        this.depthWrite = e.depthWrite,
        this.stencilWriteMask = e.stencilWriteMask,
        this.stencilFunc = e.stencilFunc,
        this.stencilRef = e.stencilRef,
        this.stencilFuncMask = e.stencilFuncMask,
        this.stencilFail = e.stencilFail,
        this.stencilZFail = e.stencilZFail,
        this.stencilZPass = e.stencilZPass,
        this.stencilWrite = e.stencilWrite;
        const t = e.clippingPlanes;
        let n = null;
        if (t !== null) {
            const s = t.length;
            n = new Array(s);
            for (let r = 0; r !== s; ++r)
                n[r] = t[r].clone()
        }
        return this.clippingPlanes = n,
        this.clipIntersection = e.clipIntersection,
        this.clipShadows = e.clipShadows,
        this.shadowSide = e.shadowSide,
        this.colorWrite = e.colorWrite,
        this.precision = e.precision,
        this.polygonOffset = e.polygonOffset,
        this.polygonOffsetFactor = e.polygonOffsetFactor,
        this.polygonOffsetUnits = e.polygonOffsetUnits,
        this.dithering = e.dithering,
        this.alphaTest = e.alphaTest,
        this.alphaHash = e.alphaHash,
        this.alphaToCoverage = e.alphaToCoverage,
        this.premultipliedAlpha = e.premultipliedAlpha,
        this.forceSinglePass = e.forceSinglePass,
        this.visible = e.visible,
        this.toneMapped = e.toneMapped,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    onBuild() {
        console.warn("Material: onBuild() has been removed.")
    }
}
class p3 extends uf {
    constructor(e) {
        super(),
        this.isMeshBasicMaterial = !0,
        this.type = "MeshBasicMaterial",
        this.color = new un(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapRotation = new Xr,
        this.combine = XM,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.envMapRotation.copy(e.envMapRotation),
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.fog = e.fog,
        this
    }
}
const Kn = new Te
  , Qf = new nn;
class zr {
    constructor(e, t, n=!1) {
        if (Array.isArray(e))
            throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.isBufferAttribute = !0,
        this.name = "",
        this.array = e,
        this.itemSize = t,
        this.count = e !== void 0 ? e.length / t : 0,
        this.normalized = n,
        this.usage = zS,
        this._updateRange = {
            offset: 0,
            count: -1
        },
        this.updateRanges = [],
        this.gpuType = Ro,
        this.version = 0
    }
    onUploadCallback() {}
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    get updateRange() {
        return hd("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."),
        this._updateRange
    }
    setUsage(e) {
        return this.usage = e,
        this
    }
    addUpdateRange(e, t) {
        this.updateRanges.push({
            start: e,
            count: t
        })
    }
    clearUpdateRanges() {
        this.updateRanges.length = 0
    }
    copy(e) {
        return this.name = e.name,
        this.array = new e.array.constructor(e.array),
        this.itemSize = e.itemSize,
        this.count = e.count,
        this.normalized = e.normalized,
        this.usage = e.usage,
        this.gpuType = e.gpuType,
        this
    }
    copyAt(e, t, n) {
        e *= this.itemSize,
        n *= t.itemSize;
        for (let s = 0, r = this.itemSize; s < r; s++)
            this.array[e + s] = t.array[n + s];
        return this
    }
    copyArray(e) {
        return this.array.set(e),
        this
    }
    applyMatrix3(e) {
        if (this.itemSize === 2)
            for (let t = 0, n = this.count; t < n; t++)
                Qf.fromBufferAttribute(this, t),
                Qf.applyMatrix3(e),
                this.setXY(t, Qf.x, Qf.y);
        else if (this.itemSize === 3)
            for (let t = 0, n = this.count; t < n; t++)
                Kn.fromBufferAttribute(this, t),
                Kn.applyMatrix3(e),
                this.setXYZ(t, Kn.x, Kn.y, Kn.z);
        return this
    }
    applyMatrix4(e) {
        for (let t = 0, n = this.count; t < n; t++)
            Kn.fromBufferAttribute(this, t),
            Kn.applyMatrix4(e),
            this.setXYZ(t, Kn.x, Kn.y, Kn.z);
        return this
    }
    applyNormalMatrix(e) {
        for (let t = 0, n = this.count; t < n; t++)
            Kn.fromBufferAttribute(this, t),
            Kn.applyNormalMatrix(e),
            this.setXYZ(t, Kn.x, Kn.y, Kn.z);
        return this
    }
    transformDirection(e) {
        for (let t = 0, n = this.count; t < n; t++)
            Kn.fromBufferAttribute(this, t),
            Kn.transformDirection(e),
            this.setXYZ(t, Kn.x, Kn.y, Kn.z);
        return this
    }
    set(e, t=0) {
        return this.array.set(e, t),
        this
    }
    getComponent(e, t) {
        let n = this.array[e * this.itemSize + t];
        return this.normalized && (n = Ou(n, this.array)),
        n
    }
    setComponent(e, t, n) {
        return this.normalized && (n = Zi(n, this.array)),
        this.array[e * this.itemSize + t] = n,
        this
    }
    getX(e) {
        let t = this.array[e * this.itemSize];
        return this.normalized && (t = Ou(t, this.array)),
        t
    }
    setX(e, t) {
        return this.normalized && (t = Zi(t, this.array)),
        this.array[e * this.itemSize] = t,
        this
    }
    getY(e) {
        let t = this.array[e * this.itemSize + 1];
        return this.normalized && (t = Ou(t, this.array)),
        t
    }
    setY(e, t) {
        return this.normalized && (t = Zi(t, this.array)),
        this.array[e * this.itemSize + 1] = t,
        this
    }
    getZ(e) {
        let t = this.array[e * this.itemSize + 2];
        return this.normalized && (t = Ou(t, this.array)),
        t
    }
    setZ(e, t) {
        return this.normalized && (t = Zi(t, this.array)),
        this.array[e * this.itemSize + 2] = t,
        this
    }
    getW(e) {
        let t = this.array[e * this.itemSize + 3];
        return this.normalized && (t = Ou(t, this.array)),
        t
    }
    setW(e, t) {
        return this.normalized && (t = Zi(t, this.array)),
        this.array[e * this.itemSize + 3] = t,
        this
    }
    setXY(e, t, n) {
        return e *= this.itemSize,
        this.normalized && (t = Zi(t, this.array),
        n = Zi(n, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = n,
        this
    }
    setXYZ(e, t, n, s) {
        return e *= this.itemSize,
        this.normalized && (t = Zi(t, this.array),
        n = Zi(n, this.array),
        s = Zi(s, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = n,
        this.array[e + 2] = s,
        this
    }
    setXYZW(e, t, n, s, r) {
        return e *= this.itemSize,
        this.normalized && (t = Zi(t, this.array),
        n = Zi(n, this.array),
        s = Zi(s, this.array),
        r = Zi(r, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = n,
        this.array[e + 2] = s,
        this.array[e + 3] = r,
        this
    }
    onUpload(e) {
        return this.onUploadCallback = e,
        this
    }
    clone() {
        return new this.constructor(this.array,this.itemSize).copy(this)
    }
    toJSON() {
        const e = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.from(this.array),
            normalized: this.normalized
        };
        return this.name !== "" && (e.name = this.name),
        this.usage !== zS && (e.usage = this.usage),
        e
    }
}
class m3 extends zr {
    constructor(e, t, n) {
        super(new Uint16Array(e), t, n)
    }
}
class g3 extends zr {
    constructor(e, t, n) {
        super(new Uint32Array(e), t, n)
    }
}
class Gr extends zr {
    constructor(e, t, n) {
        super(new Float32Array(e), t, n)
    }
}
let dY = 0;
const ks = new qn
  , og = new Fi
  , cc = new Te
  , ms = new cf
  , $u = new cf
  , hi = new Te;
class Pa extends Tu {
    constructor() {
        super(),
        this.isBufferGeometry = !0,
        Object.defineProperty(this, "id", {
            value: dY++
        }),
        this.uuid = af(),
        this.name = "",
        this.type = "BufferGeometry",
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.morphTargetsRelative = !1,
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null,
        this.drawRange = {
            start: 0,
            count: 1 / 0
        },
        this.userData = {}
    }
    getIndex() {
        return this.index
    }
    setIndex(e) {
        return Array.isArray(e) ? this.index = new (c3(e) ? g3 : m3)(e,1) : this.index = e,
        this
    }
    getAttribute(e) {
        return this.attributes[e]
    }
    setAttribute(e, t) {
        return this.attributes[e] = t,
        this
    }
    deleteAttribute(e) {
        return delete this.attributes[e],
        this
    }
    hasAttribute(e) {
        return this.attributes[e] !== void 0
    }
    addGroup(e, t, n=0) {
        this.groups.push({
            start: e,
            count: t,
            materialIndex: n
        })
    }
    clearGroups() {
        this.groups = []
    }
    setDrawRange(e, t) {
        this.drawRange.start = e,
        this.drawRange.count = t
    }
    applyMatrix4(e) {
        const t = this.attributes.position;
        t !== void 0 && (t.applyMatrix4(e),
        t.needsUpdate = !0);
        const n = this.attributes.normal;
        if (n !== void 0) {
            const r = new Kt().getNormalMatrix(e);
            n.applyNormalMatrix(r),
            n.needsUpdate = !0
        }
        const s = this.attributes.tangent;
        return s !== void 0 && (s.transformDirection(e),
        s.needsUpdate = !0),
        this.boundingBox !== null && this.computeBoundingBox(),
        this.boundingSphere !== null && this.computeBoundingSphere(),
        this
    }
    applyQuaternion(e) {
        return ks.makeRotationFromQuaternion(e),
        this.applyMatrix4(ks),
        this
    }
    rotateX(e) {
        return ks.makeRotationX(e),
        this.applyMatrix4(ks),
        this
    }
    rotateY(e) {
        return ks.makeRotationY(e),
        this.applyMatrix4(ks),
        this
    }
    rotateZ(e) {
        return ks.makeRotationZ(e),
        this.applyMatrix4(ks),
        this
    }
    translate(e, t, n) {
        return ks.makeTranslation(e, t, n),
        this.applyMatrix4(ks),
        this
    }
    scale(e, t, n) {
        return ks.makeScale(e, t, n),
        this.applyMatrix4(ks),
        this
    }
    lookAt(e) {
        return og.lookAt(e),
        og.updateMatrix(),
        this.applyMatrix4(og.matrix),
        this
    }
    center() {
        return this.computeBoundingBox(),
        this.boundingBox.getCenter(cc).negate(),
        this.translate(cc.x, cc.y, cc.z),
        this
    }
    setFromPoints(e) {
        const t = [];
        for (let n = 0, s = e.length; n < s; n++) {
            const r = e[n];
            t.push(r.x, r.y, r.z || 0)
        }
        return this.setAttribute("position", new Gr(t,3)),
        this
    }
    computeBoundingBox() {
        this.boundingBox === null && (this.boundingBox = new cf);
        const e = this.attributes.position
          , t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this),
            this.boundingBox.set(new Te(-1 / 0,-1 / 0,-1 / 0), new Te(1 / 0,1 / 0,1 / 0));
            return
        }
        if (e !== void 0) {
            if (this.boundingBox.setFromBufferAttribute(e),
            t)
                for (let n = 0, s = t.length; n < s; n++) {
                    const r = t[n];
                    ms.setFromBufferAttribute(r),
                    this.morphTargetsRelative ? (hi.addVectors(this.boundingBox.min, ms.min),
                    this.boundingBox.expandByPoint(hi),
                    hi.addVectors(this.boundingBox.max, ms.max),
                    this.boundingBox.expandByPoint(hi)) : (this.boundingBox.expandByPoint(ms.min),
                    this.boundingBox.expandByPoint(ms.max))
                }
        } else
            this.boundingBox.makeEmpty();
        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
    }
    computeBoundingSphere() {
        this.boundingSphere === null && (this.boundingSphere = new wx);
        const e = this.attributes.position
          , t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this),
            this.boundingSphere.set(new Te, 1 / 0);
            return
        }
        if (e) {
            const n = this.boundingSphere.center;
            if (ms.setFromBufferAttribute(e),
            t)
                for (let r = 0, o = t.length; r < o; r++) {
                    const a = t[r];
                    $u.setFromBufferAttribute(a),
                    this.morphTargetsRelative ? (hi.addVectors(ms.min, $u.min),
                    ms.expandByPoint(hi),
                    hi.addVectors(ms.max, $u.max),
                    ms.expandByPoint(hi)) : (ms.expandByPoint($u.min),
                    ms.expandByPoint($u.max))
                }
            ms.getCenter(n);
            let s = 0;
            for (let r = 0, o = e.count; r < o; r++)
                hi.fromBufferAttribute(e, r),
                s = Math.max(s, n.distanceToSquared(hi));
            if (t)
                for (let r = 0, o = t.length; r < o; r++) {
                    const a = t[r]
                      , l = this.morphTargetsRelative;
                    for (let c = 0, u = a.count; c < u; c++)
                        hi.fromBufferAttribute(a, c),
                        l && (cc.fromBufferAttribute(e, c),
                        hi.add(cc)),
                        s = Math.max(s, n.distanceToSquared(hi))
                }
            this.boundingSphere.radius = Math.sqrt(s),
            isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
        }
    }
    computeTangents() {
        const e = this.index
          , t = this.attributes;
        if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
            console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            return
        }
        const n = t.position
          , s = t.normal
          , r = t.uv;
        this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new zr(new Float32Array(4 * n.count),4));
        const o = this.getAttribute("tangent")
          , a = []
          , l = [];
        for (let L = 0; L < n.count; L++)
            a[L] = new Te,
            l[L] = new Te;
        const c = new Te
          , u = new Te
          , d = new Te
          , f = new nn
          , h = new nn
          , p = new nn
          , g = new Te
          , m = new Te;
        function v(L, T, A) {
            c.fromBufferAttribute(n, L),
            u.fromBufferAttribute(n, T),
            d.fromBufferAttribute(n, A),
            f.fromBufferAttribute(r, L),
            h.fromBufferAttribute(r, T),
            p.fromBufferAttribute(r, A),
            u.sub(c),
            d.sub(c),
            h.sub(f),
            p.sub(f);
            const k = 1 / (h.x * p.y - p.x * h.y);
            !isFinite(k) || (g.copy(u).multiplyScalar(p.y).addScaledVector(d, -h.y).multiplyScalar(k),
            m.copy(d).multiplyScalar(h.x).addScaledVector(u, -p.x).multiplyScalar(k),
            a[L].add(g),
            a[T].add(g),
            a[A].add(g),
            l[L].add(m),
            l[T].add(m),
            l[A].add(m))
        }
        let _ = this.groups;
        _.length === 0 && (_ = [{
            start: 0,
            count: e.count
        }]);
        for (let L = 0, T = _.length; L < T; ++L) {
            const A = _[L]
              , k = A.start
              , D = A.count;
            for (let F = k, z = k + D; F < z; F += 3)
                v(e.getX(F + 0), e.getX(F + 1), e.getX(F + 2))
        }
        const y = new Te
          , b = new Te
          , S = new Te
          , C = new Te;
        function M(L) {
            S.fromBufferAttribute(s, L),
            C.copy(S);
            const T = a[L];
            y.copy(T),
            y.sub(S.multiplyScalar(S.dot(T))).normalize(),
            b.crossVectors(C, T);
            const k = b.dot(l[L]) < 0 ? -1 : 1;
            o.setXYZW(L, y.x, y.y, y.z, k)
        }
        for (let L = 0, T = _.length; L < T; ++L) {
            const A = _[L]
              , k = A.start
              , D = A.count;
            for (let F = k, z = k + D; F < z; F += 3)
                M(e.getX(F + 0)),
                M(e.getX(F + 1)),
                M(e.getX(F + 2))
        }
    }
    computeVertexNormals() {
        const e = this.index
          , t = this.getAttribute("position");
        if (t !== void 0) {
            let n = this.getAttribute("normal");
            if (n === void 0)
                n = new zr(new Float32Array(t.count * 3),3),
                this.setAttribute("normal", n);
            else
                for (let f = 0, h = n.count; f < h; f++)
                    n.setXYZ(f, 0, 0, 0);
            const s = new Te
              , r = new Te
              , o = new Te
              , a = new Te
              , l = new Te
              , c = new Te
              , u = new Te
              , d = new Te;
            if (e)
                for (let f = 0, h = e.count; f < h; f += 3) {
                    const p = e.getX(f + 0)
                      , g = e.getX(f + 1)
                      , m = e.getX(f + 2);
                    s.fromBufferAttribute(t, p),
                    r.fromBufferAttribute(t, g),
                    o.fromBufferAttribute(t, m),
                    u.subVectors(o, r),
                    d.subVectors(s, r),
                    u.cross(d),
                    a.fromBufferAttribute(n, p),
                    l.fromBufferAttribute(n, g),
                    c.fromBufferAttribute(n, m),
                    a.add(u),
                    l.add(u),
                    c.add(u),
                    n.setXYZ(p, a.x, a.y, a.z),
                    n.setXYZ(g, l.x, l.y, l.z),
                    n.setXYZ(m, c.x, c.y, c.z)
                }
            else
                for (let f = 0, h = t.count; f < h; f += 3)
                    s.fromBufferAttribute(t, f + 0),
                    r.fromBufferAttribute(t, f + 1),
                    o.fromBufferAttribute(t, f + 2),
                    u.subVectors(o, r),
                    d.subVectors(s, r),
                    u.cross(d),
                    n.setXYZ(f + 0, u.x, u.y, u.z),
                    n.setXYZ(f + 1, u.x, u.y, u.z),
                    n.setXYZ(f + 2, u.x, u.y, u.z);
            this.normalizeNormals(),
            n.needsUpdate = !0
        }
    }
    normalizeNormals() {
        const e = this.attributes.normal;
        for (let t = 0, n = e.count; t < n; t++)
            hi.fromBufferAttribute(e, t),
            hi.normalize(),
            e.setXYZ(t, hi.x, hi.y, hi.z)
    }
    toNonIndexed() {
        function e(a, l) {
            const c = a.array
              , u = a.itemSize
              , d = a.normalized
              , f = new c.constructor(l.length * u);
            let h = 0
              , p = 0;
            for (let g = 0, m = l.length; g < m; g++) {
                a.isInterleavedBufferAttribute ? h = l[g] * a.data.stride + a.offset : h = l[g] * u;
                for (let v = 0; v < u; v++)
                    f[p++] = c[h++]
            }
            return new zr(f,u,d)
        }
        if (this.index === null)
            return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),
            this;
        const t = new Pa
          , n = this.index.array
          , s = this.attributes;
        for (const a in s) {
            const l = s[a]
              , c = e(l, n);
            t.setAttribute(a, c)
        }
        const r = this.morphAttributes;
        for (const a in r) {
            const l = []
              , c = r[a];
            for (let u = 0, d = c.length; u < d; u++) {
                const f = c[u]
                  , h = e(f, n);
                l.push(h)
            }
            t.morphAttributes[a] = l
        }
        t.morphTargetsRelative = this.morphTargetsRelative;
        const o = this.groups;
        for (let a = 0, l = o.length; a < l; a++) {
            const c = o[a];
            t.addGroup(c.start, c.count, c.materialIndex)
        }
        return t
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.6,
                type: "BufferGeometry",
                generator: "BufferGeometry.toJSON"
            }
        };
        if (e.uuid = this.uuid,
        e.type = this.type,
        this.name !== "" && (e.name = this.name),
        Object.keys(this.userData).length > 0 && (e.userData = this.userData),
        this.parameters !== void 0) {
            const l = this.parameters;
            for (const c in l)
                l[c] !== void 0 && (e[c] = l[c]);
            return e
        }
        e.data = {
            attributes: {}
        };
        const t = this.index;
        t !== null && (e.data.index = {
            type: t.array.constructor.name,
            array: Array.prototype.slice.call(t.array)
        });
        const n = this.attributes;
        for (const l in n) {
            const c = n[l];
            e.data.attributes[l] = c.toJSON(e.data)
        }
        const s = {};
        let r = !1;
        for (const l in this.morphAttributes) {
            const c = this.morphAttributes[l]
              , u = [];
            for (let d = 0, f = c.length; d < f; d++) {
                const h = c[d];
                u.push(h.toJSON(e.data))
            }
            u.length > 0 && (s[l] = u,
            r = !0)
        }
        r && (e.data.morphAttributes = s,
        e.data.morphTargetsRelative = this.morphTargetsRelative);
        const o = this.groups;
        o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
        const a = this.boundingSphere;
        return a !== null && (e.data.boundingSphere = {
            center: a.center.toArray(),
            radius: a.radius
        }),
        e
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null;
        const t = {};
        this.name = e.name;
        const n = e.index;
        n !== null && this.setIndex(n.clone(t));
        const s = e.attributes;
        for (const c in s) {
            const u = s[c];
            this.setAttribute(c, u.clone(t))
        }
        const r = e.morphAttributes;
        for (const c in r) {
            const u = []
              , d = r[c];
            for (let f = 0, h = d.length; f < h; f++)
                u.push(d[f].clone(t));
            this.morphAttributes[c] = u
        }
        this.morphTargetsRelative = e.morphTargetsRelative;
        const o = e.groups;
        for (let c = 0, u = o.length; c < u; c++) {
            const d = o[c];
            this.addGroup(d.start, d.count, d.materialIndex)
        }
        const a = e.boundingBox;
        a !== null && (this.boundingBox = a.clone());
        const l = e.boundingSphere;
        return l !== null && (this.boundingSphere = l.clone()),
        this.drawRange.start = e.drawRange.start,
        this.drawRange.count = e.drawRange.count,
        this.userData = e.userData,
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
const iE = new qn
  , ja = new iY
  , eh = new wx
  , sE = new Te
  , uc = new Te
  , dc = new Te
  , fc = new Te
  , ag = new Te
  , th = new Te
  , nh = new nn
  , ih = new nn
  , sh = new nn
  , rE = new Te
  , oE = new Te
  , aE = new Te
  , rh = new Te
  , oh = new Te;
class Br extends Fi {
    constructor(e=new Pa, t=new p3) {
        super(),
        this.isMesh = !0,
        this.type = "Mesh",
        this.geometry = e,
        this.material = t,
        this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t),
        e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
        e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)),
        this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
        this.geometry = e.geometry,
        this
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes
          , n = Object.keys(t);
        if (n.length > 0) {
            const s = t[n[0]];
            if (s !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let r = 0, o = s.length; r < o; r++) {
                    const a = s[r].name || String(r);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[a] = r
                }
            }
        }
    }
    getVertexPosition(e, t) {
        const n = this.geometry
          , s = n.attributes.position
          , r = n.morphAttributes.position
          , o = n.morphTargetsRelative;
        t.fromBufferAttribute(s, e);
        const a = this.morphTargetInfluences;
        if (r && a) {
            th.set(0, 0, 0);
            for (let l = 0, c = r.length; l < c; l++) {
                const u = a[l]
                  , d = r[l];
                u !== 0 && (ag.fromBufferAttribute(d, e),
                o ? th.addScaledVector(ag, u) : th.addScaledVector(ag.sub(t), u))
            }
            t.add(th)
        }
        return t
    }
    raycast(e, t) {
        const n = this.geometry
          , s = this.material
          , r = this.matrixWorld;
        s !== void 0 && (n.boundingSphere === null && n.computeBoundingSphere(),
        eh.copy(n.boundingSphere),
        eh.applyMatrix4(r),
        ja.copy(e.ray).recast(e.near),
        !(eh.containsPoint(ja.origin) === !1 && (ja.intersectSphere(eh, sE) === null || ja.origin.distanceToSquared(sE) > (e.far - e.near) ** 2)) && (iE.copy(r).invert(),
        ja.copy(e.ray).applyMatrix4(iE),
        !(n.boundingBox !== null && ja.intersectsBox(n.boundingBox) === !1) && this._computeIntersections(e, t, ja)))
    }
    _computeIntersections(e, t, n) {
        let s;
        const r = this.geometry
          , o = this.material
          , a = r.index
          , l = r.attributes.position
          , c = r.attributes.uv
          , u = r.attributes.uv1
          , d = r.attributes.normal
          , f = r.groups
          , h = r.drawRange;
        if (a !== null)
            if (Array.isArray(o))
                for (let p = 0, g = f.length; p < g; p++) {
                    const m = f[p]
                      , v = o[m.materialIndex]
                      , _ = Math.max(m.start, h.start)
                      , y = Math.min(a.count, Math.min(m.start + m.count, h.start + h.count));
                    for (let b = _, S = y; b < S; b += 3) {
                        const C = a.getX(b)
                          , M = a.getX(b + 1)
                          , L = a.getX(b + 2);
                        s = ah(this, v, e, n, c, u, d, C, M, L),
                        s && (s.faceIndex = Math.floor(b / 3),
                        s.face.materialIndex = m.materialIndex,
                        t.push(s))
                    }
                }
            else {
                const p = Math.max(0, h.start)
                  , g = Math.min(a.count, h.start + h.count);
                for (let m = p, v = g; m < v; m += 3) {
                    const _ = a.getX(m)
                      , y = a.getX(m + 1)
                      , b = a.getX(m + 2);
                    s = ah(this, o, e, n, c, u, d, _, y, b),
                    s && (s.faceIndex = Math.floor(m / 3),
                    t.push(s))
                }
            }
        else if (l !== void 0)
            if (Array.isArray(o))
                for (let p = 0, g = f.length; p < g; p++) {
                    const m = f[p]
                      , v = o[m.materialIndex]
                      , _ = Math.max(m.start, h.start)
                      , y = Math.min(l.count, Math.min(m.start + m.count, h.start + h.count));
                    for (let b = _, S = y; b < S; b += 3) {
                        const C = b
                          , M = b + 1
                          , L = b + 2;
                        s = ah(this, v, e, n, c, u, d, C, M, L),
                        s && (s.faceIndex = Math.floor(b / 3),
                        s.face.materialIndex = m.materialIndex,
                        t.push(s))
                    }
                }
            else {
                const p = Math.max(0, h.start)
                  , g = Math.min(l.count, h.start + h.count);
                for (let m = p, v = g; m < v; m += 3) {
                    const _ = m
                      , y = m + 1
                      , b = m + 2;
                    s = ah(this, o, e, n, c, u, d, _, y, b),
                    s && (s.faceIndex = Math.floor(m / 3),
                    t.push(s))
                }
            }
    }
}
function fY(i, e, t, n, s, r, o, a) {
    let l;
    if (e.side === os ? l = n.intersectTriangle(o, r, s, !0, a) : l = n.intersectTriangle(s, r, o, e.side === Ta, a),
    l === null)
        return null;
    oh.copy(a),
    oh.applyMatrix4(i.matrixWorld);
    const c = t.ray.origin.distanceTo(oh);
    return c < t.near || c > t.far ? null : {
        distance: c,
        point: oh.clone(),
        object: i
    }
}
function ah(i, e, t, n, s, r, o, a, l, c) {
    i.getVertexPosition(a, uc),
    i.getVertexPosition(l, dc),
    i.getVertexPosition(c, fc);
    const u = fY(i, e, t, n, uc, dc, fc, rh);
    if (u) {
        s && (nh.fromBufferAttribute(s, a),
        ih.fromBufferAttribute(s, l),
        sh.fromBufferAttribute(s, c),
        u.uv = Dr.getInterpolation(rh, uc, dc, fc, nh, ih, sh, new nn)),
        r && (nh.fromBufferAttribute(r, a),
        ih.fromBufferAttribute(r, l),
        sh.fromBufferAttribute(r, c),
        u.uv1 = Dr.getInterpolation(rh, uc, dc, fc, nh, ih, sh, new nn)),
        o && (rE.fromBufferAttribute(o, a),
        oE.fromBufferAttribute(o, l),
        aE.fromBufferAttribute(o, c),
        u.normal = Dr.getInterpolation(rh, uc, dc, fc, rE, oE, aE, new Te),
        u.normal.dot(n.direction) > 0 && u.normal.multiplyScalar(-1));
        const d = {
            a,
            b: l,
            c,
            normal: new Te,
            materialIndex: 0
        };
        Dr.getNormal(uc, dc, fc, d.normal),
        u.face = d
    }
    return u
}
class df extends Pa {
    constructor(e=1, t=1, n=1, s=1, r=1, o=1) {
        super(),
        this.type = "BoxGeometry",
        this.parameters = {
            width: e,
            height: t,
            depth: n,
            widthSegments: s,
            heightSegments: r,
            depthSegments: o
        };
        const a = this;
        s = Math.floor(s),
        r = Math.floor(r),
        o = Math.floor(o);
        const l = []
          , c = []
          , u = []
          , d = [];
        let f = 0
          , h = 0;
        p("z", "y", "x", -1, -1, n, t, e, o, r, 0),
        p("z", "y", "x", 1, -1, n, t, -e, o, r, 1),
        p("x", "z", "y", 1, 1, e, n, t, s, o, 2),
        p("x", "z", "y", 1, -1, e, n, -t, s, o, 3),
        p("x", "y", "z", 1, -1, e, t, n, s, r, 4),
        p("x", "y", "z", -1, -1, e, t, -n, s, r, 5),
        this.setIndex(l),
        this.setAttribute("position", new Gr(c,3)),
        this.setAttribute("normal", new Gr(u,3)),
        this.setAttribute("uv", new Gr(d,2));
        function p(g, m, v, _, y, b, S, C, M, L, T) {
            const A = b / M
              , k = S / L
              , D = b / 2
              , F = S / 2
              , z = C / 2
              , G = M + 1
              , H = L + 1;
            let X = 0
              , K = 0;
            const ce = new Te;
            for (let ue = 0; ue < H; ue++) {
                const Ie = ue * k - F;
                for (let ke = 0; ke < G; ke++) {
                    const We = ke * A - D;
                    ce[g] = We * _,
                    ce[m] = Ie * y,
                    ce[v] = z,
                    c.push(ce.x, ce.y, ce.z),
                    ce[g] = 0,
                    ce[m] = 0,
                    ce[v] = C > 0 ? 1 : -1,
                    u.push(ce.x, ce.y, ce.z),
                    d.push(ke / M),
                    d.push(1 - ue / L),
                    X += 1
                }
            }
            for (let ue = 0; ue < L; ue++)
                for (let Ie = 0; Ie < M; Ie++) {
                    const ke = f + Ie + G * ue
                      , We = f + Ie + G * (ue + 1)
                      , se = f + (Ie + 1) + G * (ue + 1)
                      , Se = f + (Ie + 1) + G * ue;
                    l.push(ke, We, Se),
                    l.push(We, se, Se),
                    K += 6
                }
            a.addGroup(h, K, T),
            h += K,
            f += X
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new df(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)
    }
}
function gu(i) {
    const e = {};
    for (const t in i) {
        e[t] = {};
        for (const n in i[t]) {
            const s = i[t][n];
            s && (s.isColor || s.isMatrix3 || s.isMatrix4 || s.isVector2 || s.isVector3 || s.isVector4 || s.isTexture || s.isQuaternion) ? s.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),
            e[t][n] = null) : e[t][n] = s.clone() : Array.isArray(s) ? e[t][n] = s.slice() : e[t][n] = s
        }
    }
    return e
}
function $i(i) {
    const e = {};
    for (let t = 0; t < i.length; t++) {
        const n = gu(i[t]);
        for (const s in n)
            e[s] = n[s]
    }
    return e
}
function hY(i) {
    const e = [];
    for (let t = 0; t < i.length; t++)
        e.push(i[t].clone());
    return e
}
function v3(i) {
    const e = i.getRenderTarget();
    return e === null ? i.outputColorSpace : e.isXRRenderTarget === !0 ? e.texture.colorSpace : pn.workingColorSpace
}
const pY = {
    clone: gu,
    merge: $i
};
var mY = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`
  , gY = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class Aa extends uf {
    constructor(e) {
        super(),
        this.isShaderMaterial = !0,
        this.type = "ShaderMaterial",
        this.defines = {},
        this.uniforms = {},
        this.uniformsGroups = [],
        this.vertexShader = mY,
        this.fragmentShader = gY,
        this.linewidth = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.fog = !1,
        this.lights = !1,
        this.clipping = !1,
        this.forceSinglePass = !0,
        this.extensions = {
            clipCullDistance: !1,
            multiDraw: !1
        },
        this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv1: [0, 0]
        },
        this.index0AttributeName = void 0,
        this.uniformsNeedUpdate = !1,
        this.glslVersion = null,
        e !== void 0 && this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.fragmentShader = e.fragmentShader,
        this.vertexShader = e.vertexShader,
        this.uniforms = gu(e.uniforms),
        this.uniformsGroups = hY(e.uniformsGroups),
        this.defines = Object.assign({}, e.defines),
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.fog = e.fog,
        this.lights = e.lights,
        this.clipping = e.clipping,
        this.extensions = Object.assign({}, e.extensions),
        this.glslVersion = e.glslVersion,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        t.glslVersion = this.glslVersion,
        t.uniforms = {};
        for (const s in this.uniforms) {
            const o = this.uniforms[s].value;
            o && o.isTexture ? t.uniforms[s] = {
                type: "t",
                value: o.toJSON(e).uuid
            } : o && o.isColor ? t.uniforms[s] = {
                type: "c",
                value: o.getHex()
            } : o && o.isVector2 ? t.uniforms[s] = {
                type: "v2",
                value: o.toArray()
            } : o && o.isVector3 ? t.uniforms[s] = {
                type: "v3",
                value: o.toArray()
            } : o && o.isVector4 ? t.uniforms[s] = {
                type: "v4",
                value: o.toArray()
            } : o && o.isMatrix3 ? t.uniforms[s] = {
                type: "m3",
                value: o.toArray()
            } : o && o.isMatrix4 ? t.uniforms[s] = {
                type: "m4",
                value: o.toArray()
            } : t.uniforms[s] = {
                value: o
            }
        }
        Object.keys(this.defines).length > 0 && (t.defines = this.defines),
        t.vertexShader = this.vertexShader,
        t.fragmentShader = this.fragmentShader,
        t.lights = this.lights,
        t.clipping = this.clipping;
        const n = {};
        for (const s in this.extensions)
            this.extensions[s] === !0 && (n[s] = !0);
        return Object.keys(n).length > 0 && (t.extensions = n),
        t
    }
}
class _3 extends Fi {
    constructor() {
        super(),
        this.isCamera = !0,
        this.type = "Camera",
        this.matrixWorldInverse = new qn,
        this.projectionMatrix = new qn,
        this.projectionMatrixInverse = new qn,
        this.coordinateSystem = Lo
    }
    copy(e, t) {
        return super.copy(e, t),
        this.matrixWorldInverse.copy(e.matrixWorldInverse),
        this.projectionMatrix.copy(e.projectionMatrix),
        this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
        this.coordinateSystem = e.coordinateSystem,
        this
    }
    getWorldDirection(e) {
        return super.getWorldDirection(e).negate()
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    updateWorldMatrix(e, t) {
        super.updateWorldMatrix(e, t),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const Yo = new Te
  , lE = new nn
  , cE = new nn;
class ar extends _3 {
    constructor(e=50, t=1, n=.1, s=2e3) {
        super(),
        this.isPerspectiveCamera = !0,
        this.type = "PerspectiveCamera",
        this.fov = e,
        this.zoom = 1,
        this.near = n,
        this.far = s,
        this.focus = 10,
        this.aspect = t,
        this.view = null,
        this.filmGauge = 35,
        this.filmOffset = 0,
        this.updateProjectionMatrix()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.fov = e.fov,
        this.zoom = e.zoom,
        this.near = e.near,
        this.far = e.far,
        this.focus = e.focus,
        this.aspect = e.aspect,
        this.view = e.view === null ? null : Object.assign({}, e.view),
        this.filmGauge = e.filmGauge,
        this.filmOffset = e.filmOffset,
        this
    }
    setFocalLength(e) {
        const t = .5 * this.getFilmHeight() / e;
        this.fov = Lv * 2 * Math.atan(t),
        this.updateProjectionMatrix()
    }
    getFocalLength() {
        const e = Math.tan(z0 * .5 * this.fov);
        return .5 * this.getFilmHeight() / e
    }
    getEffectiveFOV() {
        return Lv * 2 * Math.atan(Math.tan(z0 * .5 * this.fov) / this.zoom)
    }
    getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1)
    }
    getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1)
    }
    getViewBounds(e, t, n) {
        Yo.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse),
        t.set(Yo.x, Yo.y).multiplyScalar(-e / Yo.z),
        Yo.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse),
        n.set(Yo.x, Yo.y).multiplyScalar(-e / Yo.z)
    }
    getViewSize(e, t) {
        return this.getViewBounds(e, lE, cE),
        t.subVectors(cE, lE)
    }
    setViewOffset(e, t, n, s, r, o) {
        this.aspect = e / t,
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }),
        this.view.enabled = !0,
        this.view.fullWidth = e,
        this.view.fullHeight = t,
        this.view.offsetX = n,
        this.view.offsetY = s,
        this.view.width = r,
        this.view.height = o,
        this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = this.near;
        let t = e * Math.tan(z0 * .5 * this.fov) / this.zoom
          , n = 2 * t
          , s = this.aspect * n
          , r = -.5 * s;
        const o = this.view;
        if (this.view !== null && this.view.enabled) {
            const l = o.fullWidth
              , c = o.fullHeight;
            r += o.offsetX * s / l,
            t -= o.offsetY * n / c,
            s *= o.width / l,
            n *= o.height / c
        }
        const a = this.filmOffset;
        a !== 0 && (r += e * a / this.getFilmWidth()),
        this.projectionMatrix.makePerspective(r, r + s, t, t - n, e, this.far, this.coordinateSystem),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.fov = this.fov,
        t.object.zoom = this.zoom,
        t.object.near = this.near,
        t.object.far = this.far,
        t.object.focus = this.focus,
        t.object.aspect = this.aspect,
        this.view !== null && (t.object.view = Object.assign({}, this.view)),
        t.object.filmGauge = this.filmGauge,
        t.object.filmOffset = this.filmOffset,
        t
    }
}
const hc = -90
  , pc = 1;
class vY extends Fi {
    constructor(e, t, n) {
        super(),
        this.type = "CubeCamera",
        this.renderTarget = n,
        this.coordinateSystem = null,
        this.activeMipmapLevel = 0;
        const s = new ar(hc,pc,e,t);
        s.layers = this.layers,
        this.add(s);
        const r = new ar(hc,pc,e,t);
        r.layers = this.layers,
        this.add(r);
        const o = new ar(hc,pc,e,t);
        o.layers = this.layers,
        this.add(o);
        const a = new ar(hc,pc,e,t);
        a.layers = this.layers,
        this.add(a);
        const l = new ar(hc,pc,e,t);
        l.layers = this.layers,
        this.add(l);
        const c = new ar(hc,pc,e,t);
        c.layers = this.layers,
        this.add(c)
    }
    updateCoordinateSystem() {
        const e = this.coordinateSystem
          , t = this.children.concat()
          , [n,s,r,o,a,l] = t;
        for (const c of t)
            this.remove(c);
        if (e === Lo)
            n.up.set(0, 1, 0),
            n.lookAt(1, 0, 0),
            s.up.set(0, 1, 0),
            s.lookAt(-1, 0, 0),
            r.up.set(0, 0, -1),
            r.lookAt(0, 1, 0),
            o.up.set(0, 0, 1),
            o.lookAt(0, -1, 0),
            a.up.set(0, 1, 0),
            a.lookAt(0, 0, 1),
            l.up.set(0, 1, 0),
            l.lookAt(0, 0, -1);
        else if (e === Vp)
            n.up.set(0, -1, 0),
            n.lookAt(-1, 0, 0),
            s.up.set(0, -1, 0),
            s.lookAt(1, 0, 0),
            r.up.set(0, 0, 1),
            r.lookAt(0, 1, 0),
            o.up.set(0, 0, -1),
            o.lookAt(0, -1, 0),
            a.up.set(0, -1, 0),
            a.lookAt(0, 0, 1),
            l.up.set(0, -1, 0),
            l.lookAt(0, 0, -1);
        else
            throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
        for (const c of t)
            this.add(c),
            c.updateMatrixWorld()
    }
    update(e, t) {
        this.parent === null && this.updateMatrixWorld();
        const {renderTarget: n, activeMipmapLevel: s} = this;
        this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem,
        this.updateCoordinateSystem());
        const [r,o,a,l,c,u] = this.children
          , d = e.getRenderTarget()
          , f = e.getActiveCubeFace()
          , h = e.getActiveMipmapLevel()
          , p = e.xr.enabled;
        e.xr.enabled = !1;
        const g = n.texture.generateMipmaps;
        n.texture.generateMipmaps = !1,
        e.setRenderTarget(n, 0, s),
        e.render(t, r),
        e.setRenderTarget(n, 1, s),
        e.render(t, o),
        e.setRenderTarget(n, 2, s),
        e.render(t, a),
        e.setRenderTarget(n, 3, s),
        e.render(t, l),
        e.setRenderTarget(n, 4, s),
        e.render(t, c),
        n.texture.generateMipmaps = g,
        e.setRenderTarget(n, 5, s),
        e.render(t, u),
        e.setRenderTarget(d, f, h),
        e.xr.enabled = p,
        n.texture.needsPMREMUpdate = !0
    }
}
class x3 extends as {
    constructor(e, t, n, s, r, o, a, l, c, u) {
        e = e !== void 0 ? e : [],
        t = t !== void 0 ? t : fu,
        super(e, t, n, s, r, o, a, l, c, u),
        this.isCubeTexture = !0,
        this.flipY = !1
    }
    get images() {
        return this.image
    }
    set images(e) {
        this.image = e
    }
}
class _Y extends Dl {
    constructor(e=1, t={}) {
        super(e, e, t),
        this.isWebGLCubeRenderTarget = !0;
        const n = {
            width: e,
            height: e,
            depth: 1
        }
          , s = [n, n, n, n, n, n];
        this.texture = new x3(s,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.colorSpace),
        this.texture.isRenderTargetTexture = !0,
        this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1,
        this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : ur
    }
    fromEquirectangularTexture(e, t) {
        this.texture.type = t.type,
        this.texture.colorSpace = t.colorSpace,
        this.texture.generateMipmaps = t.generateMipmaps,
        this.texture.minFilter = t.minFilter,
        this.texture.magFilter = t.magFilter;
        const n = {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
            fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
        }
          , s = new df(5,5,5)
          , r = new Aa({
            name: "CubemapFromEquirect",
            uniforms: gu(n.uniforms),
            vertexShader: n.vertexShader,
            fragmentShader: n.fragmentShader,
            side: os,
            blending: _a
        });
        r.uniforms.tEquirect.value = t;
        const o = new Br(s,r)
          , a = t.minFilter;
        return t.minFilter === ml && (t.minFilter = ur),
        new vY(1,10,this).update(e, o),
        t.minFilter = a,
        o.geometry.dispose(),
        o.material.dispose(),
        this
    }
    clear(e, t, n, s) {
        const r = e.getRenderTarget();
        for (let o = 0; o < 6; o++)
            e.setRenderTarget(this, o),
            e.clear(t, n, s);
        e.setRenderTarget(r)
    }
}
const lg = new Te
  , xY = new Te
  , yY = new Kt;
class nl {
    constructor(e=new Te(1,0,0), t=0) {
        this.isPlane = !0,
        this.normal = e,
        this.constant = t
    }
    set(e, t) {
        return this.normal.copy(e),
        this.constant = t,
        this
    }
    setComponents(e, t, n, s) {
        return this.normal.set(e, t, n),
        this.constant = s,
        this
    }
    setFromNormalAndCoplanarPoint(e, t) {
        return this.normal.copy(e),
        this.constant = -t.dot(this.normal),
        this
    }
    setFromCoplanarPoints(e, t, n) {
        const s = lg.subVectors(n, t).cross(xY.subVectors(e, t)).normalize();
        return this.setFromNormalAndCoplanarPoint(s, e),
        this
    }
    copy(e) {
        return this.normal.copy(e.normal),
        this.constant = e.constant,
        this
    }
    normalize() {
        const e = 1 / this.normal.length();
        return this.normal.multiplyScalar(e),
        this.constant *= e,
        this
    }
    negate() {
        return this.constant *= -1,
        this.normal.negate(),
        this
    }
    distanceToPoint(e) {
        return this.normal.dot(e) + this.constant
    }
    distanceToSphere(e) {
        return this.distanceToPoint(e.center) - e.radius
    }
    projectPoint(e, t) {
        return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e))
    }
    intersectLine(e, t) {
        const n = e.delta(lg)
          , s = this.normal.dot(n);
        if (s === 0)
            return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
        const r = -(e.start.dot(this.normal) + this.constant) / s;
        return r < 0 || r > 1 ? null : t.copy(e.start).addScaledVector(n, r)
    }
    intersectsLine(e) {
        const t = this.distanceToPoint(e.start)
          , n = this.distanceToPoint(e.end);
        return t < 0 && n > 0 || n < 0 && t > 0
    }
    intersectsBox(e) {
        return e.intersectsPlane(this)
    }
    intersectsSphere(e) {
        return e.intersectsPlane(this)
    }
    coplanarPoint(e) {
        return e.copy(this.normal).multiplyScalar(-this.constant)
    }
    applyMatrix4(e, t) {
        const n = t || yY.getNormalMatrix(e)
          , s = this.coplanarPoint(lg).applyMatrix4(e)
          , r = this.normal.applyMatrix3(n).normalize();
        return this.constant = -s.dot(r),
        this
    }
    translate(e) {
        return this.constant -= e.dot(this.normal),
        this
    }
    equals(e) {
        return e.normal.equals(this.normal) && e.constant === this.constant
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const Ka = new wx
  , lh = new Te;
class Tx {
    constructor(e=new nl, t=new nl, n=new nl, s=new nl, r=new nl, o=new nl) {
        this.planes = [e, t, n, s, r, o]
    }
    set(e, t, n, s, r, o) {
        const a = this.planes;
        return a[0].copy(e),
        a[1].copy(t),
        a[2].copy(n),
        a[3].copy(s),
        a[4].copy(r),
        a[5].copy(o),
        this
    }
    copy(e) {
        const t = this.planes;
        for (let n = 0; n < 6; n++)
            t[n].copy(e.planes[n]);
        return this
    }
    setFromProjectionMatrix(e, t=Lo) {
        const n = this.planes
          , s = e.elements
          , r = s[0]
          , o = s[1]
          , a = s[2]
          , l = s[3]
          , c = s[4]
          , u = s[5]
          , d = s[6]
          , f = s[7]
          , h = s[8]
          , p = s[9]
          , g = s[10]
          , m = s[11]
          , v = s[12]
          , _ = s[13]
          , y = s[14]
          , b = s[15];
        if (n[0].setComponents(l - r, f - c, m - h, b - v).normalize(),
        n[1].setComponents(l + r, f + c, m + h, b + v).normalize(),
        n[2].setComponents(l + o, f + u, m + p, b + _).normalize(),
        n[3].setComponents(l - o, f - u, m - p, b - _).normalize(),
        n[4].setComponents(l - a, f - d, m - g, b - y).normalize(),
        t === Lo)
            n[5].setComponents(l + a, f + d, m + g, b + y).normalize();
        else if (t === Vp)
            n[5].setComponents(a, d, g, y).normalize();
        else
            throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
        return this
    }
    intersectsObject(e) {
        if (e.boundingSphere !== void 0)
            e.boundingSphere === null && e.computeBoundingSphere(),
            Ka.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
        else {
            const t = e.geometry;
            t.boundingSphere === null && t.computeBoundingSphere(),
            Ka.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)
        }
        return this.intersectsSphere(Ka)
    }
    intersectsSprite(e) {
        return Ka.center.set(0, 0, 0),
        Ka.radius = .7071067811865476,
        Ka.applyMatrix4(e.matrixWorld),
        this.intersectsSphere(Ka)
    }
    intersectsSphere(e) {
        const t = this.planes
          , n = e.center
          , s = -e.radius;
        for (let r = 0; r < 6; r++)
            if (t[r].distanceToPoint(n) < s)
                return !1;
        return !0
    }
    intersectsBox(e) {
        const t = this.planes;
        for (let n = 0; n < 6; n++) {
            const s = t[n];
            if (lh.x = s.normal.x > 0 ? e.max.x : e.min.x,
            lh.y = s.normal.y > 0 ? e.max.y : e.min.y,
            lh.z = s.normal.z > 0 ? e.max.z : e.min.z,
            s.distanceToPoint(lh) < 0)
                return !1
        }
        return !0
    }
    containsPoint(e) {
        const t = this.planes;
        for (let n = 0; n < 6; n++)
            if (t[n].distanceToPoint(e) < 0)
                return !1;
        return !0
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
function y3() {
    let i = null
      , e = !1
      , t = null
      , n = null;
    function s(r, o) {
        t(r, o),
        n = i.requestAnimationFrame(s)
    }
    return {
        start: function() {
            e !== !0 && t !== null && (n = i.requestAnimationFrame(s),
            e = !0)
        },
        stop: function() {
            i.cancelAnimationFrame(n),
            e = !1
        },
        setAnimationLoop: function(r) {
            t = r
        },
        setContext: function(r) {
            i = r
        }
    }
}
function bY(i) {
    const e = new WeakMap;
    function t(a, l) {
        const c = a.array
          , u = a.usage
          , d = c.byteLength
          , f = i.createBuffer();
        i.bindBuffer(l, f),
        i.bufferData(l, c, u),
        a.onUploadCallback();
        let h;
        if (c instanceof Float32Array)
            h = i.FLOAT;
        else if (c instanceof Uint16Array)
            a.isFloat16BufferAttribute ? h = i.HALF_FLOAT : h = i.UNSIGNED_SHORT;
        else if (c instanceof Int16Array)
            h = i.SHORT;
        else if (c instanceof Uint32Array)
            h = i.UNSIGNED_INT;
        else if (c instanceof Int32Array)
            h = i.INT;
        else if (c instanceof Int8Array)
            h = i.BYTE;
        else if (c instanceof Uint8Array)
            h = i.UNSIGNED_BYTE;
        else if (c instanceof Uint8ClampedArray)
            h = i.UNSIGNED_BYTE;
        else
            throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + c);
        return {
            buffer: f,
            type: h,
            bytesPerElement: c.BYTES_PER_ELEMENT,
            version: a.version,
            size: d
        }
    }
    function n(a, l, c) {
        const u = l.array
          , d = l._updateRange
          , f = l.updateRanges;
        if (i.bindBuffer(c, a),
        d.count === -1 && f.length === 0 && i.bufferSubData(c, 0, u),
        f.length !== 0) {
            for (let h = 0, p = f.length; h < p; h++) {
                const g = f[h];
                i.bufferSubData(c, g.start * u.BYTES_PER_ELEMENT, u, g.start, g.count)
            }
            l.clearUpdateRanges()
        }
        d.count !== -1 && (i.bufferSubData(c, d.offset * u.BYTES_PER_ELEMENT, u, d.offset, d.count),
        d.count = -1),
        l.onUploadCallback()
    }
    function s(a) {
        return a.isInterleavedBufferAttribute && (a = a.data),
        e.get(a)
    }
    function r(a) {
        a.isInterleavedBufferAttribute && (a = a.data);
        const l = e.get(a);
        l && (i.deleteBuffer(l.buffer),
        e.delete(a))
    }
    function o(a, l) {
        if (a.isInterleavedBufferAttribute && (a = a.data),
        a.isGLBufferAttribute) {
            const u = e.get(a);
            (!u || u.version < a.version) && e.set(a, {
                buffer: a.buffer,
                type: a.type,
                bytesPerElement: a.elementSize,
                version: a.version
            });
            return
        }
        const c = e.get(a);
        if (c === void 0)
            e.set(a, t(a, l));
        else if (c.version < a.version) {
            if (c.size !== a.array.byteLength)
                throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
            n(c.buffer, a, l),
            c.version = a.version
        }
    }
    return {
        get: s,
        remove: r,
        update: o
    }
}
class Lm extends Pa {
    constructor(e=1, t=1, n=1, s=1) {
        super(),
        this.type = "PlaneGeometry",
        this.parameters = {
            width: e,
            height: t,
            widthSegments: n,
            heightSegments: s
        };
        const r = e / 2
          , o = t / 2
          , a = Math.floor(n)
          , l = Math.floor(s)
          , c = a + 1
          , u = l + 1
          , d = e / a
          , f = t / l
          , h = []
          , p = []
          , g = []
          , m = [];
        for (let v = 0; v < u; v++) {
            const _ = v * f - o;
            for (let y = 0; y < c; y++) {
                const b = y * d - r;
                p.push(b, -_, 0),
                g.push(0, 0, 1),
                m.push(y / a),
                m.push(1 - v / l)
            }
        }
        for (let v = 0; v < l; v++)
            for (let _ = 0; _ < a; _++) {
                const y = _ + c * v
                  , b = _ + c * (v + 1)
                  , S = _ + 1 + c * (v + 1)
                  , C = _ + 1 + c * v;
                h.push(y, b, C),
                h.push(b, S, C)
            }
        this.setIndex(h),
        this.setAttribute("position", new Gr(p,3)),
        this.setAttribute("normal", new Gr(g,3)),
        this.setAttribute("uv", new Gr(m,2))
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new Lm(e.width,e.height,e.widthSegments,e.heightSegments)
    }
}
var SY = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`
  , EY = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`
  , wY = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`
  , TY = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`
  , AY = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`
  , CY = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`
  , MY = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT )
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN )
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`
  , RY = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`
  , LY = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`
  , IY = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`
  , kY = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`
  , PY = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`
  , DY = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`
  , FY = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`
  , OY = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`
  , UY = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`
  , NY = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`
  , BY = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`
  , VY = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`
  , $Y = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`
  , HY = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`
  , zY = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`
  , GY = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`
  , WY = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`
  , qY = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`
  , jY = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`
  , KY = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`
  , XY = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`
  , YY = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`
  , ZY = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`
  , JY = "gl_FragColor = linearToOutputTexel( gl_FragColor );"
  , QY = `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`
  , eZ = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`
  , tZ = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif

#endif`
  , nZ = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`
  , iZ = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS

		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`
  , sZ = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`
  , rZ = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`
  , oZ = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`
  , aZ = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`
  , lZ = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`
  , cZ = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`
  , uZ = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`
  , dZ = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`
  , fZ = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`
  , hZ = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`
  , pZ = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`
  , mZ = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`
  , gZ = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`
  , vZ = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`
  , _Z = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`
  , xZ = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`
  , yZ = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`
  , bZ = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`
  , SZ = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`
  , EZ = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`
  , wZ = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`
  , TZ = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`
  , AZ = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`
  , CZ = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`
  , MZ = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );

	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`
  , RZ = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`
  , LZ = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`
  , IZ = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`
  , kZ = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`
  , PZ = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`
  , DZ = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`
  , FZ = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`
  , OZ = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`
  , UZ = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`
  , NZ = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`
  , BZ = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`
  , VZ = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`
  , $Z = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`
  , HZ = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`
  , zZ = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`
  , GZ = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`
  , WZ = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`
  , qZ = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`
  , jZ = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`
  , KZ = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`
  , XZ = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`
  , YZ = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`
  , ZZ = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`
  , JZ = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`
  , QZ = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`
  , eJ = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`
  , tJ = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`
  , nJ = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`
  , iJ = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;

		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`
  , sJ = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`
  , rJ = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`
  , oJ = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`
  , aJ = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`
  , lJ = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`
  , cJ = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`
  , uJ = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`
  , dJ = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`
  , fJ = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`
  , hJ = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`
  , pJ = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`
  , mJ = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`
  , gJ = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;

				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;

				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;

		#else

			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );

		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`
  , vJ = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`
  , _J = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`
  , xJ = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`
  , yJ = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const bJ = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`
  , SJ = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , EJ = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`
  , wJ = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , TJ = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`
  , AJ = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , CJ = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`
  , MJ = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`
  , RJ = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`
  , LJ = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`
  , IJ = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`
  , kJ = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , PJ = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`
  , DJ = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`
  , FJ = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`
  , OJ = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , UJ = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , NJ = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , BJ = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`
  , VJ = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , $J = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`
  , HJ = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`
  , zJ = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , GJ = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , WJ = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`
  , qJ = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , jJ = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , KJ = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , XJ = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`
  , YJ = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`
  , ZJ = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , JJ = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`
  , QJ = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`
  , eQ = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`
  , jt = {
    alphahash_fragment: SY,
    alphahash_pars_fragment: EY,
    alphamap_fragment: wY,
    alphamap_pars_fragment: TY,
    alphatest_fragment: AY,
    alphatest_pars_fragment: CY,
    aomap_fragment: MY,
    aomap_pars_fragment: RY,
    batching_pars_vertex: LY,
    batching_vertex: IY,
    begin_vertex: kY,
    beginnormal_vertex: PY,
    bsdfs: DY,
    iridescence_fragment: FY,
    bumpmap_pars_fragment: OY,
    clipping_planes_fragment: UY,
    clipping_planes_pars_fragment: NY,
    clipping_planes_pars_vertex: BY,
    clipping_planes_vertex: VY,
    color_fragment: $Y,
    color_pars_fragment: HY,
    color_pars_vertex: zY,
    color_vertex: GY,
    common: WY,
    cube_uv_reflection_fragment: qY,
    defaultnormal_vertex: jY,
    displacementmap_pars_vertex: KY,
    displacementmap_vertex: XY,
    emissivemap_fragment: YY,
    emissivemap_pars_fragment: ZY,
    colorspace_fragment: JY,
    colorspace_pars_fragment: QY,
    envmap_fragment: eZ,
    envmap_common_pars_fragment: tZ,
    envmap_pars_fragment: nZ,
    envmap_pars_vertex: iZ,
    envmap_physical_pars_fragment: pZ,
    envmap_vertex: sZ,
    fog_vertex: rZ,
    fog_pars_vertex: oZ,
    fog_fragment: aZ,
    fog_pars_fragment: lZ,
    gradientmap_pars_fragment: cZ,
    lightmap_pars_fragment: uZ,
    lights_lambert_fragment: dZ,
    lights_lambert_pars_fragment: fZ,
    lights_pars_begin: hZ,
    lights_toon_fragment: mZ,
    lights_toon_pars_fragment: gZ,
    lights_phong_fragment: vZ,
    lights_phong_pars_fragment: _Z,
    lights_physical_fragment: xZ,
    lights_physical_pars_fragment: yZ,
    lights_fragment_begin: bZ,
    lights_fragment_maps: SZ,
    lights_fragment_end: EZ,
    logdepthbuf_fragment: wZ,
    logdepthbuf_pars_fragment: TZ,
    logdepthbuf_pars_vertex: AZ,
    logdepthbuf_vertex: CZ,
    map_fragment: MZ,
    map_pars_fragment: RZ,
    map_particle_fragment: LZ,
    map_particle_pars_fragment: IZ,
    metalnessmap_fragment: kZ,
    metalnessmap_pars_fragment: PZ,
    morphinstance_vertex: DZ,
    morphcolor_vertex: FZ,
    morphnormal_vertex: OZ,
    morphtarget_pars_vertex: UZ,
    morphtarget_vertex: NZ,
    normal_fragment_begin: BZ,
    normal_fragment_maps: VZ,
    normal_pars_fragment: $Z,
    normal_pars_vertex: HZ,
    normal_vertex: zZ,
    normalmap_pars_fragment: GZ,
    clearcoat_normal_fragment_begin: WZ,
    clearcoat_normal_fragment_maps: qZ,
    clearcoat_pars_fragment: jZ,
    iridescence_pars_fragment: KZ,
    opaque_fragment: XZ,
    packing: YZ,
    premultiplied_alpha_fragment: ZZ,
    project_vertex: JZ,
    dithering_fragment: QZ,
    dithering_pars_fragment: eJ,
    roughnessmap_fragment: tJ,
    roughnessmap_pars_fragment: nJ,
    shadowmap_pars_fragment: iJ,
    shadowmap_pars_vertex: sJ,
    shadowmap_vertex: rJ,
    shadowmask_pars_fragment: oJ,
    skinbase_vertex: aJ,
    skinning_pars_vertex: lJ,
    skinning_vertex: cJ,
    skinnormal_vertex: uJ,
    specularmap_fragment: dJ,
    specularmap_pars_fragment: fJ,
    tonemapping_fragment: hJ,
    tonemapping_pars_fragment: pJ,
    transmission_fragment: mJ,
    transmission_pars_fragment: gJ,
    uv_pars_fragment: vJ,
    uv_pars_vertex: _J,
    uv_vertex: xJ,
    worldpos_vertex: yJ,
    background_vert: bJ,
    background_frag: SJ,
    backgroundCube_vert: EJ,
    backgroundCube_frag: wJ,
    cube_vert: TJ,
    cube_frag: AJ,
    depth_vert: CJ,
    depth_frag: MJ,
    distanceRGBA_vert: RJ,
    distanceRGBA_frag: LJ,
    equirect_vert: IJ,
    equirect_frag: kJ,
    linedashed_vert: PJ,
    linedashed_frag: DJ,
    meshbasic_vert: FJ,
    meshbasic_frag: OJ,
    meshlambert_vert: UJ,
    meshlambert_frag: NJ,
    meshmatcap_vert: BJ,
    meshmatcap_frag: VJ,
    meshnormal_vert: $J,
    meshnormal_frag: HJ,
    meshphong_vert: zJ,
    meshphong_frag: GJ,
    meshphysical_vert: WJ,
    meshphysical_frag: qJ,
    meshtoon_vert: jJ,
    meshtoon_frag: KJ,
    points_vert: XJ,
    points_frag: YJ,
    shadow_vert: ZJ,
    shadow_frag: JJ,
    sprite_vert: QJ,
    sprite_frag: eQ
}
  , rt = {
    common: {
        diffuse: {
            value: new un(16777215)
        },
        opacity: {
            value: 1
        },
        map: {
            value: null
        },
        mapTransform: {
            value: new Kt
        },
        alphaMap: {
            value: null
        },
        alphaMapTransform: {
            value: new Kt
        },
        alphaTest: {
            value: 0
        }
    },
    specularmap: {
        specularMap: {
            value: null
        },
        specularMapTransform: {
            value: new Kt
        }
    },
    envmap: {
        envMap: {
            value: null
        },
        envMapRotation: {
            value: new Kt
        },
        flipEnvMap: {
            value: -1
        },
        reflectivity: {
            value: 1
        },
        ior: {
            value: 1.5
        },
        refractionRatio: {
            value: .98
        }
    },
    aomap: {
        aoMap: {
            value: null
        },
        aoMapIntensity: {
            value: 1
        },
        aoMapTransform: {
            value: new Kt
        }
    },
    lightmap: {
        lightMap: {
            value: null
        },
        lightMapIntensity: {
            value: 1
        },
        lightMapTransform: {
            value: new Kt
        }
    },
    bumpmap: {
        bumpMap: {
            value: null
        },
        bumpMapTransform: {
            value: new Kt
        },
        bumpScale: {
            value: 1
        }
    },
    normalmap: {
        normalMap: {
            value: null
        },
        normalMapTransform: {
            value: new Kt
        },
        normalScale: {
            value: new nn(1,1)
        }
    },
    displacementmap: {
        displacementMap: {
            value: null
        },
        displacementMapTransform: {
            value: new Kt
        },
        displacementScale: {
            value: 1
        },
        displacementBias: {
            value: 0
        }
    },
    emissivemap: {
        emissiveMap: {
            value: null
        },
        emissiveMapTransform: {
            value: new Kt
        }
    },
    metalnessmap: {
        metalnessMap: {
            value: null
        },
        metalnessMapTransform: {
            value: new Kt
        }
    },
    roughnessmap: {
        roughnessMap: {
            value: null
        },
        roughnessMapTransform: {
            value: new Kt
        }
    },
    gradientmap: {
        gradientMap: {
            value: null
        }
    },
    fog: {
        fogDensity: {
            value: 25e-5
        },
        fogNear: {
            value: 1
        },
        fogFar: {
            value: 2e3
        },
        fogColor: {
            value: new un(16777215)
        }
    },
    lights: {
        ambientLightColor: {
            value: []
        },
        lightProbe: {
            value: []
        },
        directionalLights: {
            value: [],
            properties: {
                direction: {},
                color: {}
            }
        },
        directionalLightShadows: {
            value: [],
            properties: {
                shadowIntensity: 1,
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        directionalShadowMap: {
            value: []
        },
        directionalShadowMatrix: {
            value: []
        },
        spotLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {}
            }
        },
        spotLightShadows: {
            value: [],
            properties: {
                shadowIntensity: 1,
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        spotLightMap: {
            value: []
        },
        spotShadowMap: {
            value: []
        },
        spotLightMatrix: {
            value: []
        },
        pointLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                decay: {},
                distance: {}
            }
        },
        pointLightShadows: {
            value: [],
            properties: {
                shadowIntensity: 1,
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {}
            }
        },
        pointShadowMap: {
            value: []
        },
        pointShadowMatrix: {
            value: []
        },
        hemisphereLights: {
            value: [],
            properties: {
                direction: {},
                skyColor: {},
                groundColor: {}
            }
        },
        rectAreaLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                width: {},
                height: {}
            }
        },
        ltc_1: {
            value: null
        },
        ltc_2: {
            value: null
        }
    },
    points: {
        diffuse: {
            value: new un(16777215)
        },
        opacity: {
            value: 1
        },
        size: {
            value: 1
        },
        scale: {
            value: 1
        },
        map: {
            value: null
        },
        alphaMap: {
            value: null
        },
        alphaMapTransform: {
            value: new Kt
        },
        alphaTest: {
            value: 0
        },
        uvTransform: {
            value: new Kt
        }
    },
    sprite: {
        diffuse: {
            value: new un(16777215)
        },
        opacity: {
            value: 1
        },
        center: {
            value: new nn(.5,.5)
        },
        rotation: {
            value: 0
        },
        map: {
            value: null
        },
        mapTransform: {
            value: new Kt
        },
        alphaMap: {
            value: null
        },
        alphaMapTransform: {
            value: new Kt
        },
        alphaTest: {
            value: 0
        }
    }
}
  , Pr = {
    basic: {
        uniforms: $i([rt.common, rt.specularmap, rt.envmap, rt.aomap, rt.lightmap, rt.fog]),
        vertexShader: jt.meshbasic_vert,
        fragmentShader: jt.meshbasic_frag
    },
    lambert: {
        uniforms: $i([rt.common, rt.specularmap, rt.envmap, rt.aomap, rt.lightmap, rt.emissivemap, rt.bumpmap, rt.normalmap, rt.displacementmap, rt.fog, rt.lights, {
            emissive: {
                value: new un(0)
            }
        }]),
        vertexShader: jt.meshlambert_vert,
        fragmentShader: jt.meshlambert_frag
    },
    phong: {
        uniforms: $i([rt.common, rt.specularmap, rt.envmap, rt.aomap, rt.lightmap, rt.emissivemap, rt.bumpmap, rt.normalmap, rt.displacementmap, rt.fog, rt.lights, {
            emissive: {
                value: new un(0)
            },
            specular: {
                value: new un(1118481)
            },
            shininess: {
                value: 30
            }
        }]),
        vertexShader: jt.meshphong_vert,
        fragmentShader: jt.meshphong_frag
    },
    standard: {
        uniforms: $i([rt.common, rt.envmap, rt.aomap, rt.lightmap, rt.emissivemap, rt.bumpmap, rt.normalmap, rt.displacementmap, rt.roughnessmap, rt.metalnessmap, rt.fog, rt.lights, {
            emissive: {
                value: new un(0)
            },
            roughness: {
                value: 1
            },
            metalness: {
                value: 0
            },
            envMapIntensity: {
                value: 1
            }
        }]),
        vertexShader: jt.meshphysical_vert,
        fragmentShader: jt.meshphysical_frag
    },
    toon: {
        uniforms: $i([rt.common, rt.aomap, rt.lightmap, rt.emissivemap, rt.bumpmap, rt.normalmap, rt.displacementmap, rt.gradientmap, rt.fog, rt.lights, {
            emissive: {
                value: new un(0)
            }
        }]),
        vertexShader: jt.meshtoon_vert,
        fragmentShader: jt.meshtoon_frag
    },
    matcap: {
        uniforms: $i([rt.common, rt.bumpmap, rt.normalmap, rt.displacementmap, rt.fog, {
            matcap: {
                value: null
            }
        }]),
        vertexShader: jt.meshmatcap_vert,
        fragmentShader: jt.meshmatcap_frag
    },
    points: {
        uniforms: $i([rt.points, rt.fog]),
        vertexShader: jt.points_vert,
        fragmentShader: jt.points_frag
    },
    dashed: {
        uniforms: $i([rt.common, rt.fog, {
            scale: {
                value: 1
            },
            dashSize: {
                value: 1
            },
            totalSize: {
                value: 2
            }
        }]),
        vertexShader: jt.linedashed_vert,
        fragmentShader: jt.linedashed_frag
    },
    depth: {
        uniforms: $i([rt.common, rt.displacementmap]),
        vertexShader: jt.depth_vert,
        fragmentShader: jt.depth_frag
    },
    normal: {
        uniforms: $i([rt.common, rt.bumpmap, rt.normalmap, rt.displacementmap, {
            opacity: {
                value: 1
            }
        }]),
        vertexShader: jt.meshnormal_vert,
        fragmentShader: jt.meshnormal_frag
    },
    sprite: {
        uniforms: $i([rt.sprite, rt.fog]),
        vertexShader: jt.sprite_vert,
        fragmentShader: jt.sprite_frag
    },
    background: {
        uniforms: {
            uvTransform: {
                value: new Kt
            },
            t2D: {
                value: null
            },
            backgroundIntensity: {
                value: 1
            }
        },
        vertexShader: jt.background_vert,
        fragmentShader: jt.background_frag
    },
    backgroundCube: {
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            },
            backgroundBlurriness: {
                value: 0
            },
            backgroundIntensity: {
                value: 1
            },
            backgroundRotation: {
                value: new Kt
            }
        },
        vertexShader: jt.backgroundCube_vert,
        fragmentShader: jt.backgroundCube_frag
    },
    cube: {
        uniforms: {
            tCube: {
                value: null
            },
            tFlip: {
                value: -1
            },
            opacity: {
                value: 1
            }
        },
        vertexShader: jt.cube_vert,
        fragmentShader: jt.cube_frag
    },
    equirect: {
        uniforms: {
            tEquirect: {
                value: null
            }
        },
        vertexShader: jt.equirect_vert,
        fragmentShader: jt.equirect_frag
    },
    distanceRGBA: {
        uniforms: $i([rt.common, rt.displacementmap, {
            referencePosition: {
                value: new Te
            },
            nearDistance: {
                value: 1
            },
            farDistance: {
                value: 1e3
            }
        }]),
        vertexShader: jt.distanceRGBA_vert,
        fragmentShader: jt.distanceRGBA_frag
    },
    shadow: {
        uniforms: $i([rt.lights, rt.fog, {
            color: {
                value: new un(0)
            },
            opacity: {
                value: 1
            }
        }]),
        vertexShader: jt.shadow_vert,
        fragmentShader: jt.shadow_frag
    }
};
Pr.physical = {
    uniforms: $i([Pr.standard.uniforms, {
        clearcoat: {
            value: 0
        },
        clearcoatMap: {
            value: null
        },
        clearcoatMapTransform: {
            value: new Kt
        },
        clearcoatNormalMap: {
            value: null
        },
        clearcoatNormalMapTransform: {
            value: new Kt
        },
        clearcoatNormalScale: {
            value: new nn(1,1)
        },
        clearcoatRoughness: {
            value: 0
        },
        clearcoatRoughnessMap: {
            value: null
        },
        clearcoatRoughnessMapTransform: {
            value: new Kt
        },
        dispersion: {
            value: 0
        },
        iridescence: {
            value: 0
        },
        iridescenceMap: {
            value: null
        },
        iridescenceMapTransform: {
            value: new Kt
        },
        iridescenceIOR: {
            value: 1.3
        },
        iridescenceThicknessMinimum: {
            value: 100
        },
        iridescenceThicknessMaximum: {
            value: 400
        },
        iridescenceThicknessMap: {
            value: null
        },
        iridescenceThicknessMapTransform: {
            value: new Kt
        },
        sheen: {
            value: 0
        },
        sheenColor: {
            value: new un(0)
        },
        sheenColorMap: {
            value: null
        },
        sheenColorMapTransform: {
            value: new Kt
        },
        sheenRoughness: {
            value: 1
        },
        sheenRoughnessMap: {
            value: null
        },
        sheenRoughnessMapTransform: {
            value: new Kt
        },
        transmission: {
            value: 0
        },
        transmissionMap: {
            value: null
        },
        transmissionMapTransform: {
            value: new Kt
        },
        transmissionSamplerSize: {
            value: new nn
        },
        transmissionSamplerMap: {
            value: null
        },
        thickness: {
            value: 0
        },
        thicknessMap: {
            value: null
        },
        thicknessMapTransform: {
            value: new Kt
        },
        attenuationDistance: {
            value: 0
        },
        attenuationColor: {
            value: new un(0)
        },
        specularColor: {
            value: new un(1,1,1)
        },
        specularColorMap: {
            value: null
        },
        specularColorMapTransform: {
            value: new Kt
        },
        specularIntensity: {
            value: 1
        },
        specularIntensityMap: {
            value: null
        },
        specularIntensityMapTransform: {
            value: new Kt
        },
        anisotropyVector: {
            value: new nn
        },
        anisotropyMap: {
            value: null
        },
        anisotropyMapTransform: {
            value: new Kt
        }
    }]),
    vertexShader: jt.meshphysical_vert,
    fragmentShader: jt.meshphysical_frag
};
const ch = {
    r: 0,
    b: 0,
    g: 0
}
  , Xa = new Xr
  , tQ = new qn;
function nQ(i, e, t, n, s, r, o) {
    const a = new un(0);
    let l = r === !0 ? 0 : 1, c, u, d = null, f = 0, h = null;
    function p(_) {
        let y = _.isScene === !0 ? _.background : null;
        return y && y.isTexture && (y = (_.backgroundBlurriness > 0 ? t : e).get(y)),
        y
    }
    function g(_) {
        let y = !1;
        const b = p(_);
        b === null ? v(a, l) : b && b.isColor && (v(b, 1),
        y = !0);
        const S = i.xr.getEnvironmentBlendMode();
        S === "additive" ? n.buffers.color.setClear(0, 0, 0, 1, o) : S === "alpha-blend" && n.buffers.color.setClear(0, 0, 0, 0, o),
        (i.autoClear || y) && (n.buffers.depth.setTest(!0),
        n.buffers.depth.setMask(!0),
        n.buffers.color.setMask(!0),
        i.clear(i.autoClearColor, i.autoClearDepth, i.autoClearStencil))
    }
    function m(_, y) {
        const b = p(y);
        b && (b.isCubeTexture || b.mapping === Mm) ? (u === void 0 && (u = new Br(new df(1,1,1),new Aa({
            name: "BackgroundCubeMaterial",
            uniforms: gu(Pr.backgroundCube.uniforms),
            vertexShader: Pr.backgroundCube.vertexShader,
            fragmentShader: Pr.backgroundCube.fragmentShader,
            side: os,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
        })),
        u.geometry.deleteAttribute("normal"),
        u.geometry.deleteAttribute("uv"),
        u.onBeforeRender = function(S, C, M) {
            this.matrixWorld.copyPosition(M.matrixWorld)
        }
        ,
        Object.defineProperty(u.material, "envMap", {
            get: function() {
                return this.uniforms.envMap.value
            }
        }),
        s.update(u)),
        Xa.copy(y.backgroundRotation),
        Xa.x *= -1,
        Xa.y *= -1,
        Xa.z *= -1,
        b.isCubeTexture && b.isRenderTargetTexture === !1 && (Xa.y *= -1,
        Xa.z *= -1),
        u.material.uniforms.envMap.value = b,
        u.material.uniforms.flipEnvMap.value = b.isCubeTexture && b.isRenderTargetTexture === !1 ? -1 : 1,
        u.material.uniforms.backgroundBlurriness.value = y.backgroundBlurriness,
        u.material.uniforms.backgroundIntensity.value = y.backgroundIntensity,
        u.material.uniforms.backgroundRotation.value.setFromMatrix4(tQ.makeRotationFromEuler(Xa)),
        u.material.toneMapped = pn.getTransfer(b.colorSpace) !== In,
        (d !== b || f !== b.version || h !== i.toneMapping) && (u.material.needsUpdate = !0,
        d = b,
        f = b.version,
        h = i.toneMapping),
        u.layers.enableAll(),
        _.unshift(u, u.geometry, u.material, 0, 0, null)) : b && b.isTexture && (c === void 0 && (c = new Br(new Lm(2,2),new Aa({
            name: "BackgroundMaterial",
            uniforms: gu(Pr.background.uniforms),
            vertexShader: Pr.background.vertexShader,
            fragmentShader: Pr.background.fragmentShader,
            side: Ta,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
        })),
        c.geometry.deleteAttribute("normal"),
        Object.defineProperty(c.material, "map", {
            get: function() {
                return this.uniforms.t2D.value
            }
        }),
        s.update(c)),
        c.material.uniforms.t2D.value = b,
        c.material.uniforms.backgroundIntensity.value = y.backgroundIntensity,
        c.material.toneMapped = pn.getTransfer(b.colorSpace) !== In,
        b.matrixAutoUpdate === !0 && b.updateMatrix(),
        c.material.uniforms.uvTransform.value.copy(b.matrix),
        (d !== b || f !== b.version || h !== i.toneMapping) && (c.material.needsUpdate = !0,
        d = b,
        f = b.version,
        h = i.toneMapping),
        c.layers.enableAll(),
        _.unshift(c, c.geometry, c.material, 0, 0, null))
    }
    function v(_, y) {
        _.getRGB(ch, v3(i)),
        n.buffers.color.setClear(ch.r, ch.g, ch.b, y, o)
    }
    return {
        getClearColor: function() {
            return a
        },
        setClearColor: function(_, y=1) {
            a.set(_),
            l = y,
            v(a, l)
        },
        getClearAlpha: function() {
            return l
        },
        setClearAlpha: function(_) {
            l = _,
            v(a, l)
        },
        render: g,
        addToRenderList: m
    }
}
function iQ(i, e) {
    const t = i.getParameter(i.MAX_VERTEX_ATTRIBS)
      , n = {}
      , s = f(null);
    let r = s
      , o = !1;
    function a(A, k, D, F, z) {
        let G = !1;
        const H = d(F, D, k);
        r !== H && (r = H,
        c(r.object)),
        G = h(A, F, D, z),
        G && p(A, F, D, z),
        z !== null && e.update(z, i.ELEMENT_ARRAY_BUFFER),
        (G || o) && (o = !1,
        b(A, k, D, F),
        z !== null && i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, e.get(z).buffer))
    }
    function l() {
        return i.createVertexArray()
    }
    function c(A) {
        return i.bindVertexArray(A)
    }
    function u(A) {
        return i.deleteVertexArray(A)
    }
    function d(A, k, D) {
        const F = D.wireframe === !0;
        let z = n[A.id];
        z === void 0 && (z = {},
        n[A.id] = z);
        let G = z[k.id];
        G === void 0 && (G = {},
        z[k.id] = G);
        let H = G[F];
        return H === void 0 && (H = f(l()),
        G[F] = H),
        H
    }
    function f(A) {
        const k = []
          , D = []
          , F = [];
        for (let z = 0; z < t; z++)
            k[z] = 0,
            D[z] = 0,
            F[z] = 0;
        return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: k,
            enabledAttributes: D,
            attributeDivisors: F,
            object: A,
            attributes: {},
            index: null
        }
    }
    function h(A, k, D, F) {
        const z = r.attributes
          , G = k.attributes;
        let H = 0;
        const X = D.getAttributes();
        for (const K in X)
            if (X[K].location >= 0) {
                const ue = z[K];
                let Ie = G[K];
                if (Ie === void 0 && (K === "instanceMatrix" && A.instanceMatrix && (Ie = A.instanceMatrix),
                K === "instanceColor" && A.instanceColor && (Ie = A.instanceColor)),
                ue === void 0 || ue.attribute !== Ie || Ie && ue.data !== Ie.data)
                    return !0;
                H++
            }
        return r.attributesNum !== H || r.index !== F
    }
    function p(A, k, D, F) {
        const z = {}
          , G = k.attributes;
        let H = 0;
        const X = D.getAttributes();
        for (const K in X)
            if (X[K].location >= 0) {
                let ue = G[K];
                ue === void 0 && (K === "instanceMatrix" && A.instanceMatrix && (ue = A.instanceMatrix),
                K === "instanceColor" && A.instanceColor && (ue = A.instanceColor));
                const Ie = {};
                Ie.attribute = ue,
                ue && ue.data && (Ie.data = ue.data),
                z[K] = Ie,
                H++
            }
        r.attributes = z,
        r.attributesNum = H,
        r.index = F
    }
    function g() {
        const A = r.newAttributes;
        for (let k = 0, D = A.length; k < D; k++)
            A[k] = 0
    }
    function m(A) {
        v(A, 0)
    }
    function v(A, k) {
        const D = r.newAttributes
          , F = r.enabledAttributes
          , z = r.attributeDivisors;
        D[A] = 1,
        F[A] === 0 && (i.enableVertexAttribArray(A),
        F[A] = 1),
        z[A] !== k && (i.vertexAttribDivisor(A, k),
        z[A] = k)
    }
    function _() {
        const A = r.newAttributes
          , k = r.enabledAttributes;
        for (let D = 0, F = k.length; D < F; D++)
            k[D] !== A[D] && (i.disableVertexAttribArray(D),
            k[D] = 0)
    }
    function y(A, k, D, F, z, G, H) {
        H === !0 ? i.vertexAttribIPointer(A, k, D, z, G) : i.vertexAttribPointer(A, k, D, F, z, G)
    }
    function b(A, k, D, F) {
        g();
        const z = F.attributes
          , G = D.getAttributes()
          , H = k.defaultAttributeValues;
        for (const X in G) {
            const K = G[X];
            if (K.location >= 0) {
                let ce = z[X];
                if (ce === void 0 && (X === "instanceMatrix" && A.instanceMatrix && (ce = A.instanceMatrix),
                X === "instanceColor" && A.instanceColor && (ce = A.instanceColor)),
                ce !== void 0) {
                    const ue = ce.normalized
                      , Ie = ce.itemSize
                      , ke = e.get(ce);
                    if (ke === void 0)
                        continue;
                    const We = ke.buffer
                      , se = ke.type
                      , Se = ke.bytesPerElement
                      , be = se === i.INT || se === i.UNSIGNED_INT || ce.gpuType === vx;
                    if (ce.isInterleavedBufferAttribute) {
                        const q = ce.data
                          , me = q.stride
                          , Ce = ce.offset;
                        if (q.isInstancedInterleavedBuffer) {
                            for (let Pe = 0; Pe < K.locationSize; Pe++)
                                v(K.location + Pe, q.meshPerAttribute);
                            A.isInstancedMesh !== !0 && F._maxInstanceCount === void 0 && (F._maxInstanceCount = q.meshPerAttribute * q.count)
                        } else
                            for (let Pe = 0; Pe < K.locationSize; Pe++)
                                m(K.location + Pe);
                        i.bindBuffer(i.ARRAY_BUFFER, We);
                        for (let Pe = 0; Pe < K.locationSize; Pe++)
                            y(K.location + Pe, Ie / K.locationSize, se, ue, me * Se, (Ce + Ie / K.locationSize * Pe) * Se, be)
                    } else {
                        if (ce.isInstancedBufferAttribute) {
                            for (let q = 0; q < K.locationSize; q++)
                                v(K.location + q, ce.meshPerAttribute);
                            A.isInstancedMesh !== !0 && F._maxInstanceCount === void 0 && (F._maxInstanceCount = ce.meshPerAttribute * ce.count)
                        } else
                            for (let q = 0; q < K.locationSize; q++)
                                m(K.location + q);
                        i.bindBuffer(i.ARRAY_BUFFER, We);
                        for (let q = 0; q < K.locationSize; q++)
                            y(K.location + q, Ie / K.locationSize, se, ue, Ie * Se, Ie / K.locationSize * q * Se, be)
                    }
                } else if (H !== void 0) {
                    const ue = H[X];
                    if (ue !== void 0)
                        switch (ue.length) {
                        case 2:
                            i.vertexAttrib2fv(K.location, ue);
                            break;
                        case 3:
                            i.vertexAttrib3fv(K.location, ue);
                            break;
                        case 4:
                            i.vertexAttrib4fv(K.location, ue);
                            break;
                        default:
                            i.vertexAttrib1fv(K.location, ue)
                        }
                }
            }
        }
        _()
    }
    function S() {
        L();
        for (const A in n) {
            const k = n[A];
            for (const D in k) {
                const F = k[D];
                for (const z in F)
                    u(F[z].object),
                    delete F[z];
                delete k[D]
            }
            delete n[A]
        }
    }
    function C(A) {
        if (n[A.id] === void 0)
            return;
        const k = n[A.id];
        for (const D in k) {
            const F = k[D];
            for (const z in F)
                u(F[z].object),
                delete F[z];
            delete k[D]
        }
        delete n[A.id]
    }
    function M(A) {
        for (const k in n) {
            const D = n[k];
            if (D[A.id] === void 0)
                continue;
            const F = D[A.id];
            for (const z in F)
                u(F[z].object),
                delete F[z];
            delete D[A.id]
        }
    }
    function L() {
        T(),
        o = !0,
        r !== s && (r = s,
        c(r.object))
    }
    function T() {
        s.geometry = null,
        s.program = null,
        s.wireframe = !1
    }
    return {
        setup: a,
        reset: L,
        resetDefaultState: T,
        dispose: S,
        releaseStatesOfGeometry: C,
        releaseStatesOfProgram: M,
        initAttributes: g,
        enableAttribute: m,
        disableUnusedAttributes: _
    }
}
function sQ(i, e, t) {
    let n;
    function s(c) {
        n = c
    }
    function r(c, u) {
        i.drawArrays(n, c, u),
        t.update(u, n, 1)
    }
    function o(c, u, d) {
        d !== 0 && (i.drawArraysInstanced(n, c, u, d),
        t.update(u, n, d))
    }
    function a(c, u, d) {
        if (d === 0)
            return;
        e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(n, c, 0, u, 0, d);
        let h = 0;
        for (let p = 0; p < d; p++)
            h += u[p];
        t.update(h, n, 1)
    }
    function l(c, u, d, f) {
        if (d === 0)
            return;
        const h = e.get("WEBGL_multi_draw");
        if (h === null)
            for (let p = 0; p < c.length; p++)
                o(c[p], u[p], f[p]);
        else {
            h.multiDrawArraysInstancedWEBGL(n, c, 0, u, 0, f, 0, d);
            let p = 0;
            for (let g = 0; g < d; g++)
                p += u[g];
            for (let g = 0; g < f.length; g++)
                t.update(p, n, f[g])
        }
    }
    this.setMode = s,
    this.render = r,
    this.renderInstances = o,
    this.renderMultiDraw = a,
    this.renderMultiDrawInstances = l
}
function rQ(i, e, t, n) {
    let s;
    function r() {
        if (s !== void 0)
            return s;
        if (e.has("EXT_texture_filter_anisotropic") === !0) {
            const C = e.get("EXT_texture_filter_anisotropic");
            s = i.getParameter(C.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
        } else
            s = 0;
        return s
    }
    function o(C) {
        return !(C !== fr && n.convert(C) !== i.getParameter(i.IMPLEMENTATION_COLOR_READ_FORMAT))
    }
    function a(C) {
        const M = C === of && (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
        return !(C !== Fo && n.convert(C) !== i.getParameter(i.IMPLEMENTATION_COLOR_READ_TYPE) && C !== Ro && !M)
    }
    function l(C) {
        if (C === "highp") {
            if (i.getShaderPrecisionFormat(i.VERTEX_SHADER, i.HIGH_FLOAT).precision > 0 && i.getShaderPrecisionFormat(i.FRAGMENT_SHADER, i.HIGH_FLOAT).precision > 0)
                return "highp";
            C = "mediump"
        }
        return C === "mediump" && i.getShaderPrecisionFormat(i.VERTEX_SHADER, i.MEDIUM_FLOAT).precision > 0 && i.getShaderPrecisionFormat(i.FRAGMENT_SHADER, i.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
    }
    let c = t.precision !== void 0 ? t.precision : "highp";
    const u = l(c);
    u !== c && (console.warn("THREE.WebGLRenderer:", c, "not supported, using", u, "instead."),
    c = u);
    const d = t.logarithmicDepthBuffer === !0
      , f = i.getParameter(i.MAX_TEXTURE_IMAGE_UNITS)
      , h = i.getParameter(i.MAX_VERTEX_TEXTURE_IMAGE_UNITS)
      , p = i.getParameter(i.MAX_TEXTURE_SIZE)
      , g = i.getParameter(i.MAX_CUBE_MAP_TEXTURE_SIZE)
      , m = i.getParameter(i.MAX_VERTEX_ATTRIBS)
      , v = i.getParameter(i.MAX_VERTEX_UNIFORM_VECTORS)
      , _ = i.getParameter(i.MAX_VARYING_VECTORS)
      , y = i.getParameter(i.MAX_FRAGMENT_UNIFORM_VECTORS)
      , b = h > 0
      , S = i.getParameter(i.MAX_SAMPLES);
    return {
        isWebGL2: !0,
        getMaxAnisotropy: r,
        getMaxPrecision: l,
        textureFormatReadable: o,
        textureTypeReadable: a,
        precision: c,
        logarithmicDepthBuffer: d,
        maxTextures: f,
        maxVertexTextures: h,
        maxTextureSize: p,
        maxCubemapSize: g,
        maxAttributes: m,
        maxVertexUniforms: v,
        maxVaryings: _,
        maxFragmentUniforms: y,
        vertexTextures: b,
        maxSamples: S
    }
}
function oQ(i) {
    const e = this;
    let t = null
      , n = 0
      , s = !1
      , r = !1;
    const o = new nl
      , a = new Kt
      , l = {
        value: null,
        needsUpdate: !1
    };
    this.uniform = l,
    this.numPlanes = 0,
    this.numIntersection = 0,
    this.init = function(d, f) {
        const h = d.length !== 0 || f || n !== 0 || s;
        return s = f,
        n = d.length,
        h
    }
    ,
    this.beginShadows = function() {
        r = !0,
        u(null)
    }
    ,
    this.endShadows = function() {
        r = !1
    }
    ,
    this.setGlobalState = function(d, f) {
        t = u(d, f, 0)
    }
    ,
    this.setState = function(d, f, h) {
        const p = d.clippingPlanes
          , g = d.clipIntersection
          , m = d.clipShadows
          , v = i.get(d);
        if (!s || p === null || p.length === 0 || r && !m)
            r ? u(null) : c();
        else {
            const _ = r ? 0 : n
              , y = _ * 4;
            let b = v.clippingState || null;
            l.value = b,
            b = u(p, f, y, h);
            for (let S = 0; S !== y; ++S)
                b[S] = t[S];
            v.clippingState = b,
            this.numIntersection = g ? this.numPlanes : 0,
            this.numPlanes += _
        }
    }
    ;
    function c() {
        l.value !== t && (l.value = t,
        l.needsUpdate = n > 0),
        e.numPlanes = n,
        e.numIntersection = 0
    }
    function u(d, f, h, p) {
        const g = d !== null ? d.length : 0;
        let m = null;
        if (g !== 0) {
            if (m = l.value,
            p !== !0 || m === null) {
                const v = h + g * 4
                  , _ = f.matrixWorldInverse;
                a.getNormalMatrix(_),
                (m === null || m.length < v) && (m = new Float32Array(v));
                for (let y = 0, b = h; y !== g; ++y,
                b += 4)
                    o.copy(d[y]).applyMatrix4(_, a),
                    o.normal.toArray(m, b),
                    m[b + 3] = o.constant
            }
            l.value = m,
            l.needsUpdate = !0
        }
        return e.numPlanes = g,
        e.numIntersection = 0,
        m
    }
}
function aQ(i) {
    let e = new WeakMap;
    function t(o, a) {
        return a === ev ? o.mapping = fu : a === tv && (o.mapping = hu),
        o
    }
    function n(o) {
        if (o && o.isTexture) {
            const a = o.mapping;
            if (a === ev || a === tv)
                if (e.has(o)) {
                    const l = e.get(o).texture;
                    return t(l, o.mapping)
                } else {
                    const l = o.image;
                    if (l && l.height > 0) {
                        const c = new _Y(l.height);
                        return c.fromEquirectangularTexture(i, o),
                        e.set(o, c),
                        o.addEventListener("dispose", s),
                        t(c.texture, o.mapping)
                    } else
                        return null
                }
        }
        return o
    }
    function s(o) {
        const a = o.target;
        a.removeEventListener("dispose", s);
        const l = e.get(a);
        l !== void 0 && (e.delete(a),
        l.dispose())
    }
    function r() {
        e = new WeakMap
    }
    return {
        get: n,
        dispose: r
    }
}
class Ax extends _3 {
    constructor(e=-1, t=1, n=1, s=-1, r=.1, o=2e3) {
        super(),
        this.isOrthographicCamera = !0,
        this.type = "OrthographicCamera",
        this.zoom = 1,
        this.view = null,
        this.left = e,
        this.right = t,
        this.top = n,
        this.bottom = s,
        this.near = r,
        this.far = o,
        this.updateProjectionMatrix()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.left = e.left,
        this.right = e.right,
        this.top = e.top,
        this.bottom = e.bottom,
        this.near = e.near,
        this.far = e.far,
        this.zoom = e.zoom,
        this.view = e.view === null ? null : Object.assign({}, e.view),
        this
    }
    setViewOffset(e, t, n, s, r, o) {
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }),
        this.view.enabled = !0,
        this.view.fullWidth = e,
        this.view.fullHeight = t,
        this.view.offsetX = n,
        this.view.offsetY = s,
        this.view.width = r,
        this.view.height = o,
        this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = (this.right - this.left) / (2 * this.zoom)
          , t = (this.top - this.bottom) / (2 * this.zoom)
          , n = (this.right + this.left) / 2
          , s = (this.top + this.bottom) / 2;
        let r = n - e
          , o = n + e
          , a = s + t
          , l = s - t;
        if (this.view !== null && this.view.enabled) {
            const c = (this.right - this.left) / this.view.fullWidth / this.zoom
              , u = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            r += c * this.view.offsetX,
            o = r + c * this.view.width,
            a -= u * this.view.offsetY,
            l = a - u * this.view.height
        }
        this.projectionMatrix.makeOrthographic(r, o, a, l, this.near, this.far, this.coordinateSystem),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.zoom = this.zoom,
        t.object.left = this.left,
        t.object.right = this.right,
        t.object.top = this.top,
        t.object.bottom = this.bottom,
        t.object.near = this.near,
        t.object.far = this.far,
        this.view !== null && (t.object.view = Object.assign({}, this.view)),
        t
    }
}
const Cc = 4
  , uE = [.125, .215, .35, .446, .526, .582]
  , ll = 20
  , cg = new Ax
  , dE = new un;
let ug = null
  , dg = 0
  , fg = 0
  , hg = !1;
const il = (1 + Math.sqrt(5)) / 2
  , mc = 1 / il
  , fE = [new Te(-il,mc,0), new Te(il,mc,0), new Te(-mc,0,il), new Te(mc,0,il), new Te(0,il,-mc), new Te(0,il,mc), new Te(-1,1,-1), new Te(1,1,-1), new Te(-1,1,1), new Te(1,1,1)];
class hE {
    constructor(e) {
        this._renderer = e,
        this._pingPongRenderTarget = null,
        this._lodMax = 0,
        this._cubeSize = 0,
        this._lodPlanes = [],
        this._sizeLods = [],
        this._sigmas = [],
        this._blurMaterial = null,
        this._cubemapMaterial = null,
        this._equirectMaterial = null,
        this._compileMaterial(this._blurMaterial)
    }
    fromScene(e, t=0, n=.1, s=100) {
        ug = this._renderer.getRenderTarget(),
        dg = this._renderer.getActiveCubeFace(),
        fg = this._renderer.getActiveMipmapLevel(),
        hg = this._renderer.xr.enabled,
        this._renderer.xr.enabled = !1,
        this._setSize(256);
        const r = this._allocateTargets();
        return r.depthBuffer = !0,
        this._sceneToCubeUV(e, n, s, r),
        t > 0 && this._blur(r, 0, 0, t),
        this._applyPMREM(r),
        this._cleanup(r),
        r
    }
    fromEquirectangular(e, t=null) {
        return this._fromTexture(e, t)
    }
    fromCubemap(e, t=null) {
        return this._fromTexture(e, t)
    }
    compileCubemapShader() {
        this._cubemapMaterial === null && (this._cubemapMaterial = gE(),
        this._compileMaterial(this._cubemapMaterial))
    }
    compileEquirectangularShader() {
        this._equirectMaterial === null && (this._equirectMaterial = mE(),
        this._compileMaterial(this._equirectMaterial))
    }
    dispose() {
        this._dispose(),
        this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
        this._equirectMaterial !== null && this._equirectMaterial.dispose()
    }
    _setSize(e) {
        this._lodMax = Math.floor(Math.log2(e)),
        this._cubeSize = Math.pow(2, this._lodMax)
    }
    _dispose() {
        this._blurMaterial !== null && this._blurMaterial.dispose(),
        this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
        for (let e = 0; e < this._lodPlanes.length; e++)
            this._lodPlanes[e].dispose()
    }
    _cleanup(e) {
        this._renderer.setRenderTarget(ug, dg, fg),
        this._renderer.xr.enabled = hg,
        e.scissorTest = !1,
        uh(e, 0, 0, e.width, e.height)
    }
    _fromTexture(e, t) {
        e.mapping === fu || e.mapping === hu ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4),
        ug = this._renderer.getRenderTarget(),
        dg = this._renderer.getActiveCubeFace(),
        fg = this._renderer.getActiveMipmapLevel(),
        hg = this._renderer.xr.enabled,
        this._renderer.xr.enabled = !1;
        const n = t || this._allocateTargets();
        return this._textureToCubeUV(e, n),
        this._applyPMREM(n),
        this._cleanup(n),
        n
    }
    _allocateTargets() {
        const e = 3 * Math.max(this._cubeSize, 112)
          , t = 4 * this._cubeSize
          , n = {
            magFilter: ur,
            minFilter: ur,
            generateMipmaps: !1,
            type: of,
            format: fr,
            colorSpace: ka,
            depthBuffer: !1
        }
          , s = pE(e, t, n);
        if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
            this._pingPongRenderTarget !== null && this._dispose(),
            this._pingPongRenderTarget = pE(e, t, n);
            const {_lodMax: r} = this;
            ({sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas} = lQ(r)),
            this._blurMaterial = cQ(r, e, t)
        }
        return s
    }
    _compileMaterial(e) {
        const t = new Br(this._lodPlanes[0],e);
        this._renderer.compile(t, cg)
    }
    _sceneToCubeUV(e, t, n, s) {
        const a = new ar(90,1,t,n)
          , l = [1, -1, 1, 1, 1, 1]
          , c = [1, 1, 1, -1, -1, -1]
          , u = this._renderer
          , d = u.autoClear
          , f = u.toneMapping;
        u.getClearColor(dE),
        u.toneMapping = xa,
        u.autoClear = !1;
        const h = new p3({
            name: "PMREM.Background",
            side: os,
            depthWrite: !1,
            depthTest: !1
        })
          , p = new Br(new df,h);
        let g = !1;
        const m = e.background;
        m ? m.isColor && (h.color.copy(m),
        e.background = null,
        g = !0) : (h.color.copy(dE),
        g = !0);
        for (let v = 0; v < 6; v++) {
            const _ = v % 3;
            _ === 0 ? (a.up.set(0, l[v], 0),
            a.lookAt(c[v], 0, 0)) : _ === 1 ? (a.up.set(0, 0, l[v]),
            a.lookAt(0, c[v], 0)) : (a.up.set(0, l[v], 0),
            a.lookAt(0, 0, c[v]));
            const y = this._cubeSize;
            uh(s, _ * y, v > 2 ? y : 0, y, y),
            u.setRenderTarget(s),
            g && u.render(p, a),
            u.render(e, a)
        }
        p.geometry.dispose(),
        p.material.dispose(),
        u.toneMapping = f,
        u.autoClear = d,
        e.background = m
    }
    _textureToCubeUV(e, t) {
        const n = this._renderer
          , s = e.mapping === fu || e.mapping === hu;
        s ? (this._cubemapMaterial === null && (this._cubemapMaterial = gE()),
        this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = mE());
        const r = s ? this._cubemapMaterial : this._equirectMaterial
          , o = new Br(this._lodPlanes[0],r)
          , a = r.uniforms;
        a.envMap.value = e;
        const l = this._cubeSize;
        uh(t, 0, 0, 3 * l, 2 * l),
        n.setRenderTarget(t),
        n.render(o, cg)
    }
    _applyPMREM(e) {
        const t = this._renderer
          , n = t.autoClear;
        t.autoClear = !1;
        const s = this._lodPlanes.length;
        for (let r = 1; r < s; r++) {
            const o = Math.sqrt(this._sigmas[r] * this._sigmas[r] - this._sigmas[r - 1] * this._sigmas[r - 1])
              , a = fE[(s - r - 1) % fE.length];
            this._blur(e, r - 1, r, o, a)
        }
        t.autoClear = n
    }
    _blur(e, t, n, s, r) {
        const o = this._pingPongRenderTarget;
        this._halfBlur(e, o, t, n, s, "latitudinal", r),
        this._halfBlur(o, e, n, n, s, "longitudinal", r)
    }
    _halfBlur(e, t, n, s, r, o, a) {
        const l = this._renderer
          , c = this._blurMaterial;
        o !== "latitudinal" && o !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
        const u = 3
          , d = new Br(this._lodPlanes[s],c)
          , f = c.uniforms
          , h = this._sizeLods[n] - 1
          , p = isFinite(r) ? Math.PI / (2 * h) : 2 * Math.PI / (2 * ll - 1)
          , g = r / p
          , m = isFinite(r) ? 1 + Math.floor(u * g) : ll;
        m > ll && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${m} samples when the maximum is set to ${ll}`);
        const v = [];
        let _ = 0;
        for (let M = 0; M < ll; ++M) {
            const L = M / g
              , T = Math.exp(-L * L / 2);
            v.push(T),
            M === 0 ? _ += T : M < m && (_ += 2 * T)
        }
        for (let M = 0; M < v.length; M++)
            v[M] = v[M] / _;
        f.envMap.value = e.texture,
        f.samples.value = m,
        f.weights.value = v,
        f.latitudinal.value = o === "latitudinal",
        a && (f.poleAxis.value = a);
        const {_lodMax: y} = this;
        f.dTheta.value = p,
        f.mipInt.value = y - n;
        const b = this._sizeLods[s]
          , S = 3 * b * (s > y - Cc ? s - y + Cc : 0)
          , C = 4 * (this._cubeSize - b);
        uh(t, S, C, 3 * b, 2 * b),
        l.setRenderTarget(t),
        l.render(d, cg)
    }
}
function lQ(i) {
    const e = []
      , t = []
      , n = [];
    let s = i;
    const r = i - Cc + 1 + uE.length;
    for (let o = 0; o < r; o++) {
        const a = Math.pow(2, s);
        t.push(a);
        let l = 1 / a;
        o > i - Cc ? l = uE[o - i + Cc - 1] : o === 0 && (l = 0),
        n.push(l);
        const c = 1 / (a - 2)
          , u = -c
          , d = 1 + c
          , f = [u, u, d, u, d, d, u, u, d, d, u, d]
          , h = 6
          , p = 6
          , g = 3
          , m = 2
          , v = 1
          , _ = new Float32Array(g * p * h)
          , y = new Float32Array(m * p * h)
          , b = new Float32Array(v * p * h);
        for (let C = 0; C < h; C++) {
            const M = C % 3 * 2 / 3 - 1
              , L = C > 2 ? 0 : -1
              , T = [M, L, 0, M + 2 / 3, L, 0, M + 2 / 3, L + 1, 0, M, L, 0, M + 2 / 3, L + 1, 0, M, L + 1, 0];
            _.set(T, g * p * C),
            y.set(f, m * p * C);
            const A = [C, C, C, C, C, C];
            b.set(A, v * p * C)
        }
        const S = new Pa;
        S.setAttribute("position", new zr(_,g)),
        S.setAttribute("uv", new zr(y,m)),
        S.setAttribute("faceIndex", new zr(b,v)),
        e.push(S),
        s > Cc && s--
    }
    return {
        lodPlanes: e,
        sizeLods: t,
        sigmas: n
    }
}
function pE(i, e, t) {
    const n = new Dl(i,e,t);
    return n.texture.mapping = Mm,
    n.texture.name = "PMREM.cubeUv",
    n.scissorTest = !0,
    n
}
function uh(i, e, t, n, s) {
    i.viewport.set(e, t, n, s),
    i.scissor.set(e, t, n, s)
}
function cQ(i, e, t) {
    const n = new Float32Array(ll)
      , s = new Te(0,1,0);
    return new Aa({
        name: "SphericalGaussianBlur",
        defines: {
            n: ll,
            CUBEUV_TEXEL_WIDTH: 1 / e,
            CUBEUV_TEXEL_HEIGHT: 1 / t,
            CUBEUV_MAX_MIP: `${i}.0`
        },
        uniforms: {
            envMap: {
                value: null
            },
            samples: {
                value: 1
            },
            weights: {
                value: n
            },
            latitudinal: {
                value: !1
            },
            dTheta: {
                value: 0
            },
            mipInt: {
                value: 0
            },
            poleAxis: {
                value: s
            }
        },
        vertexShader: Cx(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
        blending: _a,
        depthTest: !1,
        depthWrite: !1
    })
}
function mE() {
    return new Aa({
        name: "EquirectangularToCubeUV",
        uniforms: {
            envMap: {
                value: null
            }
        },
        vertexShader: Cx(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
        blending: _a,
        depthTest: !1,
        depthWrite: !1
    })
}
function gE() {
    return new Aa({
        name: "CubemapToCubeUV",
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            }
        },
        vertexShader: Cx(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
        blending: _a,
        depthTest: !1,
        depthWrite: !1
    })
}
function Cx() {
    return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
}
function uQ(i) {
    let e = new WeakMap
      , t = null;
    function n(a) {
        if (a && a.isTexture) {
            const l = a.mapping
              , c = l === ev || l === tv
              , u = l === fu || l === hu;
            if (c || u) {
                let d = e.get(a);
                const f = d !== void 0 ? d.texture.pmremVersion : 0;
                if (a.isRenderTargetTexture && a.pmremVersion !== f)
                    return t === null && (t = new hE(i)),
                    d = c ? t.fromEquirectangular(a, d) : t.fromCubemap(a, d),
                    d.texture.pmremVersion = a.pmremVersion,
                    e.set(a, d),
                    d.texture;
                if (d !== void 0)
                    return d.texture;
                {
                    const h = a.image;
                    return c && h && h.height > 0 || u && h && s(h) ? (t === null && (t = new hE(i)),
                    d = c ? t.fromEquirectangular(a) : t.fromCubemap(a),
                    d.texture.pmremVersion = a.pmremVersion,
                    e.set(a, d),
                    a.addEventListener("dispose", r),
                    d.texture) : null
                }
            }
        }
        return a
    }
    function s(a) {
        let l = 0;
        const c = 6;
        for (let u = 0; u < c; u++)
            a[u] !== void 0 && l++;
        return l === c
    }
    function r(a) {
        const l = a.target;
        l.removeEventListener("dispose", r);
        const c = e.get(l);
        c !== void 0 && (e.delete(l),
        c.dispose())
    }
    function o() {
        e = new WeakMap,
        t !== null && (t.dispose(),
        t = null)
    }
    return {
        get: n,
        dispose: o
    }
}
function dQ(i) {
    const e = {};
    function t(n) {
        if (e[n] !== void 0)
            return e[n];
        let s;
        switch (n) {
        case "WEBGL_depth_texture":
            s = i.getExtension("WEBGL_depth_texture") || i.getExtension("MOZ_WEBGL_depth_texture") || i.getExtension("WEBKIT_WEBGL_depth_texture");
            break;
        case "EXT_texture_filter_anisotropic":
            s = i.getExtension("EXT_texture_filter_anisotropic") || i.getExtension("MOZ_EXT_texture_filter_anisotropic") || i.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;
        case "WEBGL_compressed_texture_s3tc":
            s = i.getExtension("WEBGL_compressed_texture_s3tc") || i.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || i.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;
        case "WEBGL_compressed_texture_pvrtc":
            s = i.getExtension("WEBGL_compressed_texture_pvrtc") || i.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;
        default:
            s = i.getExtension(n)
        }
        return e[n] = s,
        s
    }
    return {
        has: function(n) {
            return t(n) !== null
        },
        init: function() {
            t("EXT_color_buffer_float"),
            t("WEBGL_clip_cull_distance"),
            t("OES_texture_float_linear"),
            t("EXT_color_buffer_half_float"),
            t("WEBGL_multisampled_render_to_texture"),
            t("WEBGL_render_shared_exponent")
        },
        get: function(n) {
            const s = t(n);
            return s === null && hd("THREE.WebGLRenderer: " + n + " extension not supported."),
            s
        }
    }
}
function fQ(i, e, t, n) {
    const s = {}
      , r = new WeakMap;
    function o(d) {
        const f = d.target;
        f.index !== null && e.remove(f.index);
        for (const p in f.attributes)
            e.remove(f.attributes[p]);
        for (const p in f.morphAttributes) {
            const g = f.morphAttributes[p];
            for (let m = 0, v = g.length; m < v; m++)
                e.remove(g[m])
        }
        f.removeEventListener("dispose", o),
        delete s[f.id];
        const h = r.get(f);
        h && (e.remove(h),
        r.delete(f)),
        n.releaseStatesOfGeometry(f),
        f.isInstancedBufferGeometry === !0 && delete f._maxInstanceCount,
        t.memory.geometries--
    }
    function a(d, f) {
        return s[f.id] === !0 || (f.addEventListener("dispose", o),
        s[f.id] = !0,
        t.memory.geometries++),
        f
    }
    function l(d) {
        const f = d.attributes;
        for (const p in f)
            e.update(f[p], i.ARRAY_BUFFER);
        const h = d.morphAttributes;
        for (const p in h) {
            const g = h[p];
            for (let m = 0, v = g.length; m < v; m++)
                e.update(g[m], i.ARRAY_BUFFER)
        }
    }
    function c(d) {
        const f = []
          , h = d.index
          , p = d.attributes.position;
        let g = 0;
        if (h !== null) {
            const _ = h.array;
            g = h.version;
            for (let y = 0, b = _.length; y < b; y += 3) {
                const S = _[y + 0]
                  , C = _[y + 1]
                  , M = _[y + 2];
                f.push(S, C, C, M, M, S)
            }
        } else if (p !== void 0) {
            const _ = p.array;
            g = p.version;
            for (let y = 0, b = _.length / 3 - 1; y < b; y += 3) {
                const S = y + 0
                  , C = y + 1
                  , M = y + 2;
                f.push(S, C, C, M, M, S)
            }
        } else
            return;
        const m = new (c3(f) ? g3 : m3)(f,1);
        m.version = g;
        const v = r.get(d);
        v && e.remove(v),
        r.set(d, m)
    }
    function u(d) {
        const f = r.get(d);
        if (f) {
            const h = d.index;
            h !== null && f.version < h.version && c(d)
        } else
            c(d);
        return r.get(d)
    }
    return {
        get: a,
        update: l,
        getWireframeAttribute: u
    }
}
function hQ(i, e, t) {
    let n;
    function s(f) {
        n = f
    }
    let r, o;
    function a(f) {
        r = f.type,
        o = f.bytesPerElement
    }
    function l(f, h) {
        i.drawElements(n, h, r, f * o),
        t.update(h, n, 1)
    }
    function c(f, h, p) {
        p !== 0 && (i.drawElementsInstanced(n, h, r, f * o, p),
        t.update(h, n, p))
    }
    function u(f, h, p) {
        if (p === 0)
            return;
        e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(n, h, 0, r, f, 0, p);
        let m = 0;
        for (let v = 0; v < p; v++)
            m += h[v];
        t.update(m, n, 1)
    }
    function d(f, h, p, g) {
        if (p === 0)
            return;
        const m = e.get("WEBGL_multi_draw");
        if (m === null)
            for (let v = 0; v < f.length; v++)
                c(f[v] / o, h[v], g[v]);
        else {
            m.multiDrawElementsInstancedWEBGL(n, h, 0, r, f, 0, g, 0, p);
            let v = 0;
            for (let _ = 0; _ < p; _++)
                v += h[_];
            for (let _ = 0; _ < g.length; _++)
                t.update(v, n, g[_])
        }
    }
    this.setMode = s,
    this.setIndex = a,
    this.render = l,
    this.renderInstances = c,
    this.renderMultiDraw = u,
    this.renderMultiDrawInstances = d
}
function pQ(i) {
    const e = {
        geometries: 0,
        textures: 0
    }
      , t = {
        frame: 0,
        calls: 0,
        triangles: 0,
        points: 0,
        lines: 0
    };
    function n(r, o, a) {
        switch (t.calls++,
        o) {
        case i.TRIANGLES:
            t.triangles += a * (r / 3);
            break;
        case i.LINES:
            t.lines += a * (r / 2);
            break;
        case i.LINE_STRIP:
            t.lines += a * (r - 1);
            break;
        case i.LINE_LOOP:
            t.lines += a * r;
            break;
        case i.POINTS:
            t.points += a * r;
            break;
        default:
            console.error("THREE.WebGLInfo: Unknown draw mode:", o);
            break
        }
    }
    function s() {
        t.calls = 0,
        t.triangles = 0,
        t.points = 0,
        t.lines = 0
    }
    return {
        memory: e,
        render: t,
        programs: null,
        autoReset: !0,
        reset: s,
        update: n
    }
}
function mQ(i, e, t) {
    const n = new WeakMap
      , s = new oi;
    function r(o, a, l) {
        const c = o.morphTargetInfluences
          , u = a.morphAttributes.position || a.morphAttributes.normal || a.morphAttributes.color
          , d = u !== void 0 ? u.length : 0;
        let f = n.get(a);
        if (f === void 0 || f.count !== d) {
            let T = function() {
                M.dispose(),
                n.delete(a),
                a.removeEventListener("dispose", T)
            };
            f !== void 0 && f.texture.dispose();
            const h = a.morphAttributes.position !== void 0
              , p = a.morphAttributes.normal !== void 0
              , g = a.morphAttributes.color !== void 0
              , m = a.morphAttributes.position || []
              , v = a.morphAttributes.normal || []
              , _ = a.morphAttributes.color || [];
            let y = 0;
            h === !0 && (y = 1),
            p === !0 && (y = 2),
            g === !0 && (y = 3);
            let b = a.attributes.position.count * y
              , S = 1;
            b > e.maxTextureSize && (S = Math.ceil(b / e.maxTextureSize),
            b = e.maxTextureSize);
            const C = new Float32Array(b * S * 4 * d)
              , M = new d3(C,b,S,d);
            M.type = Ro,
            M.needsUpdate = !0;
            const L = y * 4;
            for (let A = 0; A < d; A++) {
                const k = m[A]
                  , D = v[A]
                  , F = _[A]
                  , z = b * S * 4 * A;
                for (let G = 0; G < k.count; G++) {
                    const H = G * L;
                    h === !0 && (s.fromBufferAttribute(k, G),
                    C[z + H + 0] = s.x,
                    C[z + H + 1] = s.y,
                    C[z + H + 2] = s.z,
                    C[z + H + 3] = 0),
                    p === !0 && (s.fromBufferAttribute(D, G),
                    C[z + H + 4] = s.x,
                    C[z + H + 5] = s.y,
                    C[z + H + 6] = s.z,
                    C[z + H + 7] = 0),
                    g === !0 && (s.fromBufferAttribute(F, G),
                    C[z + H + 8] = s.x,
                    C[z + H + 9] = s.y,
                    C[z + H + 10] = s.z,
                    C[z + H + 11] = F.itemSize === 4 ? s.w : 1)
                }
            }
            f = {
                count: d,
                texture: M,
                size: new nn(b,S)
            },
            n.set(a, f),
            a.addEventListener("dispose", T)
        }
        if (o.isInstancedMesh === !0 && o.morphTexture !== null)
            l.getUniforms().setValue(i, "morphTexture", o.morphTexture, t);
        else {
            let h = 0;
            for (let g = 0; g < c.length; g++)
                h += c[g];
            const p = a.morphTargetsRelative ? 1 : 1 - h;
            l.getUniforms().setValue(i, "morphTargetBaseInfluence", p),
            l.getUniforms().setValue(i, "morphTargetInfluences", c)
        }
        l.getUniforms().setValue(i, "morphTargetsTexture", f.texture, t),
        l.getUniforms().setValue(i, "morphTargetsTextureSize", f.size)
    }
    return {
        update: r
    }
}
function gQ(i, e, t, n) {
    let s = new WeakMap;
    function r(l) {
        const c = n.render.frame
          , u = l.geometry
          , d = e.get(l, u);
        if (s.get(d) !== c && (e.update(d),
        s.set(d, c)),
        l.isInstancedMesh && (l.hasEventListener("dispose", a) === !1 && l.addEventListener("dispose", a),
        s.get(l) !== c && (t.update(l.instanceMatrix, i.ARRAY_BUFFER),
        l.instanceColor !== null && t.update(l.instanceColor, i.ARRAY_BUFFER),
        s.set(l, c))),
        l.isSkinnedMesh) {
            const f = l.skeleton;
            s.get(f) !== c && (f.update(),
            s.set(f, c))
        }
        return d
    }
    function o() {
        s = new WeakMap
    }
    function a(l) {
        const c = l.target;
        c.removeEventListener("dispose", a),
        t.remove(c.instanceMatrix),
        c.instanceColor !== null && t.remove(c.instanceColor)
    }
    return {
        update: r,
        dispose: o
    }
}
class b3 extends as {
    constructor(e, t, n, s, r, o, a, l, c, u=Wc) {
        if (u !== Wc && u !== mu)
            throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        n === void 0 && u === Wc && (n = Pl),
        n === void 0 && u === mu && (n = pu),
        super(null, s, r, o, a, l, u, n, c),
        this.isDepthTexture = !0,
        this.image = {
            width: e,
            height: t
        },
        this.magFilter = a !== void 0 ? a : Ns,
        this.minFilter = l !== void 0 ? l : Ns,
        this.flipY = !1,
        this.generateMipmaps = !1,
        this.compareFunction = null
    }
    copy(e) {
        return super.copy(e),
        this.compareFunction = e.compareFunction,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return this.compareFunction !== null && (t.compareFunction = this.compareFunction),
        t
    }
}
const S3 = new as
  , vE = new b3(1,1)
  , E3 = new d3
  , w3 = new tY
  , T3 = new x3
  , _E = []
  , xE = []
  , yE = new Float32Array(16)
  , bE = new Float32Array(9)
  , SE = new Float32Array(4);
function Au(i, e, t) {
    const n = i[0];
    if (n <= 0 || n > 0)
        return i;
    const s = e * t;
    let r = _E[s];
    if (r === void 0 && (r = new Float32Array(s),
    _E[s] = r),
    e !== 0) {
        n.toArray(r, 0);
        for (let o = 1, a = 0; o !== e; ++o)
            a += t,
            i[o].toArray(r, a)
    }
    return r
}
function ui(i, e) {
    if (i.length !== e.length)
        return !1;
    for (let t = 0, n = i.length; t < n; t++)
        if (i[t] !== e[t])
            return !1;
    return !0
}
function di(i, e) {
    for (let t = 0, n = e.length; t < n; t++)
        i[t] = e[t]
}
function Im(i, e) {
    let t = xE[e];
    t === void 0 && (t = new Int32Array(e),
    xE[e] = t);
    for (let n = 0; n !== e; ++n)
        t[n] = i.allocateTextureUnit();
    return t
}
function vQ(i, e) {
    const t = this.cache;
    t[0] !== e && (i.uniform1f(this.addr, e),
    t[0] = e)
}
function _Q(i, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) && (i.uniform2f(this.addr, e.x, e.y),
        t[0] = e.x,
        t[1] = e.y);
    else {
        if (ui(t, e))
            return;
        i.uniform2fv(this.addr, e),
        di(t, e)
    }
}
function xQ(i, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (i.uniform3f(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
    else if (e.r !== void 0)
        (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (i.uniform3f(this.addr, e.r, e.g, e.b),
        t[0] = e.r,
        t[1] = e.g,
        t[2] = e.b);
    else {
        if (ui(t, e))
            return;
        i.uniform3fv(this.addr, e),
        di(t, e)
    }
}
function yQ(i, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (i.uniform4f(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
    else {
        if (ui(t, e))
            return;
        i.uniform4fv(this.addr, e),
        di(t, e)
    }
}
function bQ(i, e) {
    const t = this.cache
      , n = e.elements;
    if (n === void 0) {
        if (ui(t, e))
            return;
        i.uniformMatrix2fv(this.addr, !1, e),
        di(t, e)
    } else {
        if (ui(t, n))
            return;
        SE.set(n),
        i.uniformMatrix2fv(this.addr, !1, SE),
        di(t, n)
    }
}
function SQ(i, e) {
    const t = this.cache
      , n = e.elements;
    if (n === void 0) {
        if (ui(t, e))
            return;
        i.uniformMatrix3fv(this.addr, !1, e),
        di(t, e)
    } else {
        if (ui(t, n))
            return;
        bE.set(n),
        i.uniformMatrix3fv(this.addr, !1, bE),
        di(t, n)
    }
}
function EQ(i, e) {
    const t = this.cache
      , n = e.elements;
    if (n === void 0) {
        if (ui(t, e))
            return;
        i.uniformMatrix4fv(this.addr, !1, e),
        di(t, e)
    } else {
        if (ui(t, n))
            return;
        yE.set(n),
        i.uniformMatrix4fv(this.addr, !1, yE),
        di(t, n)
    }
}
function wQ(i, e) {
    const t = this.cache;
    t[0] !== e && (i.uniform1i(this.addr, e),
    t[0] = e)
}
function TQ(i, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) && (i.uniform2i(this.addr, e.x, e.y),
        t[0] = e.x,
        t[1] = e.y);
    else {
        if (ui(t, e))
            return;
        i.uniform2iv(this.addr, e),
        di(t, e)
    }
}
function AQ(i, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (i.uniform3i(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
    else {
        if (ui(t, e))
            return;
        i.uniform3iv(this.addr, e),
        di(t, e)
    }
}
function CQ(i, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (i.uniform4i(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
    else {
        if (ui(t, e))
            return;
        i.uniform4iv(this.addr, e),
        di(t, e)
    }
}
function MQ(i, e) {
    const t = this.cache;
    t[0] !== e && (i.uniform1ui(this.addr, e),
    t[0] = e)
}
function RQ(i, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) && (i.uniform2ui(this.addr, e.x, e.y),
        t[0] = e.x,
        t[1] = e.y);
    else {
        if (ui(t, e))
            return;
        i.uniform2uiv(this.addr, e),
        di(t, e)
    }
}
function LQ(i, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (i.uniform3ui(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
    else {
        if (ui(t, e))
            return;
        i.uniform3uiv(this.addr, e),
        di(t, e)
    }
}
function IQ(i, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (i.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
    else {
        if (ui(t, e))
            return;
        i.uniform4uiv(this.addr, e),
        di(t, e)
    }
}
function kQ(i, e, t) {
    const n = this.cache
      , s = t.allocateTextureUnit();
    n[0] !== s && (i.uniform1i(this.addr, s),
    n[0] = s);
    let r;
    this.type === i.SAMPLER_2D_SHADOW ? (vE.compareFunction = l3,
    r = vE) : r = S3,
    t.setTexture2D(e || r, s)
}
function PQ(i, e, t) {
    const n = this.cache
      , s = t.allocateTextureUnit();
    n[0] !== s && (i.uniform1i(this.addr, s),
    n[0] = s),
    t.setTexture3D(e || w3, s)
}
function DQ(i, e, t) {
    const n = this.cache
      , s = t.allocateTextureUnit();
    n[0] !== s && (i.uniform1i(this.addr, s),
    n[0] = s),
    t.setTextureCube(e || T3, s)
}
function FQ(i, e, t) {
    const n = this.cache
      , s = t.allocateTextureUnit();
    n[0] !== s && (i.uniform1i(this.addr, s),
    n[0] = s),
    t.setTexture2DArray(e || E3, s)
}
function OQ(i) {
    switch (i) {
    case 5126:
        return vQ;
    case 35664:
        return _Q;
    case 35665:
        return xQ;
    case 35666:
        return yQ;
    case 35674:
        return bQ;
    case 35675:
        return SQ;
    case 35676:
        return EQ;
    case 5124:
    case 35670:
        return wQ;
    case 35667:
    case 35671:
        return TQ;
    case 35668:
    case 35672:
        return AQ;
    case 35669:
    case 35673:
        return CQ;
    case 5125:
        return MQ;
    case 36294:
        return RQ;
    case 36295:
        return LQ;
    case 36296:
        return IQ;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
        return kQ;
    case 35679:
    case 36299:
    case 36307:
        return PQ;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
        return DQ;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
        return FQ
    }
}
function UQ(i, e) {
    i.uniform1fv(this.addr, e)
}
function NQ(i, e) {
    const t = Au(e, this.size, 2);
    i.uniform2fv(this.addr, t)
}
function BQ(i, e) {
    const t = Au(e, this.size, 3);
    i.uniform3fv(this.addr, t)
}
function VQ(i, e) {
    const t = Au(e, this.size, 4);
    i.uniform4fv(this.addr, t)
}
function $Q(i, e) {
    const t = Au(e, this.size, 4);
    i.uniformMatrix2fv(this.addr, !1, t)
}
function HQ(i, e) {
    const t = Au(e, this.size, 9);
    i.uniformMatrix3fv(this.addr, !1, t)
}
function zQ(i, e) {
    const t = Au(e, this.size, 16);
    i.uniformMatrix4fv(this.addr, !1, t)
}
function GQ(i, e) {
    i.uniform1iv(this.addr, e)
}
function WQ(i, e) {
    i.uniform2iv(this.addr, e)
}
function qQ(i, e) {
    i.uniform3iv(this.addr, e)
}
function jQ(i, e) {
    i.uniform4iv(this.addr, e)
}
function KQ(i, e) {
    i.uniform1uiv(this.addr, e)
}
function XQ(i, e) {
    i.uniform2uiv(this.addr, e)
}
function YQ(i, e) {
    i.uniform3uiv(this.addr, e)
}
function ZQ(i, e) {
    i.uniform4uiv(this.addr, e)
}
function JQ(i, e, t) {
    const n = this.cache
      , s = e.length
      , r = Im(t, s);
    ui(n, r) || (i.uniform1iv(this.addr, r),
    di(n, r));
    for (let o = 0; o !== s; ++o)
        t.setTexture2D(e[o] || S3, r[o])
}
function QQ(i, e, t) {
    const n = this.cache
      , s = e.length
      , r = Im(t, s);
    ui(n, r) || (i.uniform1iv(this.addr, r),
    di(n, r));
    for (let o = 0; o !== s; ++o)
        t.setTexture3D(e[o] || w3, r[o])
}
function eee(i, e, t) {
    const n = this.cache
      , s = e.length
      , r = Im(t, s);
    ui(n, r) || (i.uniform1iv(this.addr, r),
    di(n, r));
    for (let o = 0; o !== s; ++o)
        t.setTextureCube(e[o] || T3, r[o])
}
function tee(i, e, t) {
    const n = this.cache
      , s = e.length
      , r = Im(t, s);
    ui(n, r) || (i.uniform1iv(this.addr, r),
    di(n, r));
    for (let o = 0; o !== s; ++o)
        t.setTexture2DArray(e[o] || E3, r[o])
}
function nee(i) {
    switch (i) {
    case 5126:
        return UQ;
    case 35664:
        return NQ;
    case 35665:
        return BQ;
    case 35666:
        return VQ;
    case 35674:
        return $Q;
    case 35675:
        return HQ;
    case 35676:
        return zQ;
    case 5124:
    case 35670:
        return GQ;
    case 35667:
    case 35671:
        return WQ;
    case 35668:
    case 35672:
        return qQ;
    case 35669:
    case 35673:
        return jQ;
    case 5125:
        return KQ;
    case 36294:
        return XQ;
    case 36295:
        return YQ;
    case 36296:
        return ZQ;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
        return JQ;
    case 35679:
    case 36299:
    case 36307:
        return QQ;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
        return eee;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
        return tee
    }
}
class iee {
    constructor(e, t, n) {
        this.id = e,
        this.addr = n,
        this.cache = [],
        this.type = t.type,
        this.setValue = OQ(t.type)
    }
}
class see {
    constructor(e, t, n) {
        this.id = e,
        this.addr = n,
        this.cache = [],
        this.type = t.type,
        this.size = t.size,
        this.setValue = nee(t.type)
    }
}
class ree {
    constructor(e) {
        this.id = e,
        this.seq = [],
        this.map = {}
    }
    setValue(e, t, n) {
        const s = this.seq;
        for (let r = 0, o = s.length; r !== o; ++r) {
            const a = s[r];
            a.setValue(e, t[a.id], n)
        }
    }
}
const pg = /(\w+)(\])?(\[|\.)?/g;
function EE(i, e) {
    i.seq.push(e),
    i.map[e.id] = e
}
function oee(i, e, t) {
    const n = i.name
      , s = n.length;
    for (pg.lastIndex = 0; ; ) {
        const r = pg.exec(n)
          , o = pg.lastIndex;
        let a = r[1];
        const l = r[2] === "]"
          , c = r[3];
        if (l && (a = a | 0),
        c === void 0 || c === "[" && o + 2 === s) {
            EE(t, c === void 0 ? new iee(a,i,e) : new see(a,i,e));
            break
        } else {
            let d = t.map[a];
            d === void 0 && (d = new ree(a),
            EE(t, d)),
            t = d
        }
    }
}
class Vh {
    constructor(e, t) {
        this.seq = [],
        this.map = {};
        const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
        for (let s = 0; s < n; ++s) {
            const r = e.getActiveUniform(t, s)
              , o = e.getUniformLocation(t, r.name);
            oee(r, o, this)
        }
    }
    setValue(e, t, n, s) {
        const r = this.map[t];
        r !== void 0 && r.setValue(e, n, s)
    }
    setOptional(e, t, n) {
        const s = t[n];
        s !== void 0 && this.setValue(e, n, s)
    }
    static upload(e, t, n, s) {
        for (let r = 0, o = t.length; r !== o; ++r) {
            const a = t[r]
              , l = n[a.id];
            l.needsUpdate !== !1 && a.setValue(e, l.value, s)
        }
    }
    static seqWithValue(e, t) {
        const n = [];
        for (let s = 0, r = e.length; s !== r; ++s) {
            const o = e[s];
            o.id in t && n.push(o)
        }
        return n
    }
}
function wE(i, e, t) {
    const n = i.createShader(e);
    return i.shaderSource(n, t),
    i.compileShader(n),
    n
}
const aee = 37297;
let lee = 0;
function cee(i, e) {
    const t = i.split(`
`)
      , n = []
      , s = Math.max(e - 6, 0)
      , r = Math.min(e + 6, t.length);
    for (let o = s; o < r; o++) {
        const a = o + 1;
        n.push(`${a === e ? ">" : " "} ${a}: ${t[o]}`)
    }
    return n.join(`
`)
}
function uee(i) {
    const e = pn.getPrimaries(pn.workingColorSpace)
      , t = pn.getPrimaries(i);
    let n;
    switch (e === t ? n = "" : e === Bp && t === Np ? n = "LinearDisplayP3ToLinearSRGB" : e === Np && t === Bp && (n = "LinearSRGBToLinearDisplayP3"),
    i) {
    case ka:
    case Rm:
        return [n, "LinearTransferOETF"];
    case Lr:
    case Ex:
        return [n, "sRGBTransferOETF"];
    default:
        return console.warn("THREE.WebGLProgram: Unsupported color space:", i),
        [n, "LinearTransferOETF"]
    }
}
function TE(i, e, t) {
    const n = i.getShaderParameter(e, i.COMPILE_STATUS)
      , s = i.getShaderInfoLog(e).trim();
    if (n && s === "")
        return "";
    const r = /ERROR: 0:(\d+)/.exec(s);
    if (r) {
        const o = parseInt(r[1]);
        return t.toUpperCase() + `

` + s + `

` + cee(i.getShaderSource(e), o)
    } else
        return s
}
function dee(i, e) {
    const t = uee(e);
    return `vec4 ${i}( vec4 value ) { return ${t[0]}( ${t[1]}( value ) ); }`
}
function fee(i, e) {
    let t;
    switch (e) {
    case RX:
        t = "Linear";
        break;
    case LX:
        t = "Reinhard";
        break;
    case IX:
        t = "Cineon";
        break;
    case kX:
        t = "ACESFilmic";
        break;
    case DX:
        t = "AgX";
        break;
    case FX:
        t = "Neutral";
        break;
    case PX:
        t = "Custom";
        break;
    default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        t = "Linear"
    }
    return "vec3 " + i + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
}
const dh = new Te;
function hee() {
    pn.getLuminanceCoefficients(dh);
    const i = dh.x.toFixed(4)
      , e = dh.y.toFixed(4)
      , t = dh.z.toFixed(4);
    return ["float luminance( const in vec3 rgb ) {", `	const vec3 weights = vec3( ${i}, ${e}, ${t} );`, "	return dot( weights, rgb );", "}"].join(`
`)
}
function pee(i) {
    return [i.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", i.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(Zu).join(`
`)
}
function mee(i) {
    const e = [];
    for (const t in i) {
        const n = i[t];
        n !== !1 && e.push("#define " + t + " " + n)
    }
    return e.join(`
`)
}
function gee(i, e) {
    const t = {}
      , n = i.getProgramParameter(e, i.ACTIVE_ATTRIBUTES);
    for (let s = 0; s < n; s++) {
        const r = i.getActiveAttrib(e, s)
          , o = r.name;
        let a = 1;
        r.type === i.FLOAT_MAT2 && (a = 2),
        r.type === i.FLOAT_MAT3 && (a = 3),
        r.type === i.FLOAT_MAT4 && (a = 4),
        t[o] = {
            type: r.type,
            location: i.getAttribLocation(e, o),
            locationSize: a
        }
    }
    return t
}
function Zu(i) {
    return i !== ""
}
function AE(i, e) {
    const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
    return i.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
}
function CE(i, e) {
    return i.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
}
const vee = /^[ \t]*#include +<([\w\d./]+)>/gm;
function Iv(i) {
    return i.replace(vee, xee)
}
const _ee = new Map;
function xee(i, e) {
    let t = jt[e];
    if (t === void 0) {
        const n = _ee.get(e);
        if (n !== void 0)
            t = jt[n],
            console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, n);
        else
            throw new Error("Can not resolve #include <" + e + ">")
    }
    return Iv(t)
}
const yee = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function ME(i) {
    return i.replace(yee, bee)
}
function bee(i, e, t, n) {
    let s = "";
    for (let r = parseInt(e); r < parseInt(t); r++)
        s += n.replace(/\[\s*i\s*\]/g, "[ " + r + " ]").replace(/UNROLLED_LOOP_INDEX/g, r);
    return s
}
function RE(i) {
    let e = `precision ${i.precision} float;
	precision ${i.precision} int;
	precision ${i.precision} sampler2D;
	precision ${i.precision} samplerCube;
	precision ${i.precision} sampler3D;
	precision ${i.precision} sampler2DArray;
	precision ${i.precision} sampler2DShadow;
	precision ${i.precision} samplerCubeShadow;
	precision ${i.precision} sampler2DArrayShadow;
	precision ${i.precision} isampler2D;
	precision ${i.precision} isampler3D;
	precision ${i.precision} isamplerCube;
	precision ${i.precision} isampler2DArray;
	precision ${i.precision} usampler2D;
	precision ${i.precision} usampler3D;
	precision ${i.precision} usamplerCube;
	precision ${i.precision} usampler2DArray;
	`;
    return i.precision === "highp" ? e += `
#define HIGH_PRECISION` : i.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : i.precision === "lowp" && (e += `
#define LOW_PRECISION`),
    e
}
function See(i) {
    let e = "SHADOWMAP_TYPE_BASIC";
    return i.shadowMapType === KM ? e = "SHADOWMAP_TYPE_PCF" : i.shadowMapType === tX ? e = "SHADOWMAP_TYPE_PCF_SOFT" : i.shadowMapType === ho && (e = "SHADOWMAP_TYPE_VSM"),
    e
}
function Eee(i) {
    let e = "ENVMAP_TYPE_CUBE";
    if (i.envMap)
        switch (i.envMapMode) {
        case fu:
        case hu:
            e = "ENVMAP_TYPE_CUBE";
            break;
        case Mm:
            e = "ENVMAP_TYPE_CUBE_UV";
            break
        }
    return e
}
function wee(i) {
    let e = "ENVMAP_MODE_REFLECTION";
    if (i.envMap)
        switch (i.envMapMode) {
        case hu:
            e = "ENVMAP_MODE_REFRACTION";
            break
        }
    return e
}
function Tee(i) {
    let e = "ENVMAP_BLENDING_NONE";
    if (i.envMap)
        switch (i.combine) {
        case XM:
            e = "ENVMAP_BLENDING_MULTIPLY";
            break;
        case CX:
            e = "ENVMAP_BLENDING_MIX";
            break;
        case MX:
            e = "ENVMAP_BLENDING_ADD";
            break
        }
    return e
}
function Aee(i) {
    const e = i.envMapCubeUVHeight;
    if (e === null)
        return null;
    const t = Math.log2(e) - 2
      , n = 1 / e;
    return {
        texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
        texelHeight: n,
        maxMip: t
    }
}
function Cee(i, e, t, n) {
    const s = i.getContext()
      , r = t.defines;
    let o = t.vertexShader
      , a = t.fragmentShader;
    const l = See(t)
      , c = Eee(t)
      , u = wee(t)
      , d = Tee(t)
      , f = Aee(t)
      , h = pee(t)
      , p = mee(r)
      , g = s.createProgram();
    let m, v, _ = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
    t.isRawShaderMaterial ? (m = ["#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, p].filter(Zu).join(`
`),
    m.length > 0 && (m += `
`),
    v = ["#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, p].filter(Zu).join(`
`),
    v.length > 0 && (v += `
`)) : (m = [RE(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, p, t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", t.batching ? "#define USE_BATCHING" : "", t.batchingColor ? "#define USE_BATCHING_COLOR" : "", t.instancing ? "#define USE_INSTANCING" : "", t.instancingColor ? "#define USE_INSTANCING_COLOR" : "", t.instancingMorph ? "#define USE_INSTANCING_MORPH" : "", t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + u : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropy ? "#define USE_ANISOTROPY" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.mapUv ? "#define MAP_UV " + t.mapUv : "", t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "", t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "", t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "", t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "", t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "", t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "", t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "", t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "", t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "", t.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv : "", t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "", t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "", t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "", t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "", t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "", t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "", t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "", t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "", t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "", t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "", t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "", t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "", t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "", t.vertexColors ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.skinning ? "#define USE_SKINNING" : "", t.morphTargets ? "#define USE_MORPHTARGETS" : "", t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", t.morphColors ? "#define USE_MORPHCOLORS" : "", t.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "", t.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "#ifdef USE_INSTANCING_MORPH", "	uniform sampler2D morphTexture;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "	attribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "	attribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "	attribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(Zu).join(`
`),
    v = [RE(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, p, t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "", t.map ? "#define USE_MAP" : "", t.matcap ? "#define USE_MATCAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + c : "", t.envMap ? "#define " + u : "", t.envMap ? "#define " + d : "", f ? "#define CUBEUV_TEXEL_WIDTH " + f.texelWidth : "", f ? "#define CUBEUV_TEXEL_HEIGHT " + f.texelHeight : "", f ? "#define CUBEUV_MAX_MIP " + f.maxMip + ".0" : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropy ? "#define USE_ANISOTROPY" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoat ? "#define USE_CLEARCOAT" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.dispersion ? "#define USE_DISPERSION" : "", t.iridescence ? "#define USE_IRIDESCENCE" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaTest ? "#define USE_ALPHATEST" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.sheen ? "#define USE_SHEEN" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "", t.vertexColors || t.instancingColor || t.batchingColor ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.gradientMap ? "#define USE_GRADIENTMAP" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", t.toneMapping !== xa ? "#define TONE_MAPPING" : "", t.toneMapping !== xa ? jt.tonemapping_pars_fragment : "", t.toneMapping !== xa ? fee("toneMapping", t.toneMapping) : "", t.dithering ? "#define DITHERING" : "", t.opaque ? "#define OPAQUE" : "", jt.colorspace_pars_fragment, dee("linearToOutputTexel", t.outputColorSpace), hee(), t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "", `
`].filter(Zu).join(`
`)),
    o = Iv(o),
    o = AE(o, t),
    o = CE(o, t),
    a = Iv(a),
    a = AE(a, t),
    a = CE(a, t),
    o = ME(o),
    a = ME(a),
    t.isRawShaderMaterial !== !0 && (_ = `#version 300 es
`,
    m = [h, "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + m,
    v = ["#define varying in", t.glslVersion === GS ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", t.glslVersion === GS ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
` + v);
    const y = _ + m + o
      , b = _ + v + a
      , S = wE(s, s.VERTEX_SHADER, y)
      , C = wE(s, s.FRAGMENT_SHADER, b);
    s.attachShader(g, S),
    s.attachShader(g, C),
    t.index0AttributeName !== void 0 ? s.bindAttribLocation(g, 0, t.index0AttributeName) : t.morphTargets === !0 && s.bindAttribLocation(g, 0, "position"),
    s.linkProgram(g);
    function M(k) {
        if (i.debug.checkShaderErrors) {
            const D = s.getProgramInfoLog(g).trim()
              , F = s.getShaderInfoLog(S).trim()
              , z = s.getShaderInfoLog(C).trim();
            let G = !0
              , H = !0;
            if (s.getProgramParameter(g, s.LINK_STATUS) === !1)
                if (G = !1,
                typeof i.debug.onShaderError == "function")
                    i.debug.onShaderError(s, g, S, C);
                else {
                    const X = TE(s, S, "vertex")
                      , K = TE(s, C, "fragment");
                    console.error("THREE.WebGLProgram: Shader Error " + s.getError() + " - VALIDATE_STATUS " + s.getProgramParameter(g, s.VALIDATE_STATUS) + `

Material Name: ` + k.name + `
Material Type: ` + k.type + `

Program Info Log: ` + D + `
` + X + `
` + K)
                }
            else
                D !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", D) : (F === "" || z === "") && (H = !1);
            H && (k.diagnostics = {
                runnable: G,
                programLog: D,
                vertexShader: {
                    log: F,
                    prefix: m
                },
                fragmentShader: {
                    log: z,
                    prefix: v
                }
            })
        }
        s.deleteShader(S),
        s.deleteShader(C),
        L = new Vh(s,g),
        T = gee(s, g)
    }
    let L;
    this.getUniforms = function() {
        return L === void 0 && M(this),
        L
    }
    ;
    let T;
    this.getAttributes = function() {
        return T === void 0 && M(this),
        T
    }
    ;
    let A = t.rendererExtensionParallelShaderCompile === !1;
    return this.isReady = function() {
        return A === !1 && (A = s.getProgramParameter(g, aee)),
        A
    }
    ,
    this.destroy = function() {
        n.releaseStatesOfProgram(this),
        s.deleteProgram(g),
        this.program = void 0
    }
    ,
    this.type = t.shaderType,
    this.name = t.shaderName,
    this.id = lee++,
    this.cacheKey = e,
    this.usedTimes = 1,
    this.program = g,
    this.vertexShader = S,
    this.fragmentShader = C,
    this
}
let Mee = 0;
class Ree {
    constructor() {
        this.shaderCache = new Map,
        this.materialCache = new Map
    }
    update(e) {
        const t = e.vertexShader
          , n = e.fragmentShader
          , s = this._getShaderStage(t)
          , r = this._getShaderStage(n)
          , o = this._getShaderCacheForMaterial(e);
        return o.has(s) === !1 && (o.add(s),
        s.usedTimes++),
        o.has(r) === !1 && (o.add(r),
        r.usedTimes++),
        this
    }
    remove(e) {
        const t = this.materialCache.get(e);
        for (const n of t)
            n.usedTimes--,
            n.usedTimes === 0 && this.shaderCache.delete(n.code);
        return this.materialCache.delete(e),
        this
    }
    getVertexShaderID(e) {
        return this._getShaderStage(e.vertexShader).id
    }
    getFragmentShaderID(e) {
        return this._getShaderStage(e.fragmentShader).id
    }
    dispose() {
        this.shaderCache.clear(),
        this.materialCache.clear()
    }
    _getShaderCacheForMaterial(e) {
        const t = this.materialCache;
        let n = t.get(e);
        return n === void 0 && (n = new Set,
        t.set(e, n)),
        n
    }
    _getShaderStage(e) {
        const t = this.shaderCache;
        let n = t.get(e);
        return n === void 0 && (n = new Lee(e),
        t.set(e, n)),
        n
    }
}
class Lee {
    constructor(e) {
        this.id = Mee++,
        this.code = e,
        this.usedTimes = 0
    }
}
function Iee(i, e, t, n, s, r, o) {
    const a = new f3
      , l = new Ree
      , c = new Set
      , u = []
      , d = s.logarithmicDepthBuffer
      , f = s.vertexTextures;
    let h = s.precision;
    const p = {
        MeshDepthMaterial: "depth",
        MeshDistanceMaterial: "distanceRGBA",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        MeshToonMaterial: "toon",
        MeshStandardMaterial: "physical",
        MeshPhysicalMaterial: "physical",
        MeshMatcapMaterial: "matcap",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointsMaterial: "points",
        ShadowMaterial: "shadow",
        SpriteMaterial: "sprite"
    };
    function g(T) {
        return c.add(T),
        T === 0 ? "uv" : `uv${T}`
    }
    function m(T, A, k, D, F) {
        const z = D.fog
          , G = F.geometry
          , H = T.isMeshStandardMaterial ? D.environment : null
          , X = (T.isMeshStandardMaterial ? t : e).get(T.envMap || H)
          , K = !!X && X.mapping === Mm ? X.image.height : null
          , ce = p[T.type];
        T.precision !== null && (h = s.getMaxPrecision(T.precision),
        h !== T.precision && console.warn("THREE.WebGLProgram.getParameters:", T.precision, "not supported, using", h, "instead."));
        const ue = G.morphAttributes.position || G.morphAttributes.normal || G.morphAttributes.color
          , Ie = ue !== void 0 ? ue.length : 0;
        let ke = 0;
        G.morphAttributes.position !== void 0 && (ke = 1),
        G.morphAttributes.normal !== void 0 && (ke = 2),
        G.morphAttributes.color !== void 0 && (ke = 3);
        let We, se, Se, be;
        if (ce) {
            const ne = Pr[ce];
            We = ne.vertexShader,
            se = ne.fragmentShader
        } else
            We = T.vertexShader,
            se = T.fragmentShader,
            l.update(T),
            Se = l.getVertexShaderID(T),
            be = l.getFragmentShaderID(T);
        const q = i.getRenderTarget()
          , me = F.isInstancedMesh === !0
          , Ce = F.isBatchedMesh === !0
          , Pe = !!T.map
          , vt = !!T.matcap
          , j = !!X
          , B = !!T.aoMap
          , V = !!T.lightMap
          , Q = !!T.bumpMap
          , he = !!T.normalMap
          , Ee = !!T.displacementMap
          , we = !!T.emissiveMap
          , Le = !!T.metalnessMap
          , N = !!T.roughnessMap
          , I = T.anisotropy > 0
          , W = T.clearcoat > 0
          , re = T.dispersion > 0
          , oe = T.iridescence > 0
          , fe = T.sheen > 0
          , $e = T.transmission > 0
          , Oe = I && !!T.anisotropyMap
          , qe = W && !!T.clearcoatMap
          , nt = W && !!T.clearcoatNormalMap
          , Be = W && !!T.clearcoatRoughnessMap
          , Xe = oe && !!T.iridescenceMap
          , Rt = oe && !!T.iridescenceThicknessMap
          , ht = fe && !!T.sheenColorMap
          , lt = fe && !!T.sheenRoughnessMap
          , kt = !!T.specularMap
          , _t = !!T.specularColorMap
          , Xt = !!T.specularIntensityMap
          , te = $e && !!T.transmissionMap
          , Je = $e && !!T.thicknessMap
          , De = !!T.gradientMap
          , Ue = !!T.alphaMap
          , et = T.alphaTest > 0
          , Lt = !!T.alphaHash
          , Wt = !!T.extensions;
        let $ = xa;
        T.toneMapped && (q === null || q.isXRRenderTarget === !0) && ($ = i.toneMapping);
        const Z = {
            shaderID: ce,
            shaderType: T.type,
            shaderName: T.name,
            vertexShader: We,
            fragmentShader: se,
            defines: T.defines,
            customVertexShaderID: Se,
            customFragmentShaderID: be,
            isRawShaderMaterial: T.isRawShaderMaterial === !0,
            glslVersion: T.glslVersion,
            precision: h,
            batching: Ce,
            batchingColor: Ce && F._colorsTexture !== null,
            instancing: me,
            instancingColor: me && F.instanceColor !== null,
            instancingMorph: me && F.morphTexture !== null,
            supportsVertexTextures: f,
            outputColorSpace: q === null ? i.outputColorSpace : q.isXRRenderTarget === !0 ? q.texture.colorSpace : ka,
            alphaToCoverage: !!T.alphaToCoverage,
            map: Pe,
            matcap: vt,
            envMap: j,
            envMapMode: j && X.mapping,
            envMapCubeUVHeight: K,
            aoMap: B,
            lightMap: V,
            bumpMap: Q,
            normalMap: he,
            displacementMap: f && Ee,
            emissiveMap: we,
            normalMapObjectSpace: he && T.normalMapType === BX,
            normalMapTangentSpace: he && T.normalMapType === a3,
            metalnessMap: Le,
            roughnessMap: N,
            anisotropy: I,
            anisotropyMap: Oe,
            clearcoat: W,
            clearcoatMap: qe,
            clearcoatNormalMap: nt,
            clearcoatRoughnessMap: Be,
            dispersion: re,
            iridescence: oe,
            iridescenceMap: Xe,
            iridescenceThicknessMap: Rt,
            sheen: fe,
            sheenColorMap: ht,
            sheenRoughnessMap: lt,
            specularMap: kt,
            specularColorMap: _t,
            specularIntensityMap: Xt,
            transmission: $e,
            transmissionMap: te,
            thicknessMap: Je,
            gradientMap: De,
            opaque: T.transparent === !1 && T.blending === Gc && T.alphaToCoverage === !1,
            alphaMap: Ue,
            alphaTest: et,
            alphaHash: Lt,
            combine: T.combine,
            mapUv: Pe && g(T.map.channel),
            aoMapUv: B && g(T.aoMap.channel),
            lightMapUv: V && g(T.lightMap.channel),
            bumpMapUv: Q && g(T.bumpMap.channel),
            normalMapUv: he && g(T.normalMap.channel),
            displacementMapUv: Ee && g(T.displacementMap.channel),
            emissiveMapUv: we && g(T.emissiveMap.channel),
            metalnessMapUv: Le && g(T.metalnessMap.channel),
            roughnessMapUv: N && g(T.roughnessMap.channel),
            anisotropyMapUv: Oe && g(T.anisotropyMap.channel),
            clearcoatMapUv: qe && g(T.clearcoatMap.channel),
            clearcoatNormalMapUv: nt && g(T.clearcoatNormalMap.channel),
            clearcoatRoughnessMapUv: Be && g(T.clearcoatRoughnessMap.channel),
            iridescenceMapUv: Xe && g(T.iridescenceMap.channel),
            iridescenceThicknessMapUv: Rt && g(T.iridescenceThicknessMap.channel),
            sheenColorMapUv: ht && g(T.sheenColorMap.channel),
            sheenRoughnessMapUv: lt && g(T.sheenRoughnessMap.channel),
            specularMapUv: kt && g(T.specularMap.channel),
            specularColorMapUv: _t && g(T.specularColorMap.channel),
            specularIntensityMapUv: Xt && g(T.specularIntensityMap.channel),
            transmissionMapUv: te && g(T.transmissionMap.channel),
            thicknessMapUv: Je && g(T.thicknessMap.channel),
            alphaMapUv: Ue && g(T.alphaMap.channel),
            vertexTangents: !!G.attributes.tangent && (he || I),
            vertexColors: T.vertexColors,
            vertexAlphas: T.vertexColors === !0 && !!G.attributes.color && G.attributes.color.itemSize === 4,
            pointsUvs: F.isPoints === !0 && !!G.attributes.uv && (Pe || Ue),
            fog: !!z,
            useFog: T.fog === !0,
            fogExp2: !!z && z.isFogExp2,
            flatShading: T.flatShading === !0,
            sizeAttenuation: T.sizeAttenuation === !0,
            logarithmicDepthBuffer: d,
            skinning: F.isSkinnedMesh === !0,
            morphTargets: G.morphAttributes.position !== void 0,
            morphNormals: G.morphAttributes.normal !== void 0,
            morphColors: G.morphAttributes.color !== void 0,
            morphTargetsCount: Ie,
            morphTextureStride: ke,
            numDirLights: A.directional.length,
            numPointLights: A.point.length,
            numSpotLights: A.spot.length,
            numSpotLightMaps: A.spotLightMap.length,
            numRectAreaLights: A.rectArea.length,
            numHemiLights: A.hemi.length,
            numDirLightShadows: A.directionalShadowMap.length,
            numPointLightShadows: A.pointShadowMap.length,
            numSpotLightShadows: A.spotShadowMap.length,
            numSpotLightShadowsWithMaps: A.numSpotLightShadowsWithMaps,
            numLightProbes: A.numLightProbes,
            numClippingPlanes: o.numPlanes,
            numClipIntersection: o.numIntersection,
            dithering: T.dithering,
            shadowMapEnabled: i.shadowMap.enabled && k.length > 0,
            shadowMapType: i.shadowMap.type,
            toneMapping: $,
            decodeVideoTexture: Pe && T.map.isVideoTexture === !0 && pn.getTransfer(T.map.colorSpace) === In,
            premultipliedAlpha: T.premultipliedAlpha,
            doubleSided: T.side === Ao,
            flipSided: T.side === os,
            useDepthPacking: T.depthPacking >= 0,
            depthPacking: T.depthPacking || 0,
            index0AttributeName: T.index0AttributeName,
            extensionClipCullDistance: Wt && T.extensions.clipCullDistance === !0 && n.has("WEBGL_clip_cull_distance"),
            extensionMultiDraw: (Wt && T.extensions.multiDraw === !0 || Ce) && n.has("WEBGL_multi_draw"),
            rendererExtensionParallelShaderCompile: n.has("KHR_parallel_shader_compile"),
            customProgramCacheKey: T.customProgramCacheKey()
        };
        return Z.vertexUv1s = c.has(1),
        Z.vertexUv2s = c.has(2),
        Z.vertexUv3s = c.has(3),
        c.clear(),
        Z
    }
    function v(T) {
        const A = [];
        if (T.shaderID ? A.push(T.shaderID) : (A.push(T.customVertexShaderID),
        A.push(T.customFragmentShaderID)),
        T.defines !== void 0)
            for (const k in T.defines)
                A.push(k),
                A.push(T.defines[k]);
        return T.isRawShaderMaterial === !1 && (_(A, T),
        y(A, T),
        A.push(i.outputColorSpace)),
        A.push(T.customProgramCacheKey),
        A.join()
    }
    function _(T, A) {
        T.push(A.precision),
        T.push(A.outputColorSpace),
        T.push(A.envMapMode),
        T.push(A.envMapCubeUVHeight),
        T.push(A.mapUv),
        T.push(A.alphaMapUv),
        T.push(A.lightMapUv),
        T.push(A.aoMapUv),
        T.push(A.bumpMapUv),
        T.push(A.normalMapUv),
        T.push(A.displacementMapUv),
        T.push(A.emissiveMapUv),
        T.push(A.metalnessMapUv),
        T.push(A.roughnessMapUv),
        T.push(A.anisotropyMapUv),
        T.push(A.clearcoatMapUv),
        T.push(A.clearcoatNormalMapUv),
        T.push(A.clearcoatRoughnessMapUv),
        T.push(A.iridescenceMapUv),
        T.push(A.iridescenceThicknessMapUv),
        T.push(A.sheenColorMapUv),
        T.push(A.sheenRoughnessMapUv),
        T.push(A.specularMapUv),
        T.push(A.specularColorMapUv),
        T.push(A.specularIntensityMapUv),
        T.push(A.transmissionMapUv),
        T.push(A.thicknessMapUv),
        T.push(A.combine),
        T.push(A.fogExp2),
        T.push(A.sizeAttenuation),
        T.push(A.morphTargetsCount),
        T.push(A.morphAttributeCount),
        T.push(A.numDirLights),
        T.push(A.numPointLights),
        T.push(A.numSpotLights),
        T.push(A.numSpotLightMaps),
        T.push(A.numHemiLights),
        T.push(A.numRectAreaLights),
        T.push(A.numDirLightShadows),
        T.push(A.numPointLightShadows),
        T.push(A.numSpotLightShadows),
        T.push(A.numSpotLightShadowsWithMaps),
        T.push(A.numLightProbes),
        T.push(A.shadowMapType),
        T.push(A.toneMapping),
        T.push(A.numClippingPlanes),
        T.push(A.numClipIntersection),
        T.push(A.depthPacking)
    }
    function y(T, A) {
        a.disableAll(),
        A.supportsVertexTextures && a.enable(0),
        A.instancing && a.enable(1),
        A.instancingColor && a.enable(2),
        A.instancingMorph && a.enable(3),
        A.matcap && a.enable(4),
        A.envMap && a.enable(5),
        A.normalMapObjectSpace && a.enable(6),
        A.normalMapTangentSpace && a.enable(7),
        A.clearcoat && a.enable(8),
        A.iridescence && a.enable(9),
        A.alphaTest && a.enable(10),
        A.vertexColors && a.enable(11),
        A.vertexAlphas && a.enable(12),
        A.vertexUv1s && a.enable(13),
        A.vertexUv2s && a.enable(14),
        A.vertexUv3s && a.enable(15),
        A.vertexTangents && a.enable(16),
        A.anisotropy && a.enable(17),
        A.alphaHash && a.enable(18),
        A.batching && a.enable(19),
        A.dispersion && a.enable(20),
        A.batchingColor && a.enable(21),
        T.push(a.mask),
        a.disableAll(),
        A.fog && a.enable(0),
        A.useFog && a.enable(1),
        A.flatShading && a.enable(2),
        A.logarithmicDepthBuffer && a.enable(3),
        A.skinning && a.enable(4),
        A.morphTargets && a.enable(5),
        A.morphNormals && a.enable(6),
        A.morphColors && a.enable(7),
        A.premultipliedAlpha && a.enable(8),
        A.shadowMapEnabled && a.enable(9),
        A.doubleSided && a.enable(10),
        A.flipSided && a.enable(11),
        A.useDepthPacking && a.enable(12),
        A.dithering && a.enable(13),
        A.transmission && a.enable(14),
        A.sheen && a.enable(15),
        A.opaque && a.enable(16),
        A.pointsUvs && a.enable(17),
        A.decodeVideoTexture && a.enable(18),
        A.alphaToCoverage && a.enable(19),
        T.push(a.mask)
    }
    function b(T) {
        const A = p[T.type];
        let k;
        if (A) {
            const D = Pr[A];
            k = pY.clone(D.uniforms)
        } else
            k = T.uniforms;
        return k
    }
    function S(T, A) {
        let k;
        for (let D = 0, F = u.length; D < F; D++) {
            const z = u[D];
            if (z.cacheKey === A) {
                k = z,
                ++k.usedTimes;
                break
            }
        }
        return k === void 0 && (k = new Cee(i,A,T,r),
        u.push(k)),
        k
    }
    function C(T) {
        if (--T.usedTimes === 0) {
            const A = u.indexOf(T);
            u[A] = u[u.length - 1],
            u.pop(),
            T.destroy()
        }
    }
    function M(T) {
        l.remove(T)
    }
    function L() {
        l.dispose()
    }
    return {
        getParameters: m,
        getProgramCacheKey: v,
        getUniforms: b,
        acquireProgram: S,
        releaseProgram: C,
        releaseShaderCache: M,
        programs: u,
        dispose: L
    }
}
function kee() {
    let i = new WeakMap;
    function e(o) {
        return i.has(o)
    }
    function t(o) {
        let a = i.get(o);
        return a === void 0 && (a = {},
        i.set(o, a)),
        a
    }
    function n(o) {
        i.delete(o)
    }
    function s(o, a, l) {
        i.get(o)[a] = l
    }
    function r() {
        i = new WeakMap
    }
    return {
        has: e,
        get: t,
        remove: n,
        update: s,
        dispose: r
    }
}
function Pee(i, e) {
    return i.groupOrder !== e.groupOrder ? i.groupOrder - e.groupOrder : i.renderOrder !== e.renderOrder ? i.renderOrder - e.renderOrder : i.material.id !== e.material.id ? i.material.id - e.material.id : i.z !== e.z ? i.z - e.z : i.id - e.id
}
function LE(i, e) {
    return i.groupOrder !== e.groupOrder ? i.groupOrder - e.groupOrder : i.renderOrder !== e.renderOrder ? i.renderOrder - e.renderOrder : i.z !== e.z ? e.z - i.z : i.id - e.id
}
function IE() {
    const i = [];
    let e = 0;
    const t = []
      , n = []
      , s = [];
    function r() {
        e = 0,
        t.length = 0,
        n.length = 0,
        s.length = 0
    }
    function o(d, f, h, p, g, m) {
        let v = i[e];
        return v === void 0 ? (v = {
            id: d.id,
            object: d,
            geometry: f,
            material: h,
            groupOrder: p,
            renderOrder: d.renderOrder,
            z: g,
            group: m
        },
        i[e] = v) : (v.id = d.id,
        v.object = d,
        v.geometry = f,
        v.material = h,
        v.groupOrder = p,
        v.renderOrder = d.renderOrder,
        v.z = g,
        v.group = m),
        e++,
        v
    }
    function a(d, f, h, p, g, m) {
        const v = o(d, f, h, p, g, m);
        h.transmission > 0 ? n.push(v) : h.transparent === !0 ? s.push(v) : t.push(v)
    }
    function l(d, f, h, p, g, m) {
        const v = o(d, f, h, p, g, m);
        h.transmission > 0 ? n.unshift(v) : h.transparent === !0 ? s.unshift(v) : t.unshift(v)
    }
    function c(d, f) {
        t.length > 1 && t.sort(d || Pee),
        n.length > 1 && n.sort(f || LE),
        s.length > 1 && s.sort(f || LE)
    }
    function u() {
        for (let d = e, f = i.length; d < f; d++) {
            const h = i[d];
            if (h.id === null)
                break;
            h.id = null,
            h.object = null,
            h.geometry = null,
            h.material = null,
            h.group = null
        }
    }
    return {
        opaque: t,
        transmissive: n,
        transparent: s,
        init: r,
        push: a,
        unshift: l,
        finish: u,
        sort: c
    }
}
function Dee() {
    let i = new WeakMap;
    function e(n, s) {
        const r = i.get(n);
        let o;
        return r === void 0 ? (o = new IE,
        i.set(n, [o])) : s >= r.length ? (o = new IE,
        r.push(o)) : o = r[s],
        o
    }
    function t() {
        i = new WeakMap
    }
    return {
        get: e,
        dispose: t
    }
}
function Fee() {
    const i = {};
    return {
        get: function(e) {
            if (i[e.id] !== void 0)
                return i[e.id];
            let t;
            switch (e.type) {
            case "DirectionalLight":
                t = {
                    direction: new Te,
                    color: new un
                };
                break;
            case "SpotLight":
                t = {
                    position: new Te,
                    direction: new Te,
                    color: new un,
                    distance: 0,
                    coneCos: 0,
                    penumbraCos: 0,
                    decay: 0
                };
                break;
            case "PointLight":
                t = {
                    position: new Te,
                    color: new un,
                    distance: 0,
                    decay: 0
                };
                break;
            case "HemisphereLight":
                t = {
                    direction: new Te,
                    skyColor: new un,
                    groundColor: new un
                };
                break;
            case "RectAreaLight":
                t = {
                    color: new un,
                    position: new Te,
                    halfWidth: new Te,
                    halfHeight: new Te
                };
                break
            }
            return i[e.id] = t,
            t
        }
    }
}
function Oee() {
    const i = {};
    return {
        get: function(e) {
            if (i[e.id] !== void 0)
                return i[e.id];
            let t;
            switch (e.type) {
            case "DirectionalLight":
                t = {
                    shadowIntensity: 1,
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new nn
                };
                break;
            case "SpotLight":
                t = {
                    shadowIntensity: 1,
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new nn
                };
                break;
            case "PointLight":
                t = {
                    shadowIntensity: 1,
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new nn,
                    shadowCameraNear: 1,
                    shadowCameraFar: 1e3
                };
                break
            }
            return i[e.id] = t,
            t
        }
    }
}
let Uee = 0;
function Nee(i, e) {
    return (e.castShadow ? 2 : 0) - (i.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (i.map ? 1 : 0)
}
function Bee(i) {
    const e = new Fee
      , t = Oee()
      , n = {
        version: 0,
        hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1,
            numSpotMaps: -1,
            numLightProbes: -1
        },
        ambient: [0, 0, 0],
        probe: [],
        directional: [],
        directionalShadow: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotLightMap: [],
        spotShadow: [],
        spotShadowMap: [],
        spotLightMatrix: [],
        rectArea: [],
        rectAreaLTC1: null,
        rectAreaLTC2: null,
        point: [],
        pointShadow: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: [],
        numSpotLightShadowsWithMaps: 0,
        numLightProbes: 0
    };
    for (let c = 0; c < 9; c++)
        n.probe.push(new Te);
    const s = new Te
      , r = new qn
      , o = new qn;
    function a(c) {
        let u = 0
          , d = 0
          , f = 0;
        for (let T = 0; T < 9; T++)
            n.probe[T].set(0, 0, 0);
        let h = 0
          , p = 0
          , g = 0
          , m = 0
          , v = 0
          , _ = 0
          , y = 0
          , b = 0
          , S = 0
          , C = 0
          , M = 0;
        c.sort(Nee);
        for (let T = 0, A = c.length; T < A; T++) {
            const k = c[T]
              , D = k.color
              , F = k.intensity
              , z = k.distance
              , G = k.shadow && k.shadow.map ? k.shadow.map.texture : null;
            if (k.isAmbientLight)
                u += D.r * F,
                d += D.g * F,
                f += D.b * F;
            else if (k.isLightProbe) {
                for (let H = 0; H < 9; H++)
                    n.probe[H].addScaledVector(k.sh.coefficients[H], F);
                M++
            } else if (k.isDirectionalLight) {
                const H = e.get(k);
                if (H.color.copy(k.color).multiplyScalar(k.intensity),
                k.castShadow) {
                    const X = k.shadow
                      , K = t.get(k);
                    K.shadowIntensity = X.intensity,
                    K.shadowBias = X.bias,
                    K.shadowNormalBias = X.normalBias,
                    K.shadowRadius = X.radius,
                    K.shadowMapSize = X.mapSize,
                    n.directionalShadow[h] = K,
                    n.directionalShadowMap[h] = G,
                    n.directionalShadowMatrix[h] = k.shadow.matrix,
                    _++
                }
                n.directional[h] = H,
                h++
            } else if (k.isSpotLight) {
                const H = e.get(k);
                H.position.setFromMatrixPosition(k.matrixWorld),
                H.color.copy(D).multiplyScalar(F),
                H.distance = z,
                H.coneCos = Math.cos(k.angle),
                H.penumbraCos = Math.cos(k.angle * (1 - k.penumbra)),
                H.decay = k.decay,
                n.spot[g] = H;
                const X = k.shadow;
                if (k.map && (n.spotLightMap[S] = k.map,
                S++,
                X.updateMatrices(k),
                k.castShadow && C++),
                n.spotLightMatrix[g] = X.matrix,
                k.castShadow) {
                    const K = t.get(k);
                    K.shadowIntensity = X.intensity,
                    K.shadowBias = X.bias,
                    K.shadowNormalBias = X.normalBias,
                    K.shadowRadius = X.radius,
                    K.shadowMapSize = X.mapSize,
                    n.spotShadow[g] = K,
                    n.spotShadowMap[g] = G,
                    b++
                }
                g++
            } else if (k.isRectAreaLight) {
                const H = e.get(k);
                H.color.copy(D).multiplyScalar(F),
                H.halfWidth.set(k.width * .5, 0, 0),
                H.halfHeight.set(0, k.height * .5, 0),
                n.rectArea[m] = H,
                m++
            } else if (k.isPointLight) {
                const H = e.get(k);
                if (H.color.copy(k.color).multiplyScalar(k.intensity),
                H.distance = k.distance,
                H.decay = k.decay,
                k.castShadow) {
                    const X = k.shadow
                      , K = t.get(k);
                    K.shadowIntensity = X.intensity,
                    K.shadowBias = X.bias,
                    K.shadowNormalBias = X.normalBias,
                    K.shadowRadius = X.radius,
                    K.shadowMapSize = X.mapSize,
                    K.shadowCameraNear = X.camera.near,
                    K.shadowCameraFar = X.camera.far,
                    n.pointShadow[p] = K,
                    n.pointShadowMap[p] = G,
                    n.pointShadowMatrix[p] = k.shadow.matrix,
                    y++
                }
                n.point[p] = H,
                p++
            } else if (k.isHemisphereLight) {
                const H = e.get(k);
                H.skyColor.copy(k.color).multiplyScalar(F),
                H.groundColor.copy(k.groundColor).multiplyScalar(F),
                n.hemi[v] = H,
                v++
            }
        }
        m > 0 && (i.has("OES_texture_float_linear") === !0 ? (n.rectAreaLTC1 = rt.LTC_FLOAT_1,
        n.rectAreaLTC2 = rt.LTC_FLOAT_2) : (n.rectAreaLTC1 = rt.LTC_HALF_1,
        n.rectAreaLTC2 = rt.LTC_HALF_2)),
        n.ambient[0] = u,
        n.ambient[1] = d,
        n.ambient[2] = f;
        const L = n.hash;
        (L.directionalLength !== h || L.pointLength !== p || L.spotLength !== g || L.rectAreaLength !== m || L.hemiLength !== v || L.numDirectionalShadows !== _ || L.numPointShadows !== y || L.numSpotShadows !== b || L.numSpotMaps !== S || L.numLightProbes !== M) && (n.directional.length = h,
        n.spot.length = g,
        n.rectArea.length = m,
        n.point.length = p,
        n.hemi.length = v,
        n.directionalShadow.length = _,
        n.directionalShadowMap.length = _,
        n.pointShadow.length = y,
        n.pointShadowMap.length = y,
        n.spotShadow.length = b,
        n.spotShadowMap.length = b,
        n.directionalShadowMatrix.length = _,
        n.pointShadowMatrix.length = y,
        n.spotLightMatrix.length = b + S - C,
        n.spotLightMap.length = S,
        n.numSpotLightShadowsWithMaps = C,
        n.numLightProbes = M,
        L.directionalLength = h,
        L.pointLength = p,
        L.spotLength = g,
        L.rectAreaLength = m,
        L.hemiLength = v,
        L.numDirectionalShadows = _,
        L.numPointShadows = y,
        L.numSpotShadows = b,
        L.numSpotMaps = S,
        L.numLightProbes = M,
        n.version = Uee++)
    }
    function l(c, u) {
        let d = 0
          , f = 0
          , h = 0
          , p = 0
          , g = 0;
        const m = u.matrixWorldInverse;
        for (let v = 0, _ = c.length; v < _; v++) {
            const y = c[v];
            if (y.isDirectionalLight) {
                const b = n.directional[d];
                b.direction.setFromMatrixPosition(y.matrixWorld),
                s.setFromMatrixPosition(y.target.matrixWorld),
                b.direction.sub(s),
                b.direction.transformDirection(m),
                d++
            } else if (y.isSpotLight) {
                const b = n.spot[h];
                b.position.setFromMatrixPosition(y.matrixWorld),
                b.position.applyMatrix4(m),
                b.direction.setFromMatrixPosition(y.matrixWorld),
                s.setFromMatrixPosition(y.target.matrixWorld),
                b.direction.sub(s),
                b.direction.transformDirection(m),
                h++
            } else if (y.isRectAreaLight) {
                const b = n.rectArea[p];
                b.position.setFromMatrixPosition(y.matrixWorld),
                b.position.applyMatrix4(m),
                o.identity(),
                r.copy(y.matrixWorld),
                r.premultiply(m),
                o.extractRotation(r),
                b.halfWidth.set(y.width * .5, 0, 0),
                b.halfHeight.set(0, y.height * .5, 0),
                b.halfWidth.applyMatrix4(o),
                b.halfHeight.applyMatrix4(o),
                p++
            } else if (y.isPointLight) {
                const b = n.point[f];
                b.position.setFromMatrixPosition(y.matrixWorld),
                b.position.applyMatrix4(m),
                f++
            } else if (y.isHemisphereLight) {
                const b = n.hemi[g];
                b.direction.setFromMatrixPosition(y.matrixWorld),
                b.direction.transformDirection(m),
                g++
            }
        }
    }
    return {
        setup: a,
        setupView: l,
        state: n
    }
}
function kE(i) {
    const e = new Bee(i)
      , t = []
      , n = [];
    function s(u) {
        c.camera = u,
        t.length = 0,
        n.length = 0
    }
    function r(u) {
        t.push(u)
    }
    function o(u) {
        n.push(u)
    }
    function a() {
        e.setup(t)
    }
    function l(u) {
        e.setupView(t, u)
    }
    const c = {
        lightsArray: t,
        shadowsArray: n,
        camera: null,
        lights: e,
        transmissionRenderTarget: {}
    };
    return {
        init: s,
        state: c,
        setupLights: a,
        setupLightsView: l,
        pushLight: r,
        pushShadow: o
    }
}
function Vee(i) {
    let e = new WeakMap;
    function t(s, r=0) {
        const o = e.get(s);
        let a;
        return o === void 0 ? (a = new kE(i),
        e.set(s, [a])) : r >= o.length ? (a = new kE(i),
        o.push(a)) : a = o[r],
        a
    }
    function n() {
        e = new WeakMap
    }
    return {
        get: t,
        dispose: n
    }
}
class $ee extends uf {
    constructor(e) {
        super(),
        this.isMeshDepthMaterial = !0,
        this.type = "MeshDepthMaterial",
        this.depthPacking = UX,
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.depthPacking = e.depthPacking,
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this
    }
}
class Hee extends uf {
    constructor(e) {
        super(),
        this.isMeshDistanceMaterial = !0,
        this.type = "MeshDistanceMaterial",
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this
    }
}
const zee = `void main() {
	gl_Position = vec4( position, 1.0 );
}`
  , Gee = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function Wee(i, e, t) {
    let n = new Tx;
    const s = new nn
      , r = new nn
      , o = new oi
      , a = new $ee({
        depthPacking: NX
    })
      , l = new Hee
      , c = {}
      , u = t.maxTextureSize
      , d = {
        [Ta]: os,
        [os]: Ta,
        [Ao]: Ao
    }
      , f = new Aa({
        defines: {
            VSM_SAMPLES: 8
        },
        uniforms: {
            shadow_pass: {
                value: null
            },
            resolution: {
                value: new nn
            },
            radius: {
                value: 4
            }
        },
        vertexShader: zee,
        fragmentShader: Gee
    })
      , h = f.clone();
    h.defines.HORIZONTAL_PASS = 1;
    const p = new Pa;
    p.setAttribute("position", new zr(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]),3));
    const g = new Br(p,f)
      , m = this;
    this.enabled = !1,
    this.autoUpdate = !0,
    this.needsUpdate = !1,
    this.type = KM;
    let v = this.type;
    this.render = function(C, M, L) {
        if (m.enabled === !1 || m.autoUpdate === !1 && m.needsUpdate === !1 || C.length === 0)
            return;
        const T = i.getRenderTarget()
          , A = i.getActiveCubeFace()
          , k = i.getActiveMipmapLevel()
          , D = i.state;
        D.setBlending(_a),
        D.buffers.color.setClear(1, 1, 1, 1),
        D.buffers.depth.setTest(!0),
        D.setScissorTest(!1);
        const F = v !== ho && this.type === ho
          , z = v === ho && this.type !== ho;
        for (let G = 0, H = C.length; G < H; G++) {
            const X = C[G]
              , K = X.shadow;
            if (K === void 0) {
                console.warn("THREE.WebGLShadowMap:", X, "has no shadow.");
                continue
            }
            if (K.autoUpdate === !1 && K.needsUpdate === !1)
                continue;
            s.copy(K.mapSize);
            const ce = K.getFrameExtents();
            if (s.multiply(ce),
            r.copy(K.mapSize),
            (s.x > u || s.y > u) && (s.x > u && (r.x = Math.floor(u / ce.x),
            s.x = r.x * ce.x,
            K.mapSize.x = r.x),
            s.y > u && (r.y = Math.floor(u / ce.y),
            s.y = r.y * ce.y,
            K.mapSize.y = r.y)),
            K.map === null || F === !0 || z === !0) {
                const Ie = this.type !== ho ? {
                    minFilter: Ns,
                    magFilter: Ns
                } : {};
                K.map !== null && K.map.dispose(),
                K.map = new Dl(s.x,s.y,Ie),
                K.map.texture.name = X.name + ".shadowMap",
                K.camera.updateProjectionMatrix()
            }
            i.setRenderTarget(K.map),
            i.clear();
            const ue = K.getViewportCount();
            for (let Ie = 0; Ie < ue; Ie++) {
                const ke = K.getViewport(Ie);
                o.set(r.x * ke.x, r.y * ke.y, r.x * ke.z, r.y * ke.w),
                D.viewport(o),
                K.updateMatrices(X, Ie),
                n = K.getFrustum(),
                b(M, L, K.camera, X, this.type)
            }
            K.isPointLightShadow !== !0 && this.type === ho && _(K, L),
            K.needsUpdate = !1
        }
        v = this.type,
        m.needsUpdate = !1,
        i.setRenderTarget(T, A, k)
    }
    ;
    function _(C, M) {
        const L = e.update(g);
        f.defines.VSM_SAMPLES !== C.blurSamples && (f.defines.VSM_SAMPLES = C.blurSamples,
        h.defines.VSM_SAMPLES = C.blurSamples,
        f.needsUpdate = !0,
        h.needsUpdate = !0),
        C.mapPass === null && (C.mapPass = new Dl(s.x,s.y)),
        f.uniforms.shadow_pass.value = C.map.texture,
        f.uniforms.resolution.value = C.mapSize,
        f.uniforms.radius.value = C.radius,
        i.setRenderTarget(C.mapPass),
        i.clear(),
        i.renderBufferDirect(M, null, L, f, g, null),
        h.uniforms.shadow_pass.value = C.mapPass.texture,
        h.uniforms.resolution.value = C.mapSize,
        h.uniforms.radius.value = C.radius,
        i.setRenderTarget(C.map),
        i.clear(),
        i.renderBufferDirect(M, null, L, h, g, null)
    }
    function y(C, M, L, T) {
        let A = null;
        const k = L.isPointLight === !0 ? C.customDistanceMaterial : C.customDepthMaterial;
        if (k !== void 0)
            A = k;
        else if (A = L.isPointLight === !0 ? l : a,
        i.localClippingEnabled && M.clipShadows === !0 && Array.isArray(M.clippingPlanes) && M.clippingPlanes.length !== 0 || M.displacementMap && M.displacementScale !== 0 || M.alphaMap && M.alphaTest > 0 || M.map && M.alphaTest > 0) {
            const D = A.uuid
              , F = M.uuid;
            let z = c[D];
            z === void 0 && (z = {},
            c[D] = z);
            let G = z[F];
            G === void 0 && (G = A.clone(),
            z[F] = G,
            M.addEventListener("dispose", S)),
            A = G
        }
        if (A.visible = M.visible,
        A.wireframe = M.wireframe,
        T === ho ? A.side = M.shadowSide !== null ? M.shadowSide : M.side : A.side = M.shadowSide !== null ? M.shadowSide : d[M.side],
        A.alphaMap = M.alphaMap,
        A.alphaTest = M.alphaTest,
        A.map = M.map,
        A.clipShadows = M.clipShadows,
        A.clippingPlanes = M.clippingPlanes,
        A.clipIntersection = M.clipIntersection,
        A.displacementMap = M.displacementMap,
        A.displacementScale = M.displacementScale,
        A.displacementBias = M.displacementBias,
        A.wireframeLinewidth = M.wireframeLinewidth,
        A.linewidth = M.linewidth,
        L.isPointLight === !0 && A.isMeshDistanceMaterial === !0) {
            const D = i.properties.get(A);
            D.light = L
        }
        return A
    }
    function b(C, M, L, T, A) {
        if (C.visible === !1)
            return;
        if (C.layers.test(M.layers) && (C.isMesh || C.isLine || C.isPoints) && (C.castShadow || C.receiveShadow && A === ho) && (!C.frustumCulled || n.intersectsObject(C))) {
            C.modelViewMatrix.multiplyMatrices(L.matrixWorldInverse, C.matrixWorld);
            const F = e.update(C)
              , z = C.material;
            if (Array.isArray(z)) {
                const G = F.groups;
                for (let H = 0, X = G.length; H < X; H++) {
                    const K = G[H]
                      , ce = z[K.materialIndex];
                    if (ce && ce.visible) {
                        const ue = y(C, ce, T, A);
                        C.onBeforeShadow(i, C, M, L, F, ue, K),
                        i.renderBufferDirect(L, null, F, ue, C, K),
                        C.onAfterShadow(i, C, M, L, F, ue, K)
                    }
                }
            } else if (z.visible) {
                const G = y(C, z, T, A);
                C.onBeforeShadow(i, C, M, L, F, G, null),
                i.renderBufferDirect(L, null, F, G, C, null),
                C.onAfterShadow(i, C, M, L, F, G, null)
            }
        }
        const D = C.children;
        for (let F = 0, z = D.length; F < z; F++)
            b(D[F], M, L, T, A)
    }
    function S(C) {
        C.target.removeEventListener("dispose", S);
        for (const L in c) {
            const T = c[L]
              , A = C.target.uuid;
            A in T && (T[A].dispose(),
            delete T[A])
        }
    }
}
function qee(i) {
    function e() {
        let te = !1;
        const Je = new oi;
        let De = null;
        const Ue = new oi(0,0,0,0);
        return {
            setMask: function(et) {
                De !== et && !te && (i.colorMask(et, et, et, et),
                De = et)
            },
            setLocked: function(et) {
                te = et
            },
            setClear: function(et, Lt, Wt, $, Z) {
                Z === !0 && (et *= $,
                Lt *= $,
                Wt *= $),
                Je.set(et, Lt, Wt, $),
                Ue.equals(Je) === !1 && (i.clearColor(et, Lt, Wt, $),
                Ue.copy(Je))
            },
            reset: function() {
                te = !1,
                De = null,
                Ue.set(-1, 0, 0, 0)
            }
        }
    }
    function t() {
        let te = !1
          , Je = null
          , De = null
          , Ue = null;
        return {
            setTest: function(et) {
                et ? be(i.DEPTH_TEST) : q(i.DEPTH_TEST)
            },
            setMask: function(et) {
                Je !== et && !te && (i.depthMask(et),
                Je = et)
            },
            setFunc: function(et) {
                if (De !== et) {
                    switch (et) {
                    case yX:
                        i.depthFunc(i.NEVER);
                        break;
                    case bX:
                        i.depthFunc(i.ALWAYS);
                        break;
                    case SX:
                        i.depthFunc(i.LESS);
                        break;
                    case Op:
                        i.depthFunc(i.LEQUAL);
                        break;
                    case EX:
                        i.depthFunc(i.EQUAL);
                        break;
                    case wX:
                        i.depthFunc(i.GEQUAL);
                        break;
                    case TX:
                        i.depthFunc(i.GREATER);
                        break;
                    case AX:
                        i.depthFunc(i.NOTEQUAL);
                        break;
                    default:
                        i.depthFunc(i.LEQUAL)
                    }
                    De = et
                }
            },
            setLocked: function(et) {
                te = et
            },
            setClear: function(et) {
                Ue !== et && (i.clearDepth(et),
                Ue = et)
            },
            reset: function() {
                te = !1,
                Je = null,
                De = null,
                Ue = null
            }
        }
    }
    function n() {
        let te = !1
          , Je = null
          , De = null
          , Ue = null
          , et = null
          , Lt = null
          , Wt = null
          , $ = null
          , Z = null;
        return {
            setTest: function(ne) {
                te || (ne ? be(i.STENCIL_TEST) : q(i.STENCIL_TEST))
            },
            setMask: function(ne) {
                Je !== ne && !te && (i.stencilMask(ne),
                Je = ne)
            },
            setFunc: function(ne, Ne, Ke) {
                (De !== ne || Ue !== Ne || et !== Ke) && (i.stencilFunc(ne, Ne, Ke),
                De = ne,
                Ue = Ne,
                et = Ke)
            },
            setOp: function(ne, Ne, Ke) {
                (Lt !== ne || Wt !== Ne || $ !== Ke) && (i.stencilOp(ne, Ne, Ke),
                Lt = ne,
                Wt = Ne,
                $ = Ke)
            },
            setLocked: function(ne) {
                te = ne
            },
            setClear: function(ne) {
                Z !== ne && (i.clearStencil(ne),
                Z = ne)
            },
            reset: function() {
                te = !1,
                Je = null,
                De = null,
                Ue = null,
                et = null,
                Lt = null,
                Wt = null,
                $ = null,
                Z = null
            }
        }
    }
    const s = new e
      , r = new t
      , o = new n
      , a = new WeakMap
      , l = new WeakMap;
    let c = {}
      , u = {}
      , d = new WeakMap
      , f = []
      , h = null
      , p = !1
      , g = null
      , m = null
      , v = null
      , _ = null
      , y = null
      , b = null
      , S = null
      , C = new un(0,0,0)
      , M = 0
      , L = !1
      , T = null
      , A = null
      , k = null
      , D = null
      , F = null;
    const z = i.getParameter(i.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
    let G = !1
      , H = 0;
    const X = i.getParameter(i.VERSION);
    X.indexOf("WebGL") !== -1 ? (H = parseFloat(/^WebGL (\d)/.exec(X)[1]),
    G = H >= 1) : X.indexOf("OpenGL ES") !== -1 && (H = parseFloat(/^OpenGL ES (\d)/.exec(X)[1]),
    G = H >= 2);
    let K = null
      , ce = {};
    const ue = i.getParameter(i.SCISSOR_BOX)
      , Ie = i.getParameter(i.VIEWPORT)
      , ke = new oi().fromArray(ue)
      , We = new oi().fromArray(Ie);
    function se(te, Je, De, Ue) {
        const et = new Uint8Array(4)
          , Lt = i.createTexture();
        i.bindTexture(te, Lt),
        i.texParameteri(te, i.TEXTURE_MIN_FILTER, i.NEAREST),
        i.texParameteri(te, i.TEXTURE_MAG_FILTER, i.NEAREST);
        for (let Wt = 0; Wt < De; Wt++)
            te === i.TEXTURE_3D || te === i.TEXTURE_2D_ARRAY ? i.texImage3D(Je, 0, i.RGBA, 1, 1, Ue, 0, i.RGBA, i.UNSIGNED_BYTE, et) : i.texImage2D(Je + Wt, 0, i.RGBA, 1, 1, 0, i.RGBA, i.UNSIGNED_BYTE, et);
        return Lt
    }
    const Se = {};
    Se[i.TEXTURE_2D] = se(i.TEXTURE_2D, i.TEXTURE_2D, 1),
    Se[i.TEXTURE_CUBE_MAP] = se(i.TEXTURE_CUBE_MAP, i.TEXTURE_CUBE_MAP_POSITIVE_X, 6),
    Se[i.TEXTURE_2D_ARRAY] = se(i.TEXTURE_2D_ARRAY, i.TEXTURE_2D_ARRAY, 1, 1),
    Se[i.TEXTURE_3D] = se(i.TEXTURE_3D, i.TEXTURE_3D, 1, 1),
    s.setClear(0, 0, 0, 1),
    r.setClear(1),
    o.setClear(0),
    be(i.DEPTH_TEST),
    r.setFunc(Op),
    Q(!1),
    he(NS),
    be(i.CULL_FACE),
    B(_a);
    function be(te) {
        c[te] !== !0 && (i.enable(te),
        c[te] = !0)
    }
    function q(te) {
        c[te] !== !1 && (i.disable(te),
        c[te] = !1)
    }
    function me(te, Je) {
        return u[te] !== Je ? (i.bindFramebuffer(te, Je),
        u[te] = Je,
        te === i.DRAW_FRAMEBUFFER && (u[i.FRAMEBUFFER] = Je),
        te === i.FRAMEBUFFER && (u[i.DRAW_FRAMEBUFFER] = Je),
        !0) : !1
    }
    function Ce(te, Je) {
        let De = f
          , Ue = !1;
        if (te) {
            De = d.get(Je),
            De === void 0 && (De = [],
            d.set(Je, De));
            const et = te.textures;
            if (De.length !== et.length || De[0] !== i.COLOR_ATTACHMENT0) {
                for (let Lt = 0, Wt = et.length; Lt < Wt; Lt++)
                    De[Lt] = i.COLOR_ATTACHMENT0 + Lt;
                De.length = et.length,
                Ue = !0
            }
        } else
            De[0] !== i.BACK && (De[0] = i.BACK,
            Ue = !0);
        Ue && i.drawBuffers(De)
    }
    function Pe(te) {
        return h !== te ? (i.useProgram(te),
        h = te,
        !0) : !1
    }
    const vt = {
        [al]: i.FUNC_ADD,
        [iX]: i.FUNC_SUBTRACT,
        [sX]: i.FUNC_REVERSE_SUBTRACT
    };
    vt[rX] = i.MIN,
    vt[oX] = i.MAX;
    const j = {
        [aX]: i.ZERO,
        [lX]: i.ONE,
        [cX]: i.SRC_COLOR,
        [J1]: i.SRC_ALPHA,
        [mX]: i.SRC_ALPHA_SATURATE,
        [hX]: i.DST_COLOR,
        [dX]: i.DST_ALPHA,
        [uX]: i.ONE_MINUS_SRC_COLOR,
        [Q1]: i.ONE_MINUS_SRC_ALPHA,
        [pX]: i.ONE_MINUS_DST_COLOR,
        [fX]: i.ONE_MINUS_DST_ALPHA,
        [gX]: i.CONSTANT_COLOR,
        [vX]: i.ONE_MINUS_CONSTANT_COLOR,
        [_X]: i.CONSTANT_ALPHA,
        [xX]: i.ONE_MINUS_CONSTANT_ALPHA
    };
    function B(te, Je, De, Ue, et, Lt, Wt, $, Z, ne) {
        if (te === _a) {
            p === !0 && (q(i.BLEND),
            p = !1);
            return
        }
        if (p === !1 && (be(i.BLEND),
        p = !0),
        te !== nX) {
            if (te !== g || ne !== L) {
                if ((m !== al || y !== al) && (i.blendEquation(i.FUNC_ADD),
                m = al,
                y = al),
                ne)
                    switch (te) {
                    case Gc:
                        i.blendFuncSeparate(i.ONE, i.ONE_MINUS_SRC_ALPHA, i.ONE, i.ONE_MINUS_SRC_ALPHA);
                        break;
                    case BS:
                        i.blendFunc(i.ONE, i.ONE);
                        break;
                    case VS:
                        i.blendFuncSeparate(i.ZERO, i.ONE_MINUS_SRC_COLOR, i.ZERO, i.ONE);
                        break;
                    case $S:
                        i.blendFuncSeparate(i.ZERO, i.SRC_COLOR, i.ZERO, i.SRC_ALPHA);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", te);
                        break
                    }
                else
                    switch (te) {
                    case Gc:
                        i.blendFuncSeparate(i.SRC_ALPHA, i.ONE_MINUS_SRC_ALPHA, i.ONE, i.ONE_MINUS_SRC_ALPHA);
                        break;
                    case BS:
                        i.blendFunc(i.SRC_ALPHA, i.ONE);
                        break;
                    case VS:
                        i.blendFuncSeparate(i.ZERO, i.ONE_MINUS_SRC_COLOR, i.ZERO, i.ONE);
                        break;
                    case $S:
                        i.blendFunc(i.ZERO, i.SRC_COLOR);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", te);
                        break
                    }
                v = null,
                _ = null,
                b = null,
                S = null,
                C.set(0, 0, 0),
                M = 0,
                g = te,
                L = ne
            }
            return
        }
        et = et || Je,
        Lt = Lt || De,
        Wt = Wt || Ue,
        (Je !== m || et !== y) && (i.blendEquationSeparate(vt[Je], vt[et]),
        m = Je,
        y = et),
        (De !== v || Ue !== _ || Lt !== b || Wt !== S) && (i.blendFuncSeparate(j[De], j[Ue], j[Lt], j[Wt]),
        v = De,
        _ = Ue,
        b = Lt,
        S = Wt),
        ($.equals(C) === !1 || Z !== M) && (i.blendColor($.r, $.g, $.b, Z),
        C.copy($),
        M = Z),
        g = te,
        L = !1
    }
    function V(te, Je) {
        te.side === Ao ? q(i.CULL_FACE) : be(i.CULL_FACE);
        let De = te.side === os;
        Je && (De = !De),
        Q(De),
        te.blending === Gc && te.transparent === !1 ? B(_a) : B(te.blending, te.blendEquation, te.blendSrc, te.blendDst, te.blendEquationAlpha, te.blendSrcAlpha, te.blendDstAlpha, te.blendColor, te.blendAlpha, te.premultipliedAlpha),
        r.setFunc(te.depthFunc),
        r.setTest(te.depthTest),
        r.setMask(te.depthWrite),
        s.setMask(te.colorWrite);
        const Ue = te.stencilWrite;
        o.setTest(Ue),
        Ue && (o.setMask(te.stencilWriteMask),
        o.setFunc(te.stencilFunc, te.stencilRef, te.stencilFuncMask),
        o.setOp(te.stencilFail, te.stencilZFail, te.stencilZPass)),
        we(te.polygonOffset, te.polygonOffsetFactor, te.polygonOffsetUnits),
        te.alphaToCoverage === !0 ? be(i.SAMPLE_ALPHA_TO_COVERAGE) : q(i.SAMPLE_ALPHA_TO_COVERAGE)
    }
    function Q(te) {
        T !== te && (te ? i.frontFace(i.CW) : i.frontFace(i.CCW),
        T = te)
    }
    function he(te) {
        te !== QK ? (be(i.CULL_FACE),
        te !== A && (te === NS ? i.cullFace(i.BACK) : te === eX ? i.cullFace(i.FRONT) : i.cullFace(i.FRONT_AND_BACK))) : q(i.CULL_FACE),
        A = te
    }
    function Ee(te) {
        te !== k && (G && i.lineWidth(te),
        k = te)
    }
    function we(te, Je, De) {
        te ? (be(i.POLYGON_OFFSET_FILL),
        (D !== Je || F !== De) && (i.polygonOffset(Je, De),
        D = Je,
        F = De)) : q(i.POLYGON_OFFSET_FILL)
    }
    function Le(te) {
        te ? be(i.SCISSOR_TEST) : q(i.SCISSOR_TEST)
    }
    function N(te) {
        te === void 0 && (te = i.TEXTURE0 + z - 1),
        K !== te && (i.activeTexture(te),
        K = te)
    }
    function I(te, Je, De) {
        De === void 0 && (K === null ? De = i.TEXTURE0 + z - 1 : De = K);
        let Ue = ce[De];
        Ue === void 0 && (Ue = {
            type: void 0,
            texture: void 0
        },
        ce[De] = Ue),
        (Ue.type !== te || Ue.texture !== Je) && (K !== De && (i.activeTexture(De),
        K = De),
        i.bindTexture(te, Je || Se[te]),
        Ue.type = te,
        Ue.texture = Je)
    }
    function W() {
        const te = ce[K];
        te !== void 0 && te.type !== void 0 && (i.bindTexture(te.type, null),
        te.type = void 0,
        te.texture = void 0)
    }
    function re() {
        try {
            i.compressedTexImage2D.apply(i, arguments)
        } catch (te) {
            console.error("THREE.WebGLState:", te)
        }
    }
    function oe() {
        try {
            i.compressedTexImage3D.apply(i, arguments)
        } catch (te) {
            console.error("THREE.WebGLState:", te)
        }
    }
    function fe() {
        try {
            i.texSubImage2D.apply(i, arguments)
        } catch (te) {
            console.error("THREE.WebGLState:", te)
        }
    }
    function $e() {
        try {
            i.texSubImage3D.apply(i, arguments)
        } catch (te) {
            console.error("THREE.WebGLState:", te)
        }
    }
    function Oe() {
        try {
            i.compressedTexSubImage2D.apply(i, arguments)
        } catch (te) {
            console.error("THREE.WebGLState:", te)
        }
    }
    function qe() {
        try {
            i.compressedTexSubImage3D.apply(i, arguments)
        } catch (te) {
            console.error("THREE.WebGLState:", te)
        }
    }
    function nt() {
        try {
            i.texStorage2D.apply(i, arguments)
        } catch (te) {
            console.error("THREE.WebGLState:", te)
        }
    }
    function Be() {
        try {
            i.texStorage3D.apply(i, arguments)
        } catch (te) {
            console.error("THREE.WebGLState:", te)
        }
    }
    function Xe() {
        try {
            i.texImage2D.apply(i, arguments)
        } catch (te) {
            console.error("THREE.WebGLState:", te)
        }
    }
    function Rt() {
        try {
            i.texImage3D.apply(i, arguments)
        } catch (te) {
            console.error("THREE.WebGLState:", te)
        }
    }
    function ht(te) {
        ke.equals(te) === !1 && (i.scissor(te.x, te.y, te.z, te.w),
        ke.copy(te))
    }
    function lt(te) {
        We.equals(te) === !1 && (i.viewport(te.x, te.y, te.z, te.w),
        We.copy(te))
    }
    function kt(te, Je) {
        let De = l.get(Je);
        De === void 0 && (De = new WeakMap,
        l.set(Je, De));
        let Ue = De.get(te);
        Ue === void 0 && (Ue = i.getUniformBlockIndex(Je, te.name),
        De.set(te, Ue))
    }
    function _t(te, Je) {
        const Ue = l.get(Je).get(te);
        a.get(Je) !== Ue && (i.uniformBlockBinding(Je, Ue, te.__bindingPointIndex),
        a.set(Je, Ue))
    }
    function Xt() {
        i.disable(i.BLEND),
        i.disable(i.CULL_FACE),
        i.disable(i.DEPTH_TEST),
        i.disable(i.POLYGON_OFFSET_FILL),
        i.disable(i.SCISSOR_TEST),
        i.disable(i.STENCIL_TEST),
        i.disable(i.SAMPLE_ALPHA_TO_COVERAGE),
        i.blendEquation(i.FUNC_ADD),
        i.blendFunc(i.ONE, i.ZERO),
        i.blendFuncSeparate(i.ONE, i.ZERO, i.ONE, i.ZERO),
        i.blendColor(0, 0, 0, 0),
        i.colorMask(!0, !0, !0, !0),
        i.clearColor(0, 0, 0, 0),
        i.depthMask(!0),
        i.depthFunc(i.LESS),
        i.clearDepth(1),
        i.stencilMask(4294967295),
        i.stencilFunc(i.ALWAYS, 0, 4294967295),
        i.stencilOp(i.KEEP, i.KEEP, i.KEEP),
        i.clearStencil(0),
        i.cullFace(i.BACK),
        i.frontFace(i.CCW),
        i.polygonOffset(0, 0),
        i.activeTexture(i.TEXTURE0),
        i.bindFramebuffer(i.FRAMEBUFFER, null),
        i.bindFramebuffer(i.DRAW_FRAMEBUFFER, null),
        i.bindFramebuffer(i.READ_FRAMEBUFFER, null),
        i.useProgram(null),
        i.lineWidth(1),
        i.scissor(0, 0, i.canvas.width, i.canvas.height),
        i.viewport(0, 0, i.canvas.width, i.canvas.height),
        c = {},
        K = null,
        ce = {},
        u = {},
        d = new WeakMap,
        f = [],
        h = null,
        p = !1,
        g = null,
        m = null,
        v = null,
        _ = null,
        y = null,
        b = null,
        S = null,
        C = new un(0,0,0),
        M = 0,
        L = !1,
        T = null,
        A = null,
        k = null,
        D = null,
        F = null,
        ke.set(0, 0, i.canvas.width, i.canvas.height),
        We.set(0, 0, i.canvas.width, i.canvas.height),
        s.reset(),
        r.reset(),
        o.reset()
    }
    return {
        buffers: {
            color: s,
            depth: r,
            stencil: o
        },
        enable: be,
        disable: q,
        bindFramebuffer: me,
        drawBuffers: Ce,
        useProgram: Pe,
        setBlending: B,
        setMaterial: V,
        setFlipSided: Q,
        setCullFace: he,
        setLineWidth: Ee,
        setPolygonOffset: we,
        setScissorTest: Le,
        activeTexture: N,
        bindTexture: I,
        unbindTexture: W,
        compressedTexImage2D: re,
        compressedTexImage3D: oe,
        texImage2D: Xe,
        texImage3D: Rt,
        updateUBOMapping: kt,
        uniformBlockBinding: _t,
        texStorage2D: nt,
        texStorage3D: Be,
        texSubImage2D: fe,
        texSubImage3D: $e,
        compressedTexSubImage2D: Oe,
        compressedTexSubImage3D: qe,
        scissor: ht,
        viewport: lt,
        reset: Xt
    }
}
function PE(i, e, t, n) {
    const s = jee(n);
    switch (t) {
    case e3:
        return i * e;
    case n3:
        return i * e;
    case i3:
        return i * e * 2;
    case s3:
        return i * e / s.components * s.byteLength;
    case yx:
        return i * e / s.components * s.byteLength;
    case r3:
        return i * e * 2 / s.components * s.byteLength;
    case bx:
        return i * e * 2 / s.components * s.byteLength;
    case t3:
        return i * e * 3 / s.components * s.byteLength;
    case fr:
        return i * e * 4 / s.components * s.byteLength;
    case Sx:
        return i * e * 4 / s.components * s.byteLength;
    case Fh:
    case Oh:
        return Math.floor((i + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case Uh:
    case Nh:
        return Math.floor((i + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case rv:
    case av:
        return Math.max(i, 16) * Math.max(e, 8) / 4;
    case sv:
    case ov:
        return Math.max(i, 8) * Math.max(e, 8) / 2;
    case lv:
    case cv:
        return Math.floor((i + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case uv:
        return Math.floor((i + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case dv:
        return Math.floor((i + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case fv:
        return Math.floor((i + 4) / 5) * Math.floor((e + 3) / 4) * 16;
    case hv:
        return Math.floor((i + 4) / 5) * Math.floor((e + 4) / 5) * 16;
    case pv:
        return Math.floor((i + 5) / 6) * Math.floor((e + 4) / 5) * 16;
    case mv:
        return Math.floor((i + 5) / 6) * Math.floor((e + 5) / 6) * 16;
    case gv:
        return Math.floor((i + 7) / 8) * Math.floor((e + 4) / 5) * 16;
    case vv:
        return Math.floor((i + 7) / 8) * Math.floor((e + 5) / 6) * 16;
    case _v:
        return Math.floor((i + 7) / 8) * Math.floor((e + 7) / 8) * 16;
    case xv:
        return Math.floor((i + 9) / 10) * Math.floor((e + 4) / 5) * 16;
    case yv:
        return Math.floor((i + 9) / 10) * Math.floor((e + 5) / 6) * 16;
    case bv:
        return Math.floor((i + 9) / 10) * Math.floor((e + 7) / 8) * 16;
    case Sv:
        return Math.floor((i + 9) / 10) * Math.floor((e + 9) / 10) * 16;
    case Ev:
        return Math.floor((i + 11) / 12) * Math.floor((e + 9) / 10) * 16;
    case wv:
        return Math.floor((i + 11) / 12) * Math.floor((e + 11) / 12) * 16;
    case Bh:
    case Tv:
    case Av:
        return Math.ceil(i / 4) * Math.ceil(e / 4) * 16;
    case o3:
    case Cv:
        return Math.ceil(i / 4) * Math.ceil(e / 4) * 8;
    case Mv:
    case Rv:
        return Math.ceil(i / 4) * Math.ceil(e / 4) * 16
    }
    throw new Error(`Unable to determine texture byte length for ${t} format.`)
}
function jee(i) {
    switch (i) {
    case Fo:
    case ZM:
        return {
            byteLength: 1,
            components: 1
        };
    case Nd:
    case JM:
    case of:
        return {
            byteLength: 2,
            components: 1
        };
    case _x:
    case xx:
        return {
            byteLength: 2,
            components: 4
        };
    case Pl:
    case vx:
    case Ro:
        return {
            byteLength: 4,
            components: 1
        };
    case QM:
        return {
            byteLength: 4,
            components: 3
        }
    }
    throw new Error(`Unknown texture type ${i}.`)
}
function Kee(i, e, t, n, s, r, o) {
    const a = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null
      , l = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent)
      , c = new nn
      , u = new WeakMap;
    let d;
    const f = new WeakMap;
    let h = !1;
    try {
        h = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1,1).getContext("2d") !== null
    } catch {}
    function p(N, I) {
        return h ? new OffscreenCanvas(N,I) : $p("canvas")
    }
    function g(N, I, W) {
        let re = 1;
        const oe = Le(N);
        if ((oe.width > W || oe.height > W) && (re = W / Math.max(oe.width, oe.height)),
        re < 1)
            if (typeof HTMLImageElement < "u" && N instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && N instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && N instanceof ImageBitmap || typeof VideoFrame < "u" && N instanceof VideoFrame) {
                const fe = Math.floor(re * oe.width)
                  , $e = Math.floor(re * oe.height);
                d === void 0 && (d = p(fe, $e));
                const Oe = I ? p(fe, $e) : d;
                return Oe.width = fe,
                Oe.height = $e,
                Oe.getContext("2d").drawImage(N, 0, 0, fe, $e),
                console.warn("THREE.WebGLRenderer: Texture has been resized from (" + oe.width + "x" + oe.height + ") to (" + fe + "x" + $e + ")."),
                Oe
            } else
                return "data"in N && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + oe.width + "x" + oe.height + ")."),
                N;
        return N
    }
    function m(N) {
        return N.generateMipmaps && N.minFilter !== Ns && N.minFilter !== ur
    }
    function v(N) {
        i.generateMipmap(N)
    }
    function _(N, I, W, re, oe=!1) {
        if (N !== null) {
            if (i[N] !== void 0)
                return i[N];
            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + N + "'")
        }
        let fe = I;
        if (I === i.RED && (W === i.FLOAT && (fe = i.R32F),
        W === i.HALF_FLOAT && (fe = i.R16F),
        W === i.UNSIGNED_BYTE && (fe = i.R8)),
        I === i.RED_INTEGER && (W === i.UNSIGNED_BYTE && (fe = i.R8UI),
        W === i.UNSIGNED_SHORT && (fe = i.R16UI),
        W === i.UNSIGNED_INT && (fe = i.R32UI),
        W === i.BYTE && (fe = i.R8I),
        W === i.SHORT && (fe = i.R16I),
        W === i.INT && (fe = i.R32I)),
        I === i.RG && (W === i.FLOAT && (fe = i.RG32F),
        W === i.HALF_FLOAT && (fe = i.RG16F),
        W === i.UNSIGNED_BYTE && (fe = i.RG8)),
        I === i.RG_INTEGER && (W === i.UNSIGNED_BYTE && (fe = i.RG8UI),
        W === i.UNSIGNED_SHORT && (fe = i.RG16UI),
        W === i.UNSIGNED_INT && (fe = i.RG32UI),
        W === i.BYTE && (fe = i.RG8I),
        W === i.SHORT && (fe = i.RG16I),
        W === i.INT && (fe = i.RG32I)),
        I === i.RGB && W === i.UNSIGNED_INT_5_9_9_9_REV && (fe = i.RGB9_E5),
        I === i.RGBA) {
            const $e = oe ? Up : pn.getTransfer(re);
            W === i.FLOAT && (fe = i.RGBA32F),
            W === i.HALF_FLOAT && (fe = i.RGBA16F),
            W === i.UNSIGNED_BYTE && (fe = $e === In ? i.SRGB8_ALPHA8 : i.RGBA8),
            W === i.UNSIGNED_SHORT_4_4_4_4 && (fe = i.RGBA4),
            W === i.UNSIGNED_SHORT_5_5_5_1 && (fe = i.RGB5_A1)
        }
        return (fe === i.R16F || fe === i.R32F || fe === i.RG16F || fe === i.RG32F || fe === i.RGBA16F || fe === i.RGBA32F) && e.get("EXT_color_buffer_float"),
        fe
    }
    function y(N, I) {
        let W;
        return N ? I === null || I === Pl || I === pu ? W = i.DEPTH24_STENCIL8 : I === Ro ? W = i.DEPTH32F_STENCIL8 : I === Nd && (W = i.DEPTH24_STENCIL8,
        console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : I === null || I === Pl || I === pu ? W = i.DEPTH_COMPONENT24 : I === Ro ? W = i.DEPTH_COMPONENT32F : I === Nd && (W = i.DEPTH_COMPONENT16),
        W
    }
    function b(N, I) {
        return m(N) === !0 || N.isFramebufferTexture && N.minFilter !== Ns && N.minFilter !== ur ? Math.log2(Math.max(I.width, I.height)) + 1 : N.mipmaps !== void 0 && N.mipmaps.length > 0 ? N.mipmaps.length : N.isCompressedTexture && Array.isArray(N.image) ? I.mipmaps.length : 1
    }
    function S(N) {
        const I = N.target;
        I.removeEventListener("dispose", S),
        M(I),
        I.isVideoTexture && u.delete(I)
    }
    function C(N) {
        const I = N.target;
        I.removeEventListener("dispose", C),
        T(I)
    }
    function M(N) {
        const I = n.get(N);
        if (I.__webglInit === void 0)
            return;
        const W = N.source
          , re = f.get(W);
        if (re) {
            const oe = re[I.__cacheKey];
            oe.usedTimes--,
            oe.usedTimes === 0 && L(N),
            Object.keys(re).length === 0 && f.delete(W)
        }
        n.remove(N)
    }
    function L(N) {
        const I = n.get(N);
        i.deleteTexture(I.__webglTexture);
        const W = N.source
          , re = f.get(W);
        delete re[I.__cacheKey],
        o.memory.textures--
    }
    function T(N) {
        const I = n.get(N);
        if (N.depthTexture && N.depthTexture.dispose(),
        N.isWebGLCubeRenderTarget)
            for (let re = 0; re < 6; re++) {
                if (Array.isArray(I.__webglFramebuffer[re]))
                    for (let oe = 0; oe < I.__webglFramebuffer[re].length; oe++)
                        i.deleteFramebuffer(I.__webglFramebuffer[re][oe]);
                else
                    i.deleteFramebuffer(I.__webglFramebuffer[re]);
                I.__webglDepthbuffer && i.deleteRenderbuffer(I.__webglDepthbuffer[re])
            }
        else {
            if (Array.isArray(I.__webglFramebuffer))
                for (let re = 0; re < I.__webglFramebuffer.length; re++)
                    i.deleteFramebuffer(I.__webglFramebuffer[re]);
            else
                i.deleteFramebuffer(I.__webglFramebuffer);
            if (I.__webglDepthbuffer && i.deleteRenderbuffer(I.__webglDepthbuffer),
            I.__webglMultisampledFramebuffer && i.deleteFramebuffer(I.__webglMultisampledFramebuffer),
            I.__webglColorRenderbuffer)
                for (let re = 0; re < I.__webglColorRenderbuffer.length; re++)
                    I.__webglColorRenderbuffer[re] && i.deleteRenderbuffer(I.__webglColorRenderbuffer[re]);
            I.__webglDepthRenderbuffer && i.deleteRenderbuffer(I.__webglDepthRenderbuffer)
        }
        const W = N.textures;
        for (let re = 0, oe = W.length; re < oe; re++) {
            const fe = n.get(W[re]);
            fe.__webglTexture && (i.deleteTexture(fe.__webglTexture),
            o.memory.textures--),
            n.remove(W[re])
        }
        n.remove(N)
    }
    let A = 0;
    function k() {
        A = 0
    }
    function D() {
        const N = A;
        return N >= s.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + N + " texture units while this GPU supports only " + s.maxTextures),
        A += 1,
        N
    }
    function F(N) {
        const I = [];
        return I.push(N.wrapS),
        I.push(N.wrapT),
        I.push(N.wrapR || 0),
        I.push(N.magFilter),
        I.push(N.minFilter),
        I.push(N.anisotropy),
        I.push(N.internalFormat),
        I.push(N.format),
        I.push(N.type),
        I.push(N.generateMipmaps),
        I.push(N.premultiplyAlpha),
        I.push(N.flipY),
        I.push(N.unpackAlignment),
        I.push(N.colorSpace),
        I.join()
    }
    function z(N, I) {
        const W = n.get(N);
        if (N.isVideoTexture && Ee(N),
        N.isRenderTargetTexture === !1 && N.version > 0 && W.__version !== N.version) {
            const re = N.image;
            if (re === null)
                console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
            else if (re.complete === !1)
                console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
            else {
                We(W, N, I);
                return
            }
        }
        t.bindTexture(i.TEXTURE_2D, W.__webglTexture, i.TEXTURE0 + I)
    }
    function G(N, I) {
        const W = n.get(N);
        if (N.version > 0 && W.__version !== N.version) {
            We(W, N, I);
            return
        }
        t.bindTexture(i.TEXTURE_2D_ARRAY, W.__webglTexture, i.TEXTURE0 + I)
    }
    function H(N, I) {
        const W = n.get(N);
        if (N.version > 0 && W.__version !== N.version) {
            We(W, N, I);
            return
        }
        t.bindTexture(i.TEXTURE_3D, W.__webglTexture, i.TEXTURE0 + I)
    }
    function X(N, I) {
        const W = n.get(N);
        if (N.version > 0 && W.__version !== N.version) {
            se(W, N, I);
            return
        }
        t.bindTexture(i.TEXTURE_CUBE_MAP, W.__webglTexture, i.TEXTURE0 + I)
    }
    const K = {
        [nv]: i.REPEAT,
        [pl]: i.CLAMP_TO_EDGE,
        [iv]: i.MIRRORED_REPEAT
    }
      , ce = {
        [Ns]: i.NEAREST,
        [OX]: i.NEAREST_MIPMAP_NEAREST,
        [Gf]: i.NEAREST_MIPMAP_LINEAR,
        [ur]: i.LINEAR,
        [H0]: i.LINEAR_MIPMAP_NEAREST,
        [ml]: i.LINEAR_MIPMAP_LINEAR
    }
      , ue = {
        [VX]: i.NEVER,
        [qX]: i.ALWAYS,
        [$X]: i.LESS,
        [l3]: i.LEQUAL,
        [HX]: i.EQUAL,
        [WX]: i.GEQUAL,
        [zX]: i.GREATER,
        [GX]: i.NOTEQUAL
    };
    function Ie(N, I) {
        if (I.type === Ro && e.has("OES_texture_float_linear") === !1 && (I.magFilter === ur || I.magFilter === H0 || I.magFilter === Gf || I.magFilter === ml || I.minFilter === ur || I.minFilter === H0 || I.minFilter === Gf || I.minFilter === ml) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."),
        i.texParameteri(N, i.TEXTURE_WRAP_S, K[I.wrapS]),
        i.texParameteri(N, i.TEXTURE_WRAP_T, K[I.wrapT]),
        (N === i.TEXTURE_3D || N === i.TEXTURE_2D_ARRAY) && i.texParameteri(N, i.TEXTURE_WRAP_R, K[I.wrapR]),
        i.texParameteri(N, i.TEXTURE_MAG_FILTER, ce[I.magFilter]),
        i.texParameteri(N, i.TEXTURE_MIN_FILTER, ce[I.minFilter]),
        I.compareFunction && (i.texParameteri(N, i.TEXTURE_COMPARE_MODE, i.COMPARE_REF_TO_TEXTURE),
        i.texParameteri(N, i.TEXTURE_COMPARE_FUNC, ue[I.compareFunction])),
        e.has("EXT_texture_filter_anisotropic") === !0) {
            if (I.magFilter === Ns || I.minFilter !== Gf && I.minFilter !== ml || I.type === Ro && e.has("OES_texture_float_linear") === !1)
                return;
            if (I.anisotropy > 1 || n.get(I).__currentAnisotropy) {
                const W = e.get("EXT_texture_filter_anisotropic");
                i.texParameterf(N, W.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(I.anisotropy, s.getMaxAnisotropy())),
                n.get(I).__currentAnisotropy = I.anisotropy
            }
        }
    }
    function ke(N, I) {
        let W = !1;
        N.__webglInit === void 0 && (N.__webglInit = !0,
        I.addEventListener("dispose", S));
        const re = I.source;
        let oe = f.get(re);
        oe === void 0 && (oe = {},
        f.set(re, oe));
        const fe = F(I);
        if (fe !== N.__cacheKey) {
            oe[fe] === void 0 && (oe[fe] = {
                texture: i.createTexture(),
                usedTimes: 0
            },
            o.memory.textures++,
            W = !0),
            oe[fe].usedTimes++;
            const $e = oe[N.__cacheKey];
            $e !== void 0 && (oe[N.__cacheKey].usedTimes--,
            $e.usedTimes === 0 && L(I)),
            N.__cacheKey = fe,
            N.__webglTexture = oe[fe].texture
        }
        return W
    }
    function We(N, I, W) {
        let re = i.TEXTURE_2D;
        (I.isDataArrayTexture || I.isCompressedArrayTexture) && (re = i.TEXTURE_2D_ARRAY),
        I.isData3DTexture && (re = i.TEXTURE_3D);
        const oe = ke(N, I)
          , fe = I.source;
        t.bindTexture(re, N.__webglTexture, i.TEXTURE0 + W);
        const $e = n.get(fe);
        if (fe.version !== $e.__version || oe === !0) {
            t.activeTexture(i.TEXTURE0 + W);
            const Oe = pn.getPrimaries(pn.workingColorSpace)
              , qe = I.colorSpace === aa ? null : pn.getPrimaries(I.colorSpace)
              , nt = I.colorSpace === aa || Oe === qe ? i.NONE : i.BROWSER_DEFAULT_WEBGL;
            i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, I.flipY),
            i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, I.premultiplyAlpha),
            i.pixelStorei(i.UNPACK_ALIGNMENT, I.unpackAlignment),
            i.pixelStorei(i.UNPACK_COLORSPACE_CONVERSION_WEBGL, nt);
            let Be = g(I.image, !1, s.maxTextureSize);
            Be = we(I, Be);
            const Xe = r.convert(I.format, I.colorSpace)
              , Rt = r.convert(I.type);
            let ht = _(I.internalFormat, Xe, Rt, I.colorSpace, I.isVideoTexture);
            Ie(re, I);
            let lt;
            const kt = I.mipmaps
              , _t = I.isVideoTexture !== !0
              , Xt = $e.__version === void 0 || oe === !0
              , te = fe.dataReady
              , Je = b(I, Be);
            if (I.isDepthTexture)
                ht = y(I.format === mu, I.type),
                Xt && (_t ? t.texStorage2D(i.TEXTURE_2D, 1, ht, Be.width, Be.height) : t.texImage2D(i.TEXTURE_2D, 0, ht, Be.width, Be.height, 0, Xe, Rt, null));
            else if (I.isDataTexture)
                if (kt.length > 0) {
                    _t && Xt && t.texStorage2D(i.TEXTURE_2D, Je, ht, kt[0].width, kt[0].height);
                    for (let De = 0, Ue = kt.length; De < Ue; De++)
                        lt = kt[De],
                        _t ? te && t.texSubImage2D(i.TEXTURE_2D, De, 0, 0, lt.width, lt.height, Xe, Rt, lt.data) : t.texImage2D(i.TEXTURE_2D, De, ht, lt.width, lt.height, 0, Xe, Rt, lt.data);
                    I.generateMipmaps = !1
                } else
                    _t ? (Xt && t.texStorage2D(i.TEXTURE_2D, Je, ht, Be.width, Be.height),
                    te && t.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, Be.width, Be.height, Xe, Rt, Be.data)) : t.texImage2D(i.TEXTURE_2D, 0, ht, Be.width, Be.height, 0, Xe, Rt, Be.data);
            else if (I.isCompressedTexture)
                if (I.isCompressedArrayTexture) {
                    _t && Xt && t.texStorage3D(i.TEXTURE_2D_ARRAY, Je, ht, kt[0].width, kt[0].height, Be.depth);
                    for (let De = 0, Ue = kt.length; De < Ue; De++)
                        if (lt = kt[De],
                        I.format !== fr)
                            if (Xe !== null)
                                if (_t) {
                                    if (te)
                                        if (I.layerUpdates.size > 0) {
                                            const et = PE(lt.width, lt.height, I.format, I.type);
                                            for (const Lt of I.layerUpdates) {
                                                const Wt = lt.data.subarray(Lt * et / lt.data.BYTES_PER_ELEMENT, (Lt + 1) * et / lt.data.BYTES_PER_ELEMENT);
                                                t.compressedTexSubImage3D(i.TEXTURE_2D_ARRAY, De, 0, 0, Lt, lt.width, lt.height, 1, Xe, Wt, 0, 0)
                                            }
                                            I.clearLayerUpdates()
                                        } else
                                            t.compressedTexSubImage3D(i.TEXTURE_2D_ARRAY, De, 0, 0, 0, lt.width, lt.height, Be.depth, Xe, lt.data, 0, 0)
                                } else
                                    t.compressedTexImage3D(i.TEXTURE_2D_ARRAY, De, ht, lt.width, lt.height, Be.depth, 0, lt.data, 0, 0);
                            else
                                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
                        else
                            _t ? te && t.texSubImage3D(i.TEXTURE_2D_ARRAY, De, 0, 0, 0, lt.width, lt.height, Be.depth, Xe, Rt, lt.data) : t.texImage3D(i.TEXTURE_2D_ARRAY, De, ht, lt.width, lt.height, Be.depth, 0, Xe, Rt, lt.data)
                } else {
                    _t && Xt && t.texStorage2D(i.TEXTURE_2D, Je, ht, kt[0].width, kt[0].height);
                    for (let De = 0, Ue = kt.length; De < Ue; De++)
                        lt = kt[De],
                        I.format !== fr ? Xe !== null ? _t ? te && t.compressedTexSubImage2D(i.TEXTURE_2D, De, 0, 0, lt.width, lt.height, Xe, lt.data) : t.compressedTexImage2D(i.TEXTURE_2D, De, ht, lt.width, lt.height, 0, lt.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : _t ? te && t.texSubImage2D(i.TEXTURE_2D, De, 0, 0, lt.width, lt.height, Xe, Rt, lt.data) : t.texImage2D(i.TEXTURE_2D, De, ht, lt.width, lt.height, 0, Xe, Rt, lt.data)
                }
            else if (I.isDataArrayTexture)
                if (_t) {
                    if (Xt && t.texStorage3D(i.TEXTURE_2D_ARRAY, Je, ht, Be.width, Be.height, Be.depth),
                    te)
                        if (I.layerUpdates.size > 0) {
                            const De = PE(Be.width, Be.height, I.format, I.type);
                            for (const Ue of I.layerUpdates) {
                                const et = Be.data.subarray(Ue * De / Be.data.BYTES_PER_ELEMENT, (Ue + 1) * De / Be.data.BYTES_PER_ELEMENT);
                                t.texSubImage3D(i.TEXTURE_2D_ARRAY, 0, 0, 0, Ue, Be.width, Be.height, 1, Xe, Rt, et)
                            }
                            I.clearLayerUpdates()
                        } else
                            t.texSubImage3D(i.TEXTURE_2D_ARRAY, 0, 0, 0, 0, Be.width, Be.height, Be.depth, Xe, Rt, Be.data)
                } else
                    t.texImage3D(i.TEXTURE_2D_ARRAY, 0, ht, Be.width, Be.height, Be.depth, 0, Xe, Rt, Be.data);
            else if (I.isData3DTexture)
                _t ? (Xt && t.texStorage3D(i.TEXTURE_3D, Je, ht, Be.width, Be.height, Be.depth),
                te && t.texSubImage3D(i.TEXTURE_3D, 0, 0, 0, 0, Be.width, Be.height, Be.depth, Xe, Rt, Be.data)) : t.texImage3D(i.TEXTURE_3D, 0, ht, Be.width, Be.height, Be.depth, 0, Xe, Rt, Be.data);
            else if (I.isFramebufferTexture) {
                if (Xt)
                    if (_t)
                        t.texStorage2D(i.TEXTURE_2D, Je, ht, Be.width, Be.height);
                    else {
                        let De = Be.width
                          , Ue = Be.height;
                        for (let et = 0; et < Je; et++)
                            t.texImage2D(i.TEXTURE_2D, et, ht, De, Ue, 0, Xe, Rt, null),
                            De >>= 1,
                            Ue >>= 1
                    }
            } else if (kt.length > 0) {
                if (_t && Xt) {
                    const De = Le(kt[0]);
                    t.texStorage2D(i.TEXTURE_2D, Je, ht, De.width, De.height)
                }
                for (let De = 0, Ue = kt.length; De < Ue; De++)
                    lt = kt[De],
                    _t ? te && t.texSubImage2D(i.TEXTURE_2D, De, 0, 0, Xe, Rt, lt) : t.texImage2D(i.TEXTURE_2D, De, ht, Xe, Rt, lt);
                I.generateMipmaps = !1
            } else if (_t) {
                if (Xt) {
                    const De = Le(Be);
                    t.texStorage2D(i.TEXTURE_2D, Je, ht, De.width, De.height)
                }
                te && t.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, Xe, Rt, Be)
            } else
                t.texImage2D(i.TEXTURE_2D, 0, ht, Xe, Rt, Be);
            m(I) && v(re),
            $e.__version = fe.version,
            I.onUpdate && I.onUpdate(I)
        }
        N.__version = I.version
    }
    function se(N, I, W) {
        if (I.image.length !== 6)
            return;
        const re = ke(N, I)
          , oe = I.source;
        t.bindTexture(i.TEXTURE_CUBE_MAP, N.__webglTexture, i.TEXTURE0 + W);
        const fe = n.get(oe);
        if (oe.version !== fe.__version || re === !0) {
            t.activeTexture(i.TEXTURE0 + W);
            const $e = pn.getPrimaries(pn.workingColorSpace)
              , Oe = I.colorSpace === aa ? null : pn.getPrimaries(I.colorSpace)
              , qe = I.colorSpace === aa || $e === Oe ? i.NONE : i.BROWSER_DEFAULT_WEBGL;
            i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, I.flipY),
            i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, I.premultiplyAlpha),
            i.pixelStorei(i.UNPACK_ALIGNMENT, I.unpackAlignment),
            i.pixelStorei(i.UNPACK_COLORSPACE_CONVERSION_WEBGL, qe);
            const nt = I.isCompressedTexture || I.image[0].isCompressedTexture
              , Be = I.image[0] && I.image[0].isDataTexture
              , Xe = [];
            for (let Ue = 0; Ue < 6; Ue++)
                !nt && !Be ? Xe[Ue] = g(I.image[Ue], !0, s.maxCubemapSize) : Xe[Ue] = Be ? I.image[Ue].image : I.image[Ue],
                Xe[Ue] = we(I, Xe[Ue]);
            const Rt = Xe[0]
              , ht = r.convert(I.format, I.colorSpace)
              , lt = r.convert(I.type)
              , kt = _(I.internalFormat, ht, lt, I.colorSpace)
              , _t = I.isVideoTexture !== !0
              , Xt = fe.__version === void 0 || re === !0
              , te = oe.dataReady;
            let Je = b(I, Rt);
            Ie(i.TEXTURE_CUBE_MAP, I);
            let De;
            if (nt) {
                _t && Xt && t.texStorage2D(i.TEXTURE_CUBE_MAP, Je, kt, Rt.width, Rt.height);
                for (let Ue = 0; Ue < 6; Ue++) {
                    De = Xe[Ue].mipmaps;
                    for (let et = 0; et < De.length; et++) {
                        const Lt = De[et];
                        I.format !== fr ? ht !== null ? _t ? te && t.compressedTexSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + Ue, et, 0, 0, Lt.width, Lt.height, ht, Lt.data) : t.compressedTexImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + Ue, et, kt, Lt.width, Lt.height, 0, Lt.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : _t ? te && t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + Ue, et, 0, 0, Lt.width, Lt.height, ht, lt, Lt.data) : t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + Ue, et, kt, Lt.width, Lt.height, 0, ht, lt, Lt.data)
                    }
                }
            } else {
                if (De = I.mipmaps,
                _t && Xt) {
                    De.length > 0 && Je++;
                    const Ue = Le(Xe[0]);
                    t.texStorage2D(i.TEXTURE_CUBE_MAP, Je, kt, Ue.width, Ue.height)
                }
                for (let Ue = 0; Ue < 6; Ue++)
                    if (Be) {
                        _t ? te && t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + Ue, 0, 0, 0, Xe[Ue].width, Xe[Ue].height, ht, lt, Xe[Ue].data) : t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + Ue, 0, kt, Xe[Ue].width, Xe[Ue].height, 0, ht, lt, Xe[Ue].data);
                        for (let et = 0; et < De.length; et++) {
                            const Wt = De[et].image[Ue].image;
                            _t ? te && t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + Ue, et + 1, 0, 0, Wt.width, Wt.height, ht, lt, Wt.data) : t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + Ue, et + 1, kt, Wt.width, Wt.height, 0, ht, lt, Wt.data)
                        }
                    } else {
                        _t ? te && t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + Ue, 0, 0, 0, ht, lt, Xe[Ue]) : t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + Ue, 0, kt, ht, lt, Xe[Ue]);
                        for (let et = 0; et < De.length; et++) {
                            const Lt = De[et];
                            _t ? te && t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + Ue, et + 1, 0, 0, ht, lt, Lt.image[Ue]) : t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + Ue, et + 1, kt, ht, lt, Lt.image[Ue])
                        }
                    }
            }
            m(I) && v(i.TEXTURE_CUBE_MAP),
            fe.__version = oe.version,
            I.onUpdate && I.onUpdate(I)
        }
        N.__version = I.version
    }
    function Se(N, I, W, re, oe, fe) {
        const $e = r.convert(W.format, W.colorSpace)
          , Oe = r.convert(W.type)
          , qe = _(W.internalFormat, $e, Oe, W.colorSpace);
        if (!n.get(I).__hasExternalTextures) {
            const Be = Math.max(1, I.width >> fe)
              , Xe = Math.max(1, I.height >> fe);
            oe === i.TEXTURE_3D || oe === i.TEXTURE_2D_ARRAY ? t.texImage3D(oe, fe, qe, Be, Xe, I.depth, 0, $e, Oe, null) : t.texImage2D(oe, fe, qe, Be, Xe, 0, $e, Oe, null)
        }
        t.bindFramebuffer(i.FRAMEBUFFER, N),
        he(I) ? a.framebufferTexture2DMultisampleEXT(i.FRAMEBUFFER, re, oe, n.get(W).__webglTexture, 0, Q(I)) : (oe === i.TEXTURE_2D || oe >= i.TEXTURE_CUBE_MAP_POSITIVE_X && oe <= i.TEXTURE_CUBE_MAP_NEGATIVE_Z) && i.framebufferTexture2D(i.FRAMEBUFFER, re, oe, n.get(W).__webglTexture, fe),
        t.bindFramebuffer(i.FRAMEBUFFER, null)
    }
    function be(N, I, W) {
        if (i.bindRenderbuffer(i.RENDERBUFFER, N),
        I.depthBuffer) {
            const re = I.depthTexture
              , oe = re && re.isDepthTexture ? re.type : null
              , fe = y(I.stencilBuffer, oe)
              , $e = I.stencilBuffer ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT
              , Oe = Q(I);
            he(I) ? a.renderbufferStorageMultisampleEXT(i.RENDERBUFFER, Oe, fe, I.width, I.height) : W ? i.renderbufferStorageMultisample(i.RENDERBUFFER, Oe, fe, I.width, I.height) : i.renderbufferStorage(i.RENDERBUFFER, fe, I.width, I.height),
            i.framebufferRenderbuffer(i.FRAMEBUFFER, $e, i.RENDERBUFFER, N)
        } else {
            const re = I.textures;
            for (let oe = 0; oe < re.length; oe++) {
                const fe = re[oe]
                  , $e = r.convert(fe.format, fe.colorSpace)
                  , Oe = r.convert(fe.type)
                  , qe = _(fe.internalFormat, $e, Oe, fe.colorSpace)
                  , nt = Q(I);
                W && he(I) === !1 ? i.renderbufferStorageMultisample(i.RENDERBUFFER, nt, qe, I.width, I.height) : he(I) ? a.renderbufferStorageMultisampleEXT(i.RENDERBUFFER, nt, qe, I.width, I.height) : i.renderbufferStorage(i.RENDERBUFFER, qe, I.width, I.height)
            }
        }
        i.bindRenderbuffer(i.RENDERBUFFER, null)
    }
    function q(N, I) {
        if (I && I.isWebGLCubeRenderTarget)
            throw new Error("Depth Texture with cube render targets is not supported");
        if (t.bindFramebuffer(i.FRAMEBUFFER, N),
        !(I.depthTexture && I.depthTexture.isDepthTexture))
            throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
        (!n.get(I.depthTexture).__webglTexture || I.depthTexture.image.width !== I.width || I.depthTexture.image.height !== I.height) && (I.depthTexture.image.width = I.width,
        I.depthTexture.image.height = I.height,
        I.depthTexture.needsUpdate = !0),
        z(I.depthTexture, 0);
        const re = n.get(I.depthTexture).__webglTexture
          , oe = Q(I);
        if (I.depthTexture.format === Wc)
            he(I) ? a.framebufferTexture2DMultisampleEXT(i.FRAMEBUFFER, i.DEPTH_ATTACHMENT, i.TEXTURE_2D, re, 0, oe) : i.framebufferTexture2D(i.FRAMEBUFFER, i.DEPTH_ATTACHMENT, i.TEXTURE_2D, re, 0);
        else if (I.depthTexture.format === mu)
            he(I) ? a.framebufferTexture2DMultisampleEXT(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.TEXTURE_2D, re, 0, oe) : i.framebufferTexture2D(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.TEXTURE_2D, re, 0);
        else
            throw new Error("Unknown depthTexture format")
    }
    function me(N) {
        const I = n.get(N)
          , W = N.isWebGLCubeRenderTarget === !0;
        if (I.__boundDepthTexture !== N.depthTexture) {
            const re = N.depthTexture;
            if (I.__depthDisposeCallback && I.__depthDisposeCallback(),
            re) {
                const oe = () => {
                    delete I.__boundDepthTexture,
                    delete I.__depthDisposeCallback,
                    re.removeEventListener("dispose", oe)
                }
                ;
                re.addEventListener("dispose", oe),
                I.__depthDisposeCallback = oe
            }
            I.__boundDepthTexture = re
        }
        if (N.depthTexture && !I.__autoAllocateDepthBuffer) {
            if (W)
                throw new Error("target.depthTexture not supported in Cube render targets");
            q(I.__webglFramebuffer, N)
        } else if (W) {
            I.__webglDepthbuffer = [];
            for (let re = 0; re < 6; re++)
                if (t.bindFramebuffer(i.FRAMEBUFFER, I.__webglFramebuffer[re]),
                I.__webglDepthbuffer[re] === void 0)
                    I.__webglDepthbuffer[re] = i.createRenderbuffer(),
                    be(I.__webglDepthbuffer[re], N, !1);
                else {
                    const oe = N.stencilBuffer ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT
                      , fe = I.__webglDepthbuffer[re];
                    i.bindRenderbuffer(i.RENDERBUFFER, fe),
                    i.framebufferRenderbuffer(i.FRAMEBUFFER, oe, i.RENDERBUFFER, fe)
                }
        } else if (t.bindFramebuffer(i.FRAMEBUFFER, I.__webglFramebuffer),
        I.__webglDepthbuffer === void 0)
            I.__webglDepthbuffer = i.createRenderbuffer(),
            be(I.__webglDepthbuffer, N, !1);
        else {
            const re = N.stencilBuffer ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT
              , oe = I.__webglDepthbuffer;
            i.bindRenderbuffer(i.RENDERBUFFER, oe),
            i.framebufferRenderbuffer(i.FRAMEBUFFER, re, i.RENDERBUFFER, oe)
        }
        t.bindFramebuffer(i.FRAMEBUFFER, null)
    }
    function Ce(N, I, W) {
        const re = n.get(N);
        I !== void 0 && Se(re.__webglFramebuffer, N, N.texture, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, 0),
        W !== void 0 && me(N)
    }
    function Pe(N) {
        const I = N.texture
          , W = n.get(N)
          , re = n.get(I);
        N.addEventListener("dispose", C);
        const oe = N.textures
          , fe = N.isWebGLCubeRenderTarget === !0
          , $e = oe.length > 1;
        if ($e || (re.__webglTexture === void 0 && (re.__webglTexture = i.createTexture()),
        re.__version = I.version,
        o.memory.textures++),
        fe) {
            W.__webglFramebuffer = [];
            for (let Oe = 0; Oe < 6; Oe++)
                if (I.mipmaps && I.mipmaps.length > 0) {
                    W.__webglFramebuffer[Oe] = [];
                    for (let qe = 0; qe < I.mipmaps.length; qe++)
                        W.__webglFramebuffer[Oe][qe] = i.createFramebuffer()
                } else
                    W.__webglFramebuffer[Oe] = i.createFramebuffer()
        } else {
            if (I.mipmaps && I.mipmaps.length > 0) {
                W.__webglFramebuffer = [];
                for (let Oe = 0; Oe < I.mipmaps.length; Oe++)
                    W.__webglFramebuffer[Oe] = i.createFramebuffer()
            } else
                W.__webglFramebuffer = i.createFramebuffer();
            if ($e)
                for (let Oe = 0, qe = oe.length; Oe < qe; Oe++) {
                    const nt = n.get(oe[Oe]);
                    nt.__webglTexture === void 0 && (nt.__webglTexture = i.createTexture(),
                    o.memory.textures++)
                }
            if (N.samples > 0 && he(N) === !1) {
                W.__webglMultisampledFramebuffer = i.createFramebuffer(),
                W.__webglColorRenderbuffer = [],
                t.bindFramebuffer(i.FRAMEBUFFER, W.__webglMultisampledFramebuffer);
                for (let Oe = 0; Oe < oe.length; Oe++) {
                    const qe = oe[Oe];
                    W.__webglColorRenderbuffer[Oe] = i.createRenderbuffer(),
                    i.bindRenderbuffer(i.RENDERBUFFER, W.__webglColorRenderbuffer[Oe]);
                    const nt = r.convert(qe.format, qe.colorSpace)
                      , Be = r.convert(qe.type)
                      , Xe = _(qe.internalFormat, nt, Be, qe.colorSpace, N.isXRRenderTarget === !0)
                      , Rt = Q(N);
                    i.renderbufferStorageMultisample(i.RENDERBUFFER, Rt, Xe, N.width, N.height),
                    i.framebufferRenderbuffer(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0 + Oe, i.RENDERBUFFER, W.__webglColorRenderbuffer[Oe])
                }
                i.bindRenderbuffer(i.RENDERBUFFER, null),
                N.depthBuffer && (W.__webglDepthRenderbuffer = i.createRenderbuffer(),
                be(W.__webglDepthRenderbuffer, N, !0)),
                t.bindFramebuffer(i.FRAMEBUFFER, null)
            }
        }
        if (fe) {
            t.bindTexture(i.TEXTURE_CUBE_MAP, re.__webglTexture),
            Ie(i.TEXTURE_CUBE_MAP, I);
            for (let Oe = 0; Oe < 6; Oe++)
                if (I.mipmaps && I.mipmaps.length > 0)
                    for (let qe = 0; qe < I.mipmaps.length; qe++)
                        Se(W.__webglFramebuffer[Oe][qe], N, I, i.COLOR_ATTACHMENT0, i.TEXTURE_CUBE_MAP_POSITIVE_X + Oe, qe);
                else
                    Se(W.__webglFramebuffer[Oe], N, I, i.COLOR_ATTACHMENT0, i.TEXTURE_CUBE_MAP_POSITIVE_X + Oe, 0);
            m(I) && v(i.TEXTURE_CUBE_MAP),
            t.unbindTexture()
        } else if ($e) {
            for (let Oe = 0, qe = oe.length; Oe < qe; Oe++) {
                const nt = oe[Oe]
                  , Be = n.get(nt);
                t.bindTexture(i.TEXTURE_2D, Be.__webglTexture),
                Ie(i.TEXTURE_2D, nt),
                Se(W.__webglFramebuffer, N, nt, i.COLOR_ATTACHMENT0 + Oe, i.TEXTURE_2D, 0),
                m(nt) && v(i.TEXTURE_2D)
            }
            t.unbindTexture()
        } else {
            let Oe = i.TEXTURE_2D;
            if ((N.isWebGL3DRenderTarget || N.isWebGLArrayRenderTarget) && (Oe = N.isWebGL3DRenderTarget ? i.TEXTURE_3D : i.TEXTURE_2D_ARRAY),
            t.bindTexture(Oe, re.__webglTexture),
            Ie(Oe, I),
            I.mipmaps && I.mipmaps.length > 0)
                for (let qe = 0; qe < I.mipmaps.length; qe++)
                    Se(W.__webglFramebuffer[qe], N, I, i.COLOR_ATTACHMENT0, Oe, qe);
            else
                Se(W.__webglFramebuffer, N, I, i.COLOR_ATTACHMENT0, Oe, 0);
            m(I) && v(Oe),
            t.unbindTexture()
        }
        N.depthBuffer && me(N)
    }
    function vt(N) {
        const I = N.textures;
        for (let W = 0, re = I.length; W < re; W++) {
            const oe = I[W];
            if (m(oe)) {
                const fe = N.isWebGLCubeRenderTarget ? i.TEXTURE_CUBE_MAP : i.TEXTURE_2D
                  , $e = n.get(oe).__webglTexture;
                t.bindTexture(fe, $e),
                v(fe),
                t.unbindTexture()
            }
        }
    }
    const j = []
      , B = [];
    function V(N) {
        if (N.samples > 0) {
            if (he(N) === !1) {
                const I = N.textures
                  , W = N.width
                  , re = N.height;
                let oe = i.COLOR_BUFFER_BIT;
                const fe = N.stencilBuffer ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT
                  , $e = n.get(N)
                  , Oe = I.length > 1;
                if (Oe)
                    for (let qe = 0; qe < I.length; qe++)
                        t.bindFramebuffer(i.FRAMEBUFFER, $e.__webglMultisampledFramebuffer),
                        i.framebufferRenderbuffer(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0 + qe, i.RENDERBUFFER, null),
                        t.bindFramebuffer(i.FRAMEBUFFER, $e.__webglFramebuffer),
                        i.framebufferTexture2D(i.DRAW_FRAMEBUFFER, i.COLOR_ATTACHMENT0 + qe, i.TEXTURE_2D, null, 0);
                t.bindFramebuffer(i.READ_FRAMEBUFFER, $e.__webglMultisampledFramebuffer),
                t.bindFramebuffer(i.DRAW_FRAMEBUFFER, $e.__webglFramebuffer);
                for (let qe = 0; qe < I.length; qe++) {
                    if (N.resolveDepthBuffer && (N.depthBuffer && (oe |= i.DEPTH_BUFFER_BIT),
                    N.stencilBuffer && N.resolveStencilBuffer && (oe |= i.STENCIL_BUFFER_BIT)),
                    Oe) {
                        i.framebufferRenderbuffer(i.READ_FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.RENDERBUFFER, $e.__webglColorRenderbuffer[qe]);
                        const nt = n.get(I[qe]).__webglTexture;
                        i.framebufferTexture2D(i.DRAW_FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, nt, 0)
                    }
                    i.blitFramebuffer(0, 0, W, re, 0, 0, W, re, oe, i.NEAREST),
                    l === !0 && (j.length = 0,
                    B.length = 0,
                    j.push(i.COLOR_ATTACHMENT0 + qe),
                    N.depthBuffer && N.resolveDepthBuffer === !1 && (j.push(fe),
                    B.push(fe),
                    i.invalidateFramebuffer(i.DRAW_FRAMEBUFFER, B)),
                    i.invalidateFramebuffer(i.READ_FRAMEBUFFER, j))
                }
                if (t.bindFramebuffer(i.READ_FRAMEBUFFER, null),
                t.bindFramebuffer(i.DRAW_FRAMEBUFFER, null),
                Oe)
                    for (let qe = 0; qe < I.length; qe++) {
                        t.bindFramebuffer(i.FRAMEBUFFER, $e.__webglMultisampledFramebuffer),
                        i.framebufferRenderbuffer(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0 + qe, i.RENDERBUFFER, $e.__webglColorRenderbuffer[qe]);
                        const nt = n.get(I[qe]).__webglTexture;
                        t.bindFramebuffer(i.FRAMEBUFFER, $e.__webglFramebuffer),
                        i.framebufferTexture2D(i.DRAW_FRAMEBUFFER, i.COLOR_ATTACHMENT0 + qe, i.TEXTURE_2D, nt, 0)
                    }
                t.bindFramebuffer(i.DRAW_FRAMEBUFFER, $e.__webglMultisampledFramebuffer)
            } else if (N.depthBuffer && N.resolveDepthBuffer === !1 && l) {
                const I = N.stencilBuffer ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT;
                i.invalidateFramebuffer(i.DRAW_FRAMEBUFFER, [I])
            }
        }
    }
    function Q(N) {
        return Math.min(s.maxSamples, N.samples)
    }
    function he(N) {
        const I = n.get(N);
        return N.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && I.__useRenderToTexture !== !1
    }
    function Ee(N) {
        const I = o.render.frame;
        u.get(N) !== I && (u.set(N, I),
        N.update())
    }
    function we(N, I) {
        const W = N.colorSpace
          , re = N.format
          , oe = N.type;
        return N.isCompressedTexture === !0 || N.isVideoTexture === !0 || W !== ka && W !== aa && (pn.getTransfer(W) === In ? (re !== fr || oe !== Fo) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", W)),
        I
    }
    function Le(N) {
        return typeof HTMLImageElement < "u" && N instanceof HTMLImageElement ? (c.width = N.naturalWidth || N.width,
        c.height = N.naturalHeight || N.height) : typeof VideoFrame < "u" && N instanceof VideoFrame ? (c.width = N.displayWidth,
        c.height = N.displayHeight) : (c.width = N.width,
        c.height = N.height),
        c
    }
    this.allocateTextureUnit = D,
    this.resetTextureUnits = k,
    this.setTexture2D = z,
    this.setTexture2DArray = G,
    this.setTexture3D = H,
    this.setTextureCube = X,
    this.rebindTextures = Ce,
    this.setupRenderTarget = Pe,
    this.updateRenderTargetMipmap = vt,
    this.updateMultisampleRenderTarget = V,
    this.setupDepthRenderbuffer = me,
    this.setupFrameBufferTexture = Se,
    this.useMultisampledRTT = he
}
function Xee(i, e) {
    function t(n, s=aa) {
        let r;
        const o = pn.getTransfer(s);
        if (n === Fo)
            return i.UNSIGNED_BYTE;
        if (n === _x)
            return i.UNSIGNED_SHORT_4_4_4_4;
        if (n === xx)
            return i.UNSIGNED_SHORT_5_5_5_1;
        if (n === QM)
            return i.UNSIGNED_INT_5_9_9_9_REV;
        if (n === ZM)
            return i.BYTE;
        if (n === JM)
            return i.SHORT;
        if (n === Nd)
            return i.UNSIGNED_SHORT;
        if (n === vx)
            return i.INT;
        if (n === Pl)
            return i.UNSIGNED_INT;
        if (n === Ro)
            return i.FLOAT;
        if (n === of)
            return i.HALF_FLOAT;
        if (n === e3)
            return i.ALPHA;
        if (n === t3)
            return i.RGB;
        if (n === fr)
            return i.RGBA;
        if (n === n3)
            return i.LUMINANCE;
        if (n === i3)
            return i.LUMINANCE_ALPHA;
        if (n === Wc)
            return i.DEPTH_COMPONENT;
        if (n === mu)
            return i.DEPTH_STENCIL;
        if (n === s3)
            return i.RED;
        if (n === yx)
            return i.RED_INTEGER;
        if (n === r3)
            return i.RG;
        if (n === bx)
            return i.RG_INTEGER;
        if (n === Sx)
            return i.RGBA_INTEGER;
        if (n === Fh || n === Oh || n === Uh || n === Nh)
            if (o === In)
                if (r = e.get("WEBGL_compressed_texture_s3tc_srgb"),
                r !== null) {
                    if (n === Fh)
                        return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                    if (n === Oh)
                        return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                    if (n === Uh)
                        return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                    if (n === Nh)
                        return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                } else
                    return null;
            else if (r = e.get("WEBGL_compressed_texture_s3tc"),
            r !== null) {
                if (n === Fh)
                    return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (n === Oh)
                    return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (n === Uh)
                    return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (n === Nh)
                    return r.COMPRESSED_RGBA_S3TC_DXT5_EXT
            } else
                return null;
        if (n === sv || n === rv || n === ov || n === av)
            if (r = e.get("WEBGL_compressed_texture_pvrtc"),
            r !== null) {
                if (n === sv)
                    return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (n === rv)
                    return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (n === ov)
                    return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (n === av)
                    return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
            } else
                return null;
        if (n === lv || n === cv || n === uv)
            if (r = e.get("WEBGL_compressed_texture_etc"),
            r !== null) {
                if (n === lv || n === cv)
                    return o === In ? r.COMPRESSED_SRGB8_ETC2 : r.COMPRESSED_RGB8_ETC2;
                if (n === uv)
                    return o === In ? r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : r.COMPRESSED_RGBA8_ETC2_EAC
            } else
                return null;
        if (n === dv || n === fv || n === hv || n === pv || n === mv || n === gv || n === vv || n === _v || n === xv || n === yv || n === bv || n === Sv || n === Ev || n === wv)
            if (r = e.get("WEBGL_compressed_texture_astc"),
            r !== null) {
                if (n === dv)
                    return o === In ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : r.COMPRESSED_RGBA_ASTC_4x4_KHR;
                if (n === fv)
                    return o === In ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : r.COMPRESSED_RGBA_ASTC_5x4_KHR;
                if (n === hv)
                    return o === In ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : r.COMPRESSED_RGBA_ASTC_5x5_KHR;
                if (n === pv)
                    return o === In ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : r.COMPRESSED_RGBA_ASTC_6x5_KHR;
                if (n === mv)
                    return o === In ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : r.COMPRESSED_RGBA_ASTC_6x6_KHR;
                if (n === gv)
                    return o === In ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : r.COMPRESSED_RGBA_ASTC_8x5_KHR;
                if (n === vv)
                    return o === In ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : r.COMPRESSED_RGBA_ASTC_8x6_KHR;
                if (n === _v)
                    return o === In ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : r.COMPRESSED_RGBA_ASTC_8x8_KHR;
                if (n === xv)
                    return o === In ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : r.COMPRESSED_RGBA_ASTC_10x5_KHR;
                if (n === yv)
                    return o === In ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : r.COMPRESSED_RGBA_ASTC_10x6_KHR;
                if (n === bv)
                    return o === In ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : r.COMPRESSED_RGBA_ASTC_10x8_KHR;
                if (n === Sv)
                    return o === In ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : r.COMPRESSED_RGBA_ASTC_10x10_KHR;
                if (n === Ev)
                    return o === In ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : r.COMPRESSED_RGBA_ASTC_12x10_KHR;
                if (n === wv)
                    return o === In ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : r.COMPRESSED_RGBA_ASTC_12x12_KHR
            } else
                return null;
        if (n === Bh || n === Tv || n === Av)
            if (r = e.get("EXT_texture_compression_bptc"),
            r !== null) {
                if (n === Bh)
                    return o === In ? r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : r.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                if (n === Tv)
                    return r.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                if (n === Av)
                    return r.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
            } else
                return null;
        if (n === o3 || n === Cv || n === Mv || n === Rv)
            if (r = e.get("EXT_texture_compression_rgtc"),
            r !== null) {
                if (n === Bh)
                    return r.COMPRESSED_RED_RGTC1_EXT;
                if (n === Cv)
                    return r.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                if (n === Mv)
                    return r.COMPRESSED_RED_GREEN_RGTC2_EXT;
                if (n === Rv)
                    return r.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
            } else
                return null;
        return n === pu ? i.UNSIGNED_INT_24_8 : i[n] !== void 0 ? i[n] : null
    }
    return {
        convert: t
    }
}
class Yee extends ar {
    constructor(e=[]) {
        super(),
        this.isArrayCamera = !0,
        this.cameras = e
    }
}
class fh extends Fi {
    constructor() {
        super(),
        this.isGroup = !0,
        this.type = "Group"
    }
}
const Zee = {
    type: "move"
};
class mg {
    constructor() {
        this._targetRay = null,
        this._grip = null,
        this._hand = null
    }
    getHandSpace() {
        return this._hand === null && (this._hand = new fh,
        this._hand.matrixAutoUpdate = !1,
        this._hand.visible = !1,
        this._hand.joints = {},
        this._hand.inputState = {
            pinching: !1
        }),
        this._hand
    }
    getTargetRaySpace() {
        return this._targetRay === null && (this._targetRay = new fh,
        this._targetRay.matrixAutoUpdate = !1,
        this._targetRay.visible = !1,
        this._targetRay.hasLinearVelocity = !1,
        this._targetRay.linearVelocity = new Te,
        this._targetRay.hasAngularVelocity = !1,
        this._targetRay.angularVelocity = new Te),
        this._targetRay
    }
    getGripSpace() {
        return this._grip === null && (this._grip = new fh,
        this._grip.matrixAutoUpdate = !1,
        this._grip.visible = !1,
        this._grip.hasLinearVelocity = !1,
        this._grip.linearVelocity = new Te,
        this._grip.hasAngularVelocity = !1,
        this._grip.angularVelocity = new Te),
        this._grip
    }
    dispatchEvent(e) {
        return this._targetRay !== null && this._targetRay.dispatchEvent(e),
        this._grip !== null && this._grip.dispatchEvent(e),
        this._hand !== null && this._hand.dispatchEvent(e),
        this
    }
    connect(e) {
        if (e && e.hand) {
            const t = this._hand;
            if (t)
                for (const n of e.hand.values())
                    this._getHandJoint(t, n)
        }
        return this.dispatchEvent({
            type: "connected",
            data: e
        }),
        this
    }
    disconnect(e) {
        return this.dispatchEvent({
            type: "disconnected",
            data: e
        }),
        this._targetRay !== null && (this._targetRay.visible = !1),
        this._grip !== null && (this._grip.visible = !1),
        this._hand !== null && (this._hand.visible = !1),
        this
    }
    update(e, t, n) {
        let s = null
          , r = null
          , o = null;
        const a = this._targetRay
          , l = this._grip
          , c = this._hand;
        if (e && t.session.visibilityState !== "visible-blurred") {
            if (c && e.hand) {
                o = !0;
                for (const g of e.hand.values()) {
                    const m = t.getJointPose(g, n)
                      , v = this._getHandJoint(c, g);
                    m !== null && (v.matrix.fromArray(m.transform.matrix),
                    v.matrix.decompose(v.position, v.rotation, v.scale),
                    v.matrixWorldNeedsUpdate = !0,
                    v.jointRadius = m.radius),
                    v.visible = m !== null
                }
                const u = c.joints["index-finger-tip"]
                  , d = c.joints["thumb-tip"]
                  , f = u.position.distanceTo(d.position)
                  , h = .02
                  , p = .005;
                c.inputState.pinching && f > h + p ? (c.inputState.pinching = !1,
                this.dispatchEvent({
                    type: "pinchend",
                    handedness: e.handedness,
                    target: this
                })) : !c.inputState.pinching && f <= h - p && (c.inputState.pinching = !0,
                this.dispatchEvent({
                    type: "pinchstart",
                    handedness: e.handedness,
                    target: this
                }))
            } else
                l !== null && e.gripSpace && (r = t.getPose(e.gripSpace, n),
                r !== null && (l.matrix.fromArray(r.transform.matrix),
                l.matrix.decompose(l.position, l.rotation, l.scale),
                l.matrixWorldNeedsUpdate = !0,
                r.linearVelocity ? (l.hasLinearVelocity = !0,
                l.linearVelocity.copy(r.linearVelocity)) : l.hasLinearVelocity = !1,
                r.angularVelocity ? (l.hasAngularVelocity = !0,
                l.angularVelocity.copy(r.angularVelocity)) : l.hasAngularVelocity = !1));
            a !== null && (s = t.getPose(e.targetRaySpace, n),
            s === null && r !== null && (s = r),
            s !== null && (a.matrix.fromArray(s.transform.matrix),
            a.matrix.decompose(a.position, a.rotation, a.scale),
            a.matrixWorldNeedsUpdate = !0,
            s.linearVelocity ? (a.hasLinearVelocity = !0,
            a.linearVelocity.copy(s.linearVelocity)) : a.hasLinearVelocity = !1,
            s.angularVelocity ? (a.hasAngularVelocity = !0,
            a.angularVelocity.copy(s.angularVelocity)) : a.hasAngularVelocity = !1,
            this.dispatchEvent(Zee)))
        }
        return a !== null && (a.visible = s !== null),
        l !== null && (l.visible = r !== null),
        c !== null && (c.visible = o !== null),
        this
    }
    _getHandJoint(e, t) {
        if (e.joints[t.jointName] === void 0) {
            const n = new fh;
            n.matrixAutoUpdate = !1,
            n.visible = !1,
            e.joints[t.jointName] = n,
            e.add(n)
        }
        return e.joints[t.jointName]
    }
}
const Jee = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`
  , Qee = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class ete {
    constructor() {
        this.texture = null,
        this.mesh = null,
        this.depthNear = 0,
        this.depthFar = 0
    }
    init(e, t, n) {
        if (this.texture === null) {
            const s = new as
              , r = e.properties.get(s);
            r.__webglTexture = t.texture,
            (t.depthNear != n.depthNear || t.depthFar != n.depthFar) && (this.depthNear = t.depthNear,
            this.depthFar = t.depthFar),
            this.texture = s
        }
    }
    getMesh(e) {
        if (this.texture !== null && this.mesh === null) {
            const t = e.cameras[0].viewport
              , n = new Aa({
                vertexShader: Jee,
                fragmentShader: Qee,
                uniforms: {
                    depthColor: {
                        value: this.texture
                    },
                    depthWidth: {
                        value: t.z
                    },
                    depthHeight: {
                        value: t.w
                    }
                }
            });
            this.mesh = new Br(new Lm(20,20),n)
        }
        return this.mesh
    }
    reset() {
        this.texture = null,
        this.mesh = null
    }
    getDepthTexture() {
        return this.texture
    }
}
class tte extends Tu {
    constructor(e, t) {
        super();
        const n = this;
        let s = null
          , r = 1
          , o = null
          , a = "local-floor"
          , l = 1
          , c = null
          , u = null
          , d = null
          , f = null
          , h = null
          , p = null;
        const g = new ete
          , m = t.getContextAttributes();
        let v = null
          , _ = null;
        const y = []
          , b = []
          , S = new nn;
        let C = null;
        const M = new ar;
        M.layers.enable(1),
        M.viewport = new oi;
        const L = new ar;
        L.layers.enable(2),
        L.viewport = new oi;
        const T = [M, L]
          , A = new Yee;
        A.layers.enable(1),
        A.layers.enable(2);
        let k = null
          , D = null;
        this.cameraAutoUpdate = !0,
        this.enabled = !1,
        this.isPresenting = !1,
        this.getController = function(se) {
            let Se = y[se];
            return Se === void 0 && (Se = new mg,
            y[se] = Se),
            Se.getTargetRaySpace()
        }
        ,
        this.getControllerGrip = function(se) {
            let Se = y[se];
            return Se === void 0 && (Se = new mg,
            y[se] = Se),
            Se.getGripSpace()
        }
        ,
        this.getHand = function(se) {
            let Se = y[se];
            return Se === void 0 && (Se = new mg,
            y[se] = Se),
            Se.getHandSpace()
        }
        ;
        function F(se) {
            const Se = b.indexOf(se.inputSource);
            if (Se === -1)
                return;
            const be = y[Se];
            be !== void 0 && (be.update(se.inputSource, se.frame, c || o),
            be.dispatchEvent({
                type: se.type,
                data: se.inputSource
            }))
        }
        function z() {
            s.removeEventListener("select", F),
            s.removeEventListener("selectstart", F),
            s.removeEventListener("selectend", F),
            s.removeEventListener("squeeze", F),
            s.removeEventListener("squeezestart", F),
            s.removeEventListener("squeezeend", F),
            s.removeEventListener("end", z),
            s.removeEventListener("inputsourceschange", G);
            for (let se = 0; se < y.length; se++) {
                const Se = b[se];
                Se !== null && (b[se] = null,
                y[se].disconnect(Se))
            }
            k = null,
            D = null,
            g.reset(),
            e.setRenderTarget(v),
            h = null,
            f = null,
            d = null,
            s = null,
            _ = null,
            We.stop(),
            n.isPresenting = !1,
            e.setPixelRatio(C),
            e.setSize(S.width, S.height, !1),
            n.dispatchEvent({
                type: "sessionend"
            })
        }
        this.setFramebufferScaleFactor = function(se) {
            r = se,
            n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
        }
        ,
        this.setReferenceSpaceType = function(se) {
            a = se,
            n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
        }
        ,
        this.getReferenceSpace = function() {
            return c || o
        }
        ,
        this.setReferenceSpace = function(se) {
            c = se
        }
        ,
        this.getBaseLayer = function() {
            return f !== null ? f : h
        }
        ,
        this.getBinding = function() {
            return d
        }
        ,
        this.getFrame = function() {
            return p
        }
        ,
        this.getSession = function() {
            return s
        }
        ,
        this.setSession = async function(se) {
            if (s = se,
            s !== null) {
                if (v = e.getRenderTarget(),
                s.addEventListener("select", F),
                s.addEventListener("selectstart", F),
                s.addEventListener("selectend", F),
                s.addEventListener("squeeze", F),
                s.addEventListener("squeezestart", F),
                s.addEventListener("squeezeend", F),
                s.addEventListener("end", z),
                s.addEventListener("inputsourceschange", G),
                m.xrCompatible !== !0 && await t.makeXRCompatible(),
                C = e.getPixelRatio(),
                e.getSize(S),
                s.renderState.layers === void 0) {
                    const Se = {
                        antialias: m.antialias,
                        alpha: !0,
                        depth: m.depth,
                        stencil: m.stencil,
                        framebufferScaleFactor: r
                    };
                    h = new XRWebGLLayer(s,t,Se),
                    s.updateRenderState({
                        baseLayer: h
                    }),
                    e.setPixelRatio(1),
                    e.setSize(h.framebufferWidth, h.framebufferHeight, !1),
                    _ = new Dl(h.framebufferWidth,h.framebufferHeight,{
                        format: fr,
                        type: Fo,
                        colorSpace: e.outputColorSpace,
                        stencilBuffer: m.stencil
                    })
                } else {
                    let Se = null
                      , be = null
                      , q = null;
                    m.depth && (q = m.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24,
                    Se = m.stencil ? mu : Wc,
                    be = m.stencil ? pu : Pl);
                    const me = {
                        colorFormat: t.RGBA8,
                        depthFormat: q,
                        scaleFactor: r
                    };
                    d = new XRWebGLBinding(s,t),
                    f = d.createProjectionLayer(me),
                    s.updateRenderState({
                        layers: [f]
                    }),
                    e.setPixelRatio(1),
                    e.setSize(f.textureWidth, f.textureHeight, !1),
                    _ = new Dl(f.textureWidth,f.textureHeight,{
                        format: fr,
                        type: Fo,
                        depthTexture: new b3(f.textureWidth,f.textureHeight,be,void 0,void 0,void 0,void 0,void 0,void 0,Se),
                        stencilBuffer: m.stencil,
                        colorSpace: e.outputColorSpace,
                        samples: m.antialias ? 4 : 0,
                        resolveDepthBuffer: f.ignoreDepthValues === !1
                    })
                }
                _.isXRRenderTarget = !0,
                this.setFoveation(l),
                c = null,
                o = await s.requestReferenceSpace(a),
                We.setContext(s),
                We.start(),
                n.isPresenting = !0,
                n.dispatchEvent({
                    type: "sessionstart"
                })
            }
        }
        ,
        this.getEnvironmentBlendMode = function() {
            if (s !== null)
                return s.environmentBlendMode
        }
        ,
        this.getDepthTexture = function() {
            return g.getDepthTexture()
        }
        ;
        function G(se) {
            for (let Se = 0; Se < se.removed.length; Se++) {
                const be = se.removed[Se]
                  , q = b.indexOf(be);
                q >= 0 && (b[q] = null,
                y[q].disconnect(be))
            }
            for (let Se = 0; Se < se.added.length; Se++) {
                const be = se.added[Se];
                let q = b.indexOf(be);
                if (q === -1) {
                    for (let Ce = 0; Ce < y.length; Ce++)
                        if (Ce >= b.length) {
                            b.push(be),
                            q = Ce;
                            break
                        } else if (b[Ce] === null) {
                            b[Ce] = be,
                            q = Ce;
                            break
                        }
                    if (q === -1)
                        break
                }
                const me = y[q];
                me && me.connect(be)
            }
        }
        const H = new Te
          , X = new Te;
        function K(se, Se, be) {
            H.setFromMatrixPosition(Se.matrixWorld),
            X.setFromMatrixPosition(be.matrixWorld);
            const q = H.distanceTo(X)
              , me = Se.projectionMatrix.elements
              , Ce = be.projectionMatrix.elements
              , Pe = me[14] / (me[10] - 1)
              , vt = me[14] / (me[10] + 1)
              , j = (me[9] + 1) / me[5]
              , B = (me[9] - 1) / me[5]
              , V = (me[8] - 1) / me[0]
              , Q = (Ce[8] + 1) / Ce[0]
              , he = Pe * V
              , Ee = Pe * Q
              , we = q / (-V + Q)
              , Le = we * -V;
            if (Se.matrixWorld.decompose(se.position, se.quaternion, se.scale),
            se.translateX(Le),
            se.translateZ(we),
            se.matrixWorld.compose(se.position, se.quaternion, se.scale),
            se.matrixWorldInverse.copy(se.matrixWorld).invert(),
            me[10] === -1)
                se.projectionMatrix.copy(Se.projectionMatrix),
                se.projectionMatrixInverse.copy(Se.projectionMatrixInverse);
            else {
                const N = Pe + we
                  , I = vt + we
                  , W = he - Le
                  , re = Ee + (q - Le)
                  , oe = j * vt / I * N
                  , fe = B * vt / I * N;
                se.projectionMatrix.makePerspective(W, re, oe, fe, N, I),
                se.projectionMatrixInverse.copy(se.projectionMatrix).invert()
            }
        }
        function ce(se, Se) {
            Se === null ? se.matrixWorld.copy(se.matrix) : se.matrixWorld.multiplyMatrices(Se.matrixWorld, se.matrix),
            se.matrixWorldInverse.copy(se.matrixWorld).invert()
        }
        this.updateCamera = function(se) {
            if (s === null)
                return;
            let Se = se.near
              , be = se.far;
            g.texture !== null && (g.depthNear > 0 && (Se = g.depthNear),
            g.depthFar > 0 && (be = g.depthFar)),
            A.near = L.near = M.near = Se,
            A.far = L.far = M.far = be,
            (k !== A.near || D !== A.far) && (s.updateRenderState({
                depthNear: A.near,
                depthFar: A.far
            }),
            k = A.near,
            D = A.far);
            const q = se.parent
              , me = A.cameras;
            ce(A, q);
            for (let Ce = 0; Ce < me.length; Ce++)
                ce(me[Ce], q);
            me.length === 2 ? K(A, M, L) : A.projectionMatrix.copy(M.projectionMatrix),
            ue(se, A, q)
        }
        ;
        function ue(se, Se, be) {
            be === null ? se.matrix.copy(Se.matrixWorld) : (se.matrix.copy(be.matrixWorld),
            se.matrix.invert(),
            se.matrix.multiply(Se.matrixWorld)),
            se.matrix.decompose(se.position, se.quaternion, se.scale),
            se.updateMatrixWorld(!0),
            se.projectionMatrix.copy(Se.projectionMatrix),
            se.projectionMatrixInverse.copy(Se.projectionMatrixInverse),
            se.isPerspectiveCamera && (se.fov = Lv * 2 * Math.atan(1 / se.projectionMatrix.elements[5]),
            se.zoom = 1)
        }
        this.getCamera = function() {
            return A
        }
        ,
        this.getFoveation = function() {
            if (!(f === null && h === null))
                return l
        }
        ,
        this.setFoveation = function(se) {
            l = se,
            f !== null && (f.fixedFoveation = se),
            h !== null && h.fixedFoveation !== void 0 && (h.fixedFoveation = se)
        }
        ,
        this.hasDepthSensing = function() {
            return g.texture !== null
        }
        ,
        this.getDepthSensingMesh = function() {
            return g.getMesh(A)
        }
        ;
        let Ie = null;
        function ke(se, Se) {
            if (u = Se.getViewerPose(c || o),
            p = Se,
            u !== null) {
                const be = u.views;
                h !== null && (e.setRenderTargetFramebuffer(_, h.framebuffer),
                e.setRenderTarget(_));
                let q = !1;
                be.length !== A.cameras.length && (A.cameras.length = 0,
                q = !0);
                for (let Ce = 0; Ce < be.length; Ce++) {
                    const Pe = be[Ce];
                    let vt = null;
                    if (h !== null)
                        vt = h.getViewport(Pe);
                    else {
                        const B = d.getViewSubImage(f, Pe);
                        vt = B.viewport,
                        Ce === 0 && (e.setRenderTargetTextures(_, B.colorTexture, f.ignoreDepthValues ? void 0 : B.depthStencilTexture),
                        e.setRenderTarget(_))
                    }
                    let j = T[Ce];
                    j === void 0 && (j = new ar,
                    j.layers.enable(Ce),
                    j.viewport = new oi,
                    T[Ce] = j),
                    j.matrix.fromArray(Pe.transform.matrix),
                    j.matrix.decompose(j.position, j.quaternion, j.scale),
                    j.projectionMatrix.fromArray(Pe.projectionMatrix),
                    j.projectionMatrixInverse.copy(j.projectionMatrix).invert(),
                    j.viewport.set(vt.x, vt.y, vt.width, vt.height),
                    Ce === 0 && (A.matrix.copy(j.matrix),
                    A.matrix.decompose(A.position, A.quaternion, A.scale)),
                    q === !0 && A.cameras.push(j)
                }
                const me = s.enabledFeatures;
                if (me && me.includes("depth-sensing")) {
                    const Ce = d.getDepthInformation(be[0]);
                    Ce && Ce.isValid && Ce.texture && g.init(e, Ce, s.renderState)
                }
            }
            for (let be = 0; be < y.length; be++) {
                const q = b[be]
                  , me = y[be];
                q !== null && me !== void 0 && me.update(q, Se, c || o)
            }
            Ie && Ie(se, Se),
            Se.detectedPlanes && n.dispatchEvent({
                type: "planesdetected",
                data: Se
            }),
            p = null
        }
        const We = new y3;
        We.setAnimationLoop(ke),
        this.setAnimationLoop = function(se) {
            Ie = se
        }
        ,
        this.dispose = function() {}
    }
}
const Ya = new Xr
  , nte = new qn;
function ite(i, e) {
    function t(m, v) {
        m.matrixAutoUpdate === !0 && m.updateMatrix(),
        v.value.copy(m.matrix)
    }
    function n(m, v) {
        v.color.getRGB(m.fogColor.value, v3(i)),
        v.isFog ? (m.fogNear.value = v.near,
        m.fogFar.value = v.far) : v.isFogExp2 && (m.fogDensity.value = v.density)
    }
    function s(m, v, _, y, b) {
        v.isMeshBasicMaterial || v.isMeshLambertMaterial ? r(m, v) : v.isMeshToonMaterial ? (r(m, v),
        d(m, v)) : v.isMeshPhongMaterial ? (r(m, v),
        u(m, v)) : v.isMeshStandardMaterial ? (r(m, v),
        f(m, v),
        v.isMeshPhysicalMaterial && h(m, v, b)) : v.isMeshMatcapMaterial ? (r(m, v),
        p(m, v)) : v.isMeshDepthMaterial ? r(m, v) : v.isMeshDistanceMaterial ? (r(m, v),
        g(m, v)) : v.isMeshNormalMaterial ? r(m, v) : v.isLineBasicMaterial ? (o(m, v),
        v.isLineDashedMaterial && a(m, v)) : v.isPointsMaterial ? l(m, v, _, y) : v.isSpriteMaterial ? c(m, v) : v.isShadowMaterial ? (m.color.value.copy(v.color),
        m.opacity.value = v.opacity) : v.isShaderMaterial && (v.uniformsNeedUpdate = !1)
    }
    function r(m, v) {
        m.opacity.value = v.opacity,
        v.color && m.diffuse.value.copy(v.color),
        v.emissive && m.emissive.value.copy(v.emissive).multiplyScalar(v.emissiveIntensity),
        v.map && (m.map.value = v.map,
        t(v.map, m.mapTransform)),
        v.alphaMap && (m.alphaMap.value = v.alphaMap,
        t(v.alphaMap, m.alphaMapTransform)),
        v.bumpMap && (m.bumpMap.value = v.bumpMap,
        t(v.bumpMap, m.bumpMapTransform),
        m.bumpScale.value = v.bumpScale,
        v.side === os && (m.bumpScale.value *= -1)),
        v.normalMap && (m.normalMap.value = v.normalMap,
        t(v.normalMap, m.normalMapTransform),
        m.normalScale.value.copy(v.normalScale),
        v.side === os && m.normalScale.value.negate()),
        v.displacementMap && (m.displacementMap.value = v.displacementMap,
        t(v.displacementMap, m.displacementMapTransform),
        m.displacementScale.value = v.displacementScale,
        m.displacementBias.value = v.displacementBias),
        v.emissiveMap && (m.emissiveMap.value = v.emissiveMap,
        t(v.emissiveMap, m.emissiveMapTransform)),
        v.specularMap && (m.specularMap.value = v.specularMap,
        t(v.specularMap, m.specularMapTransform)),
        v.alphaTest > 0 && (m.alphaTest.value = v.alphaTest);
        const _ = e.get(v)
          , y = _.envMap
          , b = _.envMapRotation;
        y && (m.envMap.value = y,
        Ya.copy(b),
        Ya.x *= -1,
        Ya.y *= -1,
        Ya.z *= -1,
        y.isCubeTexture && y.isRenderTargetTexture === !1 && (Ya.y *= -1,
        Ya.z *= -1),
        m.envMapRotation.value.setFromMatrix4(nte.makeRotationFromEuler(Ya)),
        m.flipEnvMap.value = y.isCubeTexture && y.isRenderTargetTexture === !1 ? -1 : 1,
        m.reflectivity.value = v.reflectivity,
        m.ior.value = v.ior,
        m.refractionRatio.value = v.refractionRatio),
        v.lightMap && (m.lightMap.value = v.lightMap,
        m.lightMapIntensity.value = v.lightMapIntensity,
        t(v.lightMap, m.lightMapTransform)),
        v.aoMap && (m.aoMap.value = v.aoMap,
        m.aoMapIntensity.value = v.aoMapIntensity,
        t(v.aoMap, m.aoMapTransform))
    }
    function o(m, v) {
        m.diffuse.value.copy(v.color),
        m.opacity.value = v.opacity,
        v.map && (m.map.value = v.map,
        t(v.map, m.mapTransform))
    }
    function a(m, v) {
        m.dashSize.value = v.dashSize,
        m.totalSize.value = v.dashSize + v.gapSize,
        m.scale.value = v.scale
    }
    function l(m, v, _, y) {
        m.diffuse.value.copy(v.color),
        m.opacity.value = v.opacity,
        m.size.value = v.size * _,
        m.scale.value = y * .5,
        v.map && (m.map.value = v.map,
        t(v.map, m.uvTransform)),
        v.alphaMap && (m.alphaMap.value = v.alphaMap,
        t(v.alphaMap, m.alphaMapTransform)),
        v.alphaTest > 0 && (m.alphaTest.value = v.alphaTest)
    }
    function c(m, v) {
        m.diffuse.value.copy(v.color),
        m.opacity.value = v.opacity,
        m.rotation.value = v.rotation,
        v.map && (m.map.value = v.map,
        t(v.map, m.mapTransform)),
        v.alphaMap && (m.alphaMap.value = v.alphaMap,
        t(v.alphaMap, m.alphaMapTransform)),
        v.alphaTest > 0 && (m.alphaTest.value = v.alphaTest)
    }
    function u(m, v) {
        m.specular.value.copy(v.specular),
        m.shininess.value = Math.max(v.shininess, 1e-4)
    }
    function d(m, v) {
        v.gradientMap && (m.gradientMap.value = v.gradientMap)
    }
    function f(m, v) {
        m.metalness.value = v.metalness,
        v.metalnessMap && (m.metalnessMap.value = v.metalnessMap,
        t(v.metalnessMap, m.metalnessMapTransform)),
        m.roughness.value = v.roughness,
        v.roughnessMap && (m.roughnessMap.value = v.roughnessMap,
        t(v.roughnessMap, m.roughnessMapTransform)),
        v.envMap && (m.envMapIntensity.value = v.envMapIntensity)
    }
    function h(m, v, _) {
        m.ior.value = v.ior,
        v.sheen > 0 && (m.sheenColor.value.copy(v.sheenColor).multiplyScalar(v.sheen),
        m.sheenRoughness.value = v.sheenRoughness,
        v.sheenColorMap && (m.sheenColorMap.value = v.sheenColorMap,
        t(v.sheenColorMap, m.sheenColorMapTransform)),
        v.sheenRoughnessMap && (m.sheenRoughnessMap.value = v.sheenRoughnessMap,
        t(v.sheenRoughnessMap, m.sheenRoughnessMapTransform))),
        v.clearcoat > 0 && (m.clearcoat.value = v.clearcoat,
        m.clearcoatRoughness.value = v.clearcoatRoughness,
        v.clearcoatMap && (m.clearcoatMap.value = v.clearcoatMap,
        t(v.clearcoatMap, m.clearcoatMapTransform)),
        v.clearcoatRoughnessMap && (m.clearcoatRoughnessMap.value = v.clearcoatRoughnessMap,
        t(v.clearcoatRoughnessMap, m.clearcoatRoughnessMapTransform)),
        v.clearcoatNormalMap && (m.clearcoatNormalMap.value = v.clearcoatNormalMap,
        t(v.clearcoatNormalMap, m.clearcoatNormalMapTransform),
        m.clearcoatNormalScale.value.copy(v.clearcoatNormalScale),
        v.side === os && m.clearcoatNormalScale.value.negate())),
        v.dispersion > 0 && (m.dispersion.value = v.dispersion),
        v.iridescence > 0 && (m.iridescence.value = v.iridescence,
        m.iridescenceIOR.value = v.iridescenceIOR,
        m.iridescenceThicknessMinimum.value = v.iridescenceThicknessRange[0],
        m.iridescenceThicknessMaximum.value = v.iridescenceThicknessRange[1],
        v.iridescenceMap && (m.iridescenceMap.value = v.iridescenceMap,
        t(v.iridescenceMap, m.iridescenceMapTransform)),
        v.iridescenceThicknessMap && (m.iridescenceThicknessMap.value = v.iridescenceThicknessMap,
        t(v.iridescenceThicknessMap, m.iridescenceThicknessMapTransform))),
        v.transmission > 0 && (m.transmission.value = v.transmission,
        m.transmissionSamplerMap.value = _.texture,
        m.transmissionSamplerSize.value.set(_.width, _.height),
        v.transmissionMap && (m.transmissionMap.value = v.transmissionMap,
        t(v.transmissionMap, m.transmissionMapTransform)),
        m.thickness.value = v.thickness,
        v.thicknessMap && (m.thicknessMap.value = v.thicknessMap,
        t(v.thicknessMap, m.thicknessMapTransform)),
        m.attenuationDistance.value = v.attenuationDistance,
        m.attenuationColor.value.copy(v.attenuationColor)),
        v.anisotropy > 0 && (m.anisotropyVector.value.set(v.anisotropy * Math.cos(v.anisotropyRotation), v.anisotropy * Math.sin(v.anisotropyRotation)),
        v.anisotropyMap && (m.anisotropyMap.value = v.anisotropyMap,
        t(v.anisotropyMap, m.anisotropyMapTransform))),
        m.specularIntensity.value = v.specularIntensity,
        m.specularColor.value.copy(v.specularColor),
        v.specularColorMap && (m.specularColorMap.value = v.specularColorMap,
        t(v.specularColorMap, m.specularColorMapTransform)),
        v.specularIntensityMap && (m.specularIntensityMap.value = v.specularIntensityMap,
        t(v.specularIntensityMap, m.specularIntensityMapTransform))
    }
    function p(m, v) {
        v.matcap && (m.matcap.value = v.matcap)
    }
    function g(m, v) {
        const _ = e.get(v).light;
        m.referencePosition.value.setFromMatrixPosition(_.matrixWorld),
        m.nearDistance.value = _.shadow.camera.near,
        m.farDistance.value = _.shadow.camera.far
    }
    return {
        refreshFogUniforms: n,
        refreshMaterialUniforms: s
    }
}
function ste(i, e, t, n) {
    let s = {}
      , r = {}
      , o = [];
    const a = i.getParameter(i.MAX_UNIFORM_BUFFER_BINDINGS);
    function l(_, y) {
        const b = y.program;
        n.uniformBlockBinding(_, b)
    }
    function c(_, y) {
        let b = s[_.id];
        b === void 0 && (p(_),
        b = u(_),
        s[_.id] = b,
        _.addEventListener("dispose", m));
        const S = y.program;
        n.updateUBOMapping(_, S);
        const C = e.render.frame;
        r[_.id] !== C && (f(_),
        r[_.id] = C)
    }
    function u(_) {
        const y = d();
        _.__bindingPointIndex = y;
        const b = i.createBuffer()
          , S = _.__size
          , C = _.usage;
        return i.bindBuffer(i.UNIFORM_BUFFER, b),
        i.bufferData(i.UNIFORM_BUFFER, S, C),
        i.bindBuffer(i.UNIFORM_BUFFER, null),
        i.bindBufferBase(i.UNIFORM_BUFFER, y, b),
        b
    }
    function d() {
        for (let _ = 0; _ < a; _++)
            if (o.indexOf(_) === -1)
                return o.push(_),
                _;
        return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),
        0
    }
    function f(_) {
        const y = s[_.id]
          , b = _.uniforms
          , S = _.__cache;
        i.bindBuffer(i.UNIFORM_BUFFER, y);
        for (let C = 0, M = b.length; C < M; C++) {
            const L = Array.isArray(b[C]) ? b[C] : [b[C]];
            for (let T = 0, A = L.length; T < A; T++) {
                const k = L[T];
                if (h(k, C, T, S) === !0) {
                    const D = k.__offset
                      , F = Array.isArray(k.value) ? k.value : [k.value];
                    let z = 0;
                    for (let G = 0; G < F.length; G++) {
                        const H = F[G]
                          , X = g(H);
                        typeof H == "number" || typeof H == "boolean" ? (k.__data[0] = H,
                        i.bufferSubData(i.UNIFORM_BUFFER, D + z, k.__data)) : H.isMatrix3 ? (k.__data[0] = H.elements[0],
                        k.__data[1] = H.elements[1],
                        k.__data[2] = H.elements[2],
                        k.__data[3] = 0,
                        k.__data[4] = H.elements[3],
                        k.__data[5] = H.elements[4],
                        k.__data[6] = H.elements[5],
                        k.__data[7] = 0,
                        k.__data[8] = H.elements[6],
                        k.__data[9] = H.elements[7],
                        k.__data[10] = H.elements[8],
                        k.__data[11] = 0) : (H.toArray(k.__data, z),
                        z += X.storage / Float32Array.BYTES_PER_ELEMENT)
                    }
                    i.bufferSubData(i.UNIFORM_BUFFER, D, k.__data)
                }
            }
        }
        i.bindBuffer(i.UNIFORM_BUFFER, null)
    }
    function h(_, y, b, S) {
        const C = _.value
          , M = y + "_" + b;
        if (S[M] === void 0)
            return typeof C == "number" || typeof C == "boolean" ? S[M] = C : S[M] = C.clone(),
            !0;
        {
            const L = S[M];
            if (typeof C == "number" || typeof C == "boolean") {
                if (L !== C)
                    return S[M] = C,
                    !0
            } else if (L.equals(C) === !1)
                return L.copy(C),
                !0
        }
        return !1
    }
    function p(_) {
        const y = _.uniforms;
        let b = 0;
        const S = 16;
        for (let M = 0, L = y.length; M < L; M++) {
            const T = Array.isArray(y[M]) ? y[M] : [y[M]];
            for (let A = 0, k = T.length; A < k; A++) {
                const D = T[A]
                  , F = Array.isArray(D.value) ? D.value : [D.value];
                for (let z = 0, G = F.length; z < G; z++) {
                    const H = F[z]
                      , X = g(H)
                      , K = b % S
                      , ce = K % X.boundary
                      , ue = K + ce;
                    b += ce,
                    ue !== 0 && S - ue < X.storage && (b += S - ue),
                    D.__data = new Float32Array(X.storage / Float32Array.BYTES_PER_ELEMENT),
                    D.__offset = b,
                    b += X.storage
                }
            }
        }
        const C = b % S;
        return C > 0 && (b += S - C),
        _.__size = b,
        _.__cache = {},
        this
    }
    function g(_) {
        const y = {
            boundary: 0,
            storage: 0
        };
        return typeof _ == "number" || typeof _ == "boolean" ? (y.boundary = 4,
        y.storage = 4) : _.isVector2 ? (y.boundary = 8,
        y.storage = 8) : _.isVector3 || _.isColor ? (y.boundary = 16,
        y.storage = 12) : _.isVector4 ? (y.boundary = 16,
        y.storage = 16) : _.isMatrix3 ? (y.boundary = 48,
        y.storage = 48) : _.isMatrix4 ? (y.boundary = 64,
        y.storage = 64) : _.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", _),
        y
    }
    function m(_) {
        const y = _.target;
        y.removeEventListener("dispose", m);
        const b = o.indexOf(y.__bindingPointIndex);
        o.splice(b, 1),
        i.deleteBuffer(s[y.id]),
        delete s[y.id],
        delete r[y.id]
    }
    function v() {
        for (const _ in s)
            i.deleteBuffer(s[_]);
        o = [],
        s = {},
        r = {}
    }
    return {
        bind: l,
        update: c,
        dispose: v
    }
}
class rte {
    constructor(e={}) {
        const {canvas: t=KX(), context: n=null, depth: s=!0, stencil: r=!1, alpha: o=!1, antialias: a=!1, premultipliedAlpha: l=!0, preserveDrawingBuffer: c=!1, powerPreference: u="default", failIfMajorPerformanceCaveat: d=!1} = e;
        this.isWebGLRenderer = !0;
        let f;
        if (n !== null) {
            if (typeof WebGLRenderingContext < "u" && n instanceof WebGLRenderingContext)
                throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
            f = n.getContextAttributes().alpha
        } else
            f = o;
        const h = new Uint32Array(4)
          , p = new Int32Array(4);
        let g = null
          , m = null;
        const v = []
          , _ = [];
        this.domElement = t,
        this.debug = {
            checkShaderErrors: !0,
            onShaderError: null
        },
        this.autoClear = !0,
        this.autoClearColor = !0,
        this.autoClearDepth = !0,
        this.autoClearStencil = !0,
        this.sortObjects = !0,
        this.clippingPlanes = [],
        this.localClippingEnabled = !1,
        this._outputColorSpace = Lr,
        this.toneMapping = xa,
        this.toneMappingExposure = 1;
        const y = this;
        let b = !1
          , S = 0
          , C = 0
          , M = null
          , L = -1
          , T = null;
        const A = new oi
          , k = new oi;
        let D = null;
        const F = new un(0);
        let z = 0
          , G = t.width
          , H = t.height
          , X = 1
          , K = null
          , ce = null;
        const ue = new oi(0,0,G,H)
          , Ie = new oi(0,0,G,H);
        let ke = !1;
        const We = new Tx;
        let se = !1
          , Se = !1;
        const be = new qn
          , q = new Te
          , me = new oi
          , Ce = {
            background: null,
            fog: null,
            environment: null,
            overrideMaterial: null,
            isScene: !0
        };
        let Pe = !1;
        function vt() {
            return M === null ? X : 1
        }
        let j = n;
        function B(U, ie) {
            return t.getContext(U, ie)
        }
        try {
            const U = {
                alpha: !0,
                depth: s,
                stencil: r,
                antialias: a,
                premultipliedAlpha: l,
                preserveDrawingBuffer: c,
                powerPreference: u,
                failIfMajorPerformanceCaveat: d
            };
            if ("setAttribute"in t && t.setAttribute("data-engine", `three.js r${gx}`),
            t.addEventListener("webglcontextlost", De, !1),
            t.addEventListener("webglcontextrestored", Ue, !1),
            t.addEventListener("webglcontextcreationerror", et, !1),
            j === null) {
                const ie = "webgl2";
                if (j = B(ie, U),
                j === null)
                    throw B(ie) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
            }
        } catch (U) {
            throw console.error("THREE.WebGLRenderer: " + U.message),
            U
        }
        let V, Q, he, Ee, we, Le, N, I, W, re, oe, fe, $e, Oe, qe, nt, Be, Xe, Rt, ht, lt, kt, _t, Xt;
        function te() {
            V = new dQ(j),
            V.init(),
            kt = new Xee(j,V),
            Q = new rQ(j,V,e,kt),
            he = new qee(j),
            Ee = new pQ(j),
            we = new kee,
            Le = new Kee(j,V,he,we,Q,kt,Ee),
            N = new aQ(y),
            I = new uQ(y),
            W = new bY(j),
            _t = new iQ(j,W),
            re = new fQ(j,W,Ee,_t),
            oe = new gQ(j,re,W,Ee),
            Rt = new mQ(j,Q,Le),
            nt = new oQ(we),
            fe = new Iee(y,N,I,V,Q,_t,nt),
            $e = new ite(y,we),
            Oe = new Dee,
            qe = new Vee(V),
            Xe = new nQ(y,N,I,he,oe,f,l),
            Be = new Wee(y,oe,Q),
            Xt = new ste(j,Ee,Q,he),
            ht = new sQ(j,V,Ee),
            lt = new hQ(j,V,Ee),
            Ee.programs = fe.programs,
            y.capabilities = Q,
            y.extensions = V,
            y.properties = we,
            y.renderLists = Oe,
            y.shadowMap = Be,
            y.state = he,
            y.info = Ee
        }
        te();
        const Je = new tte(y,j);
        this.xr = Je,
        this.getContext = function() {
            return j
        }
        ,
        this.getContextAttributes = function() {
            return j.getContextAttributes()
        }
        ,
        this.forceContextLoss = function() {
            const U = V.get("WEBGL_lose_context");
            U && U.loseContext()
        }
        ,
        this.forceContextRestore = function() {
            const U = V.get("WEBGL_lose_context");
            U && U.restoreContext()
        }
        ,
        this.getPixelRatio = function() {
            return X
        }
        ,
        this.setPixelRatio = function(U) {
            U !== void 0 && (X = U,
            this.setSize(G, H, !1))
        }
        ,
        this.getSize = function(U) {
            return U.set(G, H)
        }
        ,
        this.setSize = function(U, ie, _e=!0) {
            if (Je.isPresenting) {
                console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
                return
            }
            G = U,
            H = ie,
            t.width = Math.floor(U * X),
            t.height = Math.floor(ie * X),
            _e === !0 && (t.style.width = U + "px",
            t.style.height = ie + "px"),
            this.setViewport(0, 0, U, ie)
        }
        ,
        this.getDrawingBufferSize = function(U) {
            return U.set(G * X, H * X).floor()
        }
        ,
        this.setDrawingBufferSize = function(U, ie, _e) {
            G = U,
            H = ie,
            X = _e,
            t.width = Math.floor(U * _e),
            t.height = Math.floor(ie * _e),
            this.setViewport(0, 0, U, ie)
        }
        ,
        this.getCurrentViewport = function(U) {
            return U.copy(A)
        }
        ,
        this.getViewport = function(U) {
            return U.copy(ue)
        }
        ,
        this.setViewport = function(U, ie, _e, ye) {
            U.isVector4 ? ue.set(U.x, U.y, U.z, U.w) : ue.set(U, ie, _e, ye),
            he.viewport(A.copy(ue).multiplyScalar(X).round())
        }
        ,
        this.getScissor = function(U) {
            return U.copy(Ie)
        }
        ,
        this.setScissor = function(U, ie, _e, ye) {
            U.isVector4 ? Ie.set(U.x, U.y, U.z, U.w) : Ie.set(U, ie, _e, ye),
            he.scissor(k.copy(Ie).multiplyScalar(X).round())
        }
        ,
        this.getScissorTest = function() {
            return ke
        }
        ,
        this.setScissorTest = function(U) {
            he.setScissorTest(ke = U)
        }
        ,
        this.setOpaqueSort = function(U) {
            K = U
        }
        ,
        this.setTransparentSort = function(U) {
            ce = U
        }
        ,
        this.getClearColor = function(U) {
            return U.copy(Xe.getClearColor())
        }
        ,
        this.setClearColor = function() {
            Xe.setClearColor.apply(Xe, arguments)
        }
        ,
        this.getClearAlpha = function() {
            return Xe.getClearAlpha()
        }
        ,
        this.setClearAlpha = function() {
            Xe.setClearAlpha.apply(Xe, arguments)
        }
        ,
        this.clear = function(U=!0, ie=!0, _e=!0) {
            let ye = 0;
            if (U) {
                let ae = !1;
                if (M !== null) {
                    const Ye = M.texture.format;
                    ae = Ye === Sx || Ye === bx || Ye === yx
                }
                if (ae) {
                    const Ye = M.texture.type
                      , at = Ye === Fo || Ye === Pl || Ye === Nd || Ye === pu || Ye === _x || Ye === xx
                      , xt = Xe.getClearColor()
                      , gt = Xe.getClearAlpha()
                      , Dt = xt.r
                      , Ft = xt.g
                      , St = xt.b;
                    at ? (h[0] = Dt,
                    h[1] = Ft,
                    h[2] = St,
                    h[3] = gt,
                    j.clearBufferuiv(j.COLOR, 0, h)) : (p[0] = Dt,
                    p[1] = Ft,
                    p[2] = St,
                    p[3] = gt,
                    j.clearBufferiv(j.COLOR, 0, p))
                } else
                    ye |= j.COLOR_BUFFER_BIT
            }
            ie && (ye |= j.DEPTH_BUFFER_BIT),
            _e && (ye |= j.STENCIL_BUFFER_BIT,
            this.state.buffers.stencil.setMask(4294967295)),
            j.clear(ye)
        }
        ,
        this.clearColor = function() {
            this.clear(!0, !1, !1)
        }
        ,
        this.clearDepth = function() {
            this.clear(!1, !0, !1)
        }
        ,
        this.clearStencil = function() {
            this.clear(!1, !1, !0)
        }
        ,
        this.dispose = function() {
            t.removeEventListener("webglcontextlost", De, !1),
            t.removeEventListener("webglcontextrestored", Ue, !1),
            t.removeEventListener("webglcontextcreationerror", et, !1),
            Oe.dispose(),
            qe.dispose(),
            we.dispose(),
            N.dispose(),
            I.dispose(),
            oe.dispose(),
            _t.dispose(),
            Xt.dispose(),
            fe.dispose(),
            Je.dispose(),
            Je.removeEventListener("sessionstart", Ke),
            Je.removeEventListener("sessionend", Qe),
            yt.stop()
        }
        ;
        function De(U) {
            U.preventDefault(),
            console.log("THREE.WebGLRenderer: Context Lost."),
            b = !0
        }
        function Ue() {
            console.log("THREE.WebGLRenderer: Context Restored."),
            b = !1;
            const U = Ee.autoReset
              , ie = Be.enabled
              , _e = Be.autoUpdate
              , ye = Be.needsUpdate
              , ae = Be.type;
            te(),
            Ee.autoReset = U,
            Be.enabled = ie,
            Be.autoUpdate = _e,
            Be.needsUpdate = ye,
            Be.type = ae
        }
        function et(U) {
            console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", U.statusMessage)
        }
        function Lt(U) {
            const ie = U.target;
            ie.removeEventListener("dispose", Lt),
            Wt(ie)
        }
        function Wt(U) {
            $(U),
            we.remove(U)
        }
        function $(U) {
            const ie = we.get(U).programs;
            ie !== void 0 && (ie.forEach(function(_e) {
                fe.releaseProgram(_e)
            }),
            U.isShaderMaterial && fe.releaseShaderCache(U))
        }
        this.renderBufferDirect = function(U, ie, _e, ye, ae, Ye) {
            ie === null && (ie = Ce);
            const at = ae.isMesh && ae.matrixWorld.determinant() < 0
              , xt = Yt(U, ie, _e, ye, ae);
            he.setMaterial(ye, at);
            let gt = _e.index
              , Dt = 1;
            if (ye.wireframe === !0) {
                if (gt = re.getWireframeAttribute(_e),
                gt === void 0)
                    return;
                Dt = 2
            }
            const Ft = _e.drawRange
              , St = _e.attributes.position;
            let rn = Ft.start * Dt
              , on = (Ft.start + Ft.count) * Dt;
            Ye !== null && (rn = Math.max(rn, Ye.start * Dt),
            on = Math.min(on, (Ye.start + Ye.count) * Dt)),
            gt !== null ? (rn = Math.max(rn, 0),
            on = Math.min(on, gt.count)) : St != null && (rn = Math.max(rn, 0),
            on = Math.min(on, St.count));
            const Jt = on - rn;
            if (Jt < 0 || Jt === 1 / 0)
                return;
            _t.setup(ae, ye, xt, _e, gt);
            let wn, qt = ht;
            if (gt !== null && (wn = W.get(gt),
            qt = lt,
            qt.setIndex(wn)),
            ae.isMesh)
                ye.wireframe === !0 ? (he.setLineWidth(ye.wireframeLinewidth * vt()),
                qt.setMode(j.LINES)) : qt.setMode(j.TRIANGLES);
            else if (ae.isLine) {
                let bt = ye.linewidth;
                bt === void 0 && (bt = 1),
                he.setLineWidth(bt * vt()),
                ae.isLineSegments ? qt.setMode(j.LINES) : ae.isLineLoop ? qt.setMode(j.LINE_LOOP) : qt.setMode(j.LINE_STRIP)
            } else
                ae.isPoints ? qt.setMode(j.POINTS) : ae.isSprite && qt.setMode(j.TRIANGLES);
            if (ae.isBatchedMesh)
                if (ae._multiDrawInstances !== null)
                    qt.renderMultiDrawInstances(ae._multiDrawStarts, ae._multiDrawCounts, ae._multiDrawCount, ae._multiDrawInstances);
                else if (V.get("WEBGL_multi_draw"))
                    qt.renderMultiDraw(ae._multiDrawStarts, ae._multiDrawCounts, ae._multiDrawCount);
                else {
                    const bt = ae._multiDrawStarts
                      , ni = ae._multiDrawCounts
                      , dn = ae._multiDrawCount
                      , Xs = gt ? W.get(gt).bytesPerElement : 1
                      , Gl = we.get(ye).currentProgram.getUniforms();
                    for (let hs = 0; hs < dn; hs++)
                        Gl.setValue(j, "_gl_DrawID", hs),
                        qt.render(bt[hs] / Xs, ni[hs])
                }
            else if (ae.isInstancedMesh)
                qt.renderInstances(rn, Jt, ae.count);
            else if (_e.isInstancedBufferGeometry) {
                const bt = _e._maxInstanceCount !== void 0 ? _e._maxInstanceCount : 1 / 0
                  , ni = Math.min(_e.instanceCount, bt);
                qt.renderInstances(rn, Jt, ni)
            } else
                qt.render(rn, Jt)
        }
        ;
        function Z(U, ie, _e) {
            U.transparent === !0 && U.side === Ao && U.forceSinglePass === !1 ? (U.side = os,
            U.needsUpdate = !0,
            He(U, ie, _e),
            U.side = Ta,
            U.needsUpdate = !0,
            He(U, ie, _e),
            U.side = Ao) : He(U, ie, _e)
        }
        this.compile = function(U, ie, _e=null) {
            _e === null && (_e = U),
            m = qe.get(_e),
            m.init(ie),
            _.push(m),
            _e.traverseVisible(function(ae) {
                ae.isLight && ae.layers.test(ie.layers) && (m.pushLight(ae),
                ae.castShadow && m.pushShadow(ae))
            }),
            U !== _e && U.traverseVisible(function(ae) {
                ae.isLight && ae.layers.test(ie.layers) && (m.pushLight(ae),
                ae.castShadow && m.pushShadow(ae))
            }),
            m.setupLights();
            const ye = new Set;
            return U.traverse(function(ae) {
                const Ye = ae.material;
                if (Ye)
                    if (Array.isArray(Ye))
                        for (let at = 0; at < Ye.length; at++) {
                            const xt = Ye[at];
                            Z(xt, _e, ae),
                            ye.add(xt)
                        }
                    else
                        Z(Ye, _e, ae),
                        ye.add(Ye)
            }),
            _.pop(),
            m = null,
            ye
        }
        ,
        this.compileAsync = function(U, ie, _e=null) {
            const ye = this.compile(U, ie, _e);
            return new Promise(ae => {
                function Ye() {
                    if (ye.forEach(function(at) {
                        we.get(at).currentProgram.isReady() && ye.delete(at)
                    }),
                    ye.size === 0) {
                        ae(U);
                        return
                    }
                    setTimeout(Ye, 10)
                }
                V.get("KHR_parallel_shader_compile") !== null ? Ye() : setTimeout(Ye, 10)
            }
            )
        }
        ;
        let ne = null;
        function Ne(U) {
            ne && ne(U)
        }
        function Ke() {
            yt.stop()
        }
        function Qe() {
            yt.start()
        }
        const yt = new y3;
        yt.setAnimationLoop(Ne),
        typeof self < "u" && yt.setContext(self),
        this.setAnimationLoop = function(U) {
            ne = U,
            Je.setAnimationLoop(U),
            U === null ? yt.stop() : yt.start()
        }
        ,
        Je.addEventListener("sessionstart", Ke),
        Je.addEventListener("sessionend", Qe),
        this.render = function(U, ie) {
            if (ie !== void 0 && ie.isCamera !== !0) {
                console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                return
            }
            if (b === !0)
                return;
            if (U.matrixWorldAutoUpdate === !0 && U.updateMatrixWorld(),
            ie.parent === null && ie.matrixWorldAutoUpdate === !0 && ie.updateMatrixWorld(),
            Je.enabled === !0 && Je.isPresenting === !0 && (Je.cameraAutoUpdate === !0 && Je.updateCamera(ie),
            ie = Je.getCamera()),
            U.isScene === !0 && U.onBeforeRender(y, U, ie, M),
            m = qe.get(U, _.length),
            m.init(ie),
            _.push(m),
            be.multiplyMatrices(ie.projectionMatrix, ie.matrixWorldInverse),
            We.setFromProjectionMatrix(be),
            Se = this.localClippingEnabled,
            se = nt.init(this.clippingPlanes, Se),
            g = Oe.get(U, v.length),
            g.init(),
            v.push(g),
            Je.enabled === !0 && Je.isPresenting === !0) {
                const Ye = y.xr.getDepthSensingMesh();
                Ye !== null && st(Ye, ie, -1 / 0, y.sortObjects)
            }
            st(U, ie, 0, y.sortObjects),
            g.finish(),
            y.sortObjects === !0 && g.sort(K, ce),
            Pe = Je.enabled === !1 || Je.isPresenting === !1 || Je.hasDepthSensing() === !1,
            Pe && Xe.addToRenderList(g, U),
            this.info.render.frame++,
            se === !0 && nt.beginShadows();
            const _e = m.state.shadowsArray;
            Be.render(_e, U, ie),
            se === !0 && nt.endShadows(),
            this.info.autoReset === !0 && this.info.reset();
            const ye = g.opaque
              , ae = g.transmissive;
            if (m.setupLights(),
            ie.isArrayCamera) {
                const Ye = ie.cameras;
                if (ae.length > 0)
                    for (let at = 0, xt = Ye.length; at < xt; at++) {
                        const gt = Ye[at];
                        ln(ye, ae, U, gt)
                    }
                Pe && Xe.render(U);
                for (let at = 0, xt = Ye.length; at < xt; at++) {
                    const gt = Ye[at];
                    an(g, U, gt, gt.viewport)
                }
            } else
                ae.length > 0 && ln(ye, ae, U, ie),
                Pe && Xe.render(U),
                an(g, U, ie);
            M !== null && (Le.updateMultisampleRenderTarget(M),
            Le.updateRenderTargetMipmap(M)),
            U.isScene === !0 && U.onAfterRender(y, U, ie),
            _t.resetDefaultState(),
            L = -1,
            T = null,
            _.pop(),
            _.length > 0 ? (m = _[_.length - 1],
            se === !0 && nt.setGlobalState(y.clippingPlanes, m.state.camera)) : m = null,
            v.pop(),
            v.length > 0 ? g = v[v.length - 1] : g = null
        }
        ;
        function st(U, ie, _e, ye) {
            if (U.visible === !1)
                return;
            if (U.layers.test(ie.layers)) {
                if (U.isGroup)
                    _e = U.renderOrder;
                else if (U.isLOD)
                    U.autoUpdate === !0 && U.update(ie);
                else if (U.isLight)
                    m.pushLight(U),
                    U.castShadow && m.pushShadow(U);
                else if (U.isSprite) {
                    if (!U.frustumCulled || We.intersectsSprite(U)) {
                        ye && me.setFromMatrixPosition(U.matrixWorld).applyMatrix4(be);
                        const at = oe.update(U)
                          , xt = U.material;
                        xt.visible && g.push(U, at, xt, _e, me.z, null)
                    }
                } else if ((U.isMesh || U.isLine || U.isPoints) && (!U.frustumCulled || We.intersectsObject(U))) {
                    const at = oe.update(U)
                      , xt = U.material;
                    if (ye && (U.boundingSphere !== void 0 ? (U.boundingSphere === null && U.computeBoundingSphere(),
                    me.copy(U.boundingSphere.center)) : (at.boundingSphere === null && at.computeBoundingSphere(),
                    me.copy(at.boundingSphere.center)),
                    me.applyMatrix4(U.matrixWorld).applyMatrix4(be)),
                    Array.isArray(xt)) {
                        const gt = at.groups;
                        for (let Dt = 0, Ft = gt.length; Dt < Ft; Dt++) {
                            const St = gt[Dt]
                              , rn = xt[St.materialIndex];
                            rn && rn.visible && g.push(U, at, rn, _e, me.z, St)
                        }
                    } else
                        xt.visible && g.push(U, at, xt, _e, me.z, null)
                }
            }
            const Ye = U.children;
            for (let at = 0, xt = Ye.length; at < xt; at++)
                st(Ye[at], ie, _e, ye)
        }
        function an(U, ie, _e, ye) {
            const ae = U.opaque
              , Ye = U.transmissive
              , at = U.transparent;
            m.setupLightsView(_e),
            se === !0 && nt.setGlobalState(y.clippingPlanes, _e),
            ye && he.viewport(A.copy(ye)),
            ae.length > 0 && Me(ae, ie, _e),
            Ye.length > 0 && Me(Ye, ie, _e),
            at.length > 0 && Me(at, ie, _e),
            he.buffers.depth.setTest(!0),
            he.buffers.depth.setMask(!0),
            he.buffers.color.setMask(!0),
            he.setPolygonOffset(!1)
        }
        function ln(U, ie, _e, ye) {
            if ((_e.isScene === !0 ? _e.overrideMaterial : null) !== null)
                return;
            m.state.transmissionRenderTarget[ye.id] === void 0 && (m.state.transmissionRenderTarget[ye.id] = new Dl(1,1,{
                generateMipmaps: !0,
                type: V.has("EXT_color_buffer_half_float") || V.has("EXT_color_buffer_float") ? of : Fo,
                minFilter: ml,
                samples: 4,
                stencilBuffer: r,
                resolveDepthBuffer: !1,
                resolveStencilBuffer: !1,
                colorSpace: pn.workingColorSpace
            }));
            const Ye = m.state.transmissionRenderTarget[ye.id]
              , at = ye.viewport || A;
            Ye.setSize(at.z, at.w);
            const xt = y.getRenderTarget();
            y.setRenderTarget(Ye),
            y.getClearColor(F),
            z = y.getClearAlpha(),
            z < 1 && y.setClearColor(16777215, .5),
            y.clear(),
            Pe && Xe.render(_e);
            const gt = y.toneMapping;
            y.toneMapping = xa;
            const Dt = ye.viewport;
            if (ye.viewport !== void 0 && (ye.viewport = void 0),
            m.setupLightsView(ye),
            se === !0 && nt.setGlobalState(y.clippingPlanes, ye),
            Me(U, _e, ye),
            Le.updateMultisampleRenderTarget(Ye),
            Le.updateRenderTargetMipmap(Ye),
            V.has("WEBGL_multisampled_render_to_texture") === !1) {
                let Ft = !1;
                for (let St = 0, rn = ie.length; St < rn; St++) {
                    const on = ie[St]
                      , Jt = on.object
                      , wn = on.geometry
                      , qt = on.material
                      , bt = on.group;
                    if (qt.side === Ao && Jt.layers.test(ye.layers)) {
                        const ni = qt.side;
                        qt.side = os,
                        qt.needsUpdate = !0,
                        ge(Jt, _e, ye, wn, qt, bt),
                        qt.side = ni,
                        qt.needsUpdate = !0,
                        Ft = !0
                    }
                }
                Ft === !0 && (Le.updateMultisampleRenderTarget(Ye),
                Le.updateRenderTargetMipmap(Ye))
            }
            y.setRenderTarget(xt),
            y.setClearColor(F, z),
            Dt !== void 0 && (ye.viewport = Dt),
            y.toneMapping = gt
        }
        function Me(U, ie, _e) {
            const ye = ie.isScene === !0 ? ie.overrideMaterial : null;
            for (let ae = 0, Ye = U.length; ae < Ye; ae++) {
                const at = U[ae]
                  , xt = at.object
                  , gt = at.geometry
                  , Dt = ye === null ? at.material : ye
                  , Ft = at.group;
                xt.layers.test(_e.layers) && ge(xt, ie, _e, gt, Dt, Ft)
            }
        }
        function ge(U, ie, _e, ye, ae, Ye) {
            U.onBeforeRender(y, ie, _e, ye, ae, Ye),
            U.modelViewMatrix.multiplyMatrices(_e.matrixWorldInverse, U.matrixWorld),
            U.normalMatrix.getNormalMatrix(U.modelViewMatrix),
            ae.onBeforeRender(y, ie, _e, ye, U, Ye),
            ae.transparent === !0 && ae.side === Ao && ae.forceSinglePass === !1 ? (ae.side = os,
            ae.needsUpdate = !0,
            y.renderBufferDirect(_e, ie, ye, ae, U, Ye),
            ae.side = Ta,
            ae.needsUpdate = !0,
            y.renderBufferDirect(_e, ie, ye, ae, U, Ye),
            ae.side = Ao) : y.renderBufferDirect(_e, ie, ye, ae, U, Ye),
            U.onAfterRender(y, ie, _e, ye, ae, Ye)
        }
        function He(U, ie, _e) {
            ie.isScene !== !0 && (ie = Ce);
            const ye = we.get(U)
              , ae = m.state.lights
              , Ye = m.state.shadowsArray
              , at = ae.state.version
              , xt = fe.getParameters(U, ae.state, Ye, ie, _e)
              , gt = fe.getProgramCacheKey(xt);
            let Dt = ye.programs;
            ye.environment = U.isMeshStandardMaterial ? ie.environment : null,
            ye.fog = ie.fog,
            ye.envMap = (U.isMeshStandardMaterial ? I : N).get(U.envMap || ye.environment),
            ye.envMapRotation = ye.environment !== null && U.envMap === null ? ie.environmentRotation : U.envMapRotation,
            Dt === void 0 && (U.addEventListener("dispose", Lt),
            Dt = new Map,
            ye.programs = Dt);
            let Ft = Dt.get(gt);
            if (Ft !== void 0) {
                if (ye.currentProgram === Ft && ye.lightsStateVersion === at)
                    return It(U, xt),
                    Ft
            } else
                xt.uniforms = fe.getUniforms(U),
                U.onBeforeCompile(xt, y),
                Ft = fe.acquireProgram(xt, gt),
                Dt.set(gt, Ft),
                ye.uniforms = xt.uniforms;
            const St = ye.uniforms;
            return (!U.isShaderMaterial && !U.isRawShaderMaterial || U.clipping === !0) && (St.clippingPlanes = nt.uniform),
            It(U, xt),
            ye.needsLights = Yi(U),
            ye.lightsStateVersion = at,
            ye.needsLights && (St.ambientLightColor.value = ae.state.ambient,
            St.lightProbe.value = ae.state.probe,
            St.directionalLights.value = ae.state.directional,
            St.directionalLightShadows.value = ae.state.directionalShadow,
            St.spotLights.value = ae.state.spot,
            St.spotLightShadows.value = ae.state.spotShadow,
            St.rectAreaLights.value = ae.state.rectArea,
            St.ltc_1.value = ae.state.rectAreaLTC1,
            St.ltc_2.value = ae.state.rectAreaLTC2,
            St.pointLights.value = ae.state.point,
            St.pointLightShadows.value = ae.state.pointShadow,
            St.hemisphereLights.value = ae.state.hemi,
            St.directionalShadowMap.value = ae.state.directionalShadowMap,
            St.directionalShadowMatrix.value = ae.state.directionalShadowMatrix,
            St.spotShadowMap.value = ae.state.spotShadowMap,
            St.spotLightMatrix.value = ae.state.spotLightMatrix,
            St.spotLightMap.value = ae.state.spotLightMap,
            St.pointShadowMap.value = ae.state.pointShadowMap,
            St.pointShadowMatrix.value = ae.state.pointShadowMatrix),
            ye.currentProgram = Ft,
            ye.uniformsList = null,
            Ft
        }
        function ft(U) {
            if (U.uniformsList === null) {
                const ie = U.currentProgram.getUniforms();
                U.uniformsList = Vh.seqWithValue(ie.seq, U.uniforms)
            }
            return U.uniformsList
        }
        function It(U, ie) {
            const _e = we.get(U);
            _e.outputColorSpace = ie.outputColorSpace,
            _e.batching = ie.batching,
            _e.batchingColor = ie.batchingColor,
            _e.instancing = ie.instancing,
            _e.instancingColor = ie.instancingColor,
            _e.instancingMorph = ie.instancingMorph,
            _e.skinning = ie.skinning,
            _e.morphTargets = ie.morphTargets,
            _e.morphNormals = ie.morphNormals,
            _e.morphColors = ie.morphColors,
            _e.morphTargetsCount = ie.morphTargetsCount,
            _e.numClippingPlanes = ie.numClippingPlanes,
            _e.numIntersection = ie.numClipIntersection,
            _e.vertexAlphas = ie.vertexAlphas,
            _e.vertexTangents = ie.vertexTangents,
            _e.toneMapping = ie.toneMapping
        }
        function Yt(U, ie, _e, ye, ae) {
            ie.isScene !== !0 && (ie = Ce),
            Le.resetTextureUnits();
            const Ye = ie.fog
              , at = ye.isMeshStandardMaterial ? ie.environment : null
              , xt = M === null ? y.outputColorSpace : M.isXRRenderTarget === !0 ? M.texture.colorSpace : ka
              , gt = (ye.isMeshStandardMaterial ? I : N).get(ye.envMap || at)
              , Dt = ye.vertexColors === !0 && !!_e.attributes.color && _e.attributes.color.itemSize === 4
              , Ft = !!_e.attributes.tangent && (!!ye.normalMap || ye.anisotropy > 0)
              , St = !!_e.morphAttributes.position
              , rn = !!_e.morphAttributes.normal
              , on = !!_e.morphAttributes.color;
            let Jt = xa;
            ye.toneMapped && (M === null || M.isXRRenderTarget === !0) && (Jt = y.toneMapping);
            const wn = _e.morphAttributes.position || _e.morphAttributes.normal || _e.morphAttributes.color
              , qt = wn !== void 0 ? wn.length : 0
              , bt = we.get(ye)
              , ni = m.state.lights;
            if (se === !0 && (Se === !0 || U !== T)) {
                const Rs = U === T && ye.id === L;
                nt.setState(ye, U, Rs)
            }
            let dn = !1;
            ye.version === bt.__version ? (bt.needsLights && bt.lightsStateVersion !== ni.state.version || bt.outputColorSpace !== xt || ae.isBatchedMesh && bt.batching === !1 || !ae.isBatchedMesh && bt.batching === !0 || ae.isBatchedMesh && bt.batchingColor === !0 && ae.colorTexture === null || ae.isBatchedMesh && bt.batchingColor === !1 && ae.colorTexture !== null || ae.isInstancedMesh && bt.instancing === !1 || !ae.isInstancedMesh && bt.instancing === !0 || ae.isSkinnedMesh && bt.skinning === !1 || !ae.isSkinnedMesh && bt.skinning === !0 || ae.isInstancedMesh && bt.instancingColor === !0 && ae.instanceColor === null || ae.isInstancedMesh && bt.instancingColor === !1 && ae.instanceColor !== null || ae.isInstancedMesh && bt.instancingMorph === !0 && ae.morphTexture === null || ae.isInstancedMesh && bt.instancingMorph === !1 && ae.morphTexture !== null || bt.envMap !== gt || ye.fog === !0 && bt.fog !== Ye || bt.numClippingPlanes !== void 0 && (bt.numClippingPlanes !== nt.numPlanes || bt.numIntersection !== nt.numIntersection) || bt.vertexAlphas !== Dt || bt.vertexTangents !== Ft || bt.morphTargets !== St || bt.morphNormals !== rn || bt.morphColors !== on || bt.toneMapping !== Jt || bt.morphTargetsCount !== qt) && (dn = !0) : (dn = !0,
            bt.__version = ye.version);
            let Xs = bt.currentProgram;
            dn === !0 && (Xs = He(ye, ie, ae));
            let Gl = !1
              , hs = !1
              , Fm = !1;
            const jn = Xs.getUniforms()
              , Vo = bt.uniforms;
            if (he.useProgram(Xs.program) && (Gl = !0,
            hs = !0,
            Fm = !0),
            ye.id !== L && (L = ye.id,
            hs = !0),
            Gl || T !== U) {
                jn.setValue(j, "projectionMatrix", U.projectionMatrix),
                jn.setValue(j, "viewMatrix", U.matrixWorldInverse);
                const Rs = jn.map.cameraPosition;
                Rs !== void 0 && Rs.setValue(j, q.setFromMatrixPosition(U.matrixWorld)),
                Q.logarithmicDepthBuffer && jn.setValue(j, "logDepthBufFC", 2 / (Math.log(U.far + 1) / Math.LN2)),
                (ye.isMeshPhongMaterial || ye.isMeshToonMaterial || ye.isMeshLambertMaterial || ye.isMeshBasicMaterial || ye.isMeshStandardMaterial || ye.isShaderMaterial) && jn.setValue(j, "isOrthographic", U.isOrthographicCamera === !0),
                T !== U && (T = U,
                hs = !0,
                Fm = !0)
            }
            if (ae.isSkinnedMesh) {
                jn.setOptional(j, ae, "bindMatrix"),
                jn.setOptional(j, ae, "bindMatrixInverse");
                const Rs = ae.skeleton;
                Rs && (Rs.boneTexture === null && Rs.computeBoneTexture(),
                jn.setValue(j, "boneTexture", Rs.boneTexture, Le))
            }
            ae.isBatchedMesh && (jn.setOptional(j, ae, "batchingTexture"),
            jn.setValue(j, "batchingTexture", ae._matricesTexture, Le),
            jn.setOptional(j, ae, "batchingIdTexture"),
            jn.setValue(j, "batchingIdTexture", ae._indirectTexture, Le),
            jn.setOptional(j, ae, "batchingColorTexture"),
            ae._colorsTexture !== null && jn.setValue(j, "batchingColorTexture", ae._colorsTexture, Le));
            const Om = _e.morphAttributes;
            if ((Om.position !== void 0 || Om.normal !== void 0 || Om.color !== void 0) && Rt.update(ae, _e, Xs),
            (hs || bt.receiveShadow !== ae.receiveShadow) && (bt.receiveShadow = ae.receiveShadow,
            jn.setValue(j, "receiveShadow", ae.receiveShadow)),
            ye.isMeshGouraudMaterial && ye.envMap !== null && (Vo.envMap.value = gt,
            Vo.flipEnvMap.value = gt.isCubeTexture && gt.isRenderTargetTexture === !1 ? -1 : 1),
            ye.isMeshStandardMaterial && ye.envMap === null && ie.environment !== null && (Vo.envMapIntensity.value = ie.environmentIntensity),
            hs && (jn.setValue(j, "toneMappingExposure", y.toneMappingExposure),
            bt.needsLights && sn(Vo, Fm),
            Ye && ye.fog === !0 && $e.refreshFogUniforms(Vo, Ye),
            $e.refreshMaterialUniforms(Vo, ye, X, H, m.state.transmissionRenderTarget[U.id]),
            Vh.upload(j, ft(bt), Vo, Le)),
            ye.isShaderMaterial && ye.uniformsNeedUpdate === !0 && (Vh.upload(j, ft(bt), Vo, Le),
            ye.uniformsNeedUpdate = !1),
            ye.isSpriteMaterial && jn.setValue(j, "center", ae.center),
            jn.setValue(j, "modelViewMatrix", ae.modelViewMatrix),
            jn.setValue(j, "normalMatrix", ae.normalMatrix),
            jn.setValue(j, "modelMatrix", ae.matrixWorld),
            ye.isShaderMaterial || ye.isRawShaderMaterial) {
                const Rs = ye.uniformsGroups;
                for (let Um = 0, RR = Rs.length; Um < RR; Um++) {
                    const qx = Rs[Um];
                    Xt.update(qx, Xs),
                    Xt.bind(qx, Xs)
                }
            }
            return Xs
        }
        function sn(U, ie) {
            U.ambientLightColor.needsUpdate = ie,
            U.lightProbe.needsUpdate = ie,
            U.directionalLights.needsUpdate = ie,
            U.directionalLightShadows.needsUpdate = ie,
            U.pointLights.needsUpdate = ie,
            U.pointLightShadows.needsUpdate = ie,
            U.spotLights.needsUpdate = ie,
            U.spotLightShadows.needsUpdate = ie,
            U.rectAreaLights.needsUpdate = ie,
            U.hemisphereLights.needsUpdate = ie
        }
        function Yi(U) {
            return U.isMeshLambertMaterial || U.isMeshToonMaterial || U.isMeshPhongMaterial || U.isMeshStandardMaterial || U.isShadowMaterial || U.isShaderMaterial && U.lights === !0
        }
        this.getActiveCubeFace = function() {
            return S
        }
        ,
        this.getActiveMipmapLevel = function() {
            return C
        }
        ,
        this.getRenderTarget = function() {
            return M
        }
        ,
        this.setRenderTargetTextures = function(U, ie, _e) {
            we.get(U.texture).__webglTexture = ie,
            we.get(U.depthTexture).__webglTexture = _e;
            const ye = we.get(U);
            ye.__hasExternalTextures = !0,
            ye.__autoAllocateDepthBuffer = _e === void 0,
            ye.__autoAllocateDepthBuffer || V.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),
            ye.__useRenderToTexture = !1)
        }
        ,
        this.setRenderTargetFramebuffer = function(U, ie) {
            const _e = we.get(U);
            _e.__webglFramebuffer = ie,
            _e.__useDefaultFramebuffer = ie === void 0
        }
        ,
        this.setRenderTarget = function(U, ie=0, _e=0) {
            M = U,
            S = ie,
            C = _e;
            let ye = !0
              , ae = null
              , Ye = !1
              , at = !1;
            if (U) {
                const gt = we.get(U);
                if (gt.__useDefaultFramebuffer !== void 0)
                    he.bindFramebuffer(j.FRAMEBUFFER, null),
                    ye = !1;
                else if (gt.__webglFramebuffer === void 0)
                    Le.setupRenderTarget(U);
                else if (gt.__hasExternalTextures)
                    Le.rebindTextures(U, we.get(U.texture).__webglTexture, we.get(U.depthTexture).__webglTexture);
                else if (U.depthBuffer) {
                    const St = U.depthTexture;
                    if (gt.__boundDepthTexture !== St) {
                        if (St !== null && we.has(St) && (U.width !== St.image.width || U.height !== St.image.height))
                            throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
                        Le.setupDepthRenderbuffer(U)
                    }
                }
                const Dt = U.texture;
                (Dt.isData3DTexture || Dt.isDataArrayTexture || Dt.isCompressedArrayTexture) && (at = !0);
                const Ft = we.get(U).__webglFramebuffer;
                U.isWebGLCubeRenderTarget ? (Array.isArray(Ft[ie]) ? ae = Ft[ie][_e] : ae = Ft[ie],
                Ye = !0) : U.samples > 0 && Le.useMultisampledRTT(U) === !1 ? ae = we.get(U).__webglMultisampledFramebuffer : Array.isArray(Ft) ? ae = Ft[_e] : ae = Ft,
                A.copy(U.viewport),
                k.copy(U.scissor),
                D = U.scissorTest
            } else
                A.copy(ue).multiplyScalar(X).floor(),
                k.copy(Ie).multiplyScalar(X).floor(),
                D = ke;
            if (he.bindFramebuffer(j.FRAMEBUFFER, ae) && ye && he.drawBuffers(U, ae),
            he.viewport(A),
            he.scissor(k),
            he.setScissorTest(D),
            Ye) {
                const gt = we.get(U.texture);
                j.framebufferTexture2D(j.FRAMEBUFFER, j.COLOR_ATTACHMENT0, j.TEXTURE_CUBE_MAP_POSITIVE_X + ie, gt.__webglTexture, _e)
            } else if (at) {
                const gt = we.get(U.texture)
                  , Dt = ie || 0;
                j.framebufferTextureLayer(j.FRAMEBUFFER, j.COLOR_ATTACHMENT0, gt.__webglTexture, _e || 0, Dt)
            }
            L = -1
        }
        ,
        this.readRenderTargetPixels = function(U, ie, _e, ye, ae, Ye, at) {
            if (!(U && U.isWebGLRenderTarget)) {
                console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                return
            }
            let xt = we.get(U).__webglFramebuffer;
            if (U.isWebGLCubeRenderTarget && at !== void 0 && (xt = xt[at]),
            xt) {
                he.bindFramebuffer(j.FRAMEBUFFER, xt);
                try {
                    const gt = U.texture
                      , Dt = gt.format
                      , Ft = gt.type;
                    if (!Q.textureFormatReadable(Dt)) {
                        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                        return
                    }
                    if (!Q.textureTypeReadable(Ft)) {
                        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                        return
                    }
                    ie >= 0 && ie <= U.width - ye && _e >= 0 && _e <= U.height - ae && j.readPixels(ie, _e, ye, ae, kt.convert(Dt), kt.convert(Ft), Ye)
                } finally {
                    const gt = M !== null ? we.get(M).__webglFramebuffer : null;
                    he.bindFramebuffer(j.FRAMEBUFFER, gt)
                }
            }
        }
        ,
        this.readRenderTargetPixelsAsync = async function(U, ie, _e, ye, ae, Ye, at) {
            if (!(U && U.isWebGLRenderTarget))
                throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            let xt = we.get(U).__webglFramebuffer;
            if (U.isWebGLCubeRenderTarget && at !== void 0 && (xt = xt[at]),
            xt) {
                he.bindFramebuffer(j.FRAMEBUFFER, xt);
                try {
                    const gt = U.texture
                      , Dt = gt.format
                      , Ft = gt.type;
                    if (!Q.textureFormatReadable(Dt))
                        throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
                    if (!Q.textureTypeReadable(Ft))
                        throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
                    if (ie >= 0 && ie <= U.width - ye && _e >= 0 && _e <= U.height - ae) {
                        const St = j.createBuffer();
                        j.bindBuffer(j.PIXEL_PACK_BUFFER, St),
                        j.bufferData(j.PIXEL_PACK_BUFFER, Ye.byteLength, j.STREAM_READ),
                        j.readPixels(ie, _e, ye, ae, kt.convert(Dt), kt.convert(Ft), 0),
                        j.flush();
                        const rn = j.fenceSync(j.SYNC_GPU_COMMANDS_COMPLETE, 0);
                        await XX(j, rn, 4);
                        try {
                            j.bindBuffer(j.PIXEL_PACK_BUFFER, St),
                            j.getBufferSubData(j.PIXEL_PACK_BUFFER, 0, Ye)
                        } finally {
                            j.deleteBuffer(St),
                            j.deleteSync(rn)
                        }
                        return Ye
                    }
                } finally {
                    const gt = M !== null ? we.get(M).__webglFramebuffer : null;
                    he.bindFramebuffer(j.FRAMEBUFFER, gt)
                }
            }
        }
        ,
        this.copyFramebufferToTexture = function(U, ie=null, _e=0) {
            U.isTexture !== !0 && (hd("WebGLRenderer: copyFramebufferToTexture function signature has changed."),
            ie = arguments[0] || null,
            U = arguments[1]);
            const ye = Math.pow(2, -_e)
              , ae = Math.floor(U.image.width * ye)
              , Ye = Math.floor(U.image.height * ye)
              , at = ie !== null ? ie.x : 0
              , xt = ie !== null ? ie.y : 0;
            Le.setTexture2D(U, 0),
            j.copyTexSubImage2D(j.TEXTURE_2D, _e, 0, 0, at, xt, ae, Ye),
            he.unbindTexture()
        }
        ,
        this.copyTextureToTexture = function(U, ie, _e=null, ye=null, ae=0) {
            U.isTexture !== !0 && (hd("WebGLRenderer: copyTextureToTexture function signature has changed."),
            ye = arguments[0] || null,
            U = arguments[1],
            ie = arguments[2],
            ae = arguments[3] || 0,
            _e = null);
            let Ye, at, xt, gt, Dt, Ft;
            _e !== null ? (Ye = _e.max.x - _e.min.x,
            at = _e.max.y - _e.min.y,
            xt = _e.min.x,
            gt = _e.min.y) : (Ye = U.image.width,
            at = U.image.height,
            xt = 0,
            gt = 0),
            ye !== null ? (Dt = ye.x,
            Ft = ye.y) : (Dt = 0,
            Ft = 0);
            const St = kt.convert(ie.format)
              , rn = kt.convert(ie.type);
            Le.setTexture2D(ie, 0),
            j.pixelStorei(j.UNPACK_FLIP_Y_WEBGL, ie.flipY),
            j.pixelStorei(j.UNPACK_PREMULTIPLY_ALPHA_WEBGL, ie.premultiplyAlpha),
            j.pixelStorei(j.UNPACK_ALIGNMENT, ie.unpackAlignment);
            const on = j.getParameter(j.UNPACK_ROW_LENGTH)
              , Jt = j.getParameter(j.UNPACK_IMAGE_HEIGHT)
              , wn = j.getParameter(j.UNPACK_SKIP_PIXELS)
              , qt = j.getParameter(j.UNPACK_SKIP_ROWS)
              , bt = j.getParameter(j.UNPACK_SKIP_IMAGES)
              , ni = U.isCompressedTexture ? U.mipmaps[ae] : U.image;
            j.pixelStorei(j.UNPACK_ROW_LENGTH, ni.width),
            j.pixelStorei(j.UNPACK_IMAGE_HEIGHT, ni.height),
            j.pixelStorei(j.UNPACK_SKIP_PIXELS, xt),
            j.pixelStorei(j.UNPACK_SKIP_ROWS, gt),
            U.isDataTexture ? j.texSubImage2D(j.TEXTURE_2D, ae, Dt, Ft, Ye, at, St, rn, ni.data) : U.isCompressedTexture ? j.compressedTexSubImage2D(j.TEXTURE_2D, ae, Dt, Ft, ni.width, ni.height, St, ni.data) : j.texSubImage2D(j.TEXTURE_2D, ae, Dt, Ft, Ye, at, St, rn, ni),
            j.pixelStorei(j.UNPACK_ROW_LENGTH, on),
            j.pixelStorei(j.UNPACK_IMAGE_HEIGHT, Jt),
            j.pixelStorei(j.UNPACK_SKIP_PIXELS, wn),
            j.pixelStorei(j.UNPACK_SKIP_ROWS, qt),
            j.pixelStorei(j.UNPACK_SKIP_IMAGES, bt),
            ae === 0 && ie.generateMipmaps && j.generateMipmap(j.TEXTURE_2D),
            he.unbindTexture()
        }
        ,
        this.copyTextureToTexture3D = function(U, ie, _e=null, ye=null, ae=0) {
            U.isTexture !== !0 && (hd("WebGLRenderer: copyTextureToTexture3D function signature has changed."),
            _e = arguments[0] || null,
            ye = arguments[1] || null,
            U = arguments[2],
            ie = arguments[3],
            ae = arguments[4] || 0);
            let Ye, at, xt, gt, Dt, Ft, St, rn, on;
            const Jt = U.isCompressedTexture ? U.mipmaps[ae] : U.image;
            _e !== null ? (Ye = _e.max.x - _e.min.x,
            at = _e.max.y - _e.min.y,
            xt = _e.max.z - _e.min.z,
            gt = _e.min.x,
            Dt = _e.min.y,
            Ft = _e.min.z) : (Ye = Jt.width,
            at = Jt.height,
            xt = Jt.depth,
            gt = 0,
            Dt = 0,
            Ft = 0),
            ye !== null ? (St = ye.x,
            rn = ye.y,
            on = ye.z) : (St = 0,
            rn = 0,
            on = 0);
            const wn = kt.convert(ie.format)
              , qt = kt.convert(ie.type);
            let bt;
            if (ie.isData3DTexture)
                Le.setTexture3D(ie, 0),
                bt = j.TEXTURE_3D;
            else if (ie.isDataArrayTexture || ie.isCompressedArrayTexture)
                Le.setTexture2DArray(ie, 0),
                bt = j.TEXTURE_2D_ARRAY;
            else {
                console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                return
            }
            j.pixelStorei(j.UNPACK_FLIP_Y_WEBGL, ie.flipY),
            j.pixelStorei(j.UNPACK_PREMULTIPLY_ALPHA_WEBGL, ie.premultiplyAlpha),
            j.pixelStorei(j.UNPACK_ALIGNMENT, ie.unpackAlignment);
            const ni = j.getParameter(j.UNPACK_ROW_LENGTH)
              , dn = j.getParameter(j.UNPACK_IMAGE_HEIGHT)
              , Xs = j.getParameter(j.UNPACK_SKIP_PIXELS)
              , Gl = j.getParameter(j.UNPACK_SKIP_ROWS)
              , hs = j.getParameter(j.UNPACK_SKIP_IMAGES);
            j.pixelStorei(j.UNPACK_ROW_LENGTH, Jt.width),
            j.pixelStorei(j.UNPACK_IMAGE_HEIGHT, Jt.height),
            j.pixelStorei(j.UNPACK_SKIP_PIXELS, gt),
            j.pixelStorei(j.UNPACK_SKIP_ROWS, Dt),
            j.pixelStorei(j.UNPACK_SKIP_IMAGES, Ft),
            U.isDataTexture || U.isData3DTexture ? j.texSubImage3D(bt, ae, St, rn, on, Ye, at, xt, wn, qt, Jt.data) : ie.isCompressedArrayTexture ? j.compressedTexSubImage3D(bt, ae, St, rn, on, Ye, at, xt, wn, Jt.data) : j.texSubImage3D(bt, ae, St, rn, on, Ye, at, xt, wn, qt, Jt),
            j.pixelStorei(j.UNPACK_ROW_LENGTH, ni),
            j.pixelStorei(j.UNPACK_IMAGE_HEIGHT, dn),
            j.pixelStorei(j.UNPACK_SKIP_PIXELS, Xs),
            j.pixelStorei(j.UNPACK_SKIP_ROWS, Gl),
            j.pixelStorei(j.UNPACK_SKIP_IMAGES, hs),
            ae === 0 && ie.generateMipmaps && j.generateMipmap(bt),
            he.unbindTexture()
        }
        ,
        this.initRenderTarget = function(U) {
            we.get(U).__webglFramebuffer === void 0 && Le.setupRenderTarget(U)
        }
        ,
        this.initTexture = function(U) {
            U.isCubeTexture ? Le.setTextureCube(U, 0) : U.isData3DTexture ? Le.setTexture3D(U, 0) : U.isDataArrayTexture || U.isCompressedArrayTexture ? Le.setTexture2DArray(U, 0) : Le.setTexture2D(U, 0),
            he.unbindTexture()
        }
        ,
        this.resetState = function() {
            S = 0,
            C = 0,
            M = null,
            he.reset(),
            _t.reset()
        }
        ,
        typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
            detail: this
        }))
    }
    get coordinateSystem() {
        return Lo
    }
    get outputColorSpace() {
        return this._outputColorSpace
    }
    set outputColorSpace(e) {
        this._outputColorSpace = e;
        const t = this.getContext();
        t.drawingBufferColorSpace = e === Ex ? "display-p3" : "srgb",
        t.unpackColorSpace = pn.workingColorSpace === Rm ? "display-p3" : "srgb"
    }
}
class ote extends Fi {
    constructor() {
        super(),
        this.isScene = !0,
        this.type = "Scene",
        this.background = null,
        this.environment = null,
        this.fog = null,
        this.backgroundBlurriness = 0,
        this.backgroundIntensity = 1,
        this.backgroundRotation = new Xr,
        this.environmentIntensity = 1,
        this.environmentRotation = new Xr,
        this.overrideMaterial = null,
        typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
            detail: this
        }))
    }
    copy(e, t) {
        return super.copy(e, t),
        e.background !== null && (this.background = e.background.clone()),
        e.environment !== null && (this.environment = e.environment.clone()),
        e.fog !== null && (this.fog = e.fog.clone()),
        this.backgroundBlurriness = e.backgroundBlurriness,
        this.backgroundIntensity = e.backgroundIntensity,
        this.backgroundRotation.copy(e.backgroundRotation),
        this.environmentIntensity = e.environmentIntensity,
        this.environmentRotation.copy(e.environmentRotation),
        e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()),
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return this.fog !== null && (t.object.fog = this.fog.toJSON()),
        this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness),
        this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity),
        t.object.backgroundRotation = this.backgroundRotation.toArray(),
        this.environmentIntensity !== 1 && (t.object.environmentIntensity = this.environmentIntensity),
        t.object.environmentRotation = this.environmentRotation.toArray(),
        t
    }
}
class Mx extends Pa {
    constructor(e=1, t=32, n=0, s=Math.PI * 2) {
        super(),
        this.type = "CircleGeometry",
        this.parameters = {
            radius: e,
            segments: t,
            thetaStart: n,
            thetaLength: s
        },
        t = Math.max(3, t);
        const r = []
          , o = []
          , a = []
          , l = []
          , c = new Te
          , u = new nn;
        o.push(0, 0, 0),
        a.push(0, 0, 1),
        l.push(.5, .5);
        for (let d = 0, f = 3; d <= t; d++,
        f += 3) {
            const h = n + d / t * s;
            c.x = e * Math.cos(h),
            c.y = e * Math.sin(h),
            o.push(c.x, c.y, c.z),
            a.push(0, 0, 1),
            u.x = (o[f] / e + 1) / 2,
            u.y = (o[f + 1] / e + 1) / 2,
            l.push(u.x, u.y)
        }
        for (let d = 1; d <= t; d++)
            r.push(d, d + 1, 0);
        this.setIndex(r),
        this.setAttribute("position", new Gr(o,3)),
        this.setAttribute("normal", new Gr(a,3)),
        this.setAttribute("uv", new Gr(l,2))
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new Mx(e.radius,e.segments,e.thetaStart,e.thetaLength)
    }
}
class ate extends uf {
    constructor(e) {
        super(),
        this.isMeshStandardMaterial = !0,
        this.defines = {
            STANDARD: ""
        },
        this.type = "MeshStandardMaterial",
        this.color = new un(16777215),
        this.roughness = 1,
        this.metalness = 0,
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new un(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = a3,
        this.normalScale = new nn(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.roughnessMap = null,
        this.metalnessMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapRotation = new Xr,
        this.envMapIntensity = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.defines = {
            STANDARD: ""
        },
        this.color.copy(e.color),
        this.roughness = e.roughness,
        this.metalness = e.metalness,
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.roughnessMap = e.roughnessMap,
        this.metalnessMap = e.metalnessMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.envMapRotation.copy(e.envMapRotation),
        this.envMapIntensity = e.envMapIntensity,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.flatShading = e.flatShading,
        this.fog = e.fog,
        this
    }
}
class A3 extends Fi {
    constructor(e, t=1) {
        super(),
        this.isLight = !0,
        this.type = "Light",
        this.color = new un(e),
        this.intensity = t
    }
    dispose() {}
    copy(e, t) {
        return super.copy(e, t),
        this.color.copy(e.color),
        this.intensity = e.intensity,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.color = this.color.getHex(),
        t.object.intensity = this.intensity,
        this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()),
        this.distance !== void 0 && (t.object.distance = this.distance),
        this.angle !== void 0 && (t.object.angle = this.angle),
        this.decay !== void 0 && (t.object.decay = this.decay),
        this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
        this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
        this.target !== void 0 && (t.object.target = this.target.uuid),
        t
    }
}
const gg = new qn
  , DE = new Te
  , FE = new Te;
class lte {
    constructor(e) {
        this.camera = e,
        this.intensity = 1,
        this.bias = 0,
        this.normalBias = 0,
        this.radius = 1,
        this.blurSamples = 8,
        this.mapSize = new nn(512,512),
        this.map = null,
        this.mapPass = null,
        this.matrix = new qn,
        this.autoUpdate = !0,
        this.needsUpdate = !1,
        this._frustum = new Tx,
        this._frameExtents = new nn(1,1),
        this._viewportCount = 1,
        this._viewports = [new oi(0,0,1,1)]
    }
    getViewportCount() {
        return this._viewportCount
    }
    getFrustum() {
        return this._frustum
    }
    updateMatrices(e) {
        const t = this.camera
          , n = this.matrix;
        DE.setFromMatrixPosition(e.matrixWorld),
        t.position.copy(DE),
        FE.setFromMatrixPosition(e.target.matrixWorld),
        t.lookAt(FE),
        t.updateMatrixWorld(),
        gg.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(gg),
        n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
        n.multiply(gg)
    }
    getViewport(e) {
        return this._viewports[e]
    }
    getFrameExtents() {
        return this._frameExtents
    }
    dispose() {
        this.map && this.map.dispose(),
        this.mapPass && this.mapPass.dispose()
    }
    copy(e) {
        return this.camera = e.camera.clone(),
        this.intensity = e.intensity,
        this.bias = e.bias,
        this.radius = e.radius,
        this.mapSize.copy(e.mapSize),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    toJSON() {
        const e = {};
        return this.intensity !== 1 && (e.intensity = this.intensity),
        this.bias !== 0 && (e.bias = this.bias),
        this.normalBias !== 0 && (e.normalBias = this.normalBias),
        this.radius !== 1 && (e.radius = this.radius),
        (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()),
        e.camera = this.camera.toJSON(!1).object,
        delete e.camera.matrix,
        e
    }
}
class cte extends lte {
    constructor() {
        super(new Ax(-5,5,5,-5,.5,500)),
        this.isDirectionalLightShadow = !0
    }
}
class ute extends A3 {
    constructor(e, t) {
        super(e, t),
        this.isDirectionalLight = !0,
        this.type = "DirectionalLight",
        this.position.copy(Fi.DEFAULT_UP),
        this.updateMatrix(),
        this.target = new Fi,
        this.shadow = new cte
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e) {
        return super.copy(e),
        this.target = e.target.clone(),
        this.shadow = e.shadow.clone(),
        this
    }
}
class dte extends A3 {
    constructor(e, t) {
        super(e, t),
        this.isAmbientLight = !0,
        this.type = "AmbientLight"
    }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{
    detail: {
        revision: gx
    }
}));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = gx);
const C3 = ut({
    __name: "ThreeJS",
    props: {
        ballPosition: Number
    },
    setup(i) {
        const e = i
          , t = xe(null)
          , n = xe(null);
        let s = null
          , r = null
          , o = null;
        return Ln( () => {
            if (t.value && n.value) {
                let a = function() {
                    r.render(l, o),
                    requestAnimationFrame(a)
                };
                r = new rte({
                    canvas: t.value,
                    antialias: !0
                }),
                r.setPixelRatio(window.devicePixelRatio),
                r.setSize(n.value.clientWidth, n.value.clientHeight),
                r.setClearColor(1579035),
                r.outputEncoding = void 0;
                const l = new ote
                  , c = n.value.clientWidth / n.value.clientHeight;
                o = new Ax(-100 * c / 2,100 * c / 2,100 / 2,-100 / 2,.1,1e3),
                o.position.set(0, 0, 150);
                const u = new dte(16777215,.5);
                l.add(u);
                const d = new ute(16777215,1);
                d.position.set(0, 1, 1).normalize(),
                l.add(d),
                s = new Br(new Mx(3,64),new ate({
                    color: 16776960,
                    flatShading: !0
                })),
                l.add(s),
                a();
                const f = () => {
                    if (n.value && r && o) {
                        const h = n.value.clientWidth
                          , p = n.value.clientHeight;
                        r.setSize(h, p);
                        const g = h / p;
                        o.left = -100 * g / 2,
                        o.right = 100 * g / 2,
                        o.updateProjectionMatrix()
                    }
                }
                ;
                window.addEventListener("resize", f),
                Zd( () => {
                    window.removeEventListener("resize", f)
                }
                )
            }
        }
        ),
        Bt( () => e.ballPosition, a => {
            s && (s.position.y = -47 + a / 100 * 94)
        }
        ),
        (a, l) => (w(),
        R("div", {
            ref_key: "parentDiv",
            ref: n,
            class: "w-full h-full block relative mx-auto"
        }, [x("canvas", {
            id: "c",
            ref_key: "canvas",
            ref: t,
            class: "absolute inset-0 !h-full !w-full"
        }, null, 512)], 512))
    }
})
  , fte = {
    class: "m-3.5"
}
  , hte = {
    class: "flex"
}
  , pte = {
    class: "m-3.5"
}
  , mte = {
    class: "flex"
}
  , gte = {
    class: "p-4"
}
  , vte = {
    class: "grid grid-cols-1 lg:grid-cols-2 gap-4"
}
  , _te = {
    class: "text-white font-medium text-xl"
}
  , xte = {
    class: "absolute"
}
  , yte = {
    class: "flex gap-x-1.5 ml-auto"
}
  , bte = {
    class: "flex mt-2 gap-2"
}
  , Ste = ["value"]
  , Ete = {
    class: "p-4"
}
  , wte = {
    class: "grid grid-cols-1 lg:grid-cols-2 gap-4"
}
  , Tte = {
    class: "w-full"
}
  , Ate = {
    class: "border border-zinc-700 flex relative rounded-md"
}
  , Cte = {
    key: 1,
    class: "absolute flex h-full w-full hover:bg-gray-800 text-gray-800 hover:text-gray-700"
}
  , Mte = {
    key: 2,
    class: "absolute bottom-1.5 left-1.5 flex gap-1.5 z-10 cursor-pointer"
}
  , Rte = {
    class: "bg-black/90 rounded backdrop-blur p-2 font-medium text-sm"
}
  , Lte = {
    key: 3,
    class: "flex absolute bottom-1.5 right-1.5 z-10 cursor-pointer"
}
  , Ite = {
    class: "bg-black/90 rounded backdrop-blur p-2 font-medium text-sm opacity-60 flex items-center justify-center"
}
  , kte = {
    class: "text-white"
}
  , Pte = {
    class: "relative m-1 h-5 w-5"
}
  , Dte = {
    class: "w-full"
}
  , Fte = {
    class: "flex gap-4"
}
  , Ote = {
    class: "w-1/6"
}
  , Ute = {
    class: "w-full h-80"
}
  , Nte = {
    class: "w-full h-full border border-zinc-700 rounded-md p-4"
}
  , Bte = {
    class: "w-5/6"
}
  , Vte = {
    class: "border border-zinc-700 flex relative rounded-md w-full h-80"
}
  , $te = {
    key: 1,
    class: "absolute flex h-full w-full hover:bg-gray-800 text-gray-800 hover:text-gray-700"
}
  , Hte = ["muted"]
  , zte = {
    key: 2,
    class: "m-1.5 absolute opacity-60 p-2 rounded bg-black"
}
  , Gte = {
    class: "text-sm inline"
}
  , Wte = ["checked"]
  , qte = ["checked"]
  , jte = ["checked"]
  , Kte = {
    key: 3,
    class: "absolute bottom-1.5 left-1.5 flex gap-1.5 z-10 cursor-pointer"
}
  , Xte = {
    class: "bg-black/90 rounded backdrop-blur p-2 font-medium text-sm opacity-60"
}
  , Yte = {
    key: 0,
    class: "flex m-2 justify-center sm:mx-auto sm:justify-around bg-transparent pt-4 h-auto w-full sm:w-1/4 gap-4 md:gap-1"
}
  , Zte = {
    class: "hidden mx-auto text-sm"
}
  , Jte = {
    class: "hidden mx-auto text-sm"
}
  , Qte = ut({
    __name: "LiveStream",
    setup(i) {
        const e = Zr()
          , {autoblow: t, handy: n, bluetoothFleshyThrust: s} = Pn(e);
        let r = Vt( () => t.value.connected)
          , o = Vt( () => n.value.connected)
          , a = Vt( () => s.value.connected);
        const l = Vt( () => t.value.connected || n.value.connected || s.value.connected)
          , c = xe(!1)
          , {isMobile: u} = Ks();
        let d;
        const f = Ki()
          , h = xe(!1)
          , p = xe("Copy");
        let g = xe(!1)
          , m = xe(!1)
          , v = xe(!1);
        const _ = xe(null)
          , y = xe(null);
        let b, S = xe(!1), C = xe("info"), M = xe(""), L = xe(""), T = xe("bg-red-900"), A = 500, k = xe(""), D = xe(void 0);
        const F = xe([]);
        let z = 1e3;
        new Date().getTime();
        let G = xe("Unknown");
        const H = ["Close Hand", "Backside Fist", "Fist", "Cylindrical", "Cylindrical Grasp", "Spherical Grasp", "Thumbs Up"]
          , X = xe({});
        let K = null
          , ce = xe(!1)
          , ue = xe(!0);
        function Ie() {
            l.value ? (L.value = "Device connected successfully",
            T.value = "bg-green-600",
            setTimeout( () => {
                L.value = "",
                T.value = "bg-transparent"
            }
            , 2e3)) : (L.value = "Please connect the device",
            T.value = "bg-red-900")
        }
        function ke(Me) {
            const {speed: ge, position: He} = Me;
            e.devices.forEach(ft => {
                switch (ft.connector) {
                case cn.Handy:
                    o.value && n.value.XPVP(He, ge);
                    break;
                case cn.Autoblow:
                    r.value && t.value.goto(He, ge);
                    break;
                case cn.BluetoothFleshyThrust:
                    a.value && s.value.move(He, ge);
                    break
                }
            }
            )
        }
        const We = String(window.btoa(String(Math.random())));
        let se = xe(f.params.streamToken ? f.params.streamToken : "");
        const Se = !f.params.streamToken;
        k.value = `${window.location.href}/${We}`.replace("live-stream//", "live-stream/");
        const be = new WebSocket("/api/ws?username=" + We);
        be.onmessage = Me => {
            const ge = JSON.parse(Me.data);
            ge.type === "offer" ? (se.value = ge.username,
            j(ge.offer)) : ge.type === "answer" ? B(ge.answer) : ge.type === "candidate" ? V(ge.candidate) : ge.type === "bye" ? te(!1, ge.username) : ge.type === "machineAINumberHand" ? (console.log("data", ge.data),
            G.value = ge.data,
            Oe(Number(ge.data.split(",")[0]))) : ge.type === "notfound" && (_t("info", "The recipient has disconnected."),
            Se && Je())
        }
        ,
        be.addEventListener("close", function(Me) {
            g.value = !1,
            te(),
            ln(),
            _t("danger", "Socket connection closed")
        }),
        be.addEventListener("error", function(Me) {
            _t("danger", "Socket error")
        });
        let q;
        const me = () => {
            console.log("checkConnection >>>> checkConnectionTimer"),
            clearTimeout(q),
            be.readyState > 0 ? vt() : q = setTimeout(me, 1e3)
        }
        ;
        be.addEventListener("open", () => {
            be.readyState === WebSocket.OPEN && (g.value = !0,
            D.value = setInterval( () => {
                be.send(JSON.stringify({
                    type: "isConnected"
                }))
            }
            , 1e4))
        }
        );
        const Ce = Me => {
            console.log(">>>>>> ", Me.type),
            be.readyState === WebSocket.OPEN && se.value ? (Me.recipient = se.value,
            Me.ishost = Se,
            be.send(JSON.stringify(Me))) : (be.readyState === WebSocket.CLOSED || be.readyState === WebSocket.CLOSING) && _t("danger", "WebSocket is not open")
        }
        ;
        function Pe() {
            const Me = {
                iceServers: [{
                    urls: "stun:stun.l.google.com:19302"
                }]
            };
            d = new RTCPeerConnection(Me);
            try {
                b instanceof MediaStream && v && b.getTracks().forEach(ge => {
                    d.addTrack(ge, b)
                }
                )
            } catch (ge) {
                console.error("Error (createPeerConnection):", ge)
            }
            d.onicecandidate = ge => {
                ge.candidate && Ce({
                    type: "candidate",
                    candidate: ge.candidate
                })
            }
            ,
            d.ontrack = ge => {
                console.log("Remote track received:", ge.streams[0]),
                y.value && (y.value.srcObject = ge.streams[0])
            }
        }
        function vt() {
            console.log("createOffer"),
            m.value = !1,
            Pe(),
            d.createOffer().then(Me => d.setLocalDescription(Me)).then( () => {
                Ce({
                    type: "offer",
                    offer: d.localDescription,
                    username: We
                })
            }
            ).catch(Me => console.error("Error creating an offer:", Me))
        }
        function j(Me) {
            m.value = !0,
            Pe(),
            d.setRemoteDescription(new RTCSessionDescription(Me)).then( () => d.createAnswer()).then(ge => d.setLocalDescription(ge)).then( () => {
                Ce({
                    type: "answer",
                    answer: d.localDescription
                })
            }
            ).catch(ge => console.error("Error handling offer:", ge)).finally( () => {
                Xe()
            }
            )
        }
        function B(Me) {
            m.value = !0,
            Xe(),
            d.setRemoteDescription(new RTCSessionDescription(Me)).catch(ge => console.error("Error setting remote description:", ge))
        }
        function V(Me) {
            d.addIceCandidate(new RTCIceCandidate(Me)).catch(ge => console.error("Error adding ICE candidate:", ge))
        }
        let Q = 0, he = null, Ee = 0, we = null, Le = xe(3e5), N = xe(3e5), I = xe("144"), W, re = xe(50), oe = -47, fe = 0, $e = !0;
        const Oe = Me => {
            fe = Me,
            performance.now(),
            $e = !0,
            H.includes(G.value.substring(6)) && qe()
        }
        ;
        function qe() {
            function Me(He, ft, It) {
                return He + (ft - He) * It
            }
            function ge(He, ft, It) {
                if (It <= He)
                    return 0;
                if (It >= ft)
                    return 1;
                const Yt = (It - He) / (ft - He);
                return Yt * Yt * (3 - 2 * Yt)
            }
            if ($e) {
                const He = performance.now();
                let ft = Math.min(He, 1);
                const It = ge(0, 1, ft);
                oe = Me(oe, fe, It),
                re.value = oe,
                ke({
                    speed: A,
                    position: oe.toFixed(0)
                }),
                ft >= 1 && ($e = !1)
            }
        }
        function nt() {
            if (b) {
                let Me = b.getAudioTracks()[0];
                console.log("********************", Me),
                Me && (ue.value = !ue.value,
                Me.enabled = ue.value)
            }
        }
        function Be() {
            if (b) {
                let Me = b.getVideoTracks()[0];
                console.log("********************", Me),
                Me.enabled ? Me.enabled = !1 : Me.enabled = !0,
                ce.value = !ce.value
            } else
                ce.value = !0
        }
        function Xe(Me=3e5) {
            const ge = d.getSenders().find(He => He.track.kind === "video");
            if (ge) {
                const He = ge.getParameters();
                He.encodings || (He.encodings = [{}]),
                He.encodings[0].maxBitrate = Number(Me),
                ge.setParameters(He).then( () => {
                    console.log("Bitrate set to:", I.value)
                }
                ).catch(ft => {
                    console.log("Failed to set bitrate:", ft)
                }
                )
            }
        }
        async function Rt() {
            W = setInterval(async () => {
                d && (await d.getStats()).forEach(ge => {
                    if (ge.type === "outbound-rtp" && ge.kind === "video") {
                        const He = ge.bytesSent
                          , ft = ge.timestamp;
                        if (Q !== 0 && he) {
                            const It = He - Q
                              , Yt = (ft - he) / 1e3;
                            Le.value = It * 8 / 1e3 / Yt
                        }
                        Q = He,
                        he = ft
                    }
                    if (ge.type === "inbound-rtp" && ge.kind === "video") {
                        const He = ge.bytesReceived
                          , ft = ge.timestamp;
                        if (Ee !== 0 && we) {
                            const It = He - Ee
                              , Yt = (ft - we) / 1e3
                              , sn = It * 8 / 1e3 / Yt;
                            N.value = sn
                        }
                        Ee = He,
                        we = ft
                    }
                }
                )
            }
            , 1e3)
        }
        function ht() {
            W && (clearTimeout(W),
            W = void 0)
        }
        function lt() {
            switch (String(Le.value)) {
            case "300000":
                I.value = "144";
                break;
            case "600000":
                I.value = "240";
                break;
            case "1000000":
                I.value = "360";
                break;
            case "2000000":
                I.value = "480";
                break;
            case "5000000":
                I.value = "720";
                break;
            default:
                I.value = "144";
                break
            }
        }
        function kt(Me) {
            Le.value = Me.target.value,
            lt(),
            Xe(Me.target.value)
        }
        const _t = (Me, ge) => {
            Me == "success" ? C.value = "bg-green-600 text-white" : Me == "warning" ? C.value = "bg-gray-600 text-white" : Me == "danger" ? C.value = "bg-red-900 text-white" : C.value = "bg-blue-900 text-white",
            M.value = ge
        }
          , Xt = {
            webSocketErr: () => {
                M.value = "",
                C.value = "border text-black"
            }
            ,
            deviceError: () => {
                L.value = "",
                T.value = "border text-black"
            }
        }
          , te = (Me=!0, ge="") => {
            Me && Ce({
                type: "bye",
                username: We,
                recipient: se.value,
                ishost: Se
            }),
            (ge == se.value || Me) && (ht(),
            clearInterval(D.value),
            D.value = void 0,
            be.close(),
            Se || b.getTracks().forEach(He => He.stop()),
            Je(),
            S.value = !1)
        }
          , Je = () => {
            y.value && y.value.srcObject.getTracks().forEach(Me => Me.stop()),
            se.value = "",
            d && d.close(),
            m.value = !1
        }
          , De = () => {
            k.value == "" && _t("warning", "Something error to generate link. Please try again."),
            navigator.clipboard.writeText(k.value).then( () => {
                p.value = "Copied"
            }
            ).catch(Me => {
                _t("danger", "Clipboard permission issue, please check and try again.")
            }
            ).finally( () => {
                setTimeout( () => {
                    p.value = "Copy",
                    h.value = !1
                }
                , 1e3)
            }
            )
        }
          , Ue = (Me, ge) => {
            G.value = ge;
            let He = Number(G.value.split(",")[0]);
            Oe(He),
            se.value && Ce({
                type: "machineAINumberHand",
                username: Me,
                data: ge
            })
        }
        ;
        async function et() {
            let He = 0;
            for (; He < 3; )
                try {
                    const ft = await handPoseDetection.createDetector(handPoseDetection.SupportedModels.MediaPipeHands, {
                        runtime: "mediapipe",
                        modelType: "full",
                        maxHands: 1,
                        solutionPath: "https://cdn.jsdelivr.net/npm/@mediapipe/hands/"
                    });
                    return console.log("Hand pose model loaded successfully."),
                    ft
                } catch (ft) {
                    He++,
                    console.log(`Attempt ${He} to load the hand pose model failed. Retrying... [Error: `, ft, "]"),
                    He < 3 && await new Promise(It => setTimeout(It, 2e3))
                }
            return console.log("Failed to load the hand pose model after maximum retries."),
            null
        }
        function Lt(Me, ge, He) {
            if (He.clearRect(0, 0, He.canvas.width, He.canvas.height),
            !He)
                return;
            const ft = Math.max(0, Math.min(100, 100 - ge[0].y / _.value.videoHeight * 100));
            if (Ue(se.value, `${ft.toFixed(2)},${Me}`),
            _.value) {
                const sn = (X.value.width - _.value.videoWidth * .3) / 2
                  , Yi = (X.value.height - _.value.videoHeight * .3) / 2;
                ge.forEach(ie => {
                    const _e = ie.x * .3 + sn
                      , ye = ie.y * .3 + Yi;
                    He.fillStyle = "red",
                    He.beginPath(),
                    He.arc(_e, ye, 3, 0, 2 * Math.PI),
                    He.fill()
                }
                ),
                [[0, 1], [1, 2], [2, 3], [3, 4], [0, 5], [5, 6], [6, 7], [7, 8], [5, 9], [9, 10], [10, 11], [11, 12], [9, 13], [13, 14], [14, 15], [15, 16], [13, 17], [17, 18], [18, 19], [19, 20], [0, 17]].forEach( ([ie,_e]) => {
                    const ye = ge[ie].x * .3 + sn
                      , ae = ge[ie].y * .3 + Yi
                      , Ye = ge[_e].x * .3 + sn
                      , at = ge[_e].y * .3 + Yi;
                    He.strokeStyle = "blue",
                    He.lineWidth = 1,
                    He.beginPath(),
                    He.moveTo(ye, ae),
                    He.lineTo(Ye, at),
                    He.stroke()
                }
                )
            }
        }
        function Wt(Me) {
            F.value.length == z && F.value.shift(),
            F.value.push(Me)
        }
        function $() {
            console.log(`Report-length : ${F.value.length}, Report-capacity ${z}`),
            F.value.map(Me => console.log(JSON.parse(Me)))
        }
        function Z(Me, ge) {
            const He = Me.x - ge.x
              , ft = Me.y - ge.y;
            return Math.sqrt(He * He + ft * ft)
        }
        function ne(Me) {
            const ge = Me.map( ({x: bt, y: ni}) => [bt, ni])
              , He = Me[4]
              , ft = Me[8]
              , It = Me[12]
              , Yt = Me[16]
              , sn = Me[20]
              , Yi = Me[1]
              , U = Me[0]
              , ie = Me[7]
              , _e = Me[11]
              , ye = Me[15]
              , ae = Me[19]
              , Ye = Z(U, ft)
              , at = Z(U, ie)
              , xt = Z(U, It)
              , gt = Z(U, _e)
              , Dt = Z(U, Yt)
              , Ft = Z(U, ye)
              , St = Z(U, sn)
              , rn = Z(U, ae)
              , on = Z(Yi, ft)
              , Jt = Z(Yi, It)
              , wn = Z(Yi, Yt)
              , qt = Z(Yi, sn);
            if (on < 40 && Jt < 40 && wn < 40 && qt < 40 && on < Jt && Jt < wn && wn < qt && ft.y < U.y && It.y < U.y && Yt.y < U.y && sn.y < U.y || at < 40 && gt < 40 && Ft < 40 && rn < 40 && at < Ye && gt < xt && Ft < Dt && rn < St && ft.y < U.y && It.y < U.y && Yt.y < U.y && sn.y < U.y)
                return "Close Hand";
            if (on < Jt && Jt < wn && wn < qt && on < 30 && Jt < 40 && wn < 50 && qt < 60)
                return U.y < Math.min(ft.y, It.y, Yt.y, sn.y) ? "Backside Fist" : "Fist";
            if (on > 40 && Jt > 40 && wn > 40 && qt > 40 && on < 90 && Jt < 100 && wn < 110 && qt < 120) {
                const bt = {
                    Cylindrical: ge
                };
                return Wt(JSON.stringify(bt)),
                "Cylindrical Grasp"
            } else {
                if (on > 50 && Jt > 60 && wn > 70 && qt > 80 && on < 140 && Jt < 150 && wn < 160 && qt < 170)
                    return "Spherical Grasp";
                if (on > 120 && Jt > 130 && wn > 140 && qt > 150)
                    return "Open Hand";
                if (He.y < U.y && on > 40 && Jt > 40 && wn > 40 && qt > 40)
                    return "Thumbs Up";
                {
                    const bt = {
                        "Unknown Movement": ge
                    };
                    return Wt(JSON.stringify(bt)),
                    "Unknown"
                }
            }
        }
        async function Ne() {
            const Me = await et();
            if (!Me) {
                _t("danger", "Failed to initialize the hand pose detector");
                return
            }
            async function ge() {
                if (_.value) {
                    const He = await Me.estimateHands(_.value);
                    if (He.length > 0) {
                        const ft = ne(He[0].keypoints);
                        Lt(ft, He[0].keypoints, K)
                    } else
                        K.clearRect(0, 0, X.value.width, X.value.height);
                    requestAnimationFrame(ge)
                }
            }
            ge()
        }
        const Ke = async () => {
            await tf.setBackend("webgl"),
            await tf.ready(),
            console.log("Backend set to:", tf.getBackend()),
            f.params.streamToken || Ne()
        }
        ;
        function Qe(Me) {
            console.log("createFakeVideoStream"),
            K && (K.fillStyle = "#000",
            K.fillRect(0, 0, X.value.width, X.value.height));
            const He = X.value.captureStream(10).getVideoTracks()[0];
            Me.addTrack(He);
            const ft = new AudioContext
              , It = ft.createOscillator();
            It.frequency.value = 0;
            const Yt = ft.createMediaStreamDestination();
            It.connect(Yt),
            It.start();
            const sn = Yt.stream.getAudioTracks()[0];
            return Me.addTrack(sn),
            Me
        }
        function yt() {
            b.getTracks().forEach(ge => {
                ge.addEventListener("ended", () => {
                    console.warn(`Track ended: ${ge.kind}`),
                    Me(ge)
                }
                )
            }
            );
            function Me(ge) {
                console.log(ge.kind),
                ge.kind === "audio" ? console.warn("Audio track has ended. Updating UI...") : ge.kind === "video" && console.warn("Video track has ended. Updating UI...");
                const He = b.getVideoTracks().length
                  , ft = b.getAudioTracks().length;
                He === 0 && console.log("No video tracks available."),
                ft === 0 && console.log("No audio tracks available.")
            }
        }
        function st() {
            const Me = new Date
              , ge = Me.getHours()
              , He = Me.getMinutes()
              , ft = Me.getSeconds();
            return ge * 3600 + He * 60 + ft
        }
        function an() {
            e.devices.forEach(Me => {
                switch (Me.connector) {
                case cn.Handy:
                    o.value && n.value.start_R(st());
                    break;
                case cn.Autoblow:
                    r.value && t.value.start_R(st());
                    break;
                case cn.BluetoothFleshyThrust:
                    a.value && s.value.resetPosition();
                    break
                }
            }
            )
        }
        function ln() {
            e.devices.forEach(Me => {
                switch (Me.connector) {
                case cn.Handy:
                    o.value && n.value.stop_R();
                    break;
                case cn.Autoblow:
                    r.value && t.value.stop_R();
                    break;
                case cn.BluetoothFleshyThrust:
                    a.value && s.value.resetPosition();
                    break
                }
            }
            )
        }
        return Ln( () => {
            K = X.value.getContext("2d"),
            navigator.mediaDevices.getUserMedia({
                video: !0,
                audio: !0
            }).then(Me => {
                _.value && (_.value.srcObject = Me,
                b = Me,
                v.value = !0),
                yt()
            }
            ).catch(Me => {
                console.log("Error Media Device: ", Me),
                v.value = !1,
                b = Qe(b),
                _.value && (_.value.srcObject = b)
            }
            ).finally( () => {
                console.log("isHost", Se ? "true" : "false"),
                Se ? Ke() : me()
            }
            ),
            _.value && _.value.addEventListener("play", () => {
                S.value = !0,
                Rt()
            }
            ),
            y.value && y.value.addEventListener("play", () => {
                m.value = !0
            }
            ),
            me(),
            Ie(),
            an()
        }
        ),
        Ms( () => {
            te(),
            ht()
        }
        ),
        Bt(l, (Me, ge) => {
            Ie()
        }
        ),
        Bt(r, (Me, ge) => {
            Me === !0 && t.value.start_R(st())
        }
        ),
        Bt(o, (Me, ge) => {
            Me === !0 && n.value.start_R(st())
        }
        ),
        Bt(a, (Me, ge) => {
            Me === !0 && s.value.resetPosition()
        }
        ),
        (Me, ge) => {
            var He, ft;
            return w(),
            R(Ge, null, [E(M) != "" ? (w(),
            R("div", {
                key: 0,
                class: Pt(`${E(C)} flex justify-between rounded-md text-md m-4 `)
            }, [x("div", fte, ee(E(M)), 1), x("div", hte, [O(ze, {
                name: "close",
                class: "h-6 w-6 mr-4 my-auto pointer",
                onClick: Xt.webSocketErr
            }, null, 8, ["onClick"])])], 2)) : le("", !0), E(L) != "" ? (w(),
            R("div", {
                key: 1,
                class: Pt(`${E(T)}  flex justify-between mb-12 rounded-md text-md m-4 `)
            }, [x("div", pte, ee(E(L)), 1), x("div", mte, [O(ze, {
                name: "close",
                class: "h-6 w-6 mr-4 my-auto pointer",
                onClick: Xt.deviceError
            }, null, 8, ["onClick"])])], 2)) : le("", !0), x("div", gte, [x("div", vte, [x("h2", _te, [ge[4] || (ge[4] = J(" Live Stream ")), x("span", xte, [!E(se) && E(g) ? (w(),
            Re(ze, {
                key: 0,
                name: "onlineBadges",
                class: "text-blue-500 h-5 w-5"
            })) : E(se) && E(m) == !0 ? (w(),
            Re(ze, {
                key: 1,
                name: "onlineBadges",
                class: "text-green-400 h-5 w-5"
            })) : (w(),
            Re(ze, {
                key: 2,
                name: "onlineBadges",
                class: "text-red-800 h-5 w-5"
            }))])]), x("div", yte, [O(je, {
                onClick: $
            }, {
                default: Y( () => ge[5] || (ge[5] = [J("Report")])),
                _: 1
            }), Se == !0 && E(g) && E(v) ? (w(),
            Re(je, {
                key: 0,
                onClick: ge[0] || (ge[0] = It => h.value = !0),
                ref: "shareLinkShow"
            }, {
                default: Y( () => ge[6] || (ge[6] = [J("Share")])),
                _: 1
            }, 512)) : Se ? (w(),
            Re(je, {
                key: 1,
                disabled: "",
                class: "border"
            }, {
                default: Y( () => ge[7] || (ge[7] = [J("Share")])),
                _: 1
            })) : le("", !0)])])]), (w(),
            Re(ys(E(u) ? mr : ji), {
                modelValue: h.value,
                "onUpdate:modelValue": ge[1] || (ge[1] = It => h.value = It),
                target: (He = Me.$refs.shareLinkShow) == null ? void 0 : He.$el,
                placement: "left-start",
                offset: 10
            }, {
                default: Y( () => [x("div", {
                    class: Pt(`${E(u) ? "-mt-10 pt-2" : "p-4"}`)
                }, [ge[8] || (ge[8] = x("div", {
                    class: "flex gap-3 items-center"
                }, [x("p", {
                    class: "text-lg font-medium"
                }, "Invite for video stream")], -1)), ge[9] || (ge[9] = x("hr", {
                    class: "-mx-4 my-4 border-zinc-800"
                }, null, -1)), x("div", null, [x("div", bte, [x("input", {
                    class: "w-full bg-transparent border rounded-md p-1.5",
                    value: `${E(k)}`,
                    readonly: ""
                }, null, 8, Ste), O(je, {
                    onClick: De,
                    class: "w-20",
                    theme: "blue",
                    name: "Copy"
                }, {
                    default: Y( () => [J(ee(p.value), 1)]),
                    _: 1
                })])])], 2)]),
                _: 1
            }, 8, ["modelValue", "target"])), x("div", Ete, [x("div", wte, [x("div", Tte, [ge[12] || (ge[12] = x("h2", null, "Stream Video", -1)), x("div", Ate, [y.value && E(se) && !E(m) && E(g) ? (w(),
            Re(US, {
                key: 0
            })) : y.value && E(m) ? le("", !0) : (w(),
            R("div", Cte, [O(ze, {
                name: "video-box",
                class: "w-20 h-20 flex-1 my-auto"
            })])), x("video", {
                ref_key: "remoteVideo",
                ref: y,
                autoplay: "",
                playsinline: "",
                class: "flex-1 w-auto h-80"
            }, " Your browser does not support the video tag. ", 512), Se ? le("", !0) : (w(),
            R("div", Mte, [x("div", Rte, " > UP: " + ee(E(G)), 1)])), E(se) && E(m) == !0 ? (w(),
            R("div", Lte, [x("div", Ite, [ge[11] || (ge[11] = x("span", {
                class: "mr-2 text-white"
            }, "Quality:", -1)), x("span", kte, ee(E(I)), 1), x("div", Pte, [zt(x("select", {
                onChange: kt,
                "onUpdate:modelValue": ge[2] || (ge[2] = It => Sn(Le) ? Le.value = It : Le = It),
                ref_key: "currentBitrate",
                ref: Le,
                class: "h-full w-full text-white bg-slate-700 border border-gray-300 rounded-md py-1 px-2"
            }, ge[10] || (ge[10] = [pa('<option selected value="300000">144p</option><option value="600000">240p</option><option value="1000000">360p</option><option value="2000000">480p</option><option value="5000000">720p</option>', 5)]), 544), [[wd, E(Le)]])])])])) : le("", !0)]), x("small", null, ee(E(se)), 1)]), x("div", Dte, [x("div", Fte, [x("div", Ote, [x("div", Ute, [x("h2", null, [O(je, {
                onClick: ge[3] || (ge[3] = It => c.value = !c.value),
                theme: `${c.value ? "blue" : "default"}`,
                class: "!px-1 !py-0 !my-1 mx-auto !text-xs"
            }, {
                default: Y( () => ge[13] || (ge[13] = [J(" Debug")])),
                _: 1
            }, 8, ["theme"])]), x("div", Nte, [O(C3, {
                ballPosition: E(re)
            }, null, 8, ["ballPosition"])])])]), x("div", Bte, [ge[18] || (ge[18] = x("h2", null, "My Video ", -1)), x("div", Vte, [!E(S) && Se ? (w(),
            Re(US, {
                key: 0
            })) : (ft = _.value) != null && ft.srcObject ? le("", !0) : (w(),
            R("div", $te, [O(ze, {
                name: "video-box",
                class: "w-20 h-20 flex-1 my-auto"
            })])), x("video", {
                ref_key: "localVideo",
                ref: _,
                muted: E(ue),
                autoplay: "",
                playsinline: "",
                class: "flex-1 h-full w-full localVideo"
            }, " Your browser does not support the video tag. ", 8, Hte), x("canvas", {
                ref_key: "canvas",
                ref: X,
                class: Pt(`localVideo absolute h-full w-full ${c.value && Se ? "" : "hidden"}`)
            }, null, 2), c.value ? (w(),
            R("div", zte, [x("ul", Gte, [x("li", null, [ge[14] || (ge[14] = J("isHost: ")), x("input", {
                type: "checkbox",
                checked: Se
            })]), x("li", null, [ge[15] || (ge[15] = J("SocketConn:")), x("input", {
                type: "checkbox",
                checked: E(g)
            }, null, 8, Wte)]), x("li", null, [ge[16] || (ge[16] = J("StreamPermit: ")), x("input", {
                type: "checkbox",
                checked: E(v)
            }, null, 8, qte)]), x("li", null, [ge[17] || (ge[17] = J("CallAccepted: ")), x("input", {
                type: "checkbox",
                checked: E(m)
            }, null, 8, jte)]), x("li", null, "my Audio: " + ee(E(ue)), 1), x("li", null, "my Video: " + ee(E(ce)), 1)])])) : le("", !0), Se ? (w(),
            R("div", Kte, [x("div", Xte, " < UP: " + ee(E(G)), 1)])) : le("", !0)]), x("small", null, ee(E(We)), 1)])])])]), E(m) ? (w(),
            R("div", Yte, [x("div", {
                class: "border border-slate-400 bg-gray-200 hover:bg-gray-300 h-12 w-12 rounded-full text-center flex flex-col items-center justify-center transition-colors duration-200 shadow-md",
                onClick: Be
            }, [O(ze, {
                name: E(ce) ? "video-enable" : "video-disable",
                class: "h-6 w-6 text-slate-600 mb-1"
            }, null, 8, ["name"]), x("p", Zte, ee(E(ce) ? "Resume" : "Stop"), 1)]), x("div", {
                class: "border border-slate-400 bg-gray-200 hover:bg-gray-300 h-12 w-12 rounded-full text-center flex flex-col items-center justify-center transition-colors duration-200 shadow-md",
                onClick: nt
            }, [O(ze, {
                name: E(ue) ? "mute" : "unmute",
                theme: "green",
                class: "h-6 w-6 text-slate-600 mb-1"
            }, null, 8, ["name"]), x("p", Jte, ee(E(ue) ? "Unmute" : "Mute"), 1)]), x("div", {
                class: "border border-slate-400 bg-gray-200 hover:bg-gray-300 h-12 w-12 rounded-full text-center flex flex-col items-center justify-center transition-colors duration-200 shadow-md",
                onClick: te
            }, [O(ze, {
                name: "endcall",
                theme: "red",
                class: "h-6 w-6 text-slate-600 mb-1"
            }), ge[19] || (ge[19] = x("p", {
                class: "hidden mx-auto text-sm"
            }, "End", -1))])])) : le("", !0)])], 64)
        }
    }
});
const ene = {
    class: "flex justify-between items-center mb-4"
}
  , tne = {
    key: 0,
    class: "bg-red-600 rounded px-3 text-white font-thin text-xl"
}
  , nne = {
    class: "px-4"
}
  , ine = {
    key: 0,
    class: "items-center w-full bg-transparent"
}
  , sne = {
    class: "border-t-0 px-6 align-middle border-l-0 border-r-0 text-xs whitespace-nowrap p-4 text-left flex items-center"
}
  , rne = {
    class: "ml-3 font-bold text-white"
}
  , one = {
    class: "border-t-0 px-6 align-middle border-l-0 border-r-0 text-xs whitespace-nowrap p-4"
}
  , ane = {
    class: "border-t-0 px-6 align-middle border-l-0 border-r-0 text-xs whitespace-nowrap p-4 flex gap-4"
}
  , lne = ["onClick"]
  , cne = ["onClick"]
  , une = {
    key: 1,
    class: "justify-center text-red-500 p-4"
}
  , dne = ut({
    __name: "Subscribe",
    setup(i) {
        const e = ti()
          , t = xe([])
          , n = xe("add")
          , s = xe("")
          , {isAdmin: r} = it();
        r || e.push("/");
        const o = ei({
            loading: !1,
            editing: !1,
            fields: {
                email: "",
                expireOn: ""
            }
        })
          , a = (h="", p="") => {
            n.value = h ? "Update" : "Add",
            o.fields.email = h,
            o.fields.expireOn = p,
            o.editing = !0
        }
          , l = async () => {
            try {
                if (o.fields.email !== "" && o.fields.expireOn !== "") {
                    const h = await ct.admin.updatePremium(o.fields.email, o.fields.expireOn);
                    f(h),
                    u()
                }
            } catch (h) {
                console.error("Error updating subscription:", h)
            }
        }
          , c = async () => {
            try {
                t.value = await ct.admin.getPremiumUsers()
            } catch (h) {
                t.value = [],
                console.error("Error fetching premium users:", h)
            }
        }
          , u = async () => {
            o.editing = !1,
            o.fields.email = "",
            o.fields.expireOn = "",
            c()
        }
          , d = async h => {
            if (confirm("This will revoke the user's premium status without deleting the user.") && h !== "") {
                const p = await ct.admin.removePremiumUser(h);
                f(p),
                u()
            }
        }
          , f = h => {
            s.value = h,
            setTimeout( () => {
                s.value = ""
            }
            , 2e3)
        }
        ;
        return Ln(async () => {
            u()
        }
        ),
        (h, p) => (w(),
        R(Ge, null, [x("div", ene, [p[5] || (p[5] = x("div", {
            class: "flex items-center"
        }, [x("h2", {
            class: "text-white font-thin text-xl"
        }, "Premium Users Active ")], -1)), s.value ? (w(),
        R("div", tne, ee(s.value), 1)) : le("", !0), O(je, {
            onClick: p[0] || (p[0] = g => a()),
            theme: "blue",
            class: "flex gap-x-1.5 items-center"
        }, {
            default: Y( () => [O(ze, {
                name: "plus",
                class: "h-5 w-5"
            }), p[4] || (p[4] = x("span", null, "Add", -1))]),
            _: 1
        })]), x("div", nne, [t.value.length > 0 ? (w(),
        R("table", ine, [p[6] || (p[6] = x("thead", null, [x("tr", null, [x("th", {
            class: "px-6 align-middle border border-solid py-3 text-xs uppercase border-l-0 border-r-0 whitespace-nowrap font-semibold text-left bg-zinc-800 text-zinc-300 border-zinc-700"
        }, " Email"), x("th", {
            class: "px-6 align-middle border border-solid py-3 text-xs uppercase border-l-0 border-r-0 whitespace-nowrap font-semibold text-left bg-zinc-800 text-zinc-300 border-zinc-700"
        }, " Expire On [yyyy-mm-dd]"), x("th", {
            class: "px-6 align-middle border border-solid py-3 text-xs uppercase border-l-0 border-r-0 whitespace-nowrap font-semibold text-left bg-zinc-800 text-zinc-300 border-zinc-700"
        }, " Action")])], -1)), x("tbody", null, [(w(!0),
        R(Ge, null, Ht(t.value, (g, m) => (w(),
        R("tr", null, [x("th", sne, [x("span", rne, ee(g.email), 1)]), x("td", one, ee(g.expireOn.split("T")[0]), 1), x("td", ane, [x("button", {
            class: "bg-zinc-500 text-white px-4 py-1 rounded-md hover:bg-zinc-600",
            onClick: v => a(g.email, g.expireOn.split("T")[0])
        }, [O(ze, {
            name: "pencil",
            class: "h-4 w-4 text-white"
        })], 8, lne), x("button", {
            class: "bg-red-500 text-white px-4 py-1 rounded-md hover:bg-zinc-600",
            onClick: v => d(g.email)
        }, [O(ze, {
            name: "trash",
            class: "h-4 w-4 text-white"
        })], 8, cne)])]))), 256))])])) : (w(),
        R("div", une, " Sorry, no premium users found. "))]), O(mr, {
            modelValue: o.editing,
            "onUpdate:modelValue": p[3] || (p[3] = g => o.editing = g),
            title: `${n.value}`,
            onupdate: ""
        }, {
            default: Y( () => [x("form", {
                onSubmit: Vn(l, ["prevent"]),
                class: "mt-4 flex flex-col gap-y-3"
            }, [O(vn, {
                modelValue: o.fields.email,
                "onUpdate:modelValue": p[1] || (p[1] = g => o.fields.email = g),
                type: "email",
                placeholder: "example@host.com"
            }, null, 8, ["modelValue"]), O(vn, {
                modelValue: o.fields.expireOn,
                "onUpdate:modelValue": p[2] || (p[2] = g => o.fields.expireOn = g),
                type: "date"
            }, null, 8, ["modelValue"]), O(je, {
                theme: "blue"
            }, {
                default: Y( () => p[7] || (p[7] = [J("Submit")])),
                _: 1
            })], 32), p[8] || (p[8] = x("br", null, null, -1)), p[9] || (p[9] = x("small", null, "Note: Creates a new user if they do not exist and updates their premium status based on the provided input date", -1))]),
            _: 1
        }, 8, ["modelValue", "title"])], 64))
    }
});
function yo(i) {
    if (i === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return i
}
function M3(i, e) {
    i.prototype = Object.create(e.prototype),
    i.prototype.constructor = i,
    i.__proto__ = e
}
/*!
 * GSAP 3.12.5
 * https://gsap.com
 *
 * @license Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var Ts = {
    autoSleep: 120,
    force3D: "auto",
    nullTargetWarn: 1,
    units: {
        lineHeight: ""
    }
}, vu = {
    duration: .5,
    overwrite: !1,
    delay: 0
}, Rx, Oi, Dn, Bs = 1e8, Cn = 1 / Bs, kv = Math.PI * 2, fne = kv / 4, hne = 0, R3 = Math.sqrt, pne = Math.cos, mne = Math.sin, bi = function(e) {
    return typeof e == "string"
}, zn = function(e) {
    return typeof e == "function"
}, Oo = function(e) {
    return typeof e == "number"
}, Lx = function(e) {
    return typeof e > "u"
}, Yr = function(e) {
    return typeof e == "object"
}, ls = function(e) {
    return e !== !1
}, Ix = function() {
    return typeof window < "u"
}, hh = function(e) {
    return zn(e) || bi(e)
}, L3 = typeof ArrayBuffer == "function" && ArrayBuffer.isView || function() {}
, Ui = Array.isArray, Pv = /(?:-?\.?\d|\.)+/gi, I3 = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, Mc = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, vg = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, k3 = /[+-]=-?[.\d]+/, P3 = /[^,'"\[\]\s]+/gi, gne = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i, Nn, Ir, Dv, kx, Cs = {}, Hp = {}, D3, F3 = function(e) {
    return (Hp = Fl(e, Cs)) && fs
}, Px = function(e, t) {
    return console.warn("Invalid property", e, "set to", t, "Missing plugin? gsap.registerPlugin()")
}, Bd = function(e, t) {
    return !t && console.warn(e)
}, O3 = function(e, t) {
    return e && (Cs[e] = t) && Hp && (Hp[e] = t) || Cs
}, Vd = function() {
    return 0
}, vne = {
    suppressEvents: !0,
    isStart: !0,
    kill: !1
}, $h = {
    suppressEvents: !0,
    kill: !1
}, _ne = {
    suppressEvents: !0
}, Dx = {}, ya = [], Fv = {}, U3, gs = {}, _g = {}, OE = 30, Hh = [], Fx = "", Ox = function(e) {
    var t = e[0], n, s;
    if (Yr(t) || zn(t) || (e = [e]),
    !(n = (t._gsap || {}).harness)) {
        for (s = Hh.length; s-- && !Hh[s].targetTest(t); )
            ;
        n = Hh[s]
    }
    for (s = e.length; s--; )
        e[s] && (e[s]._gsap || (e[s]._gsap = new aR(e[s],n))) || e.splice(s, 1);
    return e
}, El = function(e) {
    return e._gsap || Ox(Vs(e))[0]._gsap
}, N3 = function(e, t, n) {
    return (n = e[t]) && zn(n) ? e[t]() : Lx(n) && e.getAttribute && e.getAttribute(t) || n
}, cs = function(e, t) {
    return (e = e.split(",")).forEach(t) || e
}, Gn = function(e) {
    return Math.round(e * 1e5) / 1e5 || 0
}, vi = function(e) {
    return Math.round(e * 1e7) / 1e7 || 0
}, jc = function(e, t) {
    var n = t.charAt(0)
      , s = parseFloat(t.substr(2));
    return e = parseFloat(e),
    n === "+" ? e + s : n === "-" ? e - s : n === "*" ? e * s : e / s
}, xne = function(e, t) {
    for (var n = t.length, s = 0; e.indexOf(t[s]) < 0 && ++s < n; )
        ;
    return s < n
}, zp = function() {
    var e = ya.length, t = ya.slice(0), n, s;
    for (Fv = {},
    ya.length = 0,
    n = 0; n < e; n++)
        s = t[n],
        s && s._lazy && (s.render(s._lazy[0], s._lazy[1], !0)._lazy = 0)
}, B3 = function(e, t, n, s) {
    ya.length && !Oi && zp(),
    e.render(t, n, s || Oi && t < 0 && (e._initted || e._startAt)),
    ya.length && !Oi && zp()
}, V3 = function(e) {
    var t = parseFloat(e);
    return (t || t === 0) && (e + "").match(P3).length < 2 ? t : bi(e) ? e.trim() : e
}, $3 = function(e) {
    return e
}, js = function(e, t) {
    for (var n in t)
        n in e || (e[n] = t[n]);
    return e
}, yne = function(e) {
    return function(t, n) {
        for (var s in n)
            s in t || s === "duration" && e || s === "ease" || (t[s] = n[s])
    }
}, Fl = function(e, t) {
    for (var n in t)
        e[n] = t[n];
    return e
}, UE = function i(e, t) {
    for (var n in t)
        n !== "__proto__" && n !== "constructor" && n !== "prototype" && (e[n] = Yr(t[n]) ? i(e[n] || (e[n] = {}), t[n]) : t[n]);
    return e
}, Gp = function(e, t) {
    var n = {}, s;
    for (s in e)
        s in t || (n[s] = e[s]);
    return n
}, pd = function(e) {
    var t = e.parent || Nn
      , n = e.keyframes ? yne(Ui(e.keyframes)) : js;
    if (ls(e.inherit))
        for (; t; )
            n(e, t.vars.defaults),
            t = t.parent || t._dp;
    return e
}, bne = function(e, t) {
    for (var n = e.length, s = n === t.length; s && n-- && e[n] === t[n]; )
        ;
    return n < 0
}, H3 = function(e, t, n, s, r) {
    n === void 0 && (n = "_first"),
    s === void 0 && (s = "_last");
    var o = e[s], a;
    if (r)
        for (a = t[r]; o && o[r] > a; )
            o = o._prev;
    return o ? (t._next = o._next,
    o._next = t) : (t._next = e[n],
    e[n] = t),
    t._next ? t._next._prev = t : e[s] = t,
    t._prev = o,
    t.parent = t._dp = e,
    t
}, km = function(e, t, n, s) {
    n === void 0 && (n = "_first"),
    s === void 0 && (s = "_last");
    var r = t._prev
      , o = t._next;
    r ? r._next = o : e[n] === t && (e[n] = o),
    o ? o._prev = r : e[s] === t && (e[s] = r),
    t._next = t._prev = t.parent = null
}, Ca = function(e, t) {
    e.parent && (!t || e.parent.autoRemoveChildren) && e.parent.remove && e.parent.remove(e),
    e._act = 0
}, wl = function(e, t) {
    if (e && (!t || t._end > e._dur || t._start < 0))
        for (var n = e; n; )
            n._dirty = 1,
            n = n.parent;
    return e
}, Sne = function(e) {
    for (var t = e.parent; t && t.parent; )
        t._dirty = 1,
        t.totalDuration(),
        t = t.parent;
    return e
}, Ov = function(e, t, n, s) {
    return e._startAt && (Oi ? e._startAt.revert($h) : e.vars.immediateRender && !e.vars.autoRevert || e._startAt.render(t, !0, s))
}, Ene = function i(e) {
    return !e || e._ts && i(e.parent)
}, NE = function(e) {
    return e._repeat ? _u(e._tTime, e = e.duration() + e._rDelay) * e : 0
}, _u = function(e, t) {
    var n = Math.floor(e /= t);
    return e && n === e ? n - 1 : n
}, Wp = function(e, t) {
    return (e - t._start) * t._ts + (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur)
}, Pm = function(e) {
    return e._end = vi(e._start + (e._tDur / Math.abs(e._ts || e._rts || Cn) || 0))
}, Dm = function(e, t) {
    var n = e._dp;
    return n && n.smoothChildTiming && e._ts && (e._start = vi(n._time - (e._ts > 0 ? t / e._ts : ((e._dirty ? e.totalDuration() : e._tDur) - t) / -e._ts)),
    Pm(e),
    n._dirty || wl(n, e)),
    e
}, z3 = function(e, t) {
    var n;
    if ((t._time || !t._dur && t._initted || t._start < e._time && (t._dur || !t.add)) && (n = Wp(e.rawTime(), t),
    (!t._dur || ff(0, t.totalDuration(), n) - t._tTime > Cn) && t.render(n, !0)),
    wl(e, t)._dp && e._initted && e._time >= e._dur && e._ts) {
        if (e._dur < e.duration())
            for (n = e; n._dp; )
                n.rawTime() >= 0 && n.totalTime(n._tTime),
                n = n._dp;
        e._zTime = -Cn
    }
}, Fr = function(e, t, n, s) {
    return t.parent && Ca(t),
    t._start = vi((Oo(n) ? n : n || e !== Nn ? Ds(e, n, t) : e._time) + t._delay),
    t._end = vi(t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)),
    H3(e, t, "_first", "_last", e._sort ? "_start" : 0),
    Uv(t) || (e._recent = t),
    s || z3(e, t),
    e._ts < 0 && Dm(e, e._tTime),
    e
}, G3 = function(e, t) {
    return (Cs.ScrollTrigger || Px("scrollTrigger", t)) && Cs.ScrollTrigger.create(t, e)
}, W3 = function(e, t, n, s, r) {
    if (Nx(e, t, r),
    !e._initted)
        return 1;
    if (!n && e._pt && !Oi && (e._dur && e.vars.lazy !== !1 || !e._dur && e.vars.lazy) && U3 !== _s.frame)
        return ya.push(e),
        e._lazy = [r, s],
        1
}, wne = function i(e) {
    var t = e.parent;
    return t && t._ts && t._initted && !t._lock && (t.rawTime() < 0 || i(t))
}, Uv = function(e) {
    var t = e.data;
    return t === "isFromStart" || t === "isStart"
}, Tne = function(e, t, n, s) {
    var r = e.ratio, o = t < 0 || !t && (!e._start && wne(e) && !(!e._initted && Uv(e)) || (e._ts < 0 || e._dp._ts < 0) && !Uv(e)) ? 0 : 1, a = e._rDelay, l = 0, c, u, d;
    if (a && e._repeat && (l = ff(0, e._tDur, t),
    u = _u(l, a),
    e._yoyo && u & 1 && (o = 1 - o),
    u !== _u(e._tTime, a) && (r = 1 - o,
    e.vars.repeatRefresh && e._initted && e.invalidate())),
    o !== r || Oi || s || e._zTime === Cn || !t && e._zTime) {
        if (!e._initted && W3(e, t, s, n, l))
            return;
        for (d = e._zTime,
        e._zTime = t || (n ? Cn : 0),
        n || (n = t && !d),
        e.ratio = o,
        e._from && (o = 1 - o),
        e._time = 0,
        e._tTime = l,
        c = e._pt; c; )
            c.r(o, c.d),
            c = c._next;
        t < 0 && Ov(e, t, n, !0),
        e._onUpdate && !n && Ss(e, "onUpdate"),
        l && e._repeat && !n && e.parent && Ss(e, "onRepeat"),
        (t >= e._tDur || t < 0) && e.ratio === o && (o && Ca(e, 1),
        !n && !Oi && (Ss(e, o ? "onComplete" : "onReverseComplete", !0),
        e._prom && e._prom()))
    } else
        e._zTime || (e._zTime = t)
}, Ane = function(e, t, n) {
    var s;
    if (n > t)
        for (s = e._first; s && s._start <= n; ) {
            if (s.data === "isPause" && s._start > t)
                return s;
            s = s._next
        }
    else
        for (s = e._last; s && s._start >= n; ) {
            if (s.data === "isPause" && s._start < t)
                return s;
            s = s._prev
        }
}, xu = function(e, t, n, s) {
    var r = e._repeat
      , o = vi(t) || 0
      , a = e._tTime / e._tDur;
    return a && !s && (e._time *= o / e._dur),
    e._dur = o,
    e._tDur = r ? r < 0 ? 1e10 : vi(o * (r + 1) + e._rDelay * r) : o,
    a > 0 && !s && Dm(e, e._tTime = e._tDur * a),
    e.parent && Pm(e),
    n || wl(e.parent, e),
    e
}, BE = function(e) {
    return e instanceof Wi ? wl(e) : xu(e, e._dur)
}, Cne = {
    _start: 0,
    endTime: Vd,
    totalDuration: Vd
}, Ds = function i(e, t, n) {
    var s = e.labels, r = e._recent || Cne, o = e.duration() >= Bs ? r.endTime(!1) : e._dur, a, l, c;
    return bi(t) && (isNaN(t) || t in s) ? (l = t.charAt(0),
    c = t.substr(-1) === "%",
    a = t.indexOf("="),
    l === "<" || l === ">" ? (a >= 0 && (t = t.replace(/=/, "")),
    (l === "<" ? r._start : r.endTime(r._repeat >= 0)) + (parseFloat(t.substr(1)) || 0) * (c ? (a < 0 ? r : n).totalDuration() / 100 : 1)) : a < 0 ? (t in s || (s[t] = o),
    s[t]) : (l = parseFloat(t.charAt(a - 1) + t.substr(a + 1)),
    c && n && (l = l / 100 * (Ui(n) ? n[0] : n).totalDuration()),
    a > 1 ? i(e, t.substr(0, a - 1), n) + l : o + l)) : t == null ? o : +t
}, md = function(e, t, n) {
    var s = Oo(t[1]), r = (s ? 2 : 1) + (e < 2 ? 0 : 1), o = t[r], a, l;
    if (s && (o.duration = t[1]),
    o.parent = n,
    e) {
        for (a = o,
        l = n; l && !("immediateRender"in a); )
            a = l.vars.defaults || {},
            l = ls(l.vars.inherit) && l.parent;
        o.immediateRender = ls(a.immediateRender),
        e < 2 ? o.runBackwards = 1 : o.startAt = t[r - 1]
    }
    return new Yn(t[0],o,t[r + 1])
}, Da = function(e, t) {
    return e || e === 0 ? t(e) : t
}, ff = function(e, t, n) {
    return n < e ? e : n > t ? t : n
}, Pi = function(e, t) {
    return !bi(e) || !(t = gne.exec(e)) ? "" : t[1]
}, Mne = function(e, t, n) {
    return Da(n, function(s) {
        return ff(e, t, s)
    })
}, Nv = [].slice, q3 = function(e, t) {
    return e && Yr(e) && "length"in e && (!t && !e.length || e.length - 1 in e && Yr(e[0])) && !e.nodeType && e !== Ir
}, Rne = function(e, t, n) {
    return n === void 0 && (n = []),
    e.forEach(function(s) {
        var r;
        return bi(s) && !t || q3(s, 1) ? (r = n).push.apply(r, Vs(s)) : n.push(s)
    }) || n
}, Vs = function(e, t, n) {
    return Dn && !t && Dn.selector ? Dn.selector(e) : bi(e) && !n && (Dv || !yu()) ? Nv.call((t || kx).querySelectorAll(e), 0) : Ui(e) ? Rne(e, n) : q3(e) ? Nv.call(e, 0) : e ? [e] : []
}, Bv = function(e) {
    return e = Vs(e)[0] || Bd("Invalid scope") || {},
    function(t) {
        var n = e.current || e.nativeElement || e;
        return Vs(t, n.querySelectorAll ? n : n === e ? Bd("Invalid scope") || kx.createElement("div") : e)
    }
}, j3 = function(e) {
    return e.sort(function() {
        return .5 - Math.random()
    })
}, K3 = function(e) {
    if (zn(e))
        return e;
    var t = Yr(e) ? e : {
        each: e
    }
      , n = Tl(t.ease)
      , s = t.from || 0
      , r = parseFloat(t.base) || 0
      , o = {}
      , a = s > 0 && s < 1
      , l = isNaN(s) || a
      , c = t.axis
      , u = s
      , d = s;
    return bi(s) ? u = d = {
        center: .5,
        edges: .5,
        end: 1
    }[s] || 0 : !a && l && (u = s[0],
    d = s[1]),
    function(f, h, p) {
        var g = (p || t).length, m = o[g], v, _, y, b, S, C, M, L, T;
        if (!m) {
            if (T = t.grid === "auto" ? 0 : (t.grid || [1, Bs])[1],
            !T) {
                for (M = -Bs; M < (M = p[T++].getBoundingClientRect().left) && T < g; )
                    ;
                T < g && T--
            }
            for (m = o[g] = [],
            v = l ? Math.min(T, g) * u - .5 : s % T,
            _ = T === Bs ? 0 : l ? g * d / T - .5 : s / T | 0,
            M = 0,
            L = Bs,
            C = 0; C < g; C++)
                y = C % T - v,
                b = _ - (C / T | 0),
                m[C] = S = c ? Math.abs(c === "y" ? b : y) : R3(y * y + b * b),
                S > M && (M = S),
                S < L && (L = S);
            s === "random" && j3(m),
            m.max = M - L,
            m.min = L,
            m.v = g = (parseFloat(t.amount) || parseFloat(t.each) * (T > g ? g - 1 : c ? c === "y" ? g / T : T : Math.max(T, g / T)) || 0) * (s === "edges" ? -1 : 1),
            m.b = g < 0 ? r - g : r,
            m.u = Pi(t.amount || t.each) || 0,
            n = n && g < 0 ? sR(n) : n
        }
        return g = (m[f] - m.min) / m.max || 0,
        vi(m.b + (n ? n(g) : g) * m.v) + m.u
    }
}, Vv = function(e) {
    var t = Math.pow(10, ((e + "").split(".")[1] || "").length);
    return function(n) {
        var s = vi(Math.round(parseFloat(n) / e) * e * t);
        return (s - s % 1) / t + (Oo(n) ? 0 : Pi(n))
    }
}, X3 = function(e, t) {
    var n = Ui(e), s, r;
    return !n && Yr(e) && (s = n = e.radius || Bs,
    e.values ? (e = Vs(e.values),
    (r = !Oo(e[0])) && (s *= s)) : e = Vv(e.increment)),
    Da(t, n ? zn(e) ? function(o) {
        return r = e(o),
        Math.abs(r - o) <= s ? r : o
    }
    : function(o) {
        for (var a = parseFloat(r ? o.x : o), l = parseFloat(r ? o.y : 0), c = Bs, u = 0, d = e.length, f, h; d--; )
            r ? (f = e[d].x - a,
            h = e[d].y - l,
            f = f * f + h * h) : f = Math.abs(e[d] - a),
            f < c && (c = f,
            u = d);
        return u = !s || c <= s ? e[u] : o,
        r || u === o || Oo(o) ? u : u + Pi(o)
    }
    : Vv(e))
}, Y3 = function(e, t, n, s) {
    return Da(Ui(e) ? !t : n === !0 ? !!(n = 0) : !s, function() {
        return Ui(e) ? e[~~(Math.random() * e.length)] : (n = n || 1e-5) && (s = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) && Math.floor(Math.round((e - n / 2 + Math.random() * (t - e + n * .99)) / n) * n * s) / s
    })
}, Lne = function() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
        t[n] = arguments[n];
    return function(s) {
        return t.reduce(function(r, o) {
            return o(r)
        }, s)
    }
}, Ine = function(e, t) {
    return function(n) {
        return e(parseFloat(n)) + (t || Pi(n))
    }
}, kne = function(e, t, n) {
    return J3(e, t, 0, 1, n)
}, Z3 = function(e, t, n) {
    return Da(n, function(s) {
        return e[~~t(s)]
    })
}, Pne = function i(e, t, n) {
    var s = t - e;
    return Ui(e) ? Z3(e, i(0, e.length), t) : Da(n, function(r) {
        return (s + (r - e) % s) % s + e
    })
}, Dne = function i(e, t, n) {
    var s = t - e
      , r = s * 2;
    return Ui(e) ? Z3(e, i(0, e.length - 1), t) : Da(n, function(o) {
        return o = (r + (o - e) % r) % r || 0,
        e + (o > s ? r - o : o)
    })
}, $d = function(e) {
    for (var t = 0, n = "", s, r, o, a; ~(s = e.indexOf("random(", t)); )
        o = e.indexOf(")", s),
        a = e.charAt(s + 7) === "[",
        r = e.substr(s + 7, o - s - 7).match(a ? P3 : Pv),
        n += e.substr(t, s - t) + Y3(a ? r : +r[0], a ? 0 : +r[1], +r[2] || 1e-5),
        t = o + 1;
    return n + e.substr(t, e.length - t)
}, J3 = function(e, t, n, s, r) {
    var o = t - e
      , a = s - n;
    return Da(r, function(l) {
        return n + ((l - e) / o * a || 0)
    })
}, Fne = function i(e, t, n, s) {
    var r = isNaN(e + t) ? 0 : function(h) {
        return (1 - h) * e + h * t
    }
    ;
    if (!r) {
        var o = bi(e), a = {}, l, c, u, d, f;
        if (n === !0 && (s = 1) && (n = null),
        o)
            e = {
                p: e
            },
            t = {
                p: t
            };
        else if (Ui(e) && !Ui(t)) {
            for (u = [],
            d = e.length,
            f = d - 2,
            c = 1; c < d; c++)
                u.push(i(e[c - 1], e[c]));
            d--,
            r = function(p) {
                p *= d;
                var g = Math.min(f, ~~p);
                return u[g](p - g)
            }
            ,
            n = t
        } else
            s || (e = Fl(Ui(e) ? [] : {}, e));
        if (!u) {
            for (l in t)
                Ux.call(a, e, l, "get", t[l]);
            r = function(p) {
                return $x(p, a) || (o ? e.p : e)
            }
        }
    }
    return Da(n, r)
}, VE = function(e, t, n) {
    var s = e.labels, r = Bs, o, a, l;
    for (o in s)
        a = s[o] - t,
        a < 0 == !!n && a && r > (a = Math.abs(a)) && (l = o,
        r = a);
    return l
}, Ss = function(e, t, n) {
    var s = e.vars, r = s[t], o = Dn, a = e._ctx, l, c, u;
    if (!!r)
        return l = s[t + "Params"],
        c = s.callbackScope || e,
        n && ya.length && zp(),
        a && (Dn = a),
        u = l ? r.apply(c, l) : r.call(c),
        Dn = o,
        u
}, Ju = function(e) {
    return Ca(e),
    e.scrollTrigger && e.scrollTrigger.kill(!!Oi),
    e.progress() < 1 && Ss(e, "onInterrupt"),
    e
}, Rc, Q3 = [], eR = function(e) {
    if (!!e)
        if (e = !e.name && e.default || e,
        Ix() || e.headless) {
            var t = e.name
              , n = zn(e)
              , s = t && !n && e.init ? function() {
                this._props = []
            }
            : e
              , r = {
                init: Vd,
                render: $x,
                add: Ux,
                kill: Zne,
                modifier: Yne,
                rawVars: 0
            }
              , o = {
                targetTest: 0,
                get: 0,
                getSetter: Vx,
                aliases: {},
                register: 0
            };
            if (yu(),
            e !== s) {
                if (gs[t])
                    return;
                js(s, js(Gp(e, r), o)),
                Fl(s.prototype, Fl(r, Gp(e, o))),
                gs[s.prop = t] = s,
                e.targetTest && (Hh.push(s),
                Dx[t] = 1),
                t = (t === "css" ? "CSS" : t.charAt(0).toUpperCase() + t.substr(1)) + "Plugin"
            }
            O3(t, s),
            e.register && e.register(fs, s, us)
        } else
            Q3.push(e)
}, xn = 255, Qu = {
    aqua: [0, xn, xn],
    lime: [0, xn, 0],
    silver: [192, 192, 192],
    black: [0, 0, 0],
    maroon: [128, 0, 0],
    teal: [0, 128, 128],
    blue: [0, 0, xn],
    navy: [0, 0, 128],
    white: [xn, xn, xn],
    olive: [128, 128, 0],
    yellow: [xn, xn, 0],
    orange: [xn, 165, 0],
    gray: [128, 128, 128],
    purple: [128, 0, 128],
    green: [0, 128, 0],
    red: [xn, 0, 0],
    pink: [xn, 192, 203],
    cyan: [0, xn, xn],
    transparent: [xn, xn, xn, 0]
}, xg = function(e, t, n) {
    return e += e < 0 ? 1 : e > 1 ? -1 : 0,
    (e * 6 < 1 ? t + (n - t) * e * 6 : e < .5 ? n : e * 3 < 2 ? t + (n - t) * (2 / 3 - e) * 6 : t) * xn + .5 | 0
}, tR = function(e, t, n) {
    var s = e ? Oo(e) ? [e >> 16, e >> 8 & xn, e & xn] : 0 : Qu.black, r, o, a, l, c, u, d, f, h, p;
    if (!s) {
        if (e.substr(-1) === "," && (e = e.substr(0, e.length - 1)),
        Qu[e])
            s = Qu[e];
        else if (e.charAt(0) === "#") {
            if (e.length < 6 && (r = e.charAt(1),
            o = e.charAt(2),
            a = e.charAt(3),
            e = "#" + r + r + o + o + a + a + (e.length === 5 ? e.charAt(4) + e.charAt(4) : "")),
            e.length === 9)
                return s = parseInt(e.substr(1, 6), 16),
                [s >> 16, s >> 8 & xn, s & xn, parseInt(e.substr(7), 16) / 255];
            e = parseInt(e.substr(1), 16),
            s = [e >> 16, e >> 8 & xn, e & xn]
        } else if (e.substr(0, 3) === "hsl") {
            if (s = p = e.match(Pv),
            !t)
                l = +s[0] % 360 / 360,
                c = +s[1] / 100,
                u = +s[2] / 100,
                o = u <= .5 ? u * (c + 1) : u + c - u * c,
                r = u * 2 - o,
                s.length > 3 && (s[3] *= 1),
                s[0] = xg(l + 1 / 3, r, o),
                s[1] = xg(l, r, o),
                s[2] = xg(l - 1 / 3, r, o);
            else if (~e.indexOf("="))
                return s = e.match(I3),
                n && s.length < 4 && (s[3] = 1),
                s
        } else
            s = e.match(Pv) || Qu.transparent;
        s = s.map(Number)
    }
    return t && !p && (r = s[0] / xn,
    o = s[1] / xn,
    a = s[2] / xn,
    d = Math.max(r, o, a),
    f = Math.min(r, o, a),
    u = (d + f) / 2,
    d === f ? l = c = 0 : (h = d - f,
    c = u > .5 ? h / (2 - d - f) : h / (d + f),
    l = d === r ? (o - a) / h + (o < a ? 6 : 0) : d === o ? (a - r) / h + 2 : (r - o) / h + 4,
    l *= 60),
    s[0] = ~~(l + .5),
    s[1] = ~~(c * 100 + .5),
    s[2] = ~~(u * 100 + .5)),
    n && s.length < 4 && (s[3] = 1),
    s
}, nR = function(e) {
    var t = []
      , n = []
      , s = -1;
    return e.split(ba).forEach(function(r) {
        var o = r.match(Mc) || [];
        t.push.apply(t, o),
        n.push(s += o.length + 1)
    }),
    t.c = n,
    t
}, $E = function(e, t, n) {
    var s = "", r = (e + s).match(ba), o = t ? "hsla(" : "rgba(", a = 0, l, c, u, d;
    if (!r)
        return e;
    if (r = r.map(function(f) {
        return (f = tR(f, t, 1)) && o + (t ? f[0] + "," + f[1] + "%," + f[2] + "%," + f[3] : f.join(",")) + ")"
    }),
    n && (u = nR(e),
    l = n.c,
    l.join(s) !== u.c.join(s)))
        for (c = e.replace(ba, "1").split(Mc),
        d = c.length - 1; a < d; a++)
            s += c[a] + (~l.indexOf(a) ? r.shift() || o + "0,0,0,0)" : (u.length ? u : r.length ? r : n).shift());
    if (!c)
        for (c = e.split(ba),
        d = c.length - 1; a < d; a++)
            s += c[a] + r[a];
    return s + c[d]
}, ba = function() {
    var i = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b", e;
    for (e in Qu)
        i += "|" + e + "\\b";
    return new RegExp(i + ")","gi")
}(), One = /hsl[a]?\(/, iR = function(e) {
    var t = e.join(" "), n;
    if (ba.lastIndex = 0,
    ba.test(t))
        return n = One.test(t),
        e[1] = $E(e[1], n),
        e[0] = $E(e[0], n, nR(e[1])),
        !0
}, Hd, _s = function() {
    var i = Date.now, e = 500, t = 33, n = i(), s = n, r = 1e3 / 240, o = r, a = [], l, c, u, d, f, h, p = function g(m) {
        var v = i() - s, _ = m === !0, y, b, S, C;
        if ((v > e || v < 0) && (n += v - t),
        s += v,
        S = s - n,
        y = S - o,
        (y > 0 || _) && (C = ++d.frame,
        f = S - d.time * 1e3,
        d.time = S = S / 1e3,
        o += y + (y >= r ? 4 : r - y),
        b = 1),
        _ || (l = c(g)),
        b)
            for (h = 0; h < a.length; h++)
                a[h](S, f, C, m)
    };
    return d = {
        time: 0,
        frame: 0,
        tick: function() {
            p(!0)
        },
        deltaRatio: function(m) {
            return f / (1e3 / (m || 60))
        },
        wake: function() {
            D3 && (!Dv && Ix() && (Ir = Dv = window,
            kx = Ir.document || {},
            Cs.gsap = fs,
            (Ir.gsapVersions || (Ir.gsapVersions = [])).push(fs.version),
            F3(Hp || Ir.GreenSockGlobals || !Ir.gsap && Ir || {}),
            Q3.forEach(eR)),
            u = typeof requestAnimationFrame < "u" && requestAnimationFrame,
            l && d.sleep(),
            c = u || function(m) {
                return setTimeout(m, o - d.time * 1e3 + 1 | 0)
            }
            ,
            Hd = 1,
            p(2))
        },
        sleep: function() {
            (u ? cancelAnimationFrame : clearTimeout)(l),
            Hd = 0,
            c = Vd
        },
        lagSmoothing: function(m, v) {
            e = m || 1 / 0,
            t = Math.min(v || 33, e)
        },
        fps: function(m) {
            r = 1e3 / (m || 240),
            o = d.time * 1e3 + r
        },
        add: function(m, v, _) {
            var y = v ? function(b, S, C, M) {
                m(b, S, C, M),
                d.remove(y)
            }
            : m;
            return d.remove(m),
            a[_ ? "unshift" : "push"](y),
            yu(),
            y
        },
        remove: function(m, v) {
            ~(v = a.indexOf(m)) && a.splice(v, 1) && h >= v && h--
        },
        _listeners: a
    },
    d
}(), yu = function() {
    return !Hd && _s.wake()
}, Qt = {}, Une = /^[\d.\-M][\d.\-,\s]/, Nne = /["']/g, Bne = function(e) {
    for (var t = {}, n = e.substr(1, e.length - 3).split(":"), s = n[0], r = 1, o = n.length, a, l, c; r < o; r++)
        l = n[r],
        a = r !== o - 1 ? l.lastIndexOf(",") : l.length,
        c = l.substr(0, a),
        t[s] = isNaN(c) ? c.replace(Nne, "").trim() : +c,
        s = l.substr(a + 1).trim();
    return t
}, Vne = function(e) {
    var t = e.indexOf("(") + 1
      , n = e.indexOf(")")
      , s = e.indexOf("(", t);
    return e.substring(t, ~s && s < n ? e.indexOf(")", n + 1) : n)
}, $ne = function(e) {
    var t = (e + "").split("(")
      , n = Qt[t[0]];
    return n && t.length > 1 && n.config ? n.config.apply(null, ~e.indexOf("{") ? [Bne(t[1])] : Vne(e).split(",").map(V3)) : Qt._CE && Une.test(e) ? Qt._CE("", e) : n
}, sR = function(e) {
    return function(t) {
        return 1 - e(1 - t)
    }
}, rR = function i(e, t) {
    for (var n = e._first, s; n; )
        n instanceof Wi ? i(n, t) : n.vars.yoyoEase && (!n._yoyo || !n._repeat) && n._yoyo !== t && (n.timeline ? i(n.timeline, t) : (s = n._ease,
        n._ease = n._yEase,
        n._yEase = s,
        n._yoyo = t)),
        n = n._next
}, Tl = function(e, t) {
    return e && (zn(e) ? e : Qt[e] || $ne(e)) || t
}, zl = function(e, t, n, s) {
    n === void 0 && (n = function(l) {
        return 1 - t(1 - l)
    }
    ),
    s === void 0 && (s = function(l) {
        return l < .5 ? t(l * 2) / 2 : 1 - t((1 - l) * 2) / 2
    }
    );
    var r = {
        easeIn: t,
        easeOut: n,
        easeInOut: s
    }, o;
    return cs(e, function(a) {
        Qt[a] = Cs[a] = r,
        Qt[o = a.toLowerCase()] = n;
        for (var l in r)
            Qt[o + (l === "easeIn" ? ".in" : l === "easeOut" ? ".out" : ".inOut")] = Qt[a + "." + l] = r[l]
    }),
    r
}, oR = function(e) {
    return function(t) {
        return t < .5 ? (1 - e(1 - t * 2)) / 2 : .5 + e((t - .5) * 2) / 2
    }
}, yg = function i(e, t, n) {
    var s = t >= 1 ? t : 1
      , r = (n || (e ? .3 : .45)) / (t < 1 ? t : 1)
      , o = r / kv * (Math.asin(1 / s) || 0)
      , a = function(u) {
        return u === 1 ? 1 : s * Math.pow(2, -10 * u) * mne((u - o) * r) + 1
    }
      , l = e === "out" ? a : e === "in" ? function(c) {
        return 1 - a(1 - c)
    }
    : oR(a);
    return r = kv / r,
    l.config = function(c, u) {
        return i(e, c, u)
    }
    ,
    l
}, bg = function i(e, t) {
    t === void 0 && (t = 1.70158);
    var n = function(o) {
        return o ? --o * o * ((t + 1) * o + t) + 1 : 0
    }
      , s = e === "out" ? n : e === "in" ? function(r) {
        return 1 - n(1 - r)
    }
    : oR(n);
    return s.config = function(r) {
        return i(e, r)
    }
    ,
    s
};
cs("Linear,Quad,Cubic,Quart,Quint,Strong", function(i, e) {
    var t = e < 5 ? e + 1 : e;
    zl(i + ",Power" + (t - 1), e ? function(n) {
        return Math.pow(n, t)
    }
    : function(n) {
        return n
    }
    , function(n) {
        return 1 - Math.pow(1 - n, t)
    }, function(n) {
        return n < .5 ? Math.pow(n * 2, t) / 2 : 1 - Math.pow((1 - n) * 2, t) / 2
    })
});
Qt.Linear.easeNone = Qt.none = Qt.Linear.easeIn;
zl("Elastic", yg("in"), yg("out"), yg());
(function(i, e) {
    var t = 1 / e
      , n = 2 * t
      , s = 2.5 * t
      , r = function(a) {
        return a < t ? i * a * a : a < n ? i * Math.pow(a - 1.5 / e, 2) + .75 : a < s ? i * (a -= 2.25 / e) * a + .9375 : i * Math.pow(a - 2.625 / e, 2) + .984375
    };
    zl("Bounce", function(o) {
        return 1 - r(1 - o)
    }, r)
}
)(7.5625, 2.75);
zl("Expo", function(i) {
    return i ? Math.pow(2, 10 * (i - 1)) : 0
});
zl("Circ", function(i) {
    return -(R3(1 - i * i) - 1)
});
zl("Sine", function(i) {
    return i === 1 ? 1 : -pne(i * fne) + 1
});
zl("Back", bg("in"), bg("out"), bg());
Qt.SteppedEase = Qt.steps = Cs.SteppedEase = {
    config: function(e, t) {
        e === void 0 && (e = 1);
        var n = 1 / e
          , s = e + (t ? 0 : 1)
          , r = t ? 1 : 0
          , o = 1 - Cn;
        return function(a) {
            return ((s * ff(0, o, a) | 0) + r) * n
        }
    }
};
vu.ease = Qt["quad.out"];
cs("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(i) {
    return Fx += i + "," + i + "Params,"
});
var aR = function(e, t) {
    this.id = hne++,
    e._gsap = this,
    this.target = e,
    this.harness = t,
    this.get = t ? t.get : N3,
    this.set = t ? t.getSetter : Vx
}
  , zd = function() {
    function i(t) {
        this.vars = t,
        this._delay = +t.delay || 0,
        (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) && (this._rDelay = t.repeatDelay || 0,
        this._yoyo = !!t.yoyo || !!t.yoyoEase),
        this._ts = 1,
        xu(this, +t.duration, 1, 1),
        this.data = t.data,
        Dn && (this._ctx = Dn,
        Dn.data.push(this)),
        Hd || _s.wake()
    }
    var e = i.prototype;
    return e.delay = function(n) {
        return n || n === 0 ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + n - this._delay),
        this._delay = n,
        this) : this._delay
    }
    ,
    e.duration = function(n) {
        return arguments.length ? this.totalDuration(this._repeat > 0 ? n + (n + this._rDelay) * this._repeat : n) : this.totalDuration() && this._dur
    }
    ,
    e.totalDuration = function(n) {
        return arguments.length ? (this._dirty = 0,
        xu(this, this._repeat < 0 ? n : (n - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
    }
    ,
    e.totalTime = function(n, s) {
        if (yu(),
        !arguments.length)
            return this._tTime;
        var r = this._dp;
        if (r && r.smoothChildTiming && this._ts) {
            for (Dm(this, n),
            !r._dp || r.parent || z3(r, this); r && r.parent; )
                r.parent._time !== r._start + (r._ts >= 0 ? r._tTime / r._ts : (r.totalDuration() - r._tTime) / -r._ts) && r.totalTime(r._tTime, !0),
                r = r.parent;
            !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && n < this._tDur || this._ts < 0 && n > 0 || !this._tDur && !n) && Fr(this._dp, this, this._start - this._delay)
        }
        return (this._tTime !== n || !this._dur && !s || this._initted && Math.abs(this._zTime) === Cn || !n && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = n),
        B3(this, n, s)),
        this
    }
    ,
    e.time = function(n, s) {
        return arguments.length ? this.totalTime(Math.min(this.totalDuration(), n + NE(this)) % (this._dur + this._rDelay) || (n ? this._dur : 0), s) : this._time
    }
    ,
    e.totalProgress = function(n, s) {
        return arguments.length ? this.totalTime(this.totalDuration() * n, s) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() > 0 ? 1 : 0
    }
    ,
    e.progress = function(n, s) {
        return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - n : n) + NE(this), s) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0
    }
    ,
    e.iteration = function(n, s) {
        var r = this.duration() + this._rDelay;
        return arguments.length ? this.totalTime(this._time + (n - 1) * r, s) : this._repeat ? _u(this._tTime, r) + 1 : 1
    }
    ,
    e.timeScale = function(n, s) {
        if (!arguments.length)
            return this._rts === -Cn ? 0 : this._rts;
        if (this._rts === n)
            return this;
        var r = this.parent && this._ts ? Wp(this.parent._time, this) : this._tTime;
        return this._rts = +n || 0,
        this._ts = this._ps || n === -Cn ? 0 : this._rts,
        this.totalTime(ff(-Math.abs(this._delay), this._tDur, r), s !== !1),
        Pm(this),
        Sne(this)
    }
    ,
    e.paused = function(n) {
        return arguments.length ? (this._ps !== n && (this._ps = n,
        n ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()),
        this._ts = this._act = 0) : (yu(),
        this._ts = this._rts,
        this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== Cn && (this._tTime -= Cn)))),
        this) : this._ps
    }
    ,
    e.startTime = function(n) {
        if (arguments.length) {
            this._start = n;
            var s = this.parent || this._dp;
            return s && (s._sort || !this.parent) && Fr(s, this, n - this._delay),
            this
        }
        return this._start
    }
    ,
    e.endTime = function(n) {
        return this._start + (ls(n) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1)
    }
    ,
    e.rawTime = function(n) {
        var s = this.parent || this._dp;
        return s ? n && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? Wp(s.rawTime(n), this) : this._tTime : this._tTime
    }
    ,
    e.revert = function(n) {
        n === void 0 && (n = _ne);
        var s = Oi;
        return Oi = n,
        (this._initted || this._startAt) && (this.timeline && this.timeline.revert(n),
        this.totalTime(-.01, n.suppressEvents)),
        this.data !== "nested" && n.kill !== !1 && this.kill(),
        Oi = s,
        this
    }
    ,
    e.globalTime = function(n) {
        for (var s = this, r = arguments.length ? n : s.rawTime(); s; )
            r = s._start + r / (Math.abs(s._ts) || 1),
            s = s._dp;
        return !this.parent && this._sat ? this._sat.globalTime(n) : r
    }
    ,
    e.repeat = function(n) {
        return arguments.length ? (this._repeat = n === 1 / 0 ? -2 : n,
        BE(this)) : this._repeat === -2 ? 1 / 0 : this._repeat
    }
    ,
    e.repeatDelay = function(n) {
        if (arguments.length) {
            var s = this._time;
            return this._rDelay = n,
            BE(this),
            s ? this.time(s) : this
        }
        return this._rDelay
    }
    ,
    e.yoyo = function(n) {
        return arguments.length ? (this._yoyo = n,
        this) : this._yoyo
    }
    ,
    e.seek = function(n, s) {
        return this.totalTime(Ds(this, n), ls(s))
    }
    ,
    e.restart = function(n, s) {
        return this.play().totalTime(n ? -this._delay : 0, ls(s))
    }
    ,
    e.play = function(n, s) {
        return n != null && this.seek(n, s),
        this.reversed(!1).paused(!1)
    }
    ,
    e.reverse = function(n, s) {
        return n != null && this.seek(n || this.totalDuration(), s),
        this.reversed(!0).paused(!1)
    }
    ,
    e.pause = function(n, s) {
        return n != null && this.seek(n, s),
        this.paused(!0)
    }
    ,
    e.resume = function() {
        return this.paused(!1)
    }
    ,
    e.reversed = function(n) {
        return arguments.length ? (!!n !== this.reversed() && this.timeScale(-this._rts || (n ? -Cn : 0)),
        this) : this._rts < 0
    }
    ,
    e.invalidate = function() {
        return this._initted = this._act = 0,
        this._zTime = -Cn,
        this
    }
    ,
    e.isActive = function() {
        var n = this.parent || this._dp, s = this._start, r;
        return !!(!n || this._ts && this._initted && n.isActive() && (r = n.rawTime(!0)) >= s && r < this.endTime(!0) - Cn)
    }
    ,
    e.eventCallback = function(n, s, r) {
        var o = this.vars;
        return arguments.length > 1 ? (s ? (o[n] = s,
        r && (o[n + "Params"] = r),
        n === "onUpdate" && (this._onUpdate = s)) : delete o[n],
        this) : o[n]
    }
    ,
    e.then = function(n) {
        var s = this;
        return new Promise(function(r) {
            var o = zn(n) ? n : $3
              , a = function() {
                var c = s.then;
                s.then = null,
                zn(o) && (o = o(s)) && (o.then || o === s) && (s.then = c),
                r(o),
                s.then = c
            };
            s._initted && s.totalProgress() === 1 && s._ts >= 0 || !s._tTime && s._ts < 0 ? a() : s._prom = a
        }
        )
    }
    ,
    e.kill = function() {
        Ju(this)
    }
    ,
    i
}();
js(zd.prototype, {
    _time: 0,
    _start: 0,
    _end: 0,
    _tTime: 0,
    _tDur: 0,
    _dirty: 0,
    _repeat: 0,
    _yoyo: !1,
    parent: null,
    _initted: !1,
    _rDelay: 0,
    _ts: 1,
    _dp: 0,
    ratio: 0,
    _zTime: -Cn,
    _prom: 0,
    _ps: !1,
    _rts: 1
});
var Wi = function(i) {
    M3(e, i);
    function e(n, s) {
        var r;
        return n === void 0 && (n = {}),
        r = i.call(this, n) || this,
        r.labels = {},
        r.smoothChildTiming = !!n.smoothChildTiming,
        r.autoRemoveChildren = !!n.autoRemoveChildren,
        r._sort = ls(n.sortChildren),
        Nn && Fr(n.parent || Nn, yo(r), s),
        n.reversed && r.reverse(),
        n.paused && r.paused(!0),
        n.scrollTrigger && G3(yo(r), n.scrollTrigger),
        r
    }
    var t = e.prototype;
    return t.to = function(s, r, o) {
        return md(0, arguments, this),
        this
    }
    ,
    t.from = function(s, r, o) {
        return md(1, arguments, this),
        this
    }
    ,
    t.fromTo = function(s, r, o, a) {
        return md(2, arguments, this),
        this
    }
    ,
    t.set = function(s, r, o) {
        return r.duration = 0,
        r.parent = this,
        pd(r).repeatDelay || (r.repeat = 0),
        r.immediateRender = !!r.immediateRender,
        new Yn(s,r,Ds(this, o),1),
        this
    }
    ,
    t.call = function(s, r, o) {
        return Fr(this, Yn.delayedCall(0, s, r), o)
    }
    ,
    t.staggerTo = function(s, r, o, a, l, c, u) {
        return o.duration = r,
        o.stagger = o.stagger || a,
        o.onComplete = c,
        o.onCompleteParams = u,
        o.parent = this,
        new Yn(s,o,Ds(this, l)),
        this
    }
    ,
    t.staggerFrom = function(s, r, o, a, l, c, u) {
        return o.runBackwards = 1,
        pd(o).immediateRender = ls(o.immediateRender),
        this.staggerTo(s, r, o, a, l, c, u)
    }
    ,
    t.staggerFromTo = function(s, r, o, a, l, c, u, d) {
        return a.startAt = o,
        pd(a).immediateRender = ls(a.immediateRender),
        this.staggerTo(s, r, a, l, c, u, d)
    }
    ,
    t.render = function(s, r, o) {
        var a = this._time, l = this._dirty ? this.totalDuration() : this._tDur, c = this._dur, u = s <= 0 ? 0 : vi(s), d = this._zTime < 0 != s < 0 && (this._initted || !c), f, h, p, g, m, v, _, y, b, S, C, M;
        if (this !== Nn && u > l && s >= 0 && (u = l),
        u !== this._tTime || o || d) {
            if (a !== this._time && c && (u += this._time - a,
            s += this._time - a),
            f = u,
            b = this._start,
            y = this._ts,
            v = !y,
            d && (c || (a = this._zTime),
            (s || !r) && (this._zTime = s)),
            this._repeat) {
                if (C = this._yoyo,
                m = c + this._rDelay,
                this._repeat < -1 && s < 0)
                    return this.totalTime(m * 100 + s, r, o);
                if (f = vi(u % m),
                u === l ? (g = this._repeat,
                f = c) : (g = ~~(u / m),
                g && g === u / m && (f = c,
                g--),
                f > c && (f = c)),
                S = _u(this._tTime, m),
                !a && this._tTime && S !== g && this._tTime - S * m - this._dur <= 0 && (S = g),
                C && g & 1 && (f = c - f,
                M = 1),
                g !== S && !this._lock) {
                    var L = C && S & 1
                      , T = L === (C && g & 1);
                    if (g < S && (L = !L),
                    a = L ? 0 : u % c ? c : u,
                    this._lock = 1,
                    this.render(a || (M ? 0 : vi(g * m)), r, !c)._lock = 0,
                    this._tTime = u,
                    !r && this.parent && Ss(this, "onRepeat"),
                    this.vars.repeatRefresh && !M && (this.invalidate()._lock = 1),
                    a && a !== this._time || v !== !this._ts || this.vars.onRepeat && !this.parent && !this._act)
                        return this;
                    if (c = this._dur,
                    l = this._tDur,
                    T && (this._lock = 2,
                    a = L ? c : -1e-4,
                    this.render(a, !0),
                    this.vars.repeatRefresh && !M && this.invalidate()),
                    this._lock = 0,
                    !this._ts && !v)
                        return this;
                    rR(this, M)
                }
            }
            if (this._hasPause && !this._forcing && this._lock < 2 && (_ = Ane(this, vi(a), vi(f)),
            _ && (u -= f - (f = _._start))),
            this._tTime = u,
            this._time = f,
            this._act = !y,
            this._initted || (this._onUpdate = this.vars.onUpdate,
            this._initted = 1,
            this._zTime = s,
            a = 0),
            !a && f && !r && !g && (Ss(this, "onStart"),
            this._tTime !== u))
                return this;
            if (f >= a && s >= 0)
                for (h = this._first; h; ) {
                    if (p = h._next,
                    (h._act || f >= h._start) && h._ts && _ !== h) {
                        if (h.parent !== this)
                            return this.render(s, r, o);
                        if (h.render(h._ts > 0 ? (f - h._start) * h._ts : (h._dirty ? h.totalDuration() : h._tDur) + (f - h._start) * h._ts, r, o),
                        f !== this._time || !this._ts && !v) {
                            _ = 0,
                            p && (u += this._zTime = -Cn);
                            break
                        }
                    }
                    h = p
                }
            else {
                h = this._last;
                for (var A = s < 0 ? s : f; h; ) {
                    if (p = h._prev,
                    (h._act || A <= h._end) && h._ts && _ !== h) {
                        if (h.parent !== this)
                            return this.render(s, r, o);
                        if (h.render(h._ts > 0 ? (A - h._start) * h._ts : (h._dirty ? h.totalDuration() : h._tDur) + (A - h._start) * h._ts, r, o || Oi && (h._initted || h._startAt)),
                        f !== this._time || !this._ts && !v) {
                            _ = 0,
                            p && (u += this._zTime = A ? -Cn : Cn);
                            break
                        }
                    }
                    h = p
                }
            }
            if (_ && !r && (this.pause(),
            _.render(f >= a ? 0 : -Cn)._zTime = f >= a ? 1 : -1,
            this._ts))
                return this._start = b,
                Pm(this),
                this.render(s, r, o);
            this._onUpdate && !r && Ss(this, "onUpdate", !0),
            (u === l && this._tTime >= this.totalDuration() || !u && a) && (b === this._start || Math.abs(y) !== Math.abs(this._ts)) && (this._lock || ((s || !c) && (u === l && this._ts > 0 || !u && this._ts < 0) && Ca(this, 1),
            !r && !(s < 0 && !a) && (u || a || !l) && (Ss(this, u === l && s >= 0 ? "onComplete" : "onReverseComplete", !0),
            this._prom && !(u < l && this.timeScale() > 0) && this._prom())))
        }
        return this
    }
    ,
    t.add = function(s, r) {
        var o = this;
        if (Oo(r) || (r = Ds(this, r, s)),
        !(s instanceof zd)) {
            if (Ui(s))
                return s.forEach(function(a) {
                    return o.add(a, r)
                }),
                this;
            if (bi(s))
                return this.addLabel(s, r);
            if (zn(s))
                s = Yn.delayedCall(0, s);
            else
                return this
        }
        return this !== s ? Fr(this, s, r) : this
    }
    ,
    t.getChildren = function(s, r, o, a) {
        s === void 0 && (s = !0),
        r === void 0 && (r = !0),
        o === void 0 && (o = !0),
        a === void 0 && (a = -Bs);
        for (var l = [], c = this._first; c; )
            c._start >= a && (c instanceof Yn ? r && l.push(c) : (o && l.push(c),
            s && l.push.apply(l, c.getChildren(!0, r, o)))),
            c = c._next;
        return l
    }
    ,
    t.getById = function(s) {
        for (var r = this.getChildren(1, 1, 1), o = r.length; o--; )
            if (r[o].vars.id === s)
                return r[o]
    }
    ,
    t.remove = function(s) {
        return bi(s) ? this.removeLabel(s) : zn(s) ? this.killTweensOf(s) : (km(this, s),
        s === this._recent && (this._recent = this._last),
        wl(this))
    }
    ,
    t.totalTime = function(s, r) {
        return arguments.length ? (this._forcing = 1,
        !this._dp && this._ts && (this._start = vi(_s.time - (this._ts > 0 ? s / this._ts : (this.totalDuration() - s) / -this._ts))),
        i.prototype.totalTime.call(this, s, r),
        this._forcing = 0,
        this) : this._tTime
    }
    ,
    t.addLabel = function(s, r) {
        return this.labels[s] = Ds(this, r),
        this
    }
    ,
    t.removeLabel = function(s) {
        return delete this.labels[s],
        this
    }
    ,
    t.addPause = function(s, r, o) {
        var a = Yn.delayedCall(0, r || Vd, o);
        return a.data = "isPause",
        this._hasPause = 1,
        Fr(this, a, Ds(this, s))
    }
    ,
    t.removePause = function(s) {
        var r = this._first;
        for (s = Ds(this, s); r; )
            r._start === s && r.data === "isPause" && Ca(r),
            r = r._next
    }
    ,
    t.killTweensOf = function(s, r, o) {
        for (var a = this.getTweensOf(s, o), l = a.length; l--; )
            ua !== a[l] && a[l].kill(s, r);
        return this
    }
    ,
    t.getTweensOf = function(s, r) {
        for (var o = [], a = Vs(s), l = this._first, c = Oo(r), u; l; )
            l instanceof Yn ? xne(l._targets, a) && (c ? (!ua || l._initted && l._ts) && l.globalTime(0) <= r && l.globalTime(l.totalDuration()) > r : !r || l.isActive()) && o.push(l) : (u = l.getTweensOf(a, r)).length && o.push.apply(o, u),
            l = l._next;
        return o
    }
    ,
    t.tweenTo = function(s, r) {
        r = r || {};
        var o = this, a = Ds(o, s), l = r, c = l.startAt, u = l.onStart, d = l.onStartParams, f = l.immediateRender, h, p = Yn.to(o, js({
            ease: r.ease || "none",
            lazy: !1,
            immediateRender: !1,
            time: a,
            overwrite: "auto",
            duration: r.duration || Math.abs((a - (c && "time"in c ? c.time : o._time)) / o.timeScale()) || Cn,
            onStart: function() {
                if (o.pause(),
                !h) {
                    var m = r.duration || Math.abs((a - (c && "time"in c ? c.time : o._time)) / o.timeScale());
                    p._dur !== m && xu(p, m, 0, 1).render(p._time, !0, !0),
                    h = 1
                }
                u && u.apply(p, d || [])
            }
        }, r));
        return f ? p.render(0) : p
    }
    ,
    t.tweenFromTo = function(s, r, o) {
        return this.tweenTo(r, js({
            startAt: {
                time: Ds(this, s)
            }
        }, o))
    }
    ,
    t.recent = function() {
        return this._recent
    }
    ,
    t.nextLabel = function(s) {
        return s === void 0 && (s = this._time),
        VE(this, Ds(this, s))
    }
    ,
    t.previousLabel = function(s) {
        return s === void 0 && (s = this._time),
        VE(this, Ds(this, s), 1)
    }
    ,
    t.currentLabel = function(s) {
        return arguments.length ? this.seek(s, !0) : this.previousLabel(this._time + Cn)
    }
    ,
    t.shiftChildren = function(s, r, o) {
        o === void 0 && (o = 0);
        for (var a = this._first, l = this.labels, c; a; )
            a._start >= o && (a._start += s,
            a._end += s),
            a = a._next;
        if (r)
            for (c in l)
                l[c] >= o && (l[c] += s);
        return wl(this)
    }
    ,
    t.invalidate = function(s) {
        var r = this._first;
        for (this._lock = 0; r; )
            r.invalidate(s),
            r = r._next;
        return i.prototype.invalidate.call(this, s)
    }
    ,
    t.clear = function(s) {
        s === void 0 && (s = !0);
        for (var r = this._first, o; r; )
            o = r._next,
            this.remove(r),
            r = o;
        return this._dp && (this._time = this._tTime = this._pTime = 0),
        s && (this.labels = {}),
        wl(this)
    }
    ,
    t.totalDuration = function(s) {
        var r = 0, o = this, a = o._last, l = Bs, c, u, d;
        if (arguments.length)
            return o.timeScale((o._repeat < 0 ? o.duration() : o.totalDuration()) / (o.reversed() ? -s : s));
        if (o._dirty) {
            for (d = o.parent; a; )
                c = a._prev,
                a._dirty && a.totalDuration(),
                u = a._start,
                u > l && o._sort && a._ts && !o._lock ? (o._lock = 1,
                Fr(o, a, u - a._delay, 1)._lock = 0) : l = u,
                u < 0 && a._ts && (r -= u,
                (!d && !o._dp || d && d.smoothChildTiming) && (o._start += u / o._ts,
                o._time -= u,
                o._tTime -= u),
                o.shiftChildren(-u, !1, -1 / 0),
                l = 0),
                a._end > r && a._ts && (r = a._end),
                a = c;
            xu(o, o === Nn && o._time > r ? o._time : r, 1, 1),
            o._dirty = 0
        }
        return o._tDur
    }
    ,
    e.updateRoot = function(s) {
        if (Nn._ts && (B3(Nn, Wp(s, Nn)),
        U3 = _s.frame),
        _s.frame >= OE) {
            OE += Ts.autoSleep || 120;
            var r = Nn._first;
            if ((!r || !r._ts) && Ts.autoSleep && _s._listeners.length < 2) {
                for (; r && !r._ts; )
                    r = r._next;
                r || _s.sleep()
            }
        }
    }
    ,
    e
}(zd);
js(Wi.prototype, {
    _lock: 0,
    _hasPause: 0,
    _forcing: 0
});
var Hne = function(e, t, n, s, r, o, a) {
    var l = new us(this._pt,e,t,0,1,hR,null,r), c = 0, u = 0, d, f, h, p, g, m, v, _;
    for (l.b = n,
    l.e = s,
    n += "",
    s += "",
    (v = ~s.indexOf("random(")) && (s = $d(s)),
    o && (_ = [n, s],
    o(_, e, t),
    n = _[0],
    s = _[1]),
    f = n.match(vg) || []; d = vg.exec(s); )
        p = d[0],
        g = s.substring(c, d.index),
        h ? h = (h + 1) % 5 : g.substr(-5) === "rgba(" && (h = 1),
        p !== f[u++] && (m = parseFloat(f[u - 1]) || 0,
        l._pt = {
            _next: l._pt,
            p: g || u === 1 ? g : ",",
            s: m,
            c: p.charAt(1) === "=" ? jc(m, p) - m : parseFloat(p) - m,
            m: h && h < 4 ? Math.round : 0
        },
        c = vg.lastIndex);
    return l.c = c < s.length ? s.substring(c, s.length) : "",
    l.fp = a,
    (k3.test(s) || v) && (l.e = 0),
    this._pt = l,
    l
}, Ux = function(e, t, n, s, r, o, a, l, c, u) {
    zn(s) && (s = s(r || 0, e, o));
    var d = e[t], f = n !== "get" ? n : zn(d) ? c ? e[t.indexOf("set") || !zn(e["get" + t.substr(3)]) ? t : "get" + t.substr(3)](c) : e[t]() : d, h = zn(d) ? c ? jne : dR : Bx, p;
    if (bi(s) && (~s.indexOf("random(") && (s = $d(s)),
    s.charAt(1) === "=" && (p = jc(f, s) + (Pi(f) || 0),
    (p || p === 0) && (s = p))),
    !u || f !== s || $v)
        return !isNaN(f * s) && s !== "" ? (p = new us(this._pt,e,t,+f || 0,s - (f || 0),typeof d == "boolean" ? Xne : fR,0,h),
        c && (p.fp = c),
        a && p.modifier(a, this, e),
        this._pt = p) : (!d && !(t in e) && Px(t, s),
        Hne.call(this, e, t, f, s, h, l || Ts.stringFilter, c))
}, zne = function(e, t, n, s, r) {
    if (zn(e) && (e = gd(e, r, t, n, s)),
    !Yr(e) || e.style && e.nodeType || Ui(e) || L3(e))
        return bi(e) ? gd(e, r, t, n, s) : e;
    var o = {}, a;
    for (a in e)
        o[a] = gd(e[a], r, t, n, s);
    return o
}, lR = function(e, t, n, s, r, o) {
    var a, l, c, u;
    if (gs[e] && (a = new gs[e]).init(r, a.rawVars ? t[e] : zne(t[e], s, r, o, n), n, s, o) !== !1 && (n._pt = l = new us(n._pt,r,e,0,1,a.render,a,0,a.priority),
    n !== Rc))
        for (c = n._ptLookup[n._targets.indexOf(r)],
        u = a._props.length; u--; )
            c[a._props[u]] = l;
    return a
}, ua, $v, Nx = function i(e, t, n) {
    var s = e.vars, r = s.ease, o = s.startAt, a = s.immediateRender, l = s.lazy, c = s.onUpdate, u = s.runBackwards, d = s.yoyoEase, f = s.keyframes, h = s.autoRevert, p = e._dur, g = e._startAt, m = e._targets, v = e.parent, _ = v && v.data === "nested" ? v.vars.targets : m, y = e._overwrite === "auto" && !Rx, b = e.timeline, S, C, M, L, T, A, k, D, F, z, G, H, X;
    if (b && (!f || !r) && (r = "none"),
    e._ease = Tl(r, vu.ease),
    e._yEase = d ? sR(Tl(d === !0 ? r : d, vu.ease)) : 0,
    d && e._yoyo && !e._repeat && (d = e._yEase,
    e._yEase = e._ease,
    e._ease = d),
    e._from = !b && !!s.runBackwards,
    !b || f && !s.stagger) {
        if (D = m[0] ? El(m[0]).harness : 0,
        H = D && s[D.prop],
        S = Gp(s, Dx),
        g && (g._zTime < 0 && g.progress(1),
        t < 0 && u && a && !h ? g.render(-1, !0) : g.revert(u && p ? $h : vne),
        g._lazy = 0),
        o) {
            if (Ca(e._startAt = Yn.set(m, js({
                data: "isStart",
                overwrite: !1,
                parent: v,
                immediateRender: !0,
                lazy: !g && ls(l),
                startAt: null,
                delay: 0,
                onUpdate: c && function() {
                    return Ss(e, "onUpdate")
                }
                ,
                stagger: 0
            }, o))),
            e._startAt._dp = 0,
            e._startAt._sat = e,
            t < 0 && (Oi || !a && !h) && e._startAt.revert($h),
            a && p && t <= 0 && n <= 0) {
                t && (e._zTime = t);
                return
            }
        } else if (u && p && !g) {
            if (t && (a = !1),
            M = js({
                overwrite: !1,
                data: "isFromStart",
                lazy: a && !g && ls(l),
                immediateRender: a,
                stagger: 0,
                parent: v
            }, S),
            H && (M[D.prop] = H),
            Ca(e._startAt = Yn.set(m, M)),
            e._startAt._dp = 0,
            e._startAt._sat = e,
            t < 0 && (Oi ? e._startAt.revert($h) : e._startAt.render(-1, !0)),
            e._zTime = t,
            !a)
                i(e._startAt, Cn, Cn);
            else if (!t)
                return
        }
        for (e._pt = e._ptCache = 0,
        l = p && ls(l) || l && !p,
        C = 0; C < m.length; C++) {
            if (T = m[C],
            k = T._gsap || Ox(m)[C]._gsap,
            e._ptLookup[C] = z = {},
            Fv[k.id] && ya.length && zp(),
            G = _ === m ? C : _.indexOf(T),
            D && (F = new D).init(T, H || S, e, G, _) !== !1 && (e._pt = L = new us(e._pt,T,F.name,0,1,F.render,F,0,F.priority),
            F._props.forEach(function(K) {
                z[K] = L
            }),
            F.priority && (A = 1)),
            !D || H)
                for (M in S)
                    gs[M] && (F = lR(M, S, e, G, T, _)) ? F.priority && (A = 1) : z[M] = L = Ux.call(e, T, M, "get", S[M], G, _, 0, s.stringFilter);
            e._op && e._op[C] && e.kill(T, e._op[C]),
            y && e._pt && (ua = e,
            Nn.killTweensOf(T, z, e.globalTime(t)),
            X = !e.parent,
            ua = 0),
            e._pt && l && (Fv[k.id] = 1)
        }
        A && pR(e),
        e._onInit && e._onInit(e)
    }
    e._onUpdate = c,
    e._initted = (!e._op || e._pt) && !X,
    f && t <= 0 && b.render(Bs, !0, !0)
}, Gne = function(e, t, n, s, r, o, a, l) {
    var c = (e._pt && e._ptCache || (e._ptCache = {}))[t], u, d, f, h;
    if (!c)
        for (c = e._ptCache[t] = [],
        f = e._ptLookup,
        h = e._targets.length; h--; ) {
            if (u = f[h][t],
            u && u.d && u.d._pt)
                for (u = u.d._pt; u && u.p !== t && u.fp !== t; )
                    u = u._next;
            if (!u)
                return $v = 1,
                e.vars[t] = "+=0",
                Nx(e, a),
                $v = 0,
                l ? Bd(t + " not eligible for reset") : 1;
            c.push(u)
        }
    for (h = c.length; h--; )
        d = c[h],
        u = d._pt || d,
        u.s = (s || s === 0) && !r ? s : u.s + (s || 0) + o * u.c,
        u.c = n - u.s,
        d.e && (d.e = Gn(n) + Pi(d.e)),
        d.b && (d.b = u.s + Pi(d.b))
}, Wne = function(e, t) {
    var n = e[0] ? El(e[0]).harness : 0, s = n && n.aliases, r, o, a, l;
    if (!s)
        return t;
    r = Fl({}, t);
    for (o in s)
        if (o in r)
            for (l = s[o].split(","),
            a = l.length; a--; )
                r[l[a]] = r[o];
    return r
}, qne = function(e, t, n, s) {
    var r = t.ease || s || "power1.inOut", o, a;
    if (Ui(t))
        a = n[e] || (n[e] = []),
        t.forEach(function(l, c) {
            return a.push({
                t: c / (t.length - 1) * 100,
                v: l,
                e: r
            })
        });
    else
        for (o in t)
            a = n[o] || (n[o] = []),
            o === "ease" || a.push({
                t: parseFloat(e),
                v: t[o],
                e: r
            })
}, gd = function(e, t, n, s, r) {
    return zn(e) ? e.call(t, n, s, r) : bi(e) && ~e.indexOf("random(") ? $d(e) : e
}, cR = Fx + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert", uR = {};
cs(cR + ",id,stagger,delay,duration,paused,scrollTrigger", function(i) {
    return uR[i] = 1
});
var Yn = function(i) {
    M3(e, i);
    function e(n, s, r, o) {
        var a;
        typeof s == "number" && (r.duration = s,
        s = r,
        r = null),
        a = i.call(this, o ? s : pd(s)) || this;
        var l = a.vars, c = l.duration, u = l.delay, d = l.immediateRender, f = l.stagger, h = l.overwrite, p = l.keyframes, g = l.defaults, m = l.scrollTrigger, v = l.yoyoEase, _ = s.parent || Nn, y = (Ui(n) || L3(n) ? Oo(n[0]) : "length"in s) ? [n] : Vs(n), b, S, C, M, L, T, A, k;
        if (a._targets = y.length ? Ox(y) : Bd("GSAP target " + n + " not found. https://gsap.com", !Ts.nullTargetWarn) || [],
        a._ptLookup = [],
        a._overwrite = h,
        p || f || hh(c) || hh(u)) {
            if (s = a.vars,
            b = a.timeline = new Wi({
                data: "nested",
                defaults: g || {},
                targets: _ && _.data === "nested" ? _.vars.targets : y
            }),
            b.kill(),
            b.parent = b._dp = yo(a),
            b._start = 0,
            f || hh(c) || hh(u)) {
                if (M = y.length,
                A = f && K3(f),
                Yr(f))
                    for (L in f)
                        ~cR.indexOf(L) && (k || (k = {}),
                        k[L] = f[L]);
                for (S = 0; S < M; S++)
                    C = Gp(s, uR),
                    C.stagger = 0,
                    v && (C.yoyoEase = v),
                    k && Fl(C, k),
                    T = y[S],
                    C.duration = +gd(c, yo(a), S, T, y),
                    C.delay = (+gd(u, yo(a), S, T, y) || 0) - a._delay,
                    !f && M === 1 && C.delay && (a._delay = u = C.delay,
                    a._start += u,
                    C.delay = 0),
                    b.to(T, C, A ? A(S, T, y) : 0),
                    b._ease = Qt.none;
                b.duration() ? c = u = 0 : a.timeline = 0
            } else if (p) {
                pd(js(b.vars.defaults, {
                    ease: "none"
                })),
                b._ease = Tl(p.ease || s.ease || "none");
                var D = 0, F, z, G;
                if (Ui(p))
                    p.forEach(function(H) {
                        return b.to(y, H, ">")
                    }),
                    b.duration();
                else {
                    C = {};
                    for (L in p)
                        L === "ease" || L === "easeEach" || qne(L, p[L], C, p.easeEach);
                    for (L in C)
                        for (F = C[L].sort(function(H, X) {
                            return H.t - X.t
                        }),
                        D = 0,
                        S = 0; S < F.length; S++)
                            z = F[S],
                            G = {
                                ease: z.e,
                                duration: (z.t - (S ? F[S - 1].t : 0)) / 100 * c
                            },
                            G[L] = z.v,
                            b.to(y, G, D),
                            D += G.duration;
                    b.duration() < c && b.to({}, {
                        duration: c - b.duration()
                    })
                }
            }
            c || a.duration(c = b.duration())
        } else
            a.timeline = 0;
        return h === !0 && !Rx && (ua = yo(a),
        Nn.killTweensOf(y),
        ua = 0),
        Fr(_, yo(a), r),
        s.reversed && a.reverse(),
        s.paused && a.paused(!0),
        (d || !c && !p && a._start === vi(_._time) && ls(d) && Ene(yo(a)) && _.data !== "nested") && (a._tTime = -Cn,
        a.render(Math.max(0, -u) || 0)),
        m && G3(yo(a), m),
        a
    }
    var t = e.prototype;
    return t.render = function(s, r, o) {
        var a = this._time, l = this._tDur, c = this._dur, u = s < 0, d = s > l - Cn && !u ? l : s < Cn ? 0 : s, f, h, p, g, m, v, _, y, b;
        if (!c)
            Tne(this, s, r, o);
        else if (d !== this._tTime || !s || o || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== u) {
            if (f = d,
            y = this.timeline,
            this._repeat) {
                if (g = c + this._rDelay,
                this._repeat < -1 && u)
                    return this.totalTime(g * 100 + s, r, o);
                if (f = vi(d % g),
                d === l ? (p = this._repeat,
                f = c) : (p = ~~(d / g),
                p && p === vi(d / g) && (f = c,
                p--),
                f > c && (f = c)),
                v = this._yoyo && p & 1,
                v && (b = this._yEase,
                f = c - f),
                m = _u(this._tTime, g),
                f === a && !o && this._initted && p === m)
                    return this._tTime = d,
                    this;
                p !== m && (y && this._yEase && rR(y, v),
                this.vars.repeatRefresh && !v && !this._lock && this._time !== g && this._initted && (this._lock = o = 1,
                this.render(vi(g * p), !0).invalidate()._lock = 0))
            }
            if (!this._initted) {
                if (W3(this, u ? s : f, o, r, d))
                    return this._tTime = 0,
                    this;
                if (a !== this._time && !(o && this.vars.repeatRefresh && p !== m))
                    return this;
                if (c !== this._dur)
                    return this.render(s, r, o)
            }
            if (this._tTime = d,
            this._time = f,
            !this._act && this._ts && (this._act = 1,
            this._lazy = 0),
            this.ratio = _ = (b || this._ease)(f / c),
            this._from && (this.ratio = _ = 1 - _),
            f && !a && !r && !p && (Ss(this, "onStart"),
            this._tTime !== d))
                return this;
            for (h = this._pt; h; )
                h.r(_, h.d),
                h = h._next;
            y && y.render(s < 0 ? s : y._dur * y._ease(f / this._dur), r, o) || this._startAt && (this._zTime = s),
            this._onUpdate && !r && (u && Ov(this, s, r, o),
            Ss(this, "onUpdate")),
            this._repeat && p !== m && this.vars.onRepeat && !r && this.parent && Ss(this, "onRepeat"),
            (d === this._tDur || !d) && this._tTime === d && (u && !this._onUpdate && Ov(this, s, !0, !0),
            (s || !c) && (d === this._tDur && this._ts > 0 || !d && this._ts < 0) && Ca(this, 1),
            !r && !(u && !a) && (d || a || v) && (Ss(this, d === l ? "onComplete" : "onReverseComplete", !0),
            this._prom && !(d < l && this.timeScale() > 0) && this._prom()))
        }
        return this
    }
    ,
    t.targets = function() {
        return this._targets
    }
    ,
    t.invalidate = function(s) {
        return (!s || !this.vars.runBackwards) && (this._startAt = 0),
        this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0,
        this._ptLookup = [],
        this.timeline && this.timeline.invalidate(s),
        i.prototype.invalidate.call(this, s)
    }
    ,
    t.resetTo = function(s, r, o, a, l) {
        Hd || _s.wake(),
        this._ts || this.play();
        var c = Math.min(this._dur, (this._dp._time - this._start) * this._ts), u;
        return this._initted || Nx(this, c),
        u = this._ease(c / this._dur),
        Gne(this, s, r, o, a, u, c, l) ? this.resetTo(s, r, o, a, 1) : (Dm(this, 0),
        this.parent || H3(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0),
        this.render(0))
    }
    ,
    t.kill = function(s, r) {
        if (r === void 0 && (r = "all"),
        !s && (!r || r === "all"))
            return this._lazy = this._pt = 0,
            this.parent ? Ju(this) : this;
        if (this.timeline) {
            var o = this.timeline.totalDuration();
            return this.timeline.killTweensOf(s, r, ua && ua.vars.overwrite !== !0)._first || Ju(this),
            this.parent && o !== this.timeline.totalDuration() && xu(this, this._dur * this.timeline._tDur / o, 0, 1),
            this
        }
        var a = this._targets, l = s ? Vs(s) : a, c = this._ptLookup, u = this._pt, d, f, h, p, g, m, v;
        if ((!r || r === "all") && bne(a, l))
            return r === "all" && (this._pt = 0),
            Ju(this);
        for (d = this._op = this._op || [],
        r !== "all" && (bi(r) && (g = {},
        cs(r, function(_) {
            return g[_] = 1
        }),
        r = g),
        r = Wne(a, r)),
        v = a.length; v--; )
            if (~l.indexOf(a[v])) {
                f = c[v],
                r === "all" ? (d[v] = r,
                p = f,
                h = {}) : (h = d[v] = d[v] || {},
                p = r);
                for (g in p)
                    m = f && f[g],
                    m && ((!("kill"in m.d) || m.d.kill(g) === !0) && km(this, m, "_pt"),
                    delete f[g]),
                    h !== "all" && (h[g] = 1)
            }
        return this._initted && !this._pt && u && Ju(this),
        this
    }
    ,
    e.to = function(s, r) {
        return new e(s,r,arguments[2])
    }
    ,
    e.from = function(s, r) {
        return md(1, arguments)
    }
    ,
    e.delayedCall = function(s, r, o, a) {
        return new e(r,0,{
            immediateRender: !1,
            lazy: !1,
            overwrite: !1,
            delay: s,
            onComplete: r,
            onReverseComplete: r,
            onCompleteParams: o,
            onReverseCompleteParams: o,
            callbackScope: a
        })
    }
    ,
    e.fromTo = function(s, r, o) {
        return md(2, arguments)
    }
    ,
    e.set = function(s, r) {
        return r.duration = 0,
        r.repeatDelay || (r.repeat = 0),
        new e(s,r)
    }
    ,
    e.killTweensOf = function(s, r, o) {
        return Nn.killTweensOf(s, r, o)
    }
    ,
    e
}(zd);
js(Yn.prototype, {
    _targets: [],
    _lazy: 0,
    _startAt: 0,
    _op: 0,
    _onInit: 0
});
cs("staggerTo,staggerFrom,staggerFromTo", function(i) {
    Yn[i] = function() {
        var e = new Wi
          , t = Nv.call(arguments, 0);
        return t.splice(i === "staggerFromTo" ? 5 : 4, 0, 0),
        e[i].apply(e, t)
    }
});
var Bx = function(e, t, n) {
    return e[t] = n
}
  , dR = function(e, t, n) {
    return e[t](n)
}
  , jne = function(e, t, n, s) {
    return e[t](s.fp, n)
}
  , Kne = function(e, t, n) {
    return e.setAttribute(t, n)
}
  , Vx = function(e, t) {
    return zn(e[t]) ? dR : Lx(e[t]) && e.setAttribute ? Kne : Bx
}
  , fR = function(e, t) {
    return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e6) / 1e6, t)
}
  , Xne = function(e, t) {
    return t.set(t.t, t.p, !!(t.s + t.c * e), t)
}
  , hR = function(e, t) {
    var n = t._pt
      , s = "";
    if (!e && t.b)
        s = t.b;
    else if (e === 1 && t.e)
        s = t.e;
    else {
        for (; n; )
            s = n.p + (n.m ? n.m(n.s + n.c * e) : Math.round((n.s + n.c * e) * 1e4) / 1e4) + s,
            n = n._next;
        s += t.c
    }
    t.set(t.t, t.p, s, t)
}
  , $x = function(e, t) {
    for (var n = t._pt; n; )
        n.r(e, n.d),
        n = n._next
}
  , Yne = function(e, t, n, s) {
    for (var r = this._pt, o; r; )
        o = r._next,
        r.p === s && r.modifier(e, t, n),
        r = o
}
  , Zne = function(e) {
    for (var t = this._pt, n, s; t; )
        s = t._next,
        t.p === e && !t.op || t.op === e ? km(this, t, "_pt") : t.dep || (n = 1),
        t = s;
    return !n
}
  , Jne = function(e, t, n, s) {
    s.mSet(e, t, s.m.call(s.tween, n, s.mt), s)
}
  , pR = function(e) {
    for (var t = e._pt, n, s, r, o; t; ) {
        for (n = t._next,
        s = r; s && s.pr > t.pr; )
            s = s._next;
        (t._prev = s ? s._prev : o) ? t._prev._next = t : r = t,
        (t._next = s) ? s._prev = t : o = t,
        t = n
    }
    e._pt = r
}
  , us = function() {
    function i(t, n, s, r, o, a, l, c, u) {
        this.t = n,
        this.s = r,
        this.c = o,
        this.p = s,
        this.r = a || fR,
        this.d = l || this,
        this.set = c || Bx,
        this.pr = u || 0,
        this._next = t,
        t && (t._prev = this)
    }
    var e = i.prototype;
    return e.modifier = function(n, s, r) {
        this.mSet = this.mSet || this.set,
        this.set = Jne,
        this.m = n,
        this.mt = r,
        this.tween = s
    }
    ,
    i
}();
cs(Fx + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(i) {
    return Dx[i] = 1
});
Cs.TweenMax = Cs.TweenLite = Yn;
Cs.TimelineLite = Cs.TimelineMax = Wi;
Nn = new Wi({
    sortChildren: !1,
    defaults: vu,
    autoRemoveChildren: !0,
    id: "root",
    smoothChildTiming: !0
});
Ts.stringFilter = iR;
var Al = []
  , zh = {}
  , Qne = []
  , HE = 0
  , eie = 0
  , Sg = function(e) {
    return (zh[e] || Qne).map(function(t) {
        return t()
    })
}
  , Hv = function() {
    var e = Date.now()
      , t = [];
    e - HE > 2 && (Sg("matchMediaInit"),
    Al.forEach(function(n) {
        var s = n.queries, r = n.conditions, o, a, l, c;
        for (a in s)
            o = Ir.matchMedia(s[a]).matches,
            o && (l = 1),
            o !== r[a] && (r[a] = o,
            c = 1);
        c && (n.revert(),
        l && t.push(n))
    }),
    Sg("matchMediaRevert"),
    t.forEach(function(n) {
        return n.onMatch(n, function(s) {
            return n.add(null, s)
        })
    }),
    HE = e,
    Sg("matchMedia"))
}
  , mR = function() {
    function i(t, n) {
        this.selector = n && Bv(n),
        this.data = [],
        this._r = [],
        this.isReverted = !1,
        this.id = eie++,
        t && this.add(t)
    }
    var e = i.prototype;
    return e.add = function(n, s, r) {
        zn(n) && (r = s,
        s = n,
        n = zn);
        var o = this
          , a = function() {
            var c = Dn, u = o.selector, d;
            return c && c !== o && c.data.push(o),
            r && (o.selector = Bv(r)),
            Dn = o,
            d = s.apply(o, arguments),
            zn(d) && o._r.push(d),
            Dn = c,
            o.selector = u,
            o.isReverted = !1,
            d
        };
        return o.last = a,
        n === zn ? a(o, function(l) {
            return o.add(null, l)
        }) : n ? o[n] = a : a
    }
    ,
    e.ignore = function(n) {
        var s = Dn;
        Dn = null,
        n(this),
        Dn = s
    }
    ,
    e.getTweens = function() {
        var n = [];
        return this.data.forEach(function(s) {
            return s instanceof i ? n.push.apply(n, s.getTweens()) : s instanceof Yn && !(s.parent && s.parent.data === "nested") && n.push(s)
        }),
        n
    }
    ,
    e.clear = function() {
        this._r.length = this.data.length = 0
    }
    ,
    e.kill = function(n, s) {
        var r = this;
        if (n ? function() {
            for (var a = r.getTweens(), l = r.data.length, c; l--; )
                c = r.data[l],
                c.data === "isFlip" && (c.revert(),
                c.getChildren(!0, !0, !1).forEach(function(u) {
                    return a.splice(a.indexOf(u), 1)
                }));
            for (a.map(function(u) {
                return {
                    g: u._dur || u._delay || u._sat && !u._sat.vars.immediateRender ? u.globalTime(0) : -1 / 0,
                    t: u
                }
            }).sort(function(u, d) {
                return d.g - u.g || -1 / 0
            }).forEach(function(u) {
                return u.t.revert(n)
            }),
            l = r.data.length; l--; )
                c = r.data[l],
                c instanceof Wi ? c.data !== "nested" && (c.scrollTrigger && c.scrollTrigger.revert(),
                c.kill()) : !(c instanceof Yn) && c.revert && c.revert(n);
            r._r.forEach(function(u) {
                return u(n, r)
            }),
            r.isReverted = !0
        }() : this.data.forEach(function(a) {
            return a.kill && a.kill()
        }),
        this.clear(),
        s)
            for (var o = Al.length; o--; )
                Al[o].id === this.id && Al.splice(o, 1)
    }
    ,
    e.revert = function(n) {
        this.kill(n || {})
    }
    ,
    i
}()
  , tie = function() {
    function i(t) {
        this.contexts = [],
        this.scope = t,
        Dn && Dn.data.push(this)
    }
    var e = i.prototype;
    return e.add = function(n, s, r) {
        Yr(n) || (n = {
            matches: n
        });
        var o = new mR(0,r || this.scope), a = o.conditions = {}, l, c, u;
        Dn && !o.selector && (o.selector = Dn.selector),
        this.contexts.push(o),
        s = o.add("onMatch", s),
        o.queries = n;
        for (c in n)
            c === "all" ? u = 1 : (l = Ir.matchMedia(n[c]),
            l && (Al.indexOf(o) < 0 && Al.push(o),
            (a[c] = l.matches) && (u = 1),
            l.addListener ? l.addListener(Hv) : l.addEventListener("change", Hv)));
        return u && s(o, function(d) {
            return o.add(null, d)
        }),
        this
    }
    ,
    e.revert = function(n) {
        this.kill(n || {})
    }
    ,
    e.kill = function(n) {
        this.contexts.forEach(function(s) {
            return s.kill(n, !0)
        })
    }
    ,
    i
}()
  , qp = {
    registerPlugin: function() {
        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
            t[n] = arguments[n];
        t.forEach(function(s) {
            return eR(s)
        })
    },
    timeline: function(e) {
        return new Wi(e)
    },
    getTweensOf: function(e, t) {
        return Nn.getTweensOf(e, t)
    },
    getProperty: function(e, t, n, s) {
        bi(e) && (e = Vs(e)[0]);
        var r = El(e || {}).get
          , o = n ? $3 : V3;
        return n === "native" && (n = ""),
        e && (t ? o((gs[t] && gs[t].get || r)(e, t, n, s)) : function(a, l, c) {
            return o((gs[a] && gs[a].get || r)(e, a, l, c))
        }
        )
    },
    quickSetter: function(e, t, n) {
        if (e = Vs(e),
        e.length > 1) {
            var s = e.map(function(u) {
                return fs.quickSetter(u, t, n)
            })
              , r = s.length;
            return function(u) {
                for (var d = r; d--; )
                    s[d](u)
            }
        }
        e = e[0] || {};
        var o = gs[t]
          , a = El(e)
          , l = a.harness && (a.harness.aliases || {})[t] || t
          , c = o ? function(u) {
            var d = new o;
            Rc._pt = 0,
            d.init(e, n ? u + n : u, Rc, 0, [e]),
            d.render(1, d),
            Rc._pt && $x(1, Rc)
        }
        : a.set(e, l);
        return o ? c : function(u) {
            return c(e, l, n ? u + n : u, a, 1)
        }
    },
    quickTo: function(e, t, n) {
        var s, r = fs.to(e, Fl((s = {},
        s[t] = "+=0.1",
        s.paused = !0,
        s), n || {})), o = function(l, c, u) {
            return r.resetTo(t, l, c, u)
        };
        return o.tween = r,
        o
    },
    isTweening: function(e) {
        return Nn.getTweensOf(e, !0).length > 0
    },
    defaults: function(e) {
        return e && e.ease && (e.ease = Tl(e.ease, vu.ease)),
        UE(vu, e || {})
    },
    config: function(e) {
        return UE(Ts, e || {})
    },
    registerEffect: function(e) {
        var t = e.name
          , n = e.effect
          , s = e.plugins
          , r = e.defaults
          , o = e.extendTimeline;
        (s || "").split(",").forEach(function(a) {
            return a && !gs[a] && !Cs[a] && Bd(t + " effect requires " + a + " plugin.")
        }),
        _g[t] = function(a, l, c) {
            return n(Vs(a), js(l || {}, r), c)
        }
        ,
        o && (Wi.prototype[t] = function(a, l, c) {
            return this.add(_g[t](a, Yr(l) ? l : (c = l) && {}, this), c)
        }
        )
    },
    registerEase: function(e, t) {
        Qt[e] = Tl(t)
    },
    parseEase: function(e, t) {
        return arguments.length ? Tl(e, t) : Qt
    },
    getById: function(e) {
        return Nn.getById(e)
    },
    exportRoot: function(e, t) {
        e === void 0 && (e = {});
        var n = new Wi(e), s, r;
        for (n.smoothChildTiming = ls(e.smoothChildTiming),
        Nn.remove(n),
        n._dp = 0,
        n._time = n._tTime = Nn._time,
        s = Nn._first; s; )
            r = s._next,
            (t || !(!s._dur && s instanceof Yn && s.vars.onComplete === s._targets[0])) && Fr(n, s, s._start - s._delay),
            s = r;
        return Fr(Nn, n, 0),
        n
    },
    context: function(e, t) {
        return e ? new mR(e,t) : Dn
    },
    matchMedia: function(e) {
        return new tie(e)
    },
    matchMediaRefresh: function() {
        return Al.forEach(function(e) {
            var t = e.conditions, n, s;
            for (s in t)
                t[s] && (t[s] = !1,
                n = 1);
            n && e.revert()
        }) || Hv()
    },
    addEventListener: function(e, t) {
        var n = zh[e] || (zh[e] = []);
        ~n.indexOf(t) || n.push(t)
    },
    removeEventListener: function(e, t) {
        var n = zh[e]
          , s = n && n.indexOf(t);
        s >= 0 && n.splice(s, 1)
    },
    utils: {
        wrap: Pne,
        wrapYoyo: Dne,
        distribute: K3,
        random: Y3,
        snap: X3,
        normalize: kne,
        getUnit: Pi,
        clamp: Mne,
        splitColor: tR,
        toArray: Vs,
        selector: Bv,
        mapRange: J3,
        pipe: Lne,
        unitize: Ine,
        interpolate: Fne,
        shuffle: j3
    },
    install: F3,
    effects: _g,
    ticker: _s,
    updateRoot: Wi.updateRoot,
    plugins: gs,
    globalTimeline: Nn,
    core: {
        PropTween: us,
        globals: O3,
        Tween: Yn,
        Timeline: Wi,
        Animation: zd,
        getCache: El,
        _removeLinkedListItem: km,
        reverting: function() {
            return Oi
        },
        context: function(e) {
            return e && Dn && (Dn.data.push(e),
            e._ctx = Dn),
            Dn
        },
        suppressOverwrites: function(e) {
            return Rx = e
        }
    }
};
cs("to,from,fromTo,delayedCall,set,killTweensOf", function(i) {
    return qp[i] = Yn[i]
});
_s.add(Wi.updateRoot);
Rc = qp.to({}, {
    duration: 0
});
var nie = function(e, t) {
    for (var n = e._pt; n && n.p !== t && n.op !== t && n.fp !== t; )
        n = n._next;
    return n
}
  , iie = function(e, t) {
    var n = e._targets, s, r, o;
    for (s in t)
        for (r = n.length; r--; )
            o = e._ptLookup[r][s],
            o && (o = o.d) && (o._pt && (o = nie(o, s)),
            o && o.modifier && o.modifier(t[s], e, n[r], s))
}
  , Eg = function(e, t) {
    return {
        name: e,
        rawVars: 1,
        init: function(s, r, o) {
            o._onInit = function(a) {
                var l, c;
                if (bi(r) && (l = {},
                cs(r, function(u) {
                    return l[u] = 1
                }),
                r = l),
                t) {
                    l = {};
                    for (c in r)
                        l[c] = t(r[c]);
                    r = l
                }
                iie(a, r)
            }
        }
    }
}
  , fs = qp.registerPlugin({
    name: "attr",
    init: function(e, t, n, s, r) {
        var o, a, l;
        this.tween = n;
        for (o in t)
            l = e.getAttribute(o) || "",
            a = this.add(e, "setAttribute", (l || 0) + "", t[o], s, r, 0, 0, o),
            a.op = o,
            a.b = l,
            this._props.push(o)
    },
    render: function(e, t) {
        for (var n = t._pt; n; )
            Oi ? n.set(n.t, n.p, n.b, n) : n.r(e, n.d),
            n = n._next
    }
}, {
    name: "endArray",
    init: function(e, t) {
        for (var n = t.length; n--; )
            this.add(e, n, e[n] || 0, t[n], 0, 0, 0, 0, 0, 1)
    }
}, Eg("roundProps", Vv), Eg("modifiers"), Eg("snap", X3)) || qp;
Yn.version = Wi.version = fs.version = "3.12.5";
D3 = 1;
Ix() && yu();
Qt.Power0;
Qt.Power1;
Qt.Power2;
Qt.Power3;
Qt.Power4;
Qt.Linear;
Qt.Quad;
Qt.Cubic;
Qt.Quart;
Qt.Quint;
Qt.Strong;
Qt.Elastic;
Qt.Back;
Qt.SteppedEase;
Qt.Bounce;
Qt.Sine;
Qt.Expo;
Qt.Circ;
/*!
 * CSSPlugin 3.12.5
 * https://gsap.com
 *
 * Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var zE, da, Kc, Hx, gl, GE, zx, sie = function() {
    return typeof window < "u"
}, Uo = {}, sl = 180 / Math.PI, Xc = Math.PI / 180, gc = Math.atan2, WE = 1e8, Gx = /([A-Z])/g, rie = /(left|right|width|margin|padding|x)/i, oie = /[\s,\(]\S/, Vr = {
    autoAlpha: "opacity,visibility",
    scale: "scaleX,scaleY",
    alpha: "opacity"
}, zv = function(e, t) {
    return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t)
}, aie = function(e, t) {
    return t.set(t.t, t.p, e === 1 ? t.e : Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t)
}, lie = function(e, t) {
    return t.set(t.t, t.p, e ? Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u : t.b, t)
}, cie = function(e, t) {
    var n = t.s + t.c * e;
    t.set(t.t, t.p, ~~(n + (n < 0 ? -.5 : .5)) + t.u, t)
}, gR = function(e, t) {
    return t.set(t.t, t.p, e ? t.e : t.b, t)
}, vR = function(e, t) {
    return t.set(t.t, t.p, e !== 1 ? t.b : t.e, t)
}, uie = function(e, t, n) {
    return e.style[t] = n
}, die = function(e, t, n) {
    return e.style.setProperty(t, n)
}, fie = function(e, t, n) {
    return e._gsap[t] = n
}, hie = function(e, t, n) {
    return e._gsap.scaleX = e._gsap.scaleY = n
}, pie = function(e, t, n, s, r) {
    var o = e._gsap;
    o.scaleX = o.scaleY = n,
    o.renderTransform(r, o)
}, mie = function(e, t, n, s, r) {
    var o = e._gsap;
    o[t] = n,
    o.renderTransform(r, o)
}, Bn = "transform", ds = Bn + "Origin", gie = function i(e, t) {
    var n = this
      , s = this.target
      , r = s.style
      , o = s._gsap;
    if (e in Uo && r) {
        if (this.tfm = this.tfm || {},
        e !== "transform")
            e = Vr[e] || e,
            ~e.indexOf(",") ? e.split(",").forEach(function(a) {
                return n.tfm[a] = So(s, a)
            }) : this.tfm[e] = o.x ? o[e] : So(s, e),
            e === ds && (this.tfm.zOrigin = o.zOrigin);
        else
            return Vr.transform.split(",").forEach(function(a) {
                return i.call(n, a, t)
            });
        if (this.props.indexOf(Bn) >= 0)
            return;
        o.svg && (this.svgo = s.getAttribute("data-svg-origin"),
        this.props.push(ds, t, "")),
        e = Bn
    }
    (r || t) && this.props.push(e, t, r[e])
}, _R = function(e) {
    e.translate && (e.removeProperty("translate"),
    e.removeProperty("scale"),
    e.removeProperty("rotate"))
}, vie = function() {
    var e = this.props, t = this.target, n = t.style, s = t._gsap, r, o;
    for (r = 0; r < e.length; r += 3)
        e[r + 1] ? t[e[r]] = e[r + 2] : e[r + 2] ? n[e[r]] = e[r + 2] : n.removeProperty(e[r].substr(0, 2) === "--" ? e[r] : e[r].replace(Gx, "-$1").toLowerCase());
    if (this.tfm) {
        for (o in this.tfm)
            s[o] = this.tfm[o];
        s.svg && (s.renderTransform(),
        t.setAttribute("data-svg-origin", this.svgo || "")),
        r = zx(),
        (!r || !r.isStart) && !n[Bn] && (_R(n),
        s.zOrigin && n[ds] && (n[ds] += " " + s.zOrigin + "px",
        s.zOrigin = 0,
        s.renderTransform()),
        s.uncache = 1)
    }
}, xR = function(e, t) {
    var n = {
        target: e,
        props: [],
        revert: vie,
        save: gie
    };
    return e._gsap || fs.core.getCache(e),
    t && t.split(",").forEach(function(s) {
        return n.save(s)
    }),
    n
}, yR, Gv = function(e, t) {
    var n = da.createElementNS ? da.createElementNS((t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), e) : da.createElement(e);
    return n && n.style ? n : da.createElement(e)
}, Wr = function i(e, t, n) {
    var s = getComputedStyle(e);
    return s[t] || s.getPropertyValue(t.replace(Gx, "-$1").toLowerCase()) || s.getPropertyValue(t) || !n && i(e, bu(t) || t, 1) || ""
}, qE = "O,Moz,ms,Ms,Webkit".split(","), bu = function(e, t, n) {
    var s = t || gl
      , r = s.style
      , o = 5;
    if (e in r && !n)
        return e;
    for (e = e.charAt(0).toUpperCase() + e.substr(1); o-- && !(qE[o] + e in r); )
        ;
    return o < 0 ? null : (o === 3 ? "ms" : o >= 0 ? qE[o] : "") + e
}, Wv = function() {
    sie() && window.document && (zE = window,
    da = zE.document,
    Kc = da.documentElement,
    gl = Gv("div") || {
        style: {}
    },
    Gv("div"),
    Bn = bu(Bn),
    ds = Bn + "Origin",
    gl.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0",
    yR = !!bu("perspective"),
    zx = fs.core.reverting,
    Hx = 1)
}, wg = function i(e) {
    var t = Gv("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), n = this.parentNode, s = this.nextSibling, r = this.style.cssText, o;
    if (Kc.appendChild(t),
    t.appendChild(this),
    this.style.display = "block",
    e)
        try {
            o = this.getBBox(),
            this._gsapBBox = this.getBBox,
            this.getBBox = i
        } catch {}
    else
        this._gsapBBox && (o = this._gsapBBox());
    return n && (s ? n.insertBefore(this, s) : n.appendChild(this)),
    Kc.removeChild(t),
    this.style.cssText = r,
    o
}, jE = function(e, t) {
    for (var n = t.length; n--; )
        if (e.hasAttribute(t[n]))
            return e.getAttribute(t[n])
}, bR = function(e) {
    var t;
    try {
        t = e.getBBox()
    } catch {
        t = wg.call(e, !0)
    }
    return t && (t.width || t.height) || e.getBBox === wg || (t = wg.call(e, !0)),
    t && !t.width && !t.x && !t.y ? {
        x: +jE(e, ["x", "cx", "x1"]) || 0,
        y: +jE(e, ["y", "cy", "y1"]) || 0,
        width: 0,
        height: 0
    } : t
}, SR = function(e) {
    return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && bR(e))
}, Ol = function(e, t) {
    if (t) {
        var n = e.style, s;
        t in Uo && t !== ds && (t = Bn),
        n.removeProperty ? (s = t.substr(0, 2),
        (s === "ms" || t.substr(0, 6) === "webkit") && (t = "-" + t),
        n.removeProperty(s === "--" ? t : t.replace(Gx, "-$1").toLowerCase())) : n.removeAttribute(t)
    }
}, fa = function(e, t, n, s, r, o) {
    var a = new us(e._pt,t,n,0,1,o ? vR : gR);
    return e._pt = a,
    a.b = s,
    a.e = r,
    e._props.push(n),
    a
}, KE = {
    deg: 1,
    rad: 1,
    turn: 1
}, _ie = {
    grid: 1,
    flex: 1
}, Ma = function i(e, t, n, s) {
    var r = parseFloat(n) || 0, o = (n + "").trim().substr((r + "").length) || "px", a = gl.style, l = rie.test(t), c = e.tagName.toLowerCase() === "svg", u = (c ? "client" : "offset") + (l ? "Width" : "Height"), d = 100, f = s === "px", h = s === "%", p, g, m, v;
    if (s === o || !r || KE[s] || KE[o])
        return r;
    if (o !== "px" && !f && (r = i(e, t, n, "px")),
    v = e.getCTM && SR(e),
    (h || o === "%") && (Uo[t] || ~t.indexOf("adius")))
        return p = v ? e.getBBox()[l ? "width" : "height"] : e[u],
        Gn(h ? r / p * d : r / 100 * p);
    if (a[l ? "width" : "height"] = d + (f ? o : s),
    g = ~t.indexOf("adius") || s === "em" && e.appendChild && !c ? e : e.parentNode,
    v && (g = (e.ownerSVGElement || {}).parentNode),
    (!g || g === da || !g.appendChild) && (g = da.body),
    m = g._gsap,
    m && h && m.width && l && m.time === _s.time && !m.uncache)
        return Gn(r / m.width * d);
    if (h && (t === "height" || t === "width")) {
        var _ = e.style[t];
        e.style[t] = d + s,
        p = e[u],
        _ ? e.style[t] = _ : Ol(e, t)
    } else
        (h || o === "%") && !_ie[Wr(g, "display")] && (a.position = Wr(e, "position")),
        g === e && (a.position = "static"),
        g.appendChild(gl),
        p = gl[u],
        g.removeChild(gl),
        a.position = "absolute";
    return l && h && (m = El(g),
    m.time = _s.time,
    m.width = g[u]),
    Gn(f ? p * r / d : p && r ? d / p * r : 0)
}, So = function(e, t, n, s) {
    var r;
    return Hx || Wv(),
    t in Vr && t !== "transform" && (t = Vr[t],
    ~t.indexOf(",") && (t = t.split(",")[0])),
    Uo[t] && t !== "transform" ? (r = Wd(e, s),
    r = t !== "transformOrigin" ? r[t] : r.svg ? r.origin : Kp(Wr(e, ds)) + " " + r.zOrigin + "px") : (r = e.style[t],
    (!r || r === "auto" || s || ~(r + "").indexOf("calc(")) && (r = jp[t] && jp[t](e, t, n) || Wr(e, t) || N3(e, t) || (t === "opacity" ? 1 : 0))),
    n && !~(r + "").trim().indexOf(" ") ? Ma(e, t, r, n) + n : r
}, xie = function(e, t, n, s) {
    if (!n || n === "none") {
        var r = bu(t, e, 1)
          , o = r && Wr(e, r, 1);
        o && o !== n ? (t = r,
        n = o) : t === "borderColor" && (n = Wr(e, "borderTopColor"))
    }
    var a = new us(this._pt,e.style,t,0,1,hR), l = 0, c = 0, u, d, f, h, p, g, m, v, _, y, b, S;
    if (a.b = n,
    a.e = s,
    n += "",
    s += "",
    s === "auto" && (g = e.style[t],
    e.style[t] = s,
    s = Wr(e, t) || s,
    g ? e.style[t] = g : Ol(e, t)),
    u = [n, s],
    iR(u),
    n = u[0],
    s = u[1],
    f = n.match(Mc) || [],
    S = s.match(Mc) || [],
    S.length) {
        for (; d = Mc.exec(s); )
            m = d[0],
            _ = s.substring(l, d.index),
            p ? p = (p + 1) % 5 : (_.substr(-5) === "rgba(" || _.substr(-5) === "hsla(") && (p = 1),
            m !== (g = f[c++] || "") && (h = parseFloat(g) || 0,
            b = g.substr((h + "").length),
            m.charAt(1) === "=" && (m = jc(h, m) + b),
            v = parseFloat(m),
            y = m.substr((v + "").length),
            l = Mc.lastIndex - y.length,
            y || (y = y || Ts.units[t] || b,
            l === s.length && (s += y,
            a.e += y)),
            b !== y && (h = Ma(e, t, g, y) || 0),
            a._pt = {
                _next: a._pt,
                p: _ || c === 1 ? _ : ",",
                s: h,
                c: v - h,
                m: p && p < 4 || t === "zIndex" ? Math.round : 0
            });
        a.c = l < s.length ? s.substring(l, s.length) : ""
    } else
        a.r = t === "display" && s === "none" ? vR : gR;
    return k3.test(s) && (a.e = 0),
    this._pt = a,
    a
}, XE = {
    top: "0%",
    bottom: "100%",
    left: "0%",
    right: "100%",
    center: "50%"
}, yie = function(e) {
    var t = e.split(" ")
      , n = t[0]
      , s = t[1] || "50%";
    return (n === "top" || n === "bottom" || s === "left" || s === "right") && (e = n,
    n = s,
    s = e),
    t[0] = XE[n] || n,
    t[1] = XE[s] || s,
    t.join(" ")
}, bie = function(e, t) {
    if (t.tween && t.tween._time === t.tween._dur) {
        var n = t.t, s = n.style, r = t.u, o = n._gsap, a, l, c;
        if (r === "all" || r === !0)
            s.cssText = "",
            l = 1;
        else
            for (r = r.split(","),
            c = r.length; --c > -1; )
                a = r[c],
                Uo[a] && (l = 1,
                a = a === "transformOrigin" ? ds : Bn),
                Ol(n, a);
        l && (Ol(n, Bn),
        o && (o.svg && n.removeAttribute("transform"),
        Wd(n, 1),
        o.uncache = 1,
        _R(s)))
    }
}, jp = {
    clearProps: function(e, t, n, s, r) {
        if (r.data !== "isFromStart") {
            var o = e._pt = new us(e._pt,t,n,0,0,bie);
            return o.u = s,
            o.pr = -10,
            o.tween = r,
            e._props.push(n),
            1
        }
    }
}, Gd = [1, 0, 0, 1, 0, 0], ER = {}, wR = function(e) {
    return e === "matrix(1, 0, 0, 1, 0, 0)" || e === "none" || !e
}, YE = function(e) {
    var t = Wr(e, Bn);
    return wR(t) ? Gd : t.substr(7).match(I3).map(Gn)
}, Wx = function(e, t) {
    var n = e._gsap || El(e), s = e.style, r = YE(e), o, a, l, c;
    return n.svg && e.getAttribute("transform") ? (l = e.transform.baseVal.consolidate().matrix,
    r = [l.a, l.b, l.c, l.d, l.e, l.f],
    r.join(",") === "1,0,0,1,0,0" ? Gd : r) : (r === Gd && !e.offsetParent && e !== Kc && !n.svg && (l = s.display,
    s.display = "block",
    o = e.parentNode,
    (!o || !e.offsetParent) && (c = 1,
    a = e.nextElementSibling,
    Kc.appendChild(e)),
    r = YE(e),
    l ? s.display = l : Ol(e, "display"),
    c && (a ? o.insertBefore(e, a) : o ? o.appendChild(e) : Kc.removeChild(e))),
    t && r.length > 6 ? [r[0], r[1], r[4], r[5], r[12], r[13]] : r)
}, qv = function(e, t, n, s, r, o) {
    var a = e._gsap, l = r || Wx(e, !0), c = a.xOrigin || 0, u = a.yOrigin || 0, d = a.xOffset || 0, f = a.yOffset || 0, h = l[0], p = l[1], g = l[2], m = l[3], v = l[4], _ = l[5], y = t.split(" "), b = parseFloat(y[0]) || 0, S = parseFloat(y[1]) || 0, C, M, L, T;
    n ? l !== Gd && (M = h * m - p * g) && (L = b * (m / M) + S * (-g / M) + (g * _ - m * v) / M,
    T = b * (-p / M) + S * (h / M) - (h * _ - p * v) / M,
    b = L,
    S = T) : (C = bR(e),
    b = C.x + (~y[0].indexOf("%") ? b / 100 * C.width : b),
    S = C.y + (~(y[1] || y[0]).indexOf("%") ? S / 100 * C.height : S)),
    s || s !== !1 && a.smooth ? (v = b - c,
    _ = S - u,
    a.xOffset = d + (v * h + _ * g) - v,
    a.yOffset = f + (v * p + _ * m) - _) : a.xOffset = a.yOffset = 0,
    a.xOrigin = b,
    a.yOrigin = S,
    a.smooth = !!s,
    a.origin = t,
    a.originIsAbsolute = !!n,
    e.style[ds] = "0px 0px",
    o && (fa(o, a, "xOrigin", c, b),
    fa(o, a, "yOrigin", u, S),
    fa(o, a, "xOffset", d, a.xOffset),
    fa(o, a, "yOffset", f, a.yOffset)),
    e.setAttribute("data-svg-origin", b + " " + S)
}, Wd = function(e, t) {
    var n = e._gsap || new aR(e);
    if ("x"in n && !t && !n.uncache)
        return n;
    var s = e.style, r = n.scaleX < 0, o = "px", a = "deg", l = getComputedStyle(e), c = Wr(e, ds) || "0", u, d, f, h, p, g, m, v, _, y, b, S, C, M, L, T, A, k, D, F, z, G, H, X, K, ce, ue, Ie, ke, We, se, Se;
    return u = d = f = g = m = v = _ = y = b = 0,
    h = p = 1,
    n.svg = !!(e.getCTM && SR(e)),
    l.translate && ((l.translate !== "none" || l.scale !== "none" || l.rotate !== "none") && (s[Bn] = (l.translate !== "none" ? "translate3d(" + (l.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (l.rotate !== "none" ? "rotate(" + l.rotate + ") " : "") + (l.scale !== "none" ? "scale(" + l.scale.split(" ").join(",") + ") " : "") + (l[Bn] !== "none" ? l[Bn] : "")),
    s.scale = s.rotate = s.translate = "none"),
    M = Wx(e, n.svg),
    n.svg && (n.uncache ? (K = e.getBBox(),
    c = n.xOrigin - K.x + "px " + (n.yOrigin - K.y) + "px",
    X = "") : X = !t && e.getAttribute("data-svg-origin"),
    qv(e, X || c, !!X || n.originIsAbsolute, n.smooth !== !1, M)),
    S = n.xOrigin || 0,
    C = n.yOrigin || 0,
    M !== Gd && (k = M[0],
    D = M[1],
    F = M[2],
    z = M[3],
    u = G = M[4],
    d = H = M[5],
    M.length === 6 ? (h = Math.sqrt(k * k + D * D),
    p = Math.sqrt(z * z + F * F),
    g = k || D ? gc(D, k) * sl : 0,
    _ = F || z ? gc(F, z) * sl + g : 0,
    _ && (p *= Math.abs(Math.cos(_ * Xc))),
    n.svg && (u -= S - (S * k + C * F),
    d -= C - (S * D + C * z))) : (Se = M[6],
    We = M[7],
    ue = M[8],
    Ie = M[9],
    ke = M[10],
    se = M[11],
    u = M[12],
    d = M[13],
    f = M[14],
    L = gc(Se, ke),
    m = L * sl,
    L && (T = Math.cos(-L),
    A = Math.sin(-L),
    X = G * T + ue * A,
    K = H * T + Ie * A,
    ce = Se * T + ke * A,
    ue = G * -A + ue * T,
    Ie = H * -A + Ie * T,
    ke = Se * -A + ke * T,
    se = We * -A + se * T,
    G = X,
    H = K,
    Se = ce),
    L = gc(-F, ke),
    v = L * sl,
    L && (T = Math.cos(-L),
    A = Math.sin(-L),
    X = k * T - ue * A,
    K = D * T - Ie * A,
    ce = F * T - ke * A,
    se = z * A + se * T,
    k = X,
    D = K,
    F = ce),
    L = gc(D, k),
    g = L * sl,
    L && (T = Math.cos(L),
    A = Math.sin(L),
    X = k * T + D * A,
    K = G * T + H * A,
    D = D * T - k * A,
    H = H * T - G * A,
    k = X,
    G = K),
    m && Math.abs(m) + Math.abs(g) > 359.9 && (m = g = 0,
    v = 180 - v),
    h = Gn(Math.sqrt(k * k + D * D + F * F)),
    p = Gn(Math.sqrt(H * H + Se * Se)),
    L = gc(G, H),
    _ = Math.abs(L) > 2e-4 ? L * sl : 0,
    b = se ? 1 / (se < 0 ? -se : se) : 0),
    n.svg && (X = e.getAttribute("transform"),
    n.forceCSS = e.setAttribute("transform", "") || !wR(Wr(e, Bn)),
    X && e.setAttribute("transform", X))),
    Math.abs(_) > 90 && Math.abs(_) < 270 && (r ? (h *= -1,
    _ += g <= 0 ? 180 : -180,
    g += g <= 0 ? 180 : -180) : (p *= -1,
    _ += _ <= 0 ? 180 : -180)),
    t = t || n.uncache,
    n.x = u - ((n.xPercent = u && (!t && n.xPercent || (Math.round(e.offsetWidth / 2) === Math.round(-u) ? -50 : 0))) ? e.offsetWidth * n.xPercent / 100 : 0) + o,
    n.y = d - ((n.yPercent = d && (!t && n.yPercent || (Math.round(e.offsetHeight / 2) === Math.round(-d) ? -50 : 0))) ? e.offsetHeight * n.yPercent / 100 : 0) + o,
    n.z = f + o,
    n.scaleX = Gn(h),
    n.scaleY = Gn(p),
    n.rotation = Gn(g) + a,
    n.rotationX = Gn(m) + a,
    n.rotationY = Gn(v) + a,
    n.skewX = _ + a,
    n.skewY = y + a,
    n.transformPerspective = b + o,
    (n.zOrigin = parseFloat(c.split(" ")[2]) || !t && n.zOrigin || 0) && (s[ds] = Kp(c)),
    n.xOffset = n.yOffset = 0,
    n.force3D = Ts.force3D,
    n.renderTransform = n.svg ? Eie : yR ? TR : Sie,
    n.uncache = 0,
    n
}, Kp = function(e) {
    return (e = e.split(" "))[0] + " " + e[1]
}, Tg = function(e, t, n) {
    var s = Pi(t);
    return Gn(parseFloat(t) + parseFloat(Ma(e, "x", n + "px", s))) + s
}, Sie = function(e, t) {
    t.z = "0px",
    t.rotationY = t.rotationX = "0deg",
    t.force3D = 0,
    TR(e, t)
}, Za = "0deg", Hu = "0px", Ja = ") ", TR = function(e, t) {
    var n = t || this
      , s = n.xPercent
      , r = n.yPercent
      , o = n.x
      , a = n.y
      , l = n.z
      , c = n.rotation
      , u = n.rotationY
      , d = n.rotationX
      , f = n.skewX
      , h = n.skewY
      , p = n.scaleX
      , g = n.scaleY
      , m = n.transformPerspective
      , v = n.force3D
      , _ = n.target
      , y = n.zOrigin
      , b = ""
      , S = v === "auto" && e && e !== 1 || v === !0;
    if (y && (d !== Za || u !== Za)) {
        var C = parseFloat(u) * Xc, M = Math.sin(C), L = Math.cos(C), T;
        C = parseFloat(d) * Xc,
        T = Math.cos(C),
        o = Tg(_, o, M * T * -y),
        a = Tg(_, a, -Math.sin(C) * -y),
        l = Tg(_, l, L * T * -y + y)
    }
    m !== Hu && (b += "perspective(" + m + Ja),
    (s || r) && (b += "translate(" + s + "%, " + r + "%) "),
    (S || o !== Hu || a !== Hu || l !== Hu) && (b += l !== Hu || S ? "translate3d(" + o + ", " + a + ", " + l + ") " : "translate(" + o + ", " + a + Ja),
    c !== Za && (b += "rotate(" + c + Ja),
    u !== Za && (b += "rotateY(" + u + Ja),
    d !== Za && (b += "rotateX(" + d + Ja),
    (f !== Za || h !== Za) && (b += "skew(" + f + ", " + h + Ja),
    (p !== 1 || g !== 1) && (b += "scale(" + p + ", " + g + Ja),
    _.style[Bn] = b || "translate(0, 0)"
}, Eie = function(e, t) {
    var n = t || this, s = n.xPercent, r = n.yPercent, o = n.x, a = n.y, l = n.rotation, c = n.skewX, u = n.skewY, d = n.scaleX, f = n.scaleY, h = n.target, p = n.xOrigin, g = n.yOrigin, m = n.xOffset, v = n.yOffset, _ = n.forceCSS, y = parseFloat(o), b = parseFloat(a), S, C, M, L, T;
    l = parseFloat(l),
    c = parseFloat(c),
    u = parseFloat(u),
    u && (u = parseFloat(u),
    c += u,
    l += u),
    l || c ? (l *= Xc,
    c *= Xc,
    S = Math.cos(l) * d,
    C = Math.sin(l) * d,
    M = Math.sin(l - c) * -f,
    L = Math.cos(l - c) * f,
    c && (u *= Xc,
    T = Math.tan(c - u),
    T = Math.sqrt(1 + T * T),
    M *= T,
    L *= T,
    u && (T = Math.tan(u),
    T = Math.sqrt(1 + T * T),
    S *= T,
    C *= T)),
    S = Gn(S),
    C = Gn(C),
    M = Gn(M),
    L = Gn(L)) : (S = d,
    L = f,
    C = M = 0),
    (y && !~(o + "").indexOf("px") || b && !~(a + "").indexOf("px")) && (y = Ma(h, "x", o, "px"),
    b = Ma(h, "y", a, "px")),
    (p || g || m || v) && (y = Gn(y + p - (p * S + g * M) + m),
    b = Gn(b + g - (p * C + g * L) + v)),
    (s || r) && (T = h.getBBox(),
    y = Gn(y + s / 100 * T.width),
    b = Gn(b + r / 100 * T.height)),
    T = "matrix(" + S + "," + C + "," + M + "," + L + "," + y + "," + b + ")",
    h.setAttribute("transform", T),
    _ && (h.style[Bn] = T)
}, wie = function(e, t, n, s, r) {
    var o = 360, a = bi(r), l = parseFloat(r) * (a && ~r.indexOf("rad") ? sl : 1), c = l - s, u = s + c + "deg", d, f;
    return a && (d = r.split("_")[1],
    d === "short" && (c %= o,
    c !== c % (o / 2) && (c += c < 0 ? o : -o)),
    d === "cw" && c < 0 ? c = (c + o * WE) % o - ~~(c / o) * o : d === "ccw" && c > 0 && (c = (c - o * WE) % o - ~~(c / o) * o)),
    e._pt = f = new us(e._pt,t,n,s,c,aie),
    f.e = u,
    f.u = "deg",
    e._props.push(n),
    f
}, ZE = function(e, t) {
    for (var n in t)
        e[n] = t[n];
    return e
}, Tie = function(e, t, n) {
    var s = ZE({}, n._gsap), r = "perspective,force3D,transformOrigin,svgOrigin", o = n.style, a, l, c, u, d, f, h, p;
    s.svg ? (c = n.getAttribute("transform"),
    n.setAttribute("transform", ""),
    o[Bn] = t,
    a = Wd(n, 1),
    Ol(n, Bn),
    n.setAttribute("transform", c)) : (c = getComputedStyle(n)[Bn],
    o[Bn] = t,
    a = Wd(n, 1),
    o[Bn] = c);
    for (l in Uo)
        c = s[l],
        u = a[l],
        c !== u && r.indexOf(l) < 0 && (h = Pi(c),
        p = Pi(u),
        d = h !== p ? Ma(n, l, c, p) : parseFloat(c),
        f = parseFloat(u),
        e._pt = new us(e._pt,a,l,d,f - d,zv),
        e._pt.u = p || 0,
        e._props.push(l));
    ZE(a, s)
};
cs("padding,margin,Width,Radius", function(i, e) {
    var t = "Top"
      , n = "Right"
      , s = "Bottom"
      , r = "Left"
      , o = (e < 3 ? [t, n, s, r] : [t + r, t + n, s + n, s + r]).map(function(a) {
        return e < 2 ? i + a : "border" + a + i
    });
    jp[e > 1 ? "border" + i : i] = function(a, l, c, u, d) {
        var f, h;
        if (arguments.length < 4)
            return f = o.map(function(p) {
                return So(a, p, c)
            }),
            h = f.join(" "),
            h.split(f[0]).length === 5 ? f[0] : h;
        f = (u + "").split(" "),
        h = {},
        o.forEach(function(p, g) {
            return h[p] = f[g] = f[g] || f[(g - 1) / 2 | 0]
        }),
        a.init(l, h, d)
    }
});
var AR = {
    name: "css",
    register: Wv,
    targetTest: function(e) {
        return e.style && e.nodeType
    },
    init: function(e, t, n, s, r) {
        var o = this._props, a = e.style, l = n.vars.startAt, c, u, d, f, h, p, g, m, v, _, y, b, S, C, M, L;
        Hx || Wv(),
        this.styles = this.styles || xR(e),
        L = this.styles.props,
        this.tween = n;
        for (g in t)
            if (g !== "autoRound" && (u = t[g],
            !(gs[g] && lR(g, t, n, s, e, r)))) {
                if (h = typeof u,
                p = jp[g],
                h === "function" && (u = u.call(n, s, e, r),
                h = typeof u),
                h === "string" && ~u.indexOf("random(") && (u = $d(u)),
                p)
                    p(this, e, g, u, n) && (M = 1);
                else if (g.substr(0, 2) === "--")
                    c = (getComputedStyle(e).getPropertyValue(g) + "").trim(),
                    u += "",
                    ba.lastIndex = 0,
                    ba.test(c) || (m = Pi(c),
                    v = Pi(u)),
                    v ? m !== v && (c = Ma(e, g, c, v) + v) : m && (u += m),
                    this.add(a, "setProperty", c, u, s, r, 0, 0, g),
                    o.push(g),
                    L.push(g, 0, a[g]);
                else if (h !== "undefined") {
                    if (l && g in l ? (c = typeof l[g] == "function" ? l[g].call(n, s, e, r) : l[g],
                    bi(c) && ~c.indexOf("random(") && (c = $d(c)),
                    Pi(c + "") || c === "auto" || (c += Ts.units[g] || Pi(So(e, g)) || ""),
                    (c + "").charAt(1) === "=" && (c = So(e, g))) : c = So(e, g),
                    f = parseFloat(c),
                    _ = h === "string" && u.charAt(1) === "=" && u.substr(0, 2),
                    _ && (u = u.substr(2)),
                    d = parseFloat(u),
                    g in Vr && (g === "autoAlpha" && (f === 1 && So(e, "visibility") === "hidden" && d && (f = 0),
                    L.push("visibility", 0, a.visibility),
                    fa(this, a, "visibility", f ? "inherit" : "hidden", d ? "inherit" : "hidden", !d)),
                    g !== "scale" && g !== "transform" && (g = Vr[g],
                    ~g.indexOf(",") && (g = g.split(",")[0]))),
                    y = g in Uo,
                    y) {
                        if (this.styles.save(g),
                        b || (S = e._gsap,
                        S.renderTransform && !t.parseTransform || Wd(e, t.parseTransform),
                        C = t.smoothOrigin !== !1 && S.smooth,
                        b = this._pt = new us(this._pt,a,Bn,0,1,S.renderTransform,S,0,-1),
                        b.dep = 1),
                        g === "scale")
                            this._pt = new us(this._pt,S,"scaleY",S.scaleY,(_ ? jc(S.scaleY, _ + d) : d) - S.scaleY || 0,zv),
                            this._pt.u = 0,
                            o.push("scaleY", g),
                            g += "X";
                        else if (g === "transformOrigin") {
                            L.push(ds, 0, a[ds]),
                            u = yie(u),
                            S.svg ? qv(e, u, 0, C, 0, this) : (v = parseFloat(u.split(" ")[2]) || 0,
                            v !== S.zOrigin && fa(this, S, "zOrigin", S.zOrigin, v),
                            fa(this, a, g, Kp(c), Kp(u)));
                            continue
                        } else if (g === "svgOrigin") {
                            qv(e, u, 1, C, 0, this);
                            continue
                        } else if (g in ER) {
                            wie(this, S, g, f, _ ? jc(f, _ + u) : u);
                            continue
                        } else if (g === "smoothOrigin") {
                            fa(this, S, "smooth", S.smooth, u);
                            continue
                        } else if (g === "force3D") {
                            S[g] = u;
                            continue
                        } else if (g === "transform") {
                            Tie(this, u, e);
                            continue
                        }
                    } else
                        g in a || (g = bu(g) || g);
                    if (y || (d || d === 0) && (f || f === 0) && !oie.test(u) && g in a)
                        m = (c + "").substr((f + "").length),
                        d || (d = 0),
                        v = Pi(u) || (g in Ts.units ? Ts.units[g] : m),
                        m !== v && (f = Ma(e, g, c, v)),
                        this._pt = new us(this._pt,y ? S : a,g,f,(_ ? jc(f, _ + d) : d) - f,!y && (v === "px" || g === "zIndex") && t.autoRound !== !1 ? cie : zv),
                        this._pt.u = v || 0,
                        m !== v && v !== "%" && (this._pt.b = c,
                        this._pt.r = lie);
                    else if (g in a)
                        xie.call(this, e, g, c, _ ? _ + u : u);
                    else if (g in e)
                        this.add(e, g, c || e[g], _ ? _ + u : u, s, r);
                    else if (g !== "parseTransform") {
                        Px(g, u);
                        continue
                    }
                    y || (g in a ? L.push(g, 0, a[g]) : L.push(g, 1, c || e[g])),
                    o.push(g)
                }
            }
        M && pR(this)
    },
    render: function(e, t) {
        if (t.tween._time || !zx())
            for (var n = t._pt; n; )
                n.r(e, n.d),
                n = n._next;
        else
            t.styles.revert()
    },
    get: So,
    aliases: Vr,
    getSetter: function(e, t, n) {
        var s = Vr[t];
        return s && s.indexOf(",") < 0 && (t = s),
        t in Uo && t !== ds && (e._gsap.x || So(e, "x")) ? n && GE === n ? t === "scale" ? hie : fie : (GE = n || {}) && (t === "scale" ? pie : mie) : e.style && !Lx(e.style[t]) ? uie : ~t.indexOf("-") ? die : Vx(e, t)
    },
    core: {
        _removeProperty: Ol,
        _getMatrix: Wx
    }
};
fs.utils.checkPrefix = bu;
fs.core.getStyleSaver = xR;
(function(i, e, t, n) {
    var s = cs(i + "," + e + "," + t, function(r) {
        Uo[r] = 1
    });
    cs(e, function(r) {
        Ts.units[r] = "deg",
        ER[r] = 1
    }),
    Vr[s[13]] = i + "," + e,
    cs(n, function(r) {
        var o = r.split(":");
        Vr[o[1]] = s[o[0]]
    })
}
)("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
cs("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(i) {
    Ts.units[i] = "px"
});
fs.registerPlugin(AR);
var jv = fs.registerPlugin(AR) || fs;
jv.core.Tween;
const Aie = {
    class: "grid grid-cols-[1fr_1fr] grid-cols-[70%_30%] md:grid-cols-[30%_70%] h-[75vh] gap-5 p-5 bg-zinc-900"
}
  , Cie = {
    class: "flex flex-col justify-start px-5 rounded-lg shadow-md rounded bg-gray-800 p-2"
}
  , Mie = {
    class: "m-2"
}
  , Rie = {
    class: "mb-2.5"
}
  , Lie = {
    class: "mb-5 flex justify-around mt-2"
}
  , Iie = {
    class: "mb-2.5"
}
  , kie = {
    class: "mb-2.5"
}
  , Pie = {
    class: "mb-2.5"
}
  , Die = {
    class: "flex justify-start"
}
  , Fie = {
    key: 1,
    class: "text-sm"
}
  , Oie = {
    key: 2,
    class: "mt-5 text-lg break-words"
}
  , Uie = {
    class: "flex justify-center items-center relative border-2 rounded-lg w-full h-full p-4"
}
  , Nie = ut({
    __name: "Mosa3js",
    setup(i) {
        const {isProduction: e} = it();
        Ti( () => ci(e ? "Stream" : "Demo"));
        const t = Zr();
        let n = xe("")
          , s = xe("bg-red-600");
        const {autoblow: r, handy: o, bluetoothFleshyThrust: a} = Pn(t)
          , l = xe(500);
        let c = 250;
        const u = xe(50)
          , d = xe(!1)
          , f = xe(!1)
          , h = xe(!0)
          , p = xe(!1)
          , g = xe(!1);
        let m = xe(!1);
        const v = xe(void 0)
          , _ = xe(void 0)
          , y = xe(void 0);
        let b = 0
          , S = 0;
        const C = xe("");
        let M = Vt( () => r.value.connected)
          , L = Vt( () => o.value.connected)
          , T = Vt( () => a.value.connected);
        const A = Vt( () => r.value.connected || o.value.connected || a.value.connected);
        function k() {
            l.value = l.value / 10,
            console.log("Frequency changed to:", l.value)
        }
        function D() {
            _.value && (clearTimeout(_.value),
            _.value = void 0)
        }
        function F() {
            A && We(),
            clearTimeout(v.value),
            v.value = void 0,
            d.value = !0,
            f.value = !0,
            D(),
            m.value = !1,
            console.log("Movement stopped.")
        }
        function z(be) {
            switch (D(),
            be) {
            case "short":
                console.log("Short Triggred"),
                K();
                break;
            case "long":
                console.log("Long Triggred"),
                X();
                break;
            case "hop":
                console.log("Hop Triggred"),
                ce();
                break;
            default:
                console.log("Short Triggred"),
                K();
                break
            }
            C.value = be.charAt(0).toUpperCase() + be.slice(1)
        }
        function G() {
            return g.value ? "hop" : h.value ? "long" : "short"
        }
        function H() {
            m.value = !0,
            d.value = !1,
            f.value = !1,
            b = 0;
            let be = [];
            if (g.value && be.push("hop"),
            h.value && be.push("long"),
            p.value && be.push("short"),
            be.length === 0) {
                console.log("No Movement Selected"),
                m.value = !1;
                return
            }
            z(G()),
            v.value = setInterval( () => {
                z(be[b]),
                b = (b + 1) % be.length
            }
            , 3e3)
        }
        function X() {
            ue(80)
        }
        function K() {
            ue(50)
        }
        function ce() {
            Ie()
        }
        function ue(be) {
            let me = Math.floor(Math.random() * 100) + 1;
            function Ce() {
                d.value || (me >= be ? me -= Math.min(be, me) : me += Math.min(be, 90 - me),
                S = me,
                A && ke({
                    speed: c,
                    position: S
                }),
                me > 50 ? console.log(`Up: ${me}`) : console.log(`Down: ${me}`),
                jv.to(u, {
                    value: me,
                    duration: c / 1e3
                }),
                _.value = setTimeout(Ce, c))
            }
            D(),
            Ce()
        }
        function Ie() {
            let Pe = 40
              , vt = !0;
            function j() {
                return Math.floor(Math.random() * 20) + 1
            }
            function B() {
                if (f.value)
                    return;
                const V = j();
                let Q;
                vt ? (Q = Math.min(Pe + V, 90),
                Q <= 40 && (Q = 40 + Math.floor(Math.random() * (90 - 40)))) : (Q = Math.max(Pe - V, 10),
                Q >= 40 && (Q = 40 - Math.floor(Math.random() * (40 - 10)))),
                S = Q,
                A && ke({
                    speed: c,
                    position: S
                }),
                Q > 40 ? console.log(`Up: ${Q}`) : console.log(`Down: ${Q}`),
                jv.to(u, {
                    value: Q,
                    duration: c / 1e3
                }),
                Pe = Q,
                vt = !vt,
                _.value = setTimeout(B, c)
            }
            D(),
            B()
        }
        function ke(be) {
            const {speed: q, position: me} = be;
            t.devices.forEach(Ce => {
                switch (Ce.connector) {
                case cn.Handy:
                    L.value && o.value.XPVP(me, q);
                    break;
                case cn.Autoblow:
                    M.value && r.value.goto(me, q);
                    break;
                case cn.BluetoothFleshyThrust:
                    T.value && a.value.move(me, q);
                    break
                }
            }
            )
        }
        function We() {
            t.devices.forEach(be => {
                switch (be.connector) {
                case cn.Handy:
                    L.value && o.value.stop_R();
                    break;
                case cn.Autoblow:
                    M.value && r.value.stop_R();
                    break;
                case cn.BluetoothFleshyThrust:
                    T.value && a.value.resetPosition();
                    break
                }
            }
            )
        }
        function se() {
            const be = new Date
              , q = be.getHours()
              , me = be.getMinutes()
              , Ce = be.getSeconds();
            return q * 3600 + me * 60 + Ce
        }
        function Se() {
            A.value ? (n.value = "Device connected successfully",
            s.value = "bg-green-500",
            setTimeout( () => {
                n.value = "",
                s.value = "bg-transparent"
            }
            , 1e3)) : (n.value = "Please connect the device",
            s.value = "bg-red-500")
        }
        return Bt(l, (be, q) => {
            c = 1e3 - be
        }
        ),
        Bt(A, (be, q) => {
            Se()
        }
        ),
        Ln( () => {
            H(),
            Se()
        }
        ),
        Bt(M, (be, q) => {
            be === !0 && r.value.start_R(se())
        }
        ),
        Bt(L, (be, q) => {
            be === !0 && o.value.start_R(se())
        }
        ),
        Bt(T, (be, q) => {
            be === !0 && a.value.resetPosition()
        }
        ),
        Ms( () => {
            v.value && clearInterval(v.value),
            _.value && clearTimeout(_.value),
            y.value && clearTimeout(y.value)
        }
        ),
        (be, q) => (w(),
        R("div", Aie, [x("div", Cie, [E(n) != "" ? (w(),
        R("div", {
            key: 0,
            class: Pt(`${E(s)} mt-2 mb-4 text-white font-thin relative flex justify-between rounded-md text-md font-medium`)
        }, [x("div", Mie, ee(E(n)), 1), q[4] || (q[4] = x("div", {
            class: "flex"
        }, null, -1))], 2)) : le("", !0), x("div", Rie, [q[5] || (q[5] = x("label", {
            class: "font-bold",
            for: "frequency"
        }, "Frequency \xA0", -1)), O(fo, {
            onChange: k,
            modelValue: l.value,
            "onUpdate:modelValue": q[0] || (q[0] = me => l.value = me),
            min: 0,
            max: 1e3,
            tooltips: !0,
            values: [100, 300, 500, 700, 900],
            class: "mt-1.5 mb-8"
        }, null, 8, ["modelValue"])]), q[14] || (q[14] = x("div", {
            class: "border-t-2 border-slate-700 mb-2 w-2/3 mx-auto"
        }, null, -1)), x("div", Lie, [x("div", Iie, [zt(x("input", {
            type: "checkbox",
            id: "long_stroke",
            "onUpdate:modelValue": q[1] || (q[1] = me => h.value = me)
        }, null, 512), [[Fc, h.value]]), q[6] || (q[6] = J("\xA0 ")), q[7] || (q[7] = x("label", {
            for: "long_stroke"
        }, "Long", -1))]), x("div", kie, [zt(x("input", {
            type: "checkbox",
            id: "short_stroke",
            "onUpdate:modelValue": q[2] || (q[2] = me => p.value = me)
        }, null, 512), [[Fc, p.value]]), q[8] || (q[8] = J("\xA0 ")), q[9] || (q[9] = x("label", {
            for: "short_stroke"
        }, "Short", -1))]), x("div", Pie, [zt(x("input", {
            type: "checkbox",
            id: "hop_stroke",
            "onUpdate:modelValue": q[3] || (q[3] = me => g.value = me)
        }, null, 512), [[Fc, g.value]]), q[10] || (q[10] = J("\xA0 ")), q[11] || (q[11] = x("label", {
            for: "hop_stroke"
        }, "Hop", -1))])]), x("div", Die, [O(je, {
            class: Pt(["inline-block", "grow", "px-4", "mr-3", "py-2", "mb-2", "text-lg", "font-bold", "cursor-pointer", "transition-colors", "duration-300", "ease-in-out"]),
            disabled: E(m),
            onClick: H,
            theme: E(m) ? "light" : "green"
        }, {
            default: Y( () => [J(ee(E(m) ? "Start disabled" : "Start"), 1)]),
            _: 1
        }, 8, ["disabled", "theme"]), O(je, {
            class: Pt(["px-4", "py-2", "grow", "mb-2", "text-lg"]),
            onClick: F,
            theme: "red"
        }, {
            default: Y( () => q[12] || (q[12] = [J("Stop")])),
            _: 1
        })]), E(m) ? (w(),
        R("p", Fie, " ** press stop to enable start button")) : le("", !0), C.value !== "" ? (w(),
        R("div", Oie, [q[13] || (q[13] = x("strong", null, "Current Movement:", -1)), J(" " + ee(C.value), 1)])) : le("", !0)]), x("div", Uie, [O(C3, {
            ballPosition: u.value
        }, null, 8, ["ballPosition"])])]))
    }
})
  , Bie = () => rf( () => import("./Studio.a4ced416.js"), [])
  , Vie = () => rf( () => import("./Videos.48badff6.js"), [])
  , $ie = () => rf( () => import("./CreateVideo.e69d5f7e.js"), [])
  , Hie = () => rf( () => import("./EditVideo.9963e540.js"), [])
  , zie = [{
    path: "/",
    name: "home",
    component: yb
}, {
    path: "/feed",
    name: "feed",
    component: MV
}, {
    path: "/videos",
    name: "videos",
    component: OV
}, {
    path: "/faptapai",
    name: "faptapai",
    component: wK
}, {
    path: "/careers/community-manager",
    name: "Community Manager",
    component: ZK
}, {
    path: "/funscripts",
    name: "funscripts",
    component: bK,
    meta: {
        requiresAuth: !0
    }
}, {
    path: "/funscripts/create",
    name: "create-funscript",
    component: XK,
    meta: {
        requiresAuth: !0
    }
}, {
    path: "/likes",
    name: "likes",
    component: RV
}, {
    path: "/preferences",
    name: "preferences",
    component: lV,
    meta: {
        requiresAuth: !0
    }
}, {
    path: "/u/:username",
    name: "user",
    component: IB
}, {
    path: "/p/:slug",
    name: "performer",
    component: NB
}, {
    path: "/t/:slug*",
    name: "tag",
    component: yV
}, {
    path: "/creators",
    name: "creators",
    component: GB
}, {
    path: "/v/:id",
    name: "watch",
    alias: "/watch/:id",
    component: uj
}, {
    path: "/tags",
    alias: "/tags/:slug",
    name: "tags",
    component: mV
}, {
    path: "/performers",
    name: "performers",
    component: DV
}, {
    path: "/f/:id",
    name: "funscript-watch",
    component: Gj
}, {
    path: "/studio",
    name: "studio",
    component: Bie,
    meta: {
        requiresAuth: !0
    }
}, {
    path: "/studio/videos",
    name: "studio-videos",
    component: Vie,
    meta: {
        requiresAuth: !0
    }
}, {
    path: "/studio/videos/create",
    name: "create-video",
    component: $ie,
    meta: {
        requiresAuth: !0
    }
}, {
    path: "/studio/videos/:id",
    name: "edit-video",
    component: Hie,
    meta: {
        requiresAuth: !0
    }
}, {
    path: "/admin",
    name: "admin",
    component: () => rf( () => import("./Admin.5ce2d818.js"), []),
    meta: {
        requiresAuth: !0
    }
}, {
    path: "/change-password/:email/:token",
    name: "forgot-password",
    component: yb,
    meta: {
        changePassword: !0
    }
}, {
    path: "/live-stream",
    alias: "/live-stream/:streamToken",
    name: "live-stream",
    component: Qte
}, {
    path: "/mosa",
    name: "mosa3js",
    component: Nie
}, {
    path: "/subscribe",
    name: "Subscribe",
    component: dne,
    meta: {
        requiresAuth: !0
    }
}, {
    path: "/:pathMatch(.*)*",
    name: "NotFound",
    redirect: "/"
}]
  , CR = dI({
    history: B4(),
    routes: zie,
    scrollBehavior(i, e, t) {
        return t || {
            top: 0
        }
    }
});
CR.beforeEach( (i, e, t) => {
    const n = it()
      , s = Xi();
    i.matched.some(r => r.meta.changePassword) && (s.changePassword = !0),
    i.matched.some(r => r.meta.requiresAuth) ? n.user ? t() : (s.authDialog = !0,
    t({
        path: "/",
        query: {
            redirect: i.fullPath
        }
    })) : t()
}
);
var Ar = (i => (i.LOADING = "loading",
i.LOADED = "loaded",
i.ERROR = "error",
i))(Ar || {});
const Gie = typeof window < "u" && window !== null
  , Wie = Xie()
  , qie = Object.prototype.propertyIsEnumerable
  , JE = Object.getOwnPropertySymbols;
function vd(i) {
    return typeof i == "function" || toString.call(i) === "[object Object]"
}
function jie(i) {
    return typeof i == "object" ? i === null : typeof i != "function"
}
function Kie(i) {
    return i !== "__proto__" && i !== "constructor" && i !== "prototype"
}
function Xie() {
    return Gie && "IntersectionObserver"in window && "IntersectionObserverEntry"in window && "intersectionRatio"in window.IntersectionObserverEntry.prototype ? ("isIntersecting"in window.IntersectionObserverEntry.prototype || Object.defineProperty(window.IntersectionObserverEntry.prototype, "isIntersecting", {
        get() {
            return this.intersectionRatio > 0
        }
    }),
    !0) : !1
}
function Yie(i, ...e) {
    if (!vd(i))
        throw new TypeError("expected the first argument to be an object");
    if (e.length === 0 || typeof Symbol != "function" || typeof JE != "function")
        return i;
    for (const t of e) {
        const n = JE(t);
        for (const s of n)
            qie.call(t, s) && (i[s] = t[s])
    }
    return i
}
function MR(i, ...e) {
    let t = 0;
    for (jie(i) && (i = e[t++]),
    i || (i = {}); t < e.length; t++)
        if (vd(e[t])) {
            for (const n of Object.keys(e[t]))
                Kie(n) && (vd(i[n]) && vd(e[t][n]) ? MR(i[n], e[t][n]) : i[n] = e[t][n]);
            Yie(i, e[t])
        }
    return i
}
const QE = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"
  , Zie = ""
  , Jie = {
    rootMargin: "0px",
    threshold: 0
}
  , vc = "data-lazy-timeout-id";
class Qie {
    constructor(e) {
        this.options = {
            loading: QE,
            error: Zie,
            observerOptions: Jie,
            log: !0,
            lifecycle: {},
            logLevel: "error"
        },
        this._images = new WeakMap,
        this.config(e)
    }
    config(e={}) {
        MR(this.options, e)
    }
    mount(e, t) {
        if (!e)
            return;
        const {src: n, loading: s, error: r, lifecycle: o, delay: a} = this._valueFormatter(typeof t == "string" ? t : t.value);
        this._lifecycle(Ar.LOADING, o, e),
        e.setAttribute("src", s || QE),
        Wie || (this.loadImages(e, n, r, o),
        this._log( () => {
            this._logger("Not support IntersectionObserver!")
        }
        )),
        this._initIntersectionObserver(e, n, r, o, a)
    }
    update(e, t) {
        var a;
        if (!e)
            return;
        (a = this._realObserver(e)) == null || a.unobserve(e);
        const {src: n, error: s, lifecycle: r, delay: o} = this._valueFormatter(typeof t == "string" ? t : t.value);
        this._initIntersectionObserver(e, n, s, r, o)
    }
    unmount(e) {
        var t;
        !e || ((t = this._realObserver(e)) == null || t.unobserve(e),
        this._images.delete(e))
    }
    loadImages(e, t, n, s) {
        this._setImageSrc(e, t, n, s)
    }
    _setImageSrc(e, t, n, s) {
        e.tagName.toLowerCase() === "img" ? (t && e.getAttribute("src") !== t && e.setAttribute("src", t),
        this._listenImageStatus(e, () => {
            this._lifecycle(Ar.LOADED, s, e)
        }
        , () => {
            var r;
            e.onload = null,
            this._lifecycle(Ar.ERROR, s, e),
            (r = this._realObserver(e)) == null || r.disconnect(),
            n && e.getAttribute("src") !== n && e.setAttribute("src", n),
            this._log( () => {
                this._logger(`Image failed to load!And failed src was: ${t} `)
            }
            )
        }
        )) : e.style.backgroundImage = `url('${t}')`
    }
    _initIntersectionObserver(e, t, n, s, r) {
        var a;
        const o = this.options.observerOptions;
        this._images.set(e, new IntersectionObserver(l => {
            Array.prototype.forEach.call(l, c => {
                r && r > 0 ? this._delayedIntersectionCallback(e, c, r, t, n, s) : this._intersectionCallback(e, c, t, n, s)
            }
            )
        }
        ,o)),
        (a = this._realObserver(e)) == null || a.observe(e)
    }
    _intersectionCallback(e, t, n, s, r) {
        var o;
        t.isIntersecting && ((o = this._realObserver(e)) == null || o.unobserve(t.target),
        this._setImageSrc(e, n, s, r))
    }
    _delayedIntersectionCallback(e, t, n, s, r, o) {
        if (t.isIntersecting) {
            if (t.target.hasAttribute(vc))
                return;
            const a = setTimeout( () => {
                this._intersectionCallback(e, t, s, r, o),
                t.target.removeAttribute(vc)
            }
            , n);
            t.target.setAttribute(vc, String(a))
        } else
            t.target.hasAttribute(vc) && (clearTimeout(Number(t.target.getAttribute(vc))),
            t.target.removeAttribute(vc))
    }
    _listenImageStatus(e, t, n) {
        e.onload = t,
        e.onerror = n
    }
    _valueFormatter(e) {
        let t = e
          , n = this.options.loading
          , s = this.options.error
          , r = this.options.lifecycle
          , o = this.options.delay;
        return vd(e) && (t = e.src,
        n = e.loading || this.options.loading,
        s = e.error || this.options.error,
        r = e.lifecycle || this.options.lifecycle,
        o = e.delay || this.options.delay),
        {
            src: t,
            loading: n,
            error: s,
            lifecycle: r,
            delay: o
        }
    }
    _log(e) {
        this.options.log && e()
    }
    _lifecycle(e, t, n) {
        switch (e) {
        case Ar.LOADING:
            n == null || n.setAttribute("lazy", Ar.LOADING),
            t != null && t.loading && t.loading(n);
            break;
        case Ar.LOADED:
            n == null || n.setAttribute("lazy", Ar.LOADED),
            t != null && t.loaded && t.loaded(n);
            break;
        case Ar.ERROR:
            n == null || n.setAttribute("lazy", Ar.ERROR),
            t != null && t.error && t.error(n);
            break
        }
    }
    _realObserver(e) {
        return this._images.get(e)
    }
    _logger(e, ...t) {
        let n = console.error;
        switch (this.options.logLevel) {
        case "error":
            n = console.error;
            break;
        case "warn":
            n = console.warn;
            break;
        case "info":
            n = console.info;
            break;
        case "debug":
            n = console.debug;
            break
        }
        n(e, t)
    }
}
const ese = {
    install(i, e) {
        const t = new Qie(e);
        i.config.globalProperties.$Lazyload = t,
        i.provide("Lazyload", t),
        i.directive("lazy", {
            mounted: t.mount.bind(t),
            updated: t.update.bind(t),
            unmounted: t.unmount.bind(t)
        })
    }
}
  , tse = "phc_zc1EuYtTWZKEHv1aWddyphRW0SirWKSViC3KNZ46Rp0";
hm.init(tse, {
    api_host: "https://app.posthog.com"
});
const ew = r4(fN).use(ese, {}).use(FP());
ct.user.getSession().then(i => i && it().setUser(i)).finally(async () => {
    ew.use(CR),
    Zr().handy.connect(),
    ew.mount("#app")
}
);
export {le as A, ei as B, je as C, mr as D, ti as E, Ge as F, b$ as G, vn as H, ji as I, wp as J, wd as K, Fc as L, $n as M, Vn as N, Ki as O, za as P, ze as _, ci as a, x as b, R as c, ut as d, E as e, pa as f, J as g, ct as h, li as i, Jd as j, w as k, Re as l, Y as m, zt as n, Ln as o, Gs as p, j_ as q, Ht as r, Pn as s, ee as t, it as u, xe as v, As as w, Ms as x, Nl as y, O as z};
