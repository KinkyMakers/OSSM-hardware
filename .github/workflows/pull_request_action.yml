name: PlatformIO CI

on:
  pull_request:
    branches:
      - main

jobs:
  check_changes:
    runs-on: ubuntu-latest
    outputs:
      changes_detected: ${{ steps.check_changes.outputs.changes_detected }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check for changes in Software directory
        id: check_changes
        run: |
          if git diff --name-only ${{ github.event.pull_request.base.sha }} ${{ github.sha }} | grep -q "^Software/"; then
            echo "Changes detected in Software directory"
            echo "changes_detected=true" >> $GITHUB_OUTPUT
          else
            echo "No changes in Software directory, skipping build"
            echo "changes_detected=false" >> $GITHUB_OUTPUT
          fi

  build:
    needs: check_changes
    if: needs.check_changes.outputs.changes_detected == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/cache@v4
        with:
          path: |
            ~/.cache/pip
            ~/.platformio/.cache
          key: ${{ runner.os }}-pio

      - uses: actions/setup-python@v5
        with:
          python-version: "3.9"

      - name: Install PlatformIO Core
        run: pip install --upgrade platformio

      - name: Build PlatformIO Project
        run: |
          cd Software
          pio run -e production

      - name: Upload firmware artifact
        uses: actions/upload-artifact@v4
        with:
          name: firmware-bin
          path: |
            Software/.pio/build/production/firmware.bin
            Software/.pio/build/production/partitions.bin
            Software/.pio/build/production/bootloader.bin
          retention-days: 1

  check:
    needs: check_changes
    if: needs.check_changes.outputs.changes_detected == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/cache@v4
        with:
          path: |
            ~/.cache/pip
            ~/.platformio/.cache
          key: ${{ runner.os }}-pio

      - uses: actions/setup-python@v5
        with:
          python-version: "3.9"

      - name: Install PlatformIO Core
        run: pip install --upgrade platformio

      - name: Check PlatformIO Project
        run: |
          cd Software
          pio check --skip-packages --fail-on-defect high -e production -f src


  test:
    needs: check_changes
    if: needs.check_changes.outputs.changes_detected == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/cache@v4
        with:
          path: |
            ~/.cache/pip
            ~/.platformio/.cache
          key: ${{ runner.os }}-pio

      - uses: actions/setup-python@v5
        with:
          python-version: "3.9"

      - name: Install PlatformIO Core
        run: pip install --upgrade platformio

      - name: Unit Test PlatformIO Project
        run: |
          cd Software
          pio test -e test

  check_docs:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: pnpm/action-setup@v4
        with:
          version: 10

      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'
          cache-dependency-path: Documentation/pnpm-lock.yaml

      - name: Install dependencies
        run: |
          cd Documentation
          pnpm install

      - name: Validate documentation
        run: |
          cd Documentation
          pnpm run mint:validate

  upload_to_supabase:
    needs: [check_changes, build]
    if: needs.check_changes.outputs.changes_detected == 'true'
    runs-on: ubuntu-latest
    permissions:
      checks: write
      contents: read
      deployments: write
    env:
      SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
      SUPABASE_PROJECT_ID: ${{ secrets.SUPABASE_PROJECT_ID }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download firmware artifact
        uses: actions/download-artifact@v4
        with:
          name: firmware-bin
          path: ./firmware

      - name: URL encode branch name
        id: encode_branch
        run: |
          BRANCH_NAME="${{ github.head_ref || github.ref_name }}"
          URL_ENCODED_BRANCH=$(echo "$BRANCH_NAME" | sed 's/\//%2F/g' | sed 's/+/%2B/g' | sed 's/ /%20/g')
          echo "encoded_branch=$URL_ENCODED_BRANCH" >> $GITHUB_OUTPUT

      - name: Setup Supabase CLI
        uses: supabase/setup-cli@v1
        with:
          version: latest

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Get commit hash
        id: get_commit_hash
        run: |
          COMMIT_HASH=$(git rev-parse --short HEAD)
          echo "commit_hash=$COMMIT_HASH" >> $GITHUB_OUTPUT

      - name: Download registry.json
        id: download_registry
        run: |
          if supabase storage cp "ss:///ossm-firmware/registry.json" ./registry.json --experimental; then
            echo "registry_exists=true" >> $GITHUB_OUTPUT
          else
            echo "Registry.json does not exist. Failing workflow."
            exit 1
          fi

      - name: Determine old commit and update registry
        id: update_registry
        run: |
          BRANCH_PATH="${{ steps.encode_branch.outputs.encoded_branch }}"
          CURRENT_COMMIT="${{ steps.get_commit_hash.outputs.commit_hash }}"

          # Read registry.json
          REGISTRY=$(cat ./registry.json)

          # Check if branch exists in registry, create empty array if not
          if ! echo "$REGISTRY" | jq -e "has(\"$BRANCH_PATH\")" > /dev/null; then
            echo "Branch $BRANCH_PATH not in registry, creating entry"
            REGISTRY=$(echo "$REGISTRY" | jq ". + {\"$BRANCH_PATH\": []}")
          fi

          # Check if firmware exists at branch path
          OLD_COMMIT=""
          if supabase storage ls "ss:///ossm-firmware/$BRANCH_PATH/firmware.bin" --experimental > /dev/null 2>&1; then
            # Firmware exists, need to determine old commit
            # First, check if there's a previous commit in the registry for this branch
            BRANCH_COMMITS=$(echo "$REGISTRY" | jq -r ".[\"$BRANCH_PATH\"] // []")
            COMMIT_COUNT=$(echo "$BRANCH_COMMITS" | jq "length")
            
            if [ "$COMMIT_COUNT" -gt 0 ]; then
              # Use the last commit in the array (most recent)
              OLD_COMMIT=$(echo "$BRANCH_COMMITS" | jq -r ".[-1]")
              echo "Found old commit from registry: $OLD_COMMIT"
            else
              # No commits in registry, try to find the commit from git history
              # Find the last commit that modified Software files before current commit
              OLD_COMMIT=$(git log --format="%h" -1 --skip=1 -- Software/ 2>/dev/null || echo "")
              if [ -z "$OLD_COMMIT" ]; then
                # Fallback: use parent commit
                OLD_COMMIT=$(git rev-parse --short HEAD^ 2>/dev/null || echo "")
              fi
              if [ -n "$OLD_COMMIT" ]; then
                echo "Determined old commit from git: $OLD_COMMIT"
              else
                echo "Warning: Could not determine old commit, using current commit"
                OLD_COMMIT="$CURRENT_COMMIT"
              fi
            fi
            
            # Add old commit to registry if not already present
            REGISTRY=$(echo "$REGISTRY" | jq ".[\"$BRANCH_PATH\"] |= (. + [\"$OLD_COMMIT\"] | unique)")
          else
            echo "No existing firmware found at $BRANCH_PATH, this is first upload"
          fi

          # Save updated registry
          echo "$REGISTRY" > ./registry.json
          echo "old_commit=$OLD_COMMIT" >> $GITHUB_OUTPUT

      - name: Move existing firmware out of the way
        if: steps.update_registry.outputs.old_commit != ''
        run: |
          OLD_COMMIT="${{ steps.update_registry.outputs.old_commit }}"
          BRANCH_PATH="${{ steps.encode_branch.outputs.encoded_branch }}"
          supabase storage mv "ss:///ossm-firmware/$BRANCH_PATH/firmware.bin" "ss:///ossm-firmware/$BRANCH_PATH/$OLD_COMMIT/firmware.bin" --experimental || true
          supabase storage mv "ss:///ossm-firmware/$BRANCH_PATH/partitions.bin" "ss:///ossm-firmware/$BRANCH_PATH/$OLD_COMMIT/partitions.bin" --experimental || true
          supabase storage mv "ss:///ossm-firmware/$BRANCH_PATH/bootloader.bin" "ss:///ossm-firmware/$BRANCH_PATH/$OLD_COMMIT/bootloader.bin" --experimental || true
          supabase storage mv "ss:///ossm-firmware/$BRANCH_PATH/manifest.json" "ss:///ossm-firmware/$BRANCH_PATH/$OLD_COMMIT/manifest.json" --experimental || true
        continue-on-error: true

      - name: Upload firmware to Supabase Storage
        run: |
          supabase storage cp ./firmware/firmware.bin "ss:///ossm-firmware/${{ steps.encode_branch.outputs.encoded_branch }}/firmware.bin" --content-type "application/octet-stream" --cache-control "no-cache" --experimental
          supabase storage cp ./firmware/partitions.bin "ss:///ossm-firmware/${{ steps.encode_branch.outputs.encoded_branch }}/partitions.bin" --content-type "application/octet-stream" --cache-control "no-cache" --experimental
          supabase storage cp ./firmware/bootloader.bin "ss:///ossm-firmware/${{ steps.encode_branch.outputs.encoded_branch }}/bootloader.bin" --content-type "application/octet-stream" --cache-control "no-cache" --experimental

      - name: Create and upload manifest.json
        run: |
          # Create a temporary manifest file with the branch name replaced
          cat .github/artifacts/manifest.json | sed "s/{{ branchName }}/${{ steps.encode_branch.outputs.encoded_branch }}/g" > ./manifest.json

          # Upload the manifest file to Supabase Storage
          supabase storage cp ./manifest.json "ss:///ossm-firmware/${{ steps.encode_branch.outputs.encoded_branch }}/manifest.json" --content-type "application/json" --cache-control "no-cache" --experimental

      - name: Upload updated registry.json
        run: |
          # Delete existing registry.json if it exists, then upload the updated one
          supabase storage rm "ss:///ossm-firmware/registry.json" --experimental --yes 
          supabase storage cp ./registry.json "ss:///ossm-firmware/registry.json" --content-type "application/json" --cache-control "no-cache" --experimental

      - name: Create GitHub Deployment
        id: create_deployment
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const deployment = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.payload.pull_request ? context.payload.pull_request.head.ref : context.ref,
              environment: 'firmware',
              auto_merge: false,
              required_contexts: [],
              description: 'OSSM Firmware Deployment'
            });

            return { id: deployment.data.id };

      - name: Create Deployment Status
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const deploymentId = ${{ steps.create_deployment.outputs.result }}.id;
            const flashUrl = 'https://docs.researchanddesire.com/ossm/tools/web-flasher?branch=${{ steps.encode_branch.outputs.encoded_branch }}';

            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: deploymentId,
              state: 'success',
              environment_url: flashUrl,
              log_url: flashUrl,
              description: 'Firmware ready to flash'
            });
