name: Version Control

on:
  push:
    branches:
      - main

permissions:
  contents: write

jobs:
  update-version:
    runs-on: ubuntu-latest
    env:
      SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
      SUPABASE_PROJECT_ID: ${{ secrets.SUPABASE_PROJECT_ID }}
    steps:
      - name: Check if sender is a bot
        id: bot_check
        run: |
          if [[ "${{ github.event.sender.login }}" == "github-actions[bot]" || "${{ github.event.sender.login }}" == "rad-version-control[bot]" ]]; then
            echo "is_bot=true" >> $GITHUB_OUTPUT
            echo "Exiting early: sender is ${{ github.event.sender.login }}"
          else
            echo "is_bot=false" >> $GITHUB_OUTPUT
          fi

      - name: Generate GitHub App Token
        id: generate_token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ secrets.RAD_VERSION_CONTROL_APP_ID }}
          private-key: ${{ secrets.RAD_VERSION_CONTROL_PRIVATE_KEY }}
          owner: ${{ github.repository_owner }}
          repositories: ${{ github.event.repository.name }}

      - name: Checkout code
        if: ${{ steps.bot_check.outputs.is_bot != 'true' }}
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ steps.generate_token.outputs.token || secrets.GITHUB_TOKEN }}

      - name: Exit early if only markdown files changed
        if: ${{ steps.bot_check.outputs.is_bot != 'true' }}
        id: check_changes
        run: |
          # Get list of changed files in the last commit
          CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD)
          echo "Changed files: $CHANGED_FILES"

          # Check if all changed files are markdown files
          NON_MD_FILES=$(echo "$CHANGED_FILES" | grep -v '\.md$' | grep -v '^$')

          if [ -z "$NON_MD_FILES" ] && [ -n "$CHANGED_FILES" ]; then
            echo "Only markdown files changed, skipping version bump"
            echo "skip=true" >> $GITHUB_OUTPUT
          else
            echo "Non-markdown files changed, proceeding with version bump"
            echo "skip=false" >> $GITHUB_OUTPUT
          fi

      - name: Setup Python
        if: ${{ steps.bot_check.outputs.is_bot != 'true' && steps.check_changes.outputs.skip != 'true' }}
        uses: actions/setup-python@v5
        with:
          python-version: "3.9"

      - name: Install PlatformIO Core
        if: ${{ steps.bot_check.outputs.is_bot != 'true' && steps.check_changes.outputs.skip != 'true' }}
        run: pip install --upgrade platformio

      - name: Setup Supabase CLI
        if: ${{ steps.bot_check.outputs.is_bot != 'true' && steps.check_changes.outputs.skip != 'true' }}
        uses: supabase/setup-cli@v1
        with:
          version: latest

      - name: Get next version
        if: ${{ steps.bot_check.outputs.is_bot != 'true' && steps.check_changes.outputs.skip != 'true' }}
        id: get_next_version
        run: |
          chmod +x ./Software/scripts/get_next_version.sh
          echo "Getting next version"
          COMMIT_MSG="$(git log -1 --pretty=%B)"
          echo "COMMIT_MSG=$COMMIT_MSG"
          ./Software/scripts/get_next_version.sh "$COMMIT_MSG"
        shell: bash

      - name: Update version
        if: ${{ steps.bot_check.outputs.is_bot != 'true' && steps.check_changes.outputs.skip != 'true' }}
        env:
          GITHUB_TOKEN: ${{ steps.generate_token.outputs.token || secrets.GITHUB_TOKEN }}
          NEXT_VERSION: ${{ steps.get_next_version.outputs.NEXT_VERSION }}
        id: version_update
        run: |
          chmod +x ./Software/scripts/version_bump.sh
          ./Software/scripts/version_bump.sh "$NEXT_VERSION"

      - name: Install Cursor CLI
        if: ${{ steps.bot_check.outputs.is_bot != 'true' && steps.check_changes.outputs.skip != 'true' }}
        run: |
          curl https://cursor.com/install -fsS | bash
          echo "$HOME/.cursor/bin" >> $GITHUB_PATH

      - name: Update changelog
        if: ${{ steps.bot_check.outputs.is_bot != 'true' && steps.check_changes.outputs.skip != 'true' }}
        env:
          CURSOR_API_KEY: ${{ secrets.CURSOR_API_KEY }}
          BUMP_TYPE: ${{ steps.get_next_version.outputs.BUMP_TYPE }}
          NEXT_VERSION: ${{ steps.get_next_version.outputs.NEXT_VERSION }}
        run: |
          CHANGELOG_PATH="Documentation/ossm/guides/changelog/overview.mdx"
          
          # Get the diff of changes (excluding version files and markdown)
          git diff HEAD~1 HEAD --unified=3 -- . ':!**/Version.h' ':!**/version.json' ':!*.md' > /tmp/changes.diff || echo "No diff available" > /tmp/changes.diff
          
          # Build the prompt using heredoc
          if [[ "$BUMP_TYPE" == "patch" ]]; then
            cat > /tmp/prompt.txt << 'PROMPT_END'
          You are updating the OSSM (Open Source Sex Machine) changelog. A patch version bump has occurred.
          Analyze the diff file at /tmp/changes.diff and append patch notes to the MOST RECENT <Update> section in the changelog. Do NOT create a new <Update> section.
          Rules: Add concise bullet points describing the changes. Focus on user-facing changes and bug fixes. Use format: **Feature/Fix name** â€” Brief description
          PROMPT_END
          else
            cat > /tmp/prompt.txt << 'PROMPT_END'
          You are updating the OSSM (Open Source Sex Machine) changelog. A major or minor version bump has occurred.
          Analyze the diff file at /tmp/changes.diff and create a NEW <Update> section at the TOP of the changelog content (after the frontmatter and intro paragraph).
          Rules: Create a new <Update label="Version X.Y.Z" description="Brief description"> section. Add a ## heading describing the main theme. Add bullet points for changes. Place the new <Update> section BEFORE any existing <Update> sections.
          PROMPT_END
          fi
          
          # Add version and path info
          echo "Version: ${NEXT_VERSION}" >> /tmp/prompt.txt
          echo "Changelog file: ${CHANGELOG_PATH}" >> /tmp/prompt.txt
          echo "Diff file: /tmp/changes.diff" >> /tmp/prompt.txt
          
          PROMPT=$(cat /tmp/prompt.txt)
          agent --print --model opus-4.5-thinking --force --workspace "$(pwd)" "$PROMPT" || echo "Changelog update skipped"

      - name: Build PlatformIO Project
        if: ${{ steps.bot_check.outputs.is_bot != 'true' && steps.check_changes.outputs.skip != 'true' }}
        run: |
          cd Software
          pio run -e production

      - name: Upload firmware to Supabase master/
        if: ${{ steps.bot_check.outputs.is_bot != 'true' && steps.check_changes.outputs.skip != 'true' }}
        run: |
          # Delete existing files
          supabase storage rm "ss:///ossm-firmware/master/firmware.bin" --experimental --yes || true
          supabase storage rm "ss:///ossm-firmware/master/partitions.bin" --experimental --yes || true
          supabase storage rm "ss:///ossm-firmware/master/bootloader.bin" --experimental --yes || true
          supabase storage rm "ss:///ossm-firmware/master/manifest.json" --experimental --yes || true
          supabase storage rm "ss:///ossm-firmware/master/version.json" --experimental --yes || true
          
          # Upload firmware binaries
          supabase storage cp ./Software/.pio/build/production/firmware.bin "ss:///ossm-firmware/master/firmware.bin" --content-type "application/octet-stream" --cache-control "no-cache" --experimental
          supabase storage cp ./Software/.pio/build/production/partitions.bin "ss:///ossm-firmware/master/partitions.bin" --content-type "application/octet-stream" --cache-control "no-cache" --experimental
          supabase storage cp ./Software/.pio/build/production/bootloader.bin "ss:///ossm-firmware/master/bootloader.bin" --content-type "application/octet-stream" --cache-control "no-cache" --experimental
          
          # Create and upload manifest.json for master
          cat .github/artifacts/manifest.json | sed "s/{{ branchName }}/master/g" > ./manifest.json
          supabase storage cp ./manifest.json "ss:///ossm-firmware/master/manifest.json" --content-type "application/json" --cache-control "no-cache" --experimental
          
          # Upload version.json
          supabase storage cp ./version.json "ss:///ossm-firmware/master/version.json" --content-type "application/json" --cache-control "no-cache" --experimental

      - name: Merge origin/main with -X ours strategy
        if: ${{ steps.bot_check.outputs.is_bot != 'true' && steps.check_changes.outputs.skip != 'true' }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git fetch origin main
          git merge origin/main -X ours --no-edit

      - name: Commit, tag, and push to main
        if: ${{ steps.bot_check.outputs.is_bot != 'true' && steps.check_changes.outputs.skip != 'true' }}
        env:
          NEXT_VERSION: ${{ steps.get_next_version.outputs.NEXT_VERSION }}
          GITHUB_TOKEN: ${{ steps.generate_token.outputs.token || secrets.GITHUB_TOKEN }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add -A
          git commit -m "AUTO: Version bump ${NEXT_VERSION}" || echo "No changes to commit"
          git tag "$NEXT_VERSION"
          git push origin main
          git push origin "$NEXT_VERSION"

      - name: Set success status for bot commits
        if: ${{ steps.bot_check.outputs.is_bot == 'true' }}
        run: |
          echo "No version bump needed - commit was from bot (${{ github.event.sender.login }})"
          exit 0

      - name: Set success status for markdown-only changes
        if: ${{ steps.check_changes.outputs.skip == 'true' }}
        run: |
          echo "No version bump needed - only markdown files changed"
          exit 0
